{"version":3,"sources":["../../../src/lib/bounding-sphere.js"],"names":["Vector3","Matrix4","mat4","INTERSECTION","scratchVector","scratchVector2","BoundingSphere","constructor","center","radius","fromCenterRadius","from","fromCornerPoints","corner","oppositeCorner","add","scale","distance","equals","right","Boolean","clone","union","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","copy","subtract","centerSeparation","magnitude","halfDistanceBetweenTangentPoints","expand","point","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE","transform","getScaling","Math","max","distanceSquaredTo","delta","lengthSquared","distanceTo","sqrt"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {INTERSECTION} from '../constants';\n\n// import Rectangle from './rectangle';\n\n// const defaultProjection = new GeographicProjection();\n// const fromRectangle2DLowerLeft = new Vector3();\n// const fromRectangle2DUpperRight = new Vector3();\n// const fromRectangle2DSouthwest = new Cartographic();\n// const fromRectangle2DNortheast = new Cartographic();\n\n// const fromRectangle3DScratch = [];\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\nexport default class BoundingSphere {\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  // Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n  // tighly and fully encompases the box.\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3()\n      .from(corner)\n      .add(oppositeCorner)\n      .scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  // Compares the provided BoundingSphere componentwise\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  // Duplicates a BoundingSphere instance.\n  clone() {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  // Computes a bounding sphere that contains both the left and right bounding spheres.\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  // Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n  expand(point) {\n    point = scratchVector.from(point);\n    const radius = point.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // Determines which side of a plane a sphere is located.\n  intersectPlane(plane) {\n    var center = this.center;\n    var radius = this.radius;\n    var normal = plane.normal;\n    var distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n\n  // Applies a 4x4 affine transformation matrix to a bounding sphere.\n  //    *\n  // @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n  // @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n  // @returns {BoundingSphere} The modified this parameter or a new BoundingSphere instance if none was provided.\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n  distanceSquaredTo(point) {\n    point = scratchVector.from(point);\n    const delta = point.subtract(this.center);\n    return delta.lengthSquared() - this.radius * this.radius;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n}\n"],"file":"bounding-sphere.js"}