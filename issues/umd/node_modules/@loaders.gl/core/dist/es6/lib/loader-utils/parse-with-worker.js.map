{"version":3,"sources":["../../../../src/lib/loader-utils/parse-with-worker.js"],"names":["_WorkerFarm","WorkerFarm","toArrayBuffer","getTransferList","parse","VERSION","canParseWithWorker","loader","data","options","context","isSupported","loaderOptions","id","worker","localWorkerUrl","workerUrl","useWorker","parseWithWorker","workerSource","workerName","name","workerFarm","getWorkerFarm","JSON","stringify","warning","version","process","arraybuffer","source","type","_workerFarm","props","maxConcurrency","onDebug","reuseWorkers","onMessage","onWorkerMessage","setProps","resolve","reject","result","url","postMessage","error","message"],"mappings":"AAAA,SAAQA,WAAW,IAAIC,UAAvB,EAAmCC,aAAnC,EAAkDC,eAAlD,QAAwE,0BAAxE;AACA,SAAQC,KAAR,QAAoB,cAApB;AAIA,MAAMC,OAAO,GAAG,mBAAuB,WAAvB,aAAmD,QAAnE;AAEA,OAAO,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,IAApC,EAA0CC,OAA1C,EAAmDC,OAAnD,EAA4D;AACjE,MAAI,CAACT,UAAU,CAACU,WAAX,EAAL,EAA+B;AAC7B,WAAO,KAAP;AACD;;AACD,QAAMC,aAAa,GAAGH,OAAO,IAAIA,OAAO,CAACF,MAAM,CAACM,EAAR,CAAxC;;AACA,MACGJ,OAAO,CAACK,MAAR,KAAmB,OAAnB,IAA8BF,aAA9B,IAA+CA,aAAa,CAACG,cAA9D,IACCN,OAAO,CAACK,MAAR,IAAkBF,aAAlB,IAAmCA,aAAa,CAACI,SAFpD,EAGE;AACA,WAAOT,MAAM,CAACU,SAAP,GAAmBV,MAAM,CAACU,SAAP,CAAiBR,OAAjB,CAAnB,GAA+C,IAAtD;AACD;;AACD,SAAO,KAAP;AACD;AAMD,eAAe,SAASS,eAAT,CAAyBX,MAAzB,EAAiCC,IAAjC,EAAuCC,OAAvC,EAAgDC,OAAhD,EAAyD;AACtE,QAAM;AAACI,IAAAA;AAAD,MAAWL,OAAO,IAAI,EAA5B;AACA,QAAMG,aAAa,GAAIH,OAAO,IAAIA,OAAO,CAACF,MAAM,CAACM,EAAR,CAAnB,IAAmC,EAAzD;AACA,QAAMG,SAAS,GAAGF,MAAM,KAAK,OAAX,GAAqBF,aAAa,CAACG,cAAnC,GAAoDH,aAAa,CAACI,SAApF;AAGA,QAAMG,YAAY,iBAAUH,SAAV,MAAlB;AACA,QAAMI,UAAU,GAAGb,MAAM,CAACc,IAA1B;AAEA,QAAMC,UAAU,GAAGC,aAAa,CAACd,OAAD,CAAhC;AAIAA,EAAAA,OAAO,GAAGe,IAAI,CAACpB,KAAL,CAAWoB,IAAI,CAACC,SAAL,CAAehB,OAAf,CAAX,CAAV;AAEA,QAAMiB,OAAO,GAAGnB,MAAM,CAACoB,OAAP,KAAmBtB,OAAnB,2BAA8CA,OAA9C,SAA2D,EAA3E;AAEA,SAAOiB,UAAU,CAACM,OAAX,CAAmBT,YAAnB,YAAoCC,UAApC,qBAAyDb,MAAM,CAACoB,OAAhE,SAA0ED,OAA1E,GAAqF;AAC1FG,IAAAA,WAAW,EAAE3B,aAAa,CAACM,IAAD,CADgE;AAE1FC,IAAAA,OAF0F;AAG1FqB,IAAAA,MAAM,uBAAgBzB,OAAhB,CAHoF;AAI1F0B,IAAAA,IAAI,EAAE;AAJoF,GAArF,CAAP;AAMD;AAED,IAAIC,WAAW,GAAG,IAAlB;;AAGA,SAAST,aAAT,CAAuBd,OAAO,GAAG,EAAjC,EAAqC;AACnC,QAAMwB,KAAK,GAAG,EAAd;;AACA,MAAIxB,OAAO,CAACyB,cAAZ,EAA4B;AAC1BD,IAAAA,KAAK,CAACC,cAAN,GAAuBzB,OAAO,CAACyB,cAA/B;AACD;;AACD,MAAIzB,OAAO,CAAC0B,OAAZ,EAAqB;AACnBF,IAAAA,KAAK,CAACE,OAAN,GAAgB1B,OAAO,CAAC0B,OAAxB;AACD;;AAED,MAAI,kBAAkB1B,OAAtB,EAA+B;AAE7BwB,IAAAA,KAAK,CAACG,YAAN,GAAqB3B,OAAO,CAAC2B,YAA7B;AACD;;AAED,MAAI,CAACJ,WAAL,EAAkB;AAChBA,IAAAA,WAAW,GAAG,IAAI/B,UAAJ,CAAe;AAACoC,MAAAA,SAAS,EAAEC;AAAZ,KAAf,CAAd;AACD;;AACDN,EAAAA,WAAW,CAACO,QAAZ,CAAqBN,KAArB;;AAEA,SAAOD,WAAP;AACD;;AAED,eAAeM,eAAf,CAA+B;AAACxB,EAAAA,MAAD;AAASN,EAAAA,IAAT;AAAegC,EAAAA,OAAf;AAAwBC,EAAAA;AAAxB,CAA/B,EAAgE;AAC9D,UAAQjC,IAAI,CAACuB,IAAb;AACE,SAAK,MAAL;AACES,MAAAA,OAAO,CAAChC,IAAI,CAACkC,MAAN,CAAP;AACA;;AAEF,SAAK,OAAL;AACE,UAAI;AACF,cAAMA,MAAM,GAAG,MAAMtC,KAAK,CAACI,IAAI,CAACqB,WAAN,EAAmBrB,IAAI,CAACC,OAAxB,EAAiCD,IAAI,CAACmC,GAAtC,CAA1B;AACA7B,QAAAA,MAAM,CAAC8B,WAAP,CAAmB;AAACb,UAAAA,IAAI,EAAE,YAAP;AAAqBlB,UAAAA,EAAE,EAAEL,IAAI,CAACK,EAA9B;AAAkC6B,UAAAA;AAAlC,SAAnB,EAA8DvC,eAAe,CAACuC,MAAD,CAA7E;AACD,OAHD,CAGE,OAAOG,KAAP,EAAc;AACd/B,QAAAA,MAAM,CAAC8B,WAAP,CAAmB;AAACb,UAAAA,IAAI,EAAE,aAAP;AAAsBlB,UAAAA,EAAE,EAAEL,IAAI,CAACK,EAA/B;AAAmCiC,UAAAA,OAAO,EAAED,KAAK,CAACC;AAAlD,SAAnB;AACD;;AACD;;AAEF,SAAK,OAAL;AACEL,MAAAA,MAAM,CAACjC,IAAI,CAACsC,OAAN,CAAN;AACA;;AAEF;AAlBF;AAqBD","sourcesContent":["import {_WorkerFarm as WorkerFarm, toArrayBuffer, getTransferList} from '@loaders.gl/loader-utils';\nimport {parse} from '../api/parse';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport function canParseWithWorker(loader, data, options, context) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n  const loaderOptions = options && options[loader.id];\n  if (\n    (options.worker === 'local' && loaderOptions && loaderOptions.localWorkerUrl) ||\n    (options.worker && loaderOptions && loaderOptions.workerUrl)\n  ) {\n    return loader.useWorker ? loader.useWorker(options) : true;\n  }\n  return false;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createWorker in @loaders.gl/loader-utils.\n */\nexport default function parseWithWorker(loader, data, options, context) {\n  const {worker} = options || {};\n  const loaderOptions = (options && options[loader.id]) || {};\n  const workerUrl = worker === 'local' ? loaderOptions.localWorkerUrl : loaderOptions.workerUrl;\n\n  // Mark as URL\n  const workerSource = `url(${workerUrl})`;\n  const workerName = loader.name;\n\n  const workerFarm = getWorkerFarm(options);\n\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n\n  const warning = loader.version !== VERSION ? `(core version ${VERSION})` : '';\n\n  return workerFarm.process(workerSource, `${workerName}-worker@${loader.version}${warning}`, {\n    arraybuffer: toArrayBuffer(data),\n    options,\n    source: `loaders.gl@${VERSION}`, // Lets worker ignore unrelated messages\n    type: 'parse' // For future extension\n  });\n}\n\nlet _workerFarm = null;\n\n// Create a single instance of a worker farm\nfunction getWorkerFarm(options = {}) {\n  const props = {};\n  if (options.maxConcurrency) {\n    props.maxConcurrency = options.maxConcurrency;\n  }\n  if (options.onDebug) {\n    props.onDebug = options.onDebug;\n  }\n\n  if ('reuseWorkers' in options) {\n    // @ts-ignore\n    props.reuseWorkers = options.reuseWorkers;\n  }\n\n  if (!_workerFarm) {\n    _workerFarm = new WorkerFarm({onMessage: onWorkerMessage});\n  }\n  _workerFarm.setProps(props);\n\n  return _workerFarm;\n}\n\nasync function onWorkerMessage({worker, data, resolve, reject}) {\n  switch (data.type) {\n    case 'done':\n      resolve(data.result);\n      break;\n\n    case 'parse':\n      try {\n        const result = await parse(data.arraybuffer, data.options, data.url);\n        worker.postMessage({type: 'parse-done', id: data.id, result}, getTransferList(result));\n      } catch (error) {\n        worker.postMessage({type: 'parse-error', id: data.id, message: error.message});\n      }\n      break;\n\n    case 'error':\n      reject(data.message);\n      break;\n\n    default:\n    // TODO - is this not an error case? Log a warning?\n  }\n}\n"],"file":"parse-with-worker.js"}