import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _asyncIterator from "@babel/runtime/helpers/esm/asyncIterator";
import { concatenateArrayBuffers, resolvePath } from '@loaders.gl/loader-utils';
import { isBrowser } from '@loaders.gl/loader-utils';
import { writeFile } from '../fetch/write-file';
import { fetchFile } from '../fetch/fetch-file';

function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}

export function encode(_x, _x2, _x3, _x4) {
  return _encode.apply(this, arguments);
}

function _encode() {
  _encode = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, writer, options, url) {
    var batches, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!writer.encode) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return writer.encode(data, options);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!writer.encodeSync) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", writer.encodeSync(data, options));

          case 6:
            if (!writer.encodeText) {
              _context.next = 12;
              break;
            }

            _context.t0 = new TextEncoder();
            _context.next = 10;
            return writer.encodeText(data, options);

          case 10:
            _context.t1 = _context.sent;
            return _context.abrupt("return", _context.t0.encode.call(_context.t0, _context.t1));

          case 12:
            if (!writer.encodeInBatches) {
              _context.next = 51;
              break;
            }

            batches = encodeInBatches(data, writer, options);
            chunks = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 17;
            _iterator = _asyncIterator(batches);

          case 19:
            _context.next = 21;
            return _iterator.next();

          case 21:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 25;
            return _step.value;

          case 25:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 32;
              break;
            }

            batch = _value;
            chunks.push(batch);

          case 29:
            _iteratorNormalCompletion = true;
            _context.next = 19;
            break;

          case 32:
            _context.next = 38;
            break;

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](17);
            _didIteratorError = true;
            _iteratorError = _context.t2;

          case 38:
            _context.prev = 38;
            _context.prev = 39;

            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 43;
              break;
            }

            _context.next = 43;
            return _iterator["return"]();

          case 43:
            _context.prev = 43;

            if (!_didIteratorError) {
              _context.next = 46;
              break;
            }

            throw _iteratorError;

          case 46:
            return _context.finish(43);

          case 47:
            return _context.finish(38);

          case 48:
            _context.next = 50;
            return concatenateArrayBuffers.apply(void 0, chunks);

          case 50:
            return _context.abrupt("return", _context.sent);

          case 51:
            if (!(!isBrowser && writer.encodeURLtoURL)) {
              _context.next = 63;
              break;
            }

            tmpInputFilename = getTemporaryFilename('input');
            _context.next = 55;
            return writeFile(tmpInputFilename, data);

          case 55:
            tmpOutputFilename = getTemporaryFilename('output');
            _context.next = 58;
            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);

          case 58:
            outputFilename = _context.sent;
            _context.next = 61;
            return fetchFile(outputFilename);

          case 61:
            response = _context.sent;
            return _context.abrupt("return", response.arrayBuffer());

          case 63:
            throw new Error('Writer could not encode data');

          case 64:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[17, 34, 38, 48], [39,, 43, 47]]);
  }));
  return _encode.apply(this, arguments);
}

export function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}
export function encodeText(_x5, _x6, _x7, _x8) {
  return _encodeText.apply(this, arguments);
}

function _encodeText() {
  _encodeText = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(data, writer, options, url) {
    var arrayBuffer;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(writer.text && writer.encodeText)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return writer.encodeText(data, options);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {
              _context2.next = 9;
              break;
            }

            _context2.next = 7;
            return encode(data, writer, options);

          case 7:
            arrayBuffer = _context2.sent;
            return _context2.abrupt("return", new TextDecoder().decode(arrayBuffer));

          case 9:
            throw new Error('Writer could not encode data as text');

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _encodeText.apply(this, arguments);
}

export function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    var dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }

  throw new Error('Writer could not encode data in batches');
}

function getIterator(data) {
  var dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}

export function encodeURLtoURL(_x9, _x10, _x11, _x12) {
  return _encodeURLtoURL.apply(this, arguments);
}

function _encodeURLtoURL() {
  _encodeURLtoURL = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(inputUrl, outputUrl, writer, options) {
    var outputFilename;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inputUrl = resolvePath(inputUrl);
            outputUrl = resolvePath(outputUrl);

            if (!(isBrowser || !writer.encodeURLtoURL)) {
              _context3.next = 4;
              break;
            }

            throw new Error();

          case 4:
            _context3.next = 6;
            return writer.encodeURLtoURL(inputUrl, outputUrl, options);

          case 6:
            outputFilename = _context3.sent;
            return _context3.abrupt("return", outputFilename);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encodeURLtoURL.apply(this, arguments);
}
//# sourceMappingURL=encode.js.map