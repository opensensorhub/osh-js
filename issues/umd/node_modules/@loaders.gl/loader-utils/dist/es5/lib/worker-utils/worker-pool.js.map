{"version":3,"sources":["../../../../src/lib/worker-utils/worker-pool.js"],"names":["WorkerPool","source","name","maxConcurrency","onMessage","onDebug","reuseWorkers","jobQueue","idleQueue","count","isDestroyed","forEach","worker","destroy","data","jobName","Promise","resolve","reject","push","_startQueuedJob","length","_getAvailableWorker","job","shift","message","backlog","process","_onWorkerDone","toLowerCase","WorkerThread"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  constructor({\n    source,\n    name = 'unnamed',\n    maxConcurrency = 1,\n    onMessage,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    // @ts-ignore\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    try {\n      job.resolve(await worker.process(job.data));\n    } catch (error) {\n      job.reject(error);\n    } finally {\n      this._onWorkerDone(worker);\n    }\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n      return;\n    }\n\n    if (this.reuseWorkers) {\n      this.idleQueue.push(worker);\n    } else {\n      worker.destroy();\n      this.count--;\n    }\n\n    this._startQueuedJob();\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"],"file":"worker-pool.js"}