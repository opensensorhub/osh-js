import { parseGLTF } from './lib/parse-gltf';
const VERSION = typeof "2.3.8" !== 'undefined' ? "2.3.8" : 'latest';
const GLTFLoader = {
  id: 'gltf',
  name: 'glTF',
  version: VERSION,
  extensions: ['gltf', 'glb'],
  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],
  text: true,
  binary: true,
  tests: ['glTF'],
  parse,
  options: {
    gltf: {
      normalize: false,
      loadBuffers: true,
      loadImages: true,
      decompressMeshes: true,
      postProcess: true
    },
    uri: '',
    log: console
  },
  deprecatedOptions: {
    fetchImages: 'gltf.loadImages',
    createImages: 'gltf.loadImages',
    decompress: 'gltf.decompressMeshes',
    postProcess: 'gltf.postProcess',
    gltf: {
      decompress: 'gltf.decompressMeshes'
    }
  }
};
export default GLTFLoader;
export async function parse(arrayBuffer, options = {}, context) {
  options = { ...GLTFLoader.options,
    ...options
  };
  options.gltf = { ...GLTFLoader.options.gltf,
    ...options.gltf
  };
  addDeprecatedGLTFOptions(options);
  const {
    byteOffset = 0
  } = options;
  const gltf = {};
  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);
}

function addDeprecatedGLTFOptions(options) {
  if ('fetchImages' in options) {
    options.gltf.loadImages = options.fetchImages;
  }

  if ('createImages' in options) {
    options.gltf.loadImages = options.createImages;
  }

  if ('fetchLinkedResources' in options) {
    options.gltf.fetchBuffers = options.fetchLinkedResources;
  }

  if ('decompress' in options) {
    options.gltf.decompressMeshes = options.decompress;
  }

  if ('decompress' in options.gltf) {
    options.gltf.decompressMeshes = options.gltf.decompress;
  }

  if ('postProcess' in options) {
    options.gltf.postProcess = options.postProcess;
  }
}
//# sourceMappingURL=gltf-loader.js.map