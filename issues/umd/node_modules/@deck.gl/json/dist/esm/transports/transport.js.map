{"version":3,"sources":["../../../src/transports/transport.js"],"names":["state","onIninitialize","_","onFinalize","onMessage","Transport","onInitialize","name","_messageQueue","userData","document","body","console","error","options","message","transport","_destroyed","debug","v","cache","Set","JSON","stringify","key","value","has","parse","err","undefined","add"],"mappings":";;;;;;;;;AACA,IAAMA,KAAK,GAAG;AACZC,EAAAA,cAAc,EAAE,wBAAAC,CAAC;AAAA,WAAIA,CAAJ;AAAA,GADL;AAEZC,EAAAA,UAAU,EAAE,oBAAAD,CAAC;AAAA,WAAIA,CAAJ;AAAA,GAFD;AAGZE,EAAAA,SAAS,EAAE;AAHC,CAAd;;IAMqBC,S;;;uCACwC;AAAA,UAAtCC,YAAsC,QAAtCA,YAAsC;AAAA,UAAxBH,UAAwB,QAAxBA,UAAwB;AAAA,UAAZC,SAAY,QAAZA,SAAY;;AACzD,UAAIE,YAAJ,EAAkB;AAChBN,QAAAA,KAAK,CAACM,YAAN,GAAqBA,YAArB;AACD;;AACD,UAAIH,UAAJ,EAAgB;AACdH,QAAAA,KAAK,CAACG,UAAN,GAAmBA,UAAnB;AACD;;AACD,UAAIC,SAAJ,EAAe;AACbJ,QAAAA,KAAK,CAACI,SAAN,GAAkBA,SAAlB;AACD;AAEF;;;AAED,uBAAgC;AAAA,QAApBG,IAAoB,uEAAb,WAAa;;AAAA;;AAC9B,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,aAAL,GAAqB,EAArB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACD;;;;wCAOmB;AAClB,aAAO,OAAOC,QAAP,KAAoB,WAApB,GAAkCA,QAAQ,CAACC,IAA3C,GAAkD,IAAzD;AACD;;;sCAKiB;AAEhBC,MAAAA,OAAO,CAACC,KAAR,CAAc,iDAAd;AACD;;;wCAKmB;AAElBD,MAAAA,OAAO,CAACC,KAAR,CAAc,iDAAd;AACD;;;kCAMyB;AAAA,UAAdC,OAAc,uEAAJ,EAAI;;AACxB,UAAMC,OAAO;AAAIC,QAAAA,SAAS,EAAE;AAAf,SAAwBF,OAAxB,CAAb;;AACAd,MAAAA,KAAK,CAACM,YAAN,CAAmBS,OAAnB;AAID;;;gCAEuB;AAAA,UAAdD,OAAc,uEAAJ,EAAI;;AACtB,UAAMC,OAAO;AAAIC,QAAAA,SAAS,EAAE;AAAf,SAAwBF,OAAxB,CAAb;;AAGAd,MAAAA,KAAK,CAACG,UAAN,CAAiBY,OAAjB;AACA,WAAKE,UAAL,GAAkB,IAAlB;AACD;;;uCAE8B;AAAA,UAAdF,OAAc,uEAAJ,EAAI;AAC7BA,MAAAA,OAAO;AAAIC,QAAAA,SAAS,EAAE;AAAf,SAAwBD,OAAxB,CAAP;AASAH,MAAAA,OAAO,CAACM,KAAR,CAAc,8BAAd,EAA8CH,OAA9C;AACAf,MAAAA,KAAK,CAACI,SAAN,CAAgBW,OAAhB;AACD;;;uCAwByBI,C,EAAG;AAC3B,UAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;AACA,aAAOC,IAAI,CAACC,SAAL,CAAeJ,CAAf,EAAkB,UAACK,GAAD,EAAMC,KAAN,EAAgB;AACvC,YAAI,QAAOA,KAAP,MAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC/C,cAAIL,KAAK,CAACM,GAAN,CAAUD,KAAV,CAAJ,EAAsB;AAEpB,gBAAI;AAEF,qBAAOH,IAAI,CAACK,KAAL,CAAWL,IAAI,CAACC,SAAL,CAAeE,KAAf,CAAX,CAAP;AACD,aAHD,CAGE,OAAOG,GAAP,EAAY;AAEZ,qBAAOC,SAAP;AACD;AACF;;AAEDT,UAAAA,KAAK,CAACU,GAAN,CAAUL,KAAV;AACD;;AACD,eAAOA,KAAP;AACD,OAhBM,CAAP;AAiBD;;;;;;SAxHkBpB,S","sourcesContent":["/* global document */\nconst state = {\n  onIninitialize: _ => _,\n  onFinalize: _ => _,\n  onMessage: null\n};\n\nexport default class Transport {\n  static setCallbacks({onInitialize, onFinalize, onMessage}) {\n    if (onInitialize) {\n      state.onInitialize = onInitialize;\n    }\n    if (onFinalize) {\n      state.onFinalize = onFinalize;\n    }\n    if (onMessage) {\n      state.onMessage = onMessage;\n    }\n    // this._flushQueuedConnections();\n  }\n\n  constructor(name = 'Transport') {\n    this.name = name;\n    this._messageQueue = [];\n    this.userData = {};\n  }\n\n  /**\n   * Return a root DOM element for this transport connection\n   * @return {HTMLElement} default implementation returns document.body\n   * Jupyter Notebook transports will return an element associated with the notebook cell\n   */\n  getRootDOMElement() {\n    return typeof document !== 'undefined' ? document.body : null;\n  }\n\n  /**\n   * Back-channel messaging\n   */\n  sendJSONMessage() {\n    // eslint-disable-next-line\n    console.error('Back-channel not implemented for this transport');\n  }\n\n  /**\n   * Back-channel messaging\n   */\n  sendBinaryMessage() {\n    // eslint-disable-next-line\n    console.error('Back-channel not implemented for this transport');\n  }\n\n  //\n  // API for transports (not intended for apps)\n  //\n\n  _initialize(options = {}) {\n    const message = {transport: this, ...options};\n    state.onInitialize(message);\n\n    // console.debug('Resolving init promise', options); // eslint-disable-line\n    // this._initResolvers.resolve(message);\n  }\n\n  _finalize(options = {}) {\n    const message = {transport: this, ...options};\n\n    // TODO - could potentially be called without Initialize being called\n    state.onFinalize(message);\n    this._destroyed = true;\n  }\n\n  _messageReceived(message = {}) {\n    message = {transport: this, ...message};\n\n    // TODO - this function could potentially be called before callback registered/ Initialize called\n    // if (!state.onMessage) {\n    //   console.error('Queueing transport message', message); // eslint-disable-line\n    //   this._messageQueue.push(message);\n    //   return;\n    // }\n\n    console.debug('Delivering transport message', message); // eslint-disable-line\n    state.onMessage(message);\n  }\n\n  /*\n  // This tries to handle the case that a transport connection initializes before the application\n  // has set the callbacks.\n  // Note: It is not clear that this can actually happen in the in initial Jupyter widget transport\n  _flushQueuedConnections() {\n    if (onInitialize) {\n      state._initPromise.then(initArgs => {\n        onInitialize(initArgs);\n\n        if (state._onMessage) {\n          // Send any queued messages\n          let message;\n          while ((message = this._messageQueue.pop())) {\n            console.debug('Delivering queued transport message', message); // eslint-disable-line\n            this._onMessage(message);\n          }\n        }\n      });\n    }\n  }\n  */\n\n  static _stringifyJSONSafe(v) {\n    const cache = new Set();\n    return JSON.stringify(v, (key, value) => {\n      if (typeof value === 'object' && value !== null) {\n        if (cache.has(value)) {\n          // Circular reference found\n          try {\n            // If this value does not reference a parent it can be deduped\n            return JSON.parse(JSON.stringify(value));\n          } catch (err) {\n            // discard key if value cannot be deduped\n            return undefined;\n          }\n        }\n        // Store value in our set\n        cache.add(value);\n      }\n      return value;\n    });\n  }\n}\n"],"file":"transport.js"}