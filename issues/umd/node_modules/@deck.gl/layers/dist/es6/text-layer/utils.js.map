{"version":3,"sources":["../../../src/text-layer/utils.js"],"names":["log","MISSING_CHAR_WIDTH","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","i","char","width","y","height","rowHeight","canvasHeight","getTextWidth","text","length","character","frameWidth","frame","breakAll","maxWidth","iconMapping","rows","rowStartCharIndex","rowOffsetLeft","textWidth","push","slice","lastRowStartCharIndex","lastRowOffsetLeft","breakWord","groupStartCharIndex","group","groupWidth","lastGroupStartIndex","subGroups","concat","autoWrapping","wordBreak","transformRow","leftOffsets","Array","warn","codePointAt","rowWidth","transformParagraph","paragraph","lineHeight","from","result","autoWrappingEnabled","isFinite","size","rowOffsetTop","lineStartIndex","line","undefined","max","characters","getTextFromBuffer","value","stride","offset","startIndices","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","characterCount","floor","texts","codes","constructor","index","startIndex","endIndex","String","fromCodePoint","apply","subarray"],"mappings":"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","sourcesContent":["// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\n\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n * @param characterSet {Array|Set} new characters\n * @param getFontWidth {Function} function to get width of each character\n * @param fontHeight {Number} height of font\n * @param buffer {Number} buffer surround each character\n * @param maxCanvasWidth {Number} max width of font atlas\n * @param mapping {Object} old mapping table\n * @param xOffset {Number} x position of last character in old mapping table\n * @param yOffset {Number} y position of last character in old mapping table\n * @returns {{\n *   mapping: Object,\n *   xOffset: Number, x position of last character\n *   yOffset: Number, y position of last character in old mapping table\n *   canvasHeight: Number, height of the font atlas canvas, power of 2\n *  }}\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n\n  let i = 0;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char, i++);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, mapping) {\n  let width = 0;\n  for (let i = 0; i < text.length; i++) {\n    const character = text[i];\n    let frameWidth = null;\n    const frame = mapping && mapping[character];\n    if (frame) {\n      frameWidth = frame.width;\n    }\n\n    width += frameWidth;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, maxWidth, iconMapping) {\n  const rows = [];\n  let rowStartCharIndex = 0;\n  let rowOffsetLeft = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text[i], iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        rows.push(text.slice(rowStartCharIndex, i));\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  // last row\n  if (rowStartCharIndex < text.length) {\n    rows.push(text.slice(rowStartCharIndex));\n  }\n\n  return {\n    rows,\n    lastRowStartCharIndex: rowStartCharIndex,\n    lastRowOffsetLeft: rowOffsetLeft\n  };\n}\n\n/* eslint-disable max-statements, complexity, max-depth */\nfunction breakWord(text, maxWidth, iconMapping) {\n  let rows = [];\n  let rowStartCharIndex = 0;\n  let groupStartCharIndex = 0;\n  let rowOffsetLeft = 0;\n  let group = null;\n\n  for (let i = 0; i < text.length; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      group = text[i];\n      groupStartCharIndex = i + 1;\n    } else if ((i + 1 < text.length && text[i + 1] === ' ') || i + 1 === text.length) {\n      group = text.slice(groupStartCharIndex, i + 1);\n      groupStartCharIndex = i + 1;\n    } else {\n      group = null;\n    }\n\n    if (group) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(group, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        const lastGroupStartIndex = groupStartCharIndex - group.length;\n        if (rowStartCharIndex < lastGroupStartIndex) {\n          rows.push(text.slice(rowStartCharIndex, lastGroupStartIndex));\n          rowStartCharIndex = lastGroupStartIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          const subGroups = breakAll(group, maxWidth, iconMapping);\n          if (subGroups.rows.length > 1) {\n            // add all the sub rows to results except last row\n            rows = rows.concat(subGroups.rows.slice(0, subGroups.rows.length - 1));\n          }\n          // move reference to last row\n          rowStartCharIndex = rowStartCharIndex + subGroups.lastRowStartCharIndex;\n          groupWidth = subGroups.lastRowOffsetLeft;\n        }\n      }\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  // last row\n  if (rowStartCharIndex < text.length) {\n    rows.push(text.slice(rowStartCharIndex));\n  }\n\n  return {\n    rows,\n    lastRowStartCharIndex: rowStartCharIndex,\n    lastRowOffsetLeft: rowOffsetLeft\n  };\n}\n/* eslint-enable max-statements, complexity, max-depth */\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping) {\n  if (wordBreak === 'break-all') {\n    return breakAll(text, maxWidth, iconMapping);\n  }\n  return breakWord(text, maxWidth, iconMapping);\n}\n\nfunction transformRow(row, iconMapping) {\n  let x = 0;\n  let rowHeight = 0;\n\n  const leftOffsets = new Array(row.length);\n  for (let i = 0; i < row.length; i++) {\n    const character = row[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height;\n      }\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  return {\n    leftOffsets,\n    rowWidth: x,\n    rowHeight\n  };\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n * @param paragraph: {String}\n * @param iconMapping {Object} character mapping table for retrieving a character from font atlas\n * @param lineHeight {Number} css line-height\n * @param wordBreak {String} css word-break option\n * @param maxWidth {number} css max-width\n * @param transformedData {Array} output transformed data array, each datum contains\n *   - text: character\n *   - index: character index in the paragraph\n *   - x: x offset in the row,\n *   - y: y offset in the paragraph\n *   - size: [width, height] size of the paragraph\n *   - rowSize: [rowWidth, rowHeight] size of the row\n *   - len: length of the paragraph\n */\n/* eslint-disable max-params, max-depth, complexity */\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  paragraph = Array.from(paragraph);\n  const result = new Array(paragraph.length);\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n\n  for (let i = 0; i <= paragraph.length; i++) {\n    const char = paragraph[i];\n    let line;\n    if (char === '\\n' || char === undefined) {\n      line = paragraph.slice(lineStartIndex, i);\n    }\n\n    if (line) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(line, wordBreak, maxWidth, iconMapping).rows\n        : [line];\n\n      for (const row of rows) {\n        const {rowWidth, rowHeight, leftOffsets} = transformRow(row, iconMapping, lineHeight);\n\n        for (const x of leftOffsets) {\n          result[lineStartIndex++] = {\n            x,\n            y: rowOffsetTop + rowHeight / 2,\n            rowWidth\n          };\n        }\n\n        rowOffsetTop = rowOffsetTop + rowHeight * lineHeight;\n        size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowWidth);\n      }\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      result[lineStartIndex++] = {x: 0, y: 0, rowWidth: 0};\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {characters: result, size};\n}\n/* eslint-enable max-depth, complexity */\n\nexport function getTextFromBuffer({value, length, stride, offset, startIndices}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] ||\n    Math.floor((value.length - elementOffset - bytesPerElement) / elementStride) + 1;\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    codes = new value.constructor(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));\n  }\n\n  return {texts, characterCount};\n}\n"],"file":"utils.js"}