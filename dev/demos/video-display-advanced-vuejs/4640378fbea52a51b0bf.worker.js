!function(Q){var B={};function I(F){if(B[F])return B[F].exports;var U=B[F]={i:F,l:!1,exports:{}};return Q[F].call(U.exports,U,U.exports,I),U.l=!0,U.exports}I.m=Q,I.c=B,I.d=function(Q,B,F){I.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:F})},I.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},I.t=function(Q,B){if(1&B&&(Q=I(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(I.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)I.d(F,U,function(B){return Q[B]}.bind(null,U));return F},I.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(B,"a",B),B},I.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},I.p="",I(I.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on sâ€™endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/parsers/DataSourceParser.js\n\n\nclass DataSourceParser_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the protocol protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @param {Number} properties.customUrlParams.video_bitrate - define a custom bitrate (in b/s)\n   * @param {Number} properties.customUrlParams.video_scale - define a custom scale, 0.0 < value < 1.0\n   * @param {Number} properties.customUrlParams.video_width - define a custom width\n   * @param {Number} properties.customUrlParams.video_height - define a custom height\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = \"\"; // adds protocol\n\n    url += properties.protocol + \"://\"; // adds endpoint url\n\n    url += properties.endpointUrl + \"?\"; // adds service\n\n    url += \"service=\" + properties.service; // adds version\n\n    url += \"&version=2.0&\"; // adds responseFormat (optional)\n\n    if (properties.responseFormat) {\n      url += \"&responseFormat=\" + properties.responseFormat;\n    }\n\n    if (isDefined(properties.customUrlParams) && Object.keys(properties.customUrlParams).length > 0) {\n      url += '&';\n\n      for (let key in properties.customUrlParams) {\n        url += key + '=' + properties.customUrlParams[key] + '&';\n      }\n\n      if (url.endsWith('&')) {\n        url = url.slice(0, -1);\n      }\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var parsers_DataSourceParser = (DataSourceParser_DataSourceParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/parsers/TimeSeriesParser.parser.js\n\n\n\nclass TimeSeriesParser_parser_TimeSeriesParserParser extends parsers_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the protocol protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = super.buildUrl(properties); // adds request\n\n    url += \"&request=GetResult\"; // adds offering\n\n    url += \"&offering=\" + properties.offeringID; // adds observedProperty\n\n    url += \"&observedProperty=\" + properties.observedProperty; // adds temporalFilter\n\n    const stTime = isDefined(properties.lastTimeStamp) ? properties.lastTimeStamp : properties.startTime;\n    this.lastStartTime = properties.startTime;\n    let endTime = properties.endTime;\n    url += \"&temporalFilter=phenomenonTime,\" + stTime + \"/\" + endTime;\n\n    if (properties.replaySpeed) {\n      // adds replaySpeed\n      url += \"&replaySpeed=\" + properties.replaySpeed;\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var TimeSeriesParser_parser = (TimeSeriesParser_parser_TimeSeriesParserParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/parsers/SosGetResultVideo.parser.js\n\n\n\nclass SosGetResultVideo_parser_VideoParser extends TimeSeriesParser_parser {\n  /**\n   * Extracts timestamp from the message. The timestamp is corresponding to the first 64bits of the binary message.\n   * @param {ArrayBuffer} data - the data to parse\n   * @return {Number} the extracted timestamp\n   */\n  parseTimeStamp(data) {\n    // read double time stamp as big endian\n    return new DataView(data).getFloat64(0, false) * 1000;\n  }\n  /**\n   * Extract data from the message. The H264 NAL unit starts at offset 12 after 8-bytes time stamp and 4-bytes frame length.\n   * @param {ArrayBuffer} data - the data to parse\n   * @return {Uint8Array} the parsed data\n   */\n\n\n  parseData(data) {\n    return {\n      // H264 NAL unit starts at offset 12 after 8-bytes time stamp and 4-bytes frame length\n      frameData: new Uint8Array(data, 12, data.byteLength - 12),\n      roll: 0\n    };\n  }\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the protocol protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {String} properties.foiId the foiId\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @param {Number} properties.customUrlParams.video_bitrate - define a custom bitrate (in b/s)\n   * @param {Number} properties.customUrlParams.video_scale - define a custom scale, 0.0 < value < 1.0\n   * @param {Number} properties.customUrlParams.video_width - define a custom width\n   * @param {Number} properties.customUrlParams.video_height - define a custom height\n   * @return {String} the full url\n   */\n\n\n  buildUrl(properties) {\n    let url = super.buildUrl(properties); // adds feature of interest urn\n\n    if (properties.foiId && properties.of !== '') {\n      url += '&featureOfInterest=' + properties.foiId;\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var SosGetResultVideo_parser = (SosGetResultVideo_parser_VideoParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/DataConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n/**\n * The DataConnector is the abstract class used to create different connectors.\n */\n\nclass DataConnector_DataConnector {\n  /**\n   * @param {String} url - The full url used to connect to the data stream\n   */\n  constructor(url) {\n    this.url = url;\n    this.id = \"DataConnector-\" + randomUUID();\n    this.reconnectTimeout = 1000 * 60 * 2; //2 min\n\n    this.status = Status.DISCONNECTED;\n    this.reconnectionInterval = -1;\n  }\n\n  checkAndClearReconnection() {\n    if (this.reconnectionInterval !== -1) {\n      clearInterval(this.reconnectionInterval);\n      this.reconnectionInterval = -1;\n    }\n  }\n\n  disconnect() {\n    this.checkStatus(Status.DISCONNECTED);\n    this.checkAndClearReconnection();\n  }\n  /**\n   * Sets the url\n   * @param url\n   */\n\n\n  setUrl(url) {\n    this.url = url;\n  }\n  /**\n   * The data protocol default id.\n   * @return {String}\n   */\n\n\n  getId() {\n    return this.id;\n  }\n  /**\n   * The stream url.\n   * @return {String}\n   */\n\n\n  getUrl() {\n    return this.url;\n  }\n  /**\n   * Sets the reconnection timeout\n   * @param {Number} timeout - delay in milliseconds before reconnecting dataSource\n   */\n\n\n  setReconnectTimeout(timeout) {\n    this.reconnectTimeout = timeout;\n  }\n\n  onReconnect() {\n    return true;\n  }\n\n  connect() {}\n\n  forceReconnect() {\n    this.disconnect();\n    this.connect();\n  }\n  /**\n   * Called when the connection STATUS changes\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {}\n  /**\n   * Check a change of the status and call the corresponding callbacks if necessary\n   * @param {Status} status - the currentStatus\n   */\n\n\n  checkStatus(status) {\n    if (status !== this.status) {\n      this.onChangeStatus(status);\n      this.status = status;\n    }\n  }\n  /**\n   * Called when the protocol has been disconnected\n   */\n\n\n  onDisconnect() {}\n  /**\n   * Called when the protocol has been connected\n   */\n\n\n  onConnect() {}\n\n}\n\n/* harmony default export */ var protocol_DataConnector = (DataConnector_DataConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/WebSocketConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the WebSocketConnector to connect to a remote server by creating a WebSocket channel.\n * @extends DataConnector\n * @example\n * import WebSocketConnector from 'osh-js/dataconnector/WebSocketConnector.js';\n *\n * let url = ...;\n * let connector = new WebSocketConnector(url);\n *\n * // connect\n * connector.connect();\n *\n * // disconnect\n * connector.disconnect();\n *\n * // close\n * connector.close();\n *\n */\n\nclass WebSocketConnector_WebSocketConnector extends protocol_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.interval = -1;\n    this.lastReceiveTime = 0;\n  }\n  /**\n   * Connect to the webSocket. If the system supports WebWorker, it will automatically creates one otherwise use\n   * the main thread.\n   */\n\n\n  async connect() {\n    if (!this.init) {\n      this.closed = false;\n      this.init = true; //creates Web Socket\n\n      this.ws = new WebSocket(this.getUrl());\n      this.ws.binaryType = 'arraybuffer';\n      this.checkStatus(Status.CONNECTING);\n      console.warn('WebSocket stream connecting');\n\n      this.ws.onopen = function (event) {\n        this.checkAndClearReconnection();\n        this.checkStatus(Status.CONNECTED);\n        console.warn('WebSocket stream connected');\n      }.bind(this);\n\n      this.ws.onmessage = function (event) {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        if (event.data.byteLength > 0) {\n          this.onMessage(event.data);\n        }\n      }.bind(this); // closes socket if any errors occur\n\n\n      this.ws.onerror = function (event) {\n        console.error('WebSocket stream error');\n        this.checkStatus(Status.DISCONNECTED);\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.createReconnection();\n      }.bind(this);\n\n      this.ws.onclose = event => {\n        this.checkStatus(Status.DISCONNECTED);\n        console.warn('WebSocket stream closed: ', event.reason, event.code);\n        this.init = false;\n\n        if (event.code !== 1000 && !this.closed) {\n          this.createReconnection();\n        }\n      };\n    }\n  }\n\n  createReconnection() {\n    if (!this.closed && this.reconnectionInterval === -1 && this.onReconnect()) {\n      this.reconnectionInterval = setInterval(function () {\n        let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n        if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n          console.warn('trying to reconnect', this.url);\n          this.connect();\n        }\n      }.bind(this), this.reconnectTimeout);\n    }\n  }\n  /**\n   * Disconnects and close the websocket.\n   */\n\n\n  disconnect() {\n    super.disconnect();\n    this.init = false;\n    this.closed = true;\n\n    if (this.ws != null && this.ws.readyState !== WebSocket.CLOSED) {\n      this.ws.close();\n    }\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n\n  isConnected() {\n    return this.ws != null && this.ws.readyState === WebSocket.OPEN;\n  }\n\n}\n\n/* harmony default export */ var protocol_WebSocketConnector = (WebSocketConnector_WebSocketConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Ajax.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the AjaxConnector to connect to a remote server by making AjaxRequest.\n * @extends DataConnector\n * @example\n * import Ajax from 'core/protocol/Ajax.js';\n *\n * let request = ...;\n * let protocol = new Ajax(url);\n *\n * // handle onSuccess\n * protocol.onSuccess = function(event) {\n *  // does something\n * }\n *\n * protocol.onError = function(event) {\n *  // does something\n * }\n *\n * // send request\n * protocol.sendRequest(request);\n *\n */\n\nclass Ajax_Ajax extends protocol_DataConnector {\n  /**\n   * Creates Ajax.\n   * @param {String} url -\n   * @param {Object} properties -\n   * @param {String} properties.method -\n   * @param {String} properties.responseType -\n   */\n  constructor(url, properties) {\n    super(url);\n    this.method = \"POST\";\n    this.responseType = \"arraybuffer\";\n\n    if (isDefined(properties)) {\n      if (properties.method) {\n        this.method = properties.method;\n      }\n\n      if (properties.responseType) {\n        this.responseType = properties.responseType;\n      }\n    }\n  }\n  /**\n   * Sends the request to the defined server.\n   * @param {String} request - The Http request\n   * @param {String} extraUrl - get query parameters\n   */\n\n\n  sendRequest(request, extraUrl) {\n    let self = this;\n    let xmlhttp = new XMLHttpRequest();\n    xmlhttp.withCredentials = true;\n    xmlhttp.timeout = 60000;\n\n    if (request === null) {\n      if (isDefined(extraUrl)) {\n        xmlhttp.open(\"GET\", this.getUrl() + \"?\" + extraUrl, true);\n      } else {\n        xmlhttp.open(\"GET\", this.getUrl(), true);\n      }\n\n      xmlhttp.responseType = this.responseType;\n\n      xmlhttp.onload = oEvent => {\n        if (xmlhttp.response) {\n          self.onMessage(xmlhttp.response);\n        }\n\n        self.checkStatus(Status.DISCONNECTED);\n      };\n\n      xmlhttp.ontimeout = e => {\n        console.log(\"Timeout\");\n        self.checkStatus(Status.DISCONNECTED);\n      };\n\n      self.checkStatus(Status.CONNECTED);\n      xmlhttp.send(null);\n    } else {\n      xmlhttp.open(\"POST\", this.getUrl(), true);\n      xmlhttp.setRequestHeader('Content-Type', 'text/xml');\n      xmlhttp.send(request);\n      self.checkStatus(Status.CONNECTED);\n\n      xmlhttp.onreadystatechange = () => {\n        if (xmlhttp.readyState < 4) {// while waiting response from server\n        } else if (xmlhttp.readyState === 4) {\n          // 4 = Response from server has been completely loaded.\n          if (xmlhttp.status === 200 && xmlhttp.status < 300) {\n            // http status between 200 to 299 are all successful\n            self.onSuccess(xmlhttp.responseText);\n          } else {\n            self.onError(\"\");\n          }\n\n          self.checkStatus(Status.DISCONNECTED);\n        }\n      };\n    }\n  }\n  /**\n   * This is the callback method in case of getting error connection.\n   * @param event The error details\n   * @event\n   */\n\n\n  onError(event) {}\n  /**\n   * This is the callback method in case of getting success connection.\n   * @param event\n   * @event\n   */\n\n\n  onSuccess(event) {}\n  /**\n   * Sends the request\n   * @private\n   */\n\n\n  connect() {\n    this.sendRequest(null);\n  }\n\n  isConnected() {\n    return false;\n  }\n\n}\n\n/* harmony default export */ var protocol_Ajax = (Ajax_Ajax);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/TopicConnector.js\n\n/**\n * Defines the FileConnector to read a File content\n * @extends DataConnector\n * @example\n * import FileConnector from 'core/protocol/TopicConnector.js';\n *\n * let protocol = new TopicConnector(<topic_name>);\n *\n * // connect\n * protocol.connect();\n *\n * // disconnect\n * protocol.disconnect();\n *\n * // close\n * protocol.close();\n *\n */\n\nclass TopicConnector_TopicConnector extends protocol_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.lastReceiveTime = -1;\n    this.interval = -1;\n    this.broadcastChannel = null;\n  }\n  /**\n   * Connect to the broadcastChannel.\n   */\n\n\n  connect() {\n    if (this.broadcastChannel === null) {\n      //creates broadcastChannel\n      this.broadcastChannel = new BroadcastChannel(this.getUrl());\n\n      this.broadcastChannel.onmessage = event => {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        this.onMessage(event.data.data);\n      }; // closes socket if any errors occur\n\n\n      this.broadcastChannel.onerror = event => {\n        console.error('BroadcastChannel stream error: ' + event);\n        this.broadcastChannel.close();\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.opened = false;\n      };\n\n      this.opened = true; //init the reconnect handler\n\n      if (this.interval === -1) {\n        this.interval = setInterval(function () {\n          let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n          if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n            console.warn(`trying to reconnect after ${this.reconnectTimeout} ..`);\n            this.reconnect();\n          }\n        }.bind(this), this.reconnectTimeout);\n      }\n    }\n  }\n  /**\n   * Disconnects the websocket.\n   */\n\n\n  disconnect() {\n    this.fullDisconnect(true);\n  }\n  /**\n   * Fully disconnect the websocket connection by sending a close message to the webWorker.\n   * @param {Boolean} removeInterval  - force removing the interval\n   */\n\n\n  fullDisconnect(removeInterval) {\n    if (this.broadcastChannel != null) {\n      this.broadcastChannel.close();\n      this.broadcastChannel = null;\n    }\n\n    if (removeInterval) {\n      clearInterval(this.interval);\n    }\n\n    this.opened = false;\n  }\n  /**\n   * Try to reconnect if the connexion if closed\n   */\n\n\n  reconnect() {\n    this.onReconnect();\n\n    if (this.init) {\n      this.fullDisconnect(false);\n    }\n\n    this.connect();\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n  /**\n   * Closes the webSocket.\n   */\n\n\n  close() {\n    this.disconnect();\n  }\n\n  isConnected() {\n    return this.broadcastChannel !== null && this.opened;\n  }\n\n}\n\n/* harmony default export */ var protocol_TopicConnector = (TopicConnector_TopicConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  STATUS: 'status'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/FileConnector.js\n\n\n/**\n * Defines the FileConnector to read a File content\n * @extends DataConnector\n * @example\n * import FileConnector from 'core/protocol/FileConnector.js';\n *\n * let paths = ['path1','path2]...];\n * let protocol = new FileConnector(paths);\n *\n * // connect\n * protocol.connect();\n *\n * // disconnect\n * protocol.disconnect();\n *\n * // close\n * protocol.close();\n *\n */\n\nclass FileConnector_FileConnector extends protocol_DataConnector {\n  /**\n   * @param (string[]) paths - list of file paths\n   */\n  constructor(paths) {\n    super(paths);\n    this.opened = false;\n  }\n  /**\n   * Start reading file content\n   */\n\n\n  async connect() {\n    if (!this.opened) {\n      this.opened = true;\n      this.onChangeStatus(Status.CONNECTED);\n      const urls = this.getUrl();\n\n      for (let url of urls) {\n        this.onMessage(await fetch(url));\n      }\n\n      this.onChangeStatus(Status.DISCONNECTED); // read is done\n\n      this.opened = false;\n    }\n  }\n\n  isConnected() {\n    return this.opened;\n  }\n\n}\n\n/* harmony default export */ var protocol_FileConnector = (FileConnector_FileConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/workers/DataSourceHandler.js\n\n\n\n\n\n\n\n\nclass DataSourceHandler_DataSourceHandler {\n  constructor(parser) {\n    this.parser = parser;\n    this.connector = null;\n    this.reconnectTimeout = 1000 * 10; // 10 secs\n\n    this.values = [];\n    this.version = -Number.MAX_SAFE_INTEGER;\n  }\n\n  createConnector(propertiesStr, topic, dataSourceId) {\n    this.dataSourceId = dataSourceId; // check for existing protocol\n\n    if (this.connector !== null) {\n      this.connector.disconnect();\n      this.connector = null;\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    const properties = JSON.parse(propertiesStr);\n\n    if (isDefined(properties.timeShift)) {\n      this.timeShift = properties.timeShift;\n    }\n\n    if (isDefined(properties.bufferingTime)) {\n      this.bufferingTime = properties.bufferingTime;\n    }\n\n    if (isDefined(properties.timeOut)) {\n      this.timeOut = properties.timeOut;\n    }\n\n    if (isDefined(properties.reconnectTimeout)) {\n      this.reconnectTimeout = properties.reconnectTimeout;\n    }\n\n    if (properties.startTime === 'now') {\n      this.batchSize = 1;\n    } else {\n      if (isDefined(properties.replaySpeed)) {\n        if (!isDefined(properties.batchSize)) {\n          this.batchSize = 1;\n        }\n      }\n\n      if (isDefined(properties.batchSize)) {\n        this.batchSize = properties.batchSize;\n      }\n    }\n\n    this.properties = properties;\n    this.createDataConnector(this.properties);\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    const url = this.parser.buildUrl({ ...properties,\n      timeShift: this.timeShift\n    }); // checks if type is WebSocketConnector\n\n    if (properties.protocol.startsWith('ws')) {\n      this.connector = new protocol_WebSocketConnector(url);\n    } else if (properties.protocol.startsWith('http')) {\n      this.connector = new protocol_Ajax(url);\n      this.connector.responseType = properties.responseType || 'arraybuffer';\n    } else if (properties.protocol.startsWith('topic')) {\n      this.connector = new protocol_TopicConnector(url);\n    } else if (properties.protocol.startsWith('file')) {\n      this.connector = new protocol_FileConnector(url, properties);\n    }\n\n    if (this.connector !== null) {\n      // set the reconnectTimeout\n      this.connector.setReconnectTimeout(this.reconnectTimeout); // connects the callback\n\n      this.connector.onMessage = this.onMessage.bind(this); // bind change connection STATUS\n\n      this.connector.onChangeStatus = this.onChangeStatus.bind(this);\n    }\n  }\n  /**\n   * Sets the current topic to listen\n   * @param {String} topic - the topic to listen\n   */\n\n\n  setTopic(topic) {\n    if (isDefined(this.broadcastChannel)) {\n      this.broadcastChannel.close();\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    this.topic = topic;\n  }\n\n  connect() {\n    if (this.connector !== null) {\n      this.connector.connect();\n    }\n  }\n\n  disconnect() {\n    if (this.connector !== null) {\n      this.connector.disconnect();\n    }\n  }\n\n  async onMessage(event) {\n    const data = await Promise.resolve(this.parser.parseData(event)); // check if data is array\n\n    if (Array.isArray(data)) {\n      for (let i = 0; i < data.length; i++) {\n        this.values.push({\n          data: data[i],\n          version: this.version\n        });\n\n        if (isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n          this.flush();\n        }\n      }\n    } else {\n      this.values.push({\n        data: data,\n        version: this.version\n      });\n    } // because parseData is ASYNC, the protocol can finish before the parsing method. In that case, we have to flushALl data\n\n\n    if (!this.isConnected()) {\n      this.flushAll();\n    } else if (isDefined(this.batchSize) && this.values.length !== 0 && this.values.length >= this.batchSize) {\n      this.flush();\n    }\n  }\n  /**\n   * Send a change status event into the broadcast channel\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {\n    if (status === Status.DISCONNECTED) {\n      this.flushAll();\n    }\n\n    this.broadcastChannel.postMessage({\n      type: EventType.STATUS,\n      status: status,\n      dataSourceId: this.dataSourceId\n    });\n  }\n\n  updateProperties(properties) {\n    this.disconnect();\n    this.createDataConnector({ ...this.properties,\n      ...properties\n    });\n    this.version++;\n    this.connect();\n  }\n\n  flushAll() {\n    while (this.values.length > 0) {\n      this.flush();\n    }\n  }\n\n  flush() {\n    let nbElements = this.values.length;\n\n    if (isDefined(this.batchSize) && this.values.length > this.batchSize) {\n      nbElements = this.batchSize;\n    }\n\n    this.broadcastChannel.postMessage({\n      dataSourceId: this.dataSourceId,\n      type: EventType.DATA,\n      values: this.values.splice(0, nbElements)\n    });\n  }\n\n  isConnected() {\n    return this.connector === null ? false : this.connector.isConnected();\n  }\n\n  handleMessage(message, worker) {\n    if (message.message === 'init') {\n      this.createConnector(message.properties, message.topic, message.id);\n    } else if (message.message === 'connect') {\n      this.connect();\n    } else if (message.message === 'disconnect') {\n      this.disconnect();\n    } else if (message.message === 'topic') {\n      this.setTopic(message.topic);\n    } else if (message.message === 'update-url') {\n      this.updateProperties(message.data);\n    } else if (message.message === 'is-connected') {\n      worker.postMessage({\n        message: 'is-connected',\n        data: this.isConnected()\n      });\n    }\n  }\n\n}\n\n/* harmony default export */ var workers_DataSourceHandler = (DataSourceHandler_DataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/workers/TimeSeriesDataSourceHandler.js\n\n\n\nclass TimeSeriesDataSourceHandler_TimeSeriesDataSourceHandler extends workers_DataSourceHandler {\n  constructor(parser) {\n    super(parser);\n    this.lastTimeStamp = null;\n    this.lastStartTime = 'now';\n    this.timeShift = 0;\n    this.timeBroadcastChannel = null;\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    super.createDataConnector({ ...properties,\n      timeShift: this.timeShift\n    });\n    const lastStartTimeCst = this.parser.lastStartTime;\n\n    this.connector.onReconnect = () => {\n      // if not real time, preserve last timestamp to reconnect at the last time received\n      // for that, we update the URL with the new last time received\n      if (lastStartTimeCst !== 'now') {\n        this.connector.setUrl(this.parser.buildUrl({ ...properties,\n          lastTimeStamp: isDefined(this.lastTimeStamp) ? new Date(this.lastTimeStamp).toISOString() : properties.startTime\n        }));\n      }\n\n      return true;\n    };\n  }\n\n  async onMessage(event) {\n    const timeStamp = await Promise.resolve(this.parser.parseTimeStamp(event) + this.timeShift);\n    const data = await Promise.resolve(this.parser.parseData(event)); // check if data is array\n\n    if (Array.isArray(data)) {\n      for (let i = 0; i < data.length; i++) {\n        this.values.push({\n          data: data[i],\n          timeStamp: timeStamp,\n          version: this.version\n        });\n      }\n    } else {\n      this.values.push({\n        data: data,\n        timeStamp: timeStamp,\n        version: this.version\n      });\n    }\n\n    this.lastTimeStamp = timeStamp;\n\n    if (this.parser.lastStartTime === 'now' || isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n      this.flush();\n\n      if (this.timeBroadcastChannel !== null) {\n        this.timeBroadcastChannel.postMessage({\n          timestamp: this.lastTimeStamp\n        });\n      }\n    }\n  }\n\n  getLastTimeStamp() {\n    return this.lastTimeStamp;\n  }\n\n  updateProperties(properties) {\n    this.disconnect();\n    let lastTimestamp = new Date(this.lastTimeStamp).toISOString();\n\n    if (properties.hasOwnProperty('startTime')) {\n      lastTimestamp = properties.startTime;\n    } else if (this.properties.startTime === 'now') {\n      //handle RealTime\n      lastTimestamp = 'now';\n    }\n\n    this.version++;\n    this.createDataConnector({ ...this.properties,\n      ...properties,\n      lastTimeStamp: lastTimestamp\n    });\n\n    if (isDefined(properties) && isDefined(properties.reconnect) && properties.reconnect) {\n      this.connect();\n    }\n  }\n\n  handleMessage(message, worker) {\n    super.handleMessage(message, worker);\n\n    if (message.message === 'last-timestamp') {\n      const lastTimeStamp = this.getLastTimeStamp();\n      worker.postMessage({\n        message: 'last-timestamp',\n        data: lastTimeStamp\n      });\n    } else if (message.message === 'topic') {\n      this.setTimeTopic(message.timeTopic);\n      super.setTopic(message.topic);\n    }\n  }\n\n  setTimeTopic(timeTopic) {\n    if (this.timeBroadcastChannel !== null) {\n      this.timeBroadcastChannel.close();\n    }\n\n    this.timeBroadcastChannel = new BroadcastChannel(timeTopic);\n  }\n\n}\n\n/* harmony default export */ var workers_TimeSeriesDataSourceHandler = (TimeSeriesDataSourceHandler_TimeSeriesDataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/workers/SosGetResultVideo.worker.js\n\n\n\nconst dataSourceHandler = new workers_TimeSeriesDataSourceHandler(new SosGetResultVideo_parser());\n\nself.onmessage = (event) => {\n    dataSourceHandler.handleMessage(event.data, self);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2RhdGFzb3VyY2UvcGFyc2Vycy9EYXRhU291cmNlUGFyc2VyLmpzP2NmYWYiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS9wYXJzZXJzL1RpbWVTZXJpZXNQYXJzZXIucGFyc2VyLmpzPzM0MjUiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS9wYXJzZXJzL1Nvc0dldFJlc3VsdFZpZGVvLnBhcnNlci5qcz85ZWM3Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL1N0YXR1cy5qcz84ODhhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL0RhdGFDb25uZWN0b3IuanM/ZTFmZCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9wcm90b2NvbC9XZWJTb2NrZXRDb25uZWN0b3IuanM/MjFkZSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9wcm90b2NvbC9BamF4LmpzP2U0MmQiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvcHJvdG9jb2wvVG9waWNDb25uZWN0b3IuanM/Zjk1MSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9ldmVudC9FdmVudFR5cGUuanM/OWUzMCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9wcm90b2NvbC9GaWxlQ29ubmVjdG9yLmpzPzU3OTEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS93b3JrZXJzL0RhdGFTb3VyY2VIYW5kbGVyLmpzP2JjYWUiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS93b3JrZXJzL1RpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlci5qcz8yMDgxIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2RhdGFzb3VyY2Uvd29ya2Vycy9Tb3NHZXRSZXN1bHRWaWRlby53b3JrZXIuanM/OTMwYyJdLCJuYW1lcyI6WyJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoZXgycmdiIiwiaGV4IiwiciIsImciLCJiIiwibWF0Y2giLCJtYXAiLCJ4IiwicGFyc2VJbnQiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUcnVlIiwiYXNzZXJ0VHlwZSIsImFzc2VydEJvb2xlYW4iLCJhc3NlcnRTdHJpbmciLCJhc3NlcnROdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZSIsImFzc2VydE9iamVjdCIsImFzc2VydEFycmF5IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRIYXNWYWx1ZSIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaXNFbGVtZW50IiwibyIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc1dlYldvcmtlciIsIldvcmtlciIsInRha2VTY3JlZW5TaG90IiwiZGl2IiwicmVtb3ZlQ3NzIiwiY3NzIiwiZGl2Q3NzIiwiY2xhc3NOYW1lIiwiYWRkQ3NzIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlTGFzdENoYXJJZkV4aXN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsInJvdW5kSGFsZiIsIm51bSIsInJvdW5kIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJhcmdzIiwiY29udGV4dCIsInRpbWVzdGFtcCIsImxhdGVyIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJsYXN0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbE5vdyIsInRocm90dGxlIiwibGVhZGluZyIsInRyYWlsaW5nIiwiY3R4IiwicHJldmlvdXMiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJtZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImtleSIsImtleXMiLCJhc3NpZ24iLCJEYXRhU291cmNlUGFyc2VyIiwiYnVpbGRVcmwiLCJwcm9wZXJ0aWVzIiwidXJsIiwicHJvdG9jb2wiLCJlbmRwb2ludFVybCIsInNlcnZpY2UiLCJyZXNwb25zZUZvcm1hdCIsImN1c3RvbVVybFBhcmFtcyIsInNsaWNlIiwiVGltZVNlcmllc1BhcnNlclBhcnNlciIsIm9mZmVyaW5nSUQiLCJvYnNlcnZlZFByb3BlcnR5Iiwic3RUaW1lIiwibGFzdFRpbWVTdGFtcCIsInN0YXJ0VGltZSIsImxhc3RTdGFydFRpbWUiLCJlbmRUaW1lIiwicmVwbGF5U3BlZWQiLCJWaWRlb1BhcnNlciIsIlRpbWVTZXJpZXNQYXJzZXIiLCJwYXJzZVRpbWVTdGFtcCIsInBhcnNlRGF0YSIsImZyYW1lRGF0YSIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwicm9sbCIsImZvaUlkIiwib2YiLCJTdGF0dXMiLCJDT05ORUNUSU5HIiwiQ09OTkVDVEVEIiwiRElTQ09OTkVDVEVEIiwiRGF0YUNvbm5lY3RvciIsImNvbnN0cnVjdG9yIiwicmVjb25uZWN0VGltZW91dCIsInN0YXR1cyIsInJlY29ubmVjdGlvbkludGVydmFsIiwiY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbiIsImNsZWFySW50ZXJ2YWwiLCJkaXNjb25uZWN0IiwiY2hlY2tTdGF0dXMiLCJzZXRVcmwiLCJnZXRJZCIsImdldFVybCIsInNldFJlY29ubmVjdFRpbWVvdXQiLCJvblJlY29ubmVjdCIsImNvbm5lY3QiLCJmb3JjZVJlY29ubmVjdCIsIm9uQ2hhbmdlU3RhdHVzIiwib25EaXNjb25uZWN0Iiwib25Db25uZWN0IiwiV2ViU29ja2V0Q29ubmVjdG9yIiwiaW50ZXJ2YWwiLCJsYXN0UmVjZWl2ZVRpbWUiLCJpbml0IiwiY2xvc2VkIiwid3MiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwiY29uc29sZSIsIndhcm4iLCJvbm9wZW4iLCJldmVudCIsImJpbmQiLCJvbm1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJvbmVycm9yIiwiZXJyb3IiLCJjcmVhdGVSZWNvbm5lY3Rpb24iLCJvbmNsb3NlIiwicmVhc29uIiwiY29kZSIsInNldEludGVydmFsIiwiZGVsdGEiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwiY2xvc2UiLCJpc0Nvbm5lY3RlZCIsIk9QRU4iLCJBamF4IiwibWV0aG9kIiwicmVzcG9uc2VUeXBlIiwic2VuZFJlcXVlc3QiLCJyZXF1ZXN0IiwiZXh0cmFVcmwiLCJzZWxmIiwieG1saHR0cCIsIlhNTEh0dHBSZXF1ZXN0Iiwid2l0aENyZWRlbnRpYWxzIiwib3BlbiIsIm9ubG9hZCIsIm9FdmVudCIsInJlc3BvbnNlIiwib250aW1lb3V0IiwiZSIsImxvZyIsInNlbmQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwib25TdWNjZXNzIiwicmVzcG9uc2VUZXh0Iiwib25FcnJvciIsIlRvcGljQ29ubmVjdG9yIiwiYnJvYWRjYXN0Q2hhbm5lbCIsIkJyb2FkY2FzdENoYW5uZWwiLCJvcGVuZWQiLCJyZWNvbm5lY3QiLCJmdWxsRGlzY29ubmVjdCIsInJlbW92ZUludGVydmFsIiwiRXZlbnRUeXBlIiwiREFUQSIsIlNUQVRVUyIsIkZpbGVDb25uZWN0b3IiLCJwYXRocyIsInVybHMiLCJmZXRjaCIsIkRhdGFTb3VyY2VIYW5kbGVyIiwicGFyc2VyIiwiY29ubmVjdG9yIiwidmFsdWVzIiwidmVyc2lvbiIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJjcmVhdGVDb25uZWN0b3IiLCJwcm9wZXJ0aWVzU3RyIiwidG9waWMiLCJkYXRhU291cmNlSWQiLCJ0aW1lU2hpZnQiLCJidWZmZXJpbmdUaW1lIiwidGltZU91dCIsImJhdGNoU2l6ZSIsImNyZWF0ZURhdGFDb25uZWN0b3IiLCJzdGFydHNXaXRoIiwic2V0VG9waWMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZsdXNoIiwiZmx1c2hBbGwiLCJwb3N0TWVzc2FnZSIsInVwZGF0ZVByb3BlcnRpZXMiLCJuYkVsZW1lbnRzIiwic3BsaWNlIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJ3b3JrZXIiLCJUaW1lU2VyaWVzRGF0YVNvdXJjZUhhbmRsZXIiLCJ0aW1lQnJvYWRjYXN0Q2hhbm5lbCIsImxhc3RTdGFydFRpbWVDc3QiLCJ0b0lTT1N0cmluZyIsInRpbWVTdGFtcCIsImdldExhc3RUaW1lU3RhbXAiLCJsYXN0VGltZXN0YW1wIiwiaGFzT3duUHJvcGVydHkiLCJzZXRUaW1lVG9waWMiLCJ0aW1lVG9waWMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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WUFBTWxJLGFBQWEsR0FBRyxLQUFLeUksZ0JBQUwsRUFBdEI7QUFDQU4sWUFBTSxDQUFDTixXQUFQLENBQW1CO0FBQ2ZLLGVBQU8sRUFBRSxnQkFETTtBQUVmclAsWUFBSSxFQUFFbUg7QUFGUyxPQUFuQjtBQUlILEtBTkQsTUFNTyxJQUFJa0ksT0FBTyxDQUFDQSxPQUFSLEtBQW9CLE9BQXhCLEVBQWlDO0FBQ3BDLFdBQUtVLFlBQUwsQ0FBa0JWLE9BQU8sQ0FBQ1csU0FBMUI7QUFDQSxZQUFNckIsUUFBTixDQUFlVSxPQUFPLENBQUNsQixLQUF2QjtBQUNIO0FBQ0o7O0FBRUQ0QixjQUFZLENBQUNDLFNBQUQsRUFBWTtBQUNwQixRQUFHLEtBQUtSLG9CQUFMLEtBQThCLElBQWpDLEVBQXVDO0FBQ25DLFdBQUtBLG9CQUFMLENBQTBCdEUsS0FBMUI7QUFDSDs7QUFDRCxTQUFLc0Usb0JBQUwsR0FBNEIsSUFBSTFDLGdCQUFKLENBQXFCa0QsU0FBckIsQ0FBNUI7QUFDSDs7QUFsSHNEOztBQW9INUNULCtIQUFmLEU7O0FDdkg2RTtBQUNMOztBQUV4RSw4QkFBOEIsbUNBQTJCLEtBQUssd0JBQXVCOztBQUVyRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqICogQG1vZHVsZSBVdGlscyAqL1xuXG4vKiogTWF4aW11bSB2YWx1ZSBvZiBhIGxvbmcgKi9cbmV4cG9ydCBjb25zdCBNQVhfTE9ORyA9IE1hdGgucG93KDIsIDUzKSArIDE7XG5cbi8qKlxuICogR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mICh2KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaGFzIGEgdmFsdWUsXG4gdGhhdCBpcyBpdCBpcyBkZWZpbmVkIGFuZCBub24gbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsdWUodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGhleCBjb2xvciBpbnRvIFJHQkFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleDJyZ2IoaGV4KXtcbiAgICBjb25zdCBbciwgZywgYl0gPSBoZXgubWF0Y2goL1xcd1xcdy9nKS5tYXAoeCA9PiBwYXJzZUludCh4LCAxNikpO1xuICAgIHJldHVybiBbciwgZywgYl07XG59XG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVHlwZSh2LCBleHBlY3RlZFR5cGUpIHtcbiAgICBsZXQgaGFzVmFsID0gaGFzVmFsdWUodik7XG4gICAgcmV0dXJuIGhhc1ZhbCAmJiB0eXBlb2YgKHYpID09PSBleHBlY3RlZFR5cGU7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUcnVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikgfHwgIXYpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKHYsIGV4cGVjdGVkVHlwZSwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICh0eXBlb2YgKHYpICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgb2YgdHlwZSBcIiArIGV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEJvb2xlYW4odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdib29sZWFuJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0cmluZyh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ3N0cmluZycsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdudW1iZXInLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmUodiwgbGV0TmFtZSkge1xuICAgIGFzc2VydE51bWJlcih2LCBsZXROYW1lKTtcbiAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCI7XG4gICAgfVxufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnb2JqZWN0JywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcnJheSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGFuIGFycmF5XCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SGFzVmFsdWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghaGFzVmFsdWUodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3Qgbm90IGJlIG51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVVVSUQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LXh4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3RhbXBzL2VtYmVkcyBhIFVVSUQgaW50byBhbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIFVVSUQgZ2VuZXJhdGVkIGZvciBpdFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbXBVVUlEKG9iaikge1xuICAgIG9iai5fb3NoX2lkID0gb2JqLl9vc2hfaWQgfHwgcmFuZG9tVVVJRCgpO1xuICAgIHJldHVybiBvYmouX29zaF9pZDtcbn1cblxuLy9idWZmZXIgaXMgYW4gQXJyYXlCdWZmZXIgb2JqZWN0LCB0aGUgb2Zmc2V0IGlmIHNwZWNpZmllZCBpbiBieXRlcywgYW5kIHRoZSB0eXBlIGlzIGEgc3RyaW5nXG4vL2NvcnJlc3BvbmRpbmcgdG8gYW4gT0dDIGRhdGEgdHlwZS5cbi8vU2VlIGh0dHA6Ly9kZWYuc2VlZ3JpZC5jc2lyby5hdS9zaXNzdm9jL29nYy1kZWYvcmVzb3VyY2U/dXJpPWh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2RhdGFUeXBlL09HQy8wL1xuLyoqXG4gKlxuICogQHBhcmFtIGJ1ZmZlclxuICogQHBhcmFtIG9mZnNldFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUJ5dGVzKGJ1ZmZlciwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblxuICAgIC8vTm90ZTogVGhlcmUgZXhpc3QgdHlwZXMgbm90IGxpc3RlZCBpbiB0aGUgbWFwIGJlbG93IHRoYXQgaGF2ZSBPR0MgZGVmaW5pdGlvbnMsIGJ1dCBubyBhcHByb3ByaWF0ZVxuICAgIC8vbWV0aG9kcyBvciBjb3JyZXNwb25kaW5nIHR5cGVzIGF2YWlsYWJsZSBmb3IgcGFyc2luZyBpbiBqYXZhc2NyaXB0LiBUaGV5IGFyZSBmbG9hdDEyOCwgZmxvYXQxNiwgc2lnbmVkTG9uZyxcbiAgICAvL2FuZCB1bnNpZ25lZExvbmdcbiAgICBsZXQgdHlwZU1hcCA9IHtcbiAgICAgICAgZG91YmxlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQ2NDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0MzI6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9UT0RPOiBzdHJpbmctdXRmLTg6XG4gICAgfTtcbiAgICByZXR1cm4gdHlwZU1hcFt0eXBlXShvZmZzZXQpO1xufVxuXG4vL1RoaXMgZnVuY3Rpb24gcmVjdXJzaXZsZXkgaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0U3RydWN0dXJlIHRvIGZpbGwgaW5cbi8vdmFsdWVzIHJlYWQgZnJvbSBkYXRhIHdoaWNoIHNob3VsZCBiZSBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBwYXlsb2FkIGZyb20gYSB3ZWJzb2NrZXRcbi8qKlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3RcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gb2Zmc2V0Qnl0ZXNcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWFkRGF0YShzdHJ1Y3QsIGRhdGEsIG9mZnNldEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IG9mZnNldEJ5dGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0LmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY3VyckZpZWxkU3RydWN0ID0gc3RydWN0LmZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QudHlwZSkgJiYgY3VyckZpZWxkU3RydWN0LnR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBQYXJzZUJ5dGVzKGRhdGEsIG9mZnNldCwgY3VyckZpZWxkU3RydWN0LnR5cGUpO1xuICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbCA9IHJldC52YWw7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcmV0LmJ5dGVzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QuY291bnQpICYmIGN1cnJGaWVsZFN0cnVjdC5jb3VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jaGVjayBpZiBjb3VudCBpcyBhIHJlZmVyZW5jZSB0byBhbm90aGVyIGxldGlhYmxlXG4gICAgICAgICAgICBpZiAoaXNOYU4oY3VyckZpZWxkU3RydWN0LmNvdW50KSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGN1cnJGaWVsZFN0cnVjdC5jb3VudDtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGROYW1lID0gc3RydWN0LmlkMkZpZWxkTWFwW2lkXTtcbiAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QuY291bnQgPSBzdHJ1Y3QuZmluZEZpZWxkQnlOYW1lKGZpZWxkTmFtZSkudmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VyckZpZWxkU3RydWN0LmZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGN1cnJGaWVsZFN0cnVjdC5maWVsZHNbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gUmVhZERhdGEoZmllbGQsIGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSByZXN1bHRTdHJ1Y3R1cmVcbiAqIEByZXR1cm4ge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gR2V0UmVzdWx0T2JqZWN0KHJlc3VsdFN0cnVjdHVyZSkge1xuICAgIC8vVE9ETzogaGFuZGxlIGNhc2VzIGZvciBuZXN0ZWQgYXJyYXlzIC8gbWF0cml4IGRhdGEgdHlwZXNcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQocmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10udmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVyYSgpIHtcbiAgICByZXR1cm4gKCEhd2luZG93Lm9wciAmJiAhIW9wci5hZGRvbnMpIHx8ICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gICAgcmV0dXJuICEhd2luZG93LmNocm9tZSAmJiAhIXdpbmRvdy5jaHJvbWUud2Vic3RvcmU7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp8Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmxpbmsoKSB7XG4gICAgcmV0dXJuIChpc0Nocm9tZSB8fCBpc09wZXJhKSAmJiAhIXdpbmRvdy5DU1M7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlJbnRlcnNlY3QoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGVsZW1lbnQpID4gLTE7XG4gICAgfSkubGVuZ3RoID4gMDtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxuICAgICAgICBvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICk7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKFdvcmtlcik7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkaXZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VTY3JlZW5TaG90KGRpdikge1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNzcyBjbGFzcyBmcm9tIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byByZW1vdmUgdGhlIGNsYXNzIGZyb21cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNzcyhkaXYsIGNzcykge1xuICAgIGxldCBkaXZDc3MgPSBkaXYuY2xhc3NOYW1lO1xuICAgIGNzcyA9IGRpdkNzcy5yZXBsYWNlKGNzcywgXCJcIik7XG4gICAgZGl2LmNsYXNzTmFtZSA9IGNzcztcbn1cblxuXG4vKipcbiAqIEFkZCBhIGNzcyBjbGFzcyB0byBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gYWRkIHRoZSBjbGFzcyB0b1xuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIGFkZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3NzKGRpdiwgY3NzKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRpdi5jbGFzc05hbWUgKyBcIiBcIiArIGNzcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB7c3RyaW5nfSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgaW5wdXQge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIHdpdGhvdXQgdGhlIGxhc3QgY2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMYXN0Q2hhcklmRXhpc3QodmFsdWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh1bmRlZmluZWQpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCAhdmFsdWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xufVxuXG4vKipcbiAqIFJvdW5kIG9mZiBudW1iZXIgdG8gbmVhcmVzdCAwLjVcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHJvdW5kIG9mZlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm91bmRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kSGFsZihudW0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0qMikvMjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCxcbiAqIHdpbGwgbm90IGJlIGV4ZWN1dGVkLiBUaGUgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHdoZW5cbiAqIGl0IHdpbGwgc3RvcCBiZWluZyBjYWxsZWQgZm9yIG1vcmUgdGhhbiBOIG1pbGxpc2Vjb25kcy5cbiAqIElmIHRoZSBgaW1tZWRpYXRlYCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlbiB0aGUgZnVuY3Rpb25cbiAqIHdpbGwgYmUgZXhlY3V0ZWQgYXQgdGhlIGZpcnN0IGNhbGwgaW5zdGVhZCBvZiB0aGUgbGFzdC5cbiAqIFBhcmFtZXRlcnMgOlxuICogLSBmdW5jOiB0aGUgZnVuY3Rpb24gdG8gYGRlYm91bmNlcmAuXG4gKiAtIHdhaXQ6IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIChOKSB0byB3YWl0IGJlZm9yZVxuICogY2FsbCBmdW5jKClcbiAqIC0gaW1tZWRpYXRlIChvcHRpb25hbCk6IENhbGwgZnVuYygpIGF0IHRoZSBmaXJzdCBpbnZvY2F0aW9uXG4gKiBpbnN0ZWFkIG9mIHRoZSBsYXN0IG9uZSAoRGVmYXVsdCBmYWxzZSlcbiAqIC0gY29udGV4dCAob3B0aW9uYWwpOiB0aGUgY29udGV4dCBpbiB3aGljaCB0byBjYWxsIGZ1bmMoKVxuICogKHRoaXMgYnkgZGVmYXVsdClcbiAqL1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGxhc3QgPSBub3cgLSB0aW1lc3RhbXA7XG5cbiAgICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIGxlYWRpbmcsIHRyYWlsaW5nLCBjb250ZXh0KSB7XG4gICAgdmFyIGN0eCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGU7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgIWxlYWRpbmcpIHByZXZpb3VzID0gbm93O1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIGN0eCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIHRyYWlsaW5nKSB7XG4gICAgICAgICAgICAvLyBTaW5vbiBvbiBz4oCZZW5kb3J0IHBlbmRhbnQgbGUgdGVtcHMgcmVzdGFudFxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBgc291cmNlYCBwcm9wZXJ0aWVzIGFuZCBpZiBhbiBgT2JqZWN0YCBzZXQgcHJvcGVydHkgdG8gbWVyZ2Ugb2YgYHRhcmdldGAgYW5kIGBzb3VyY2VgIHByb3BlcnRpZXNcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgICAgIGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCAmJiBrZXkgaW4gdGFyZ2V0KSBPYmplY3QuYXNzaWduKHNvdXJjZVtrZXldLCBtZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pKVxuICAgIH1cblxuICAgIC8vIEpvaW4gYHRhcmdldGAgYW5kIG1vZGlmaWVkIGBzb3VyY2VgXG4gICAgT2JqZWN0LmFzc2lnbih0YXJnZXQgfHwge30sIHNvdXJjZSlcbiAgICByZXR1cm4gdGFyZ2V0XG59O1xuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlsc1wiO1xuXG5jbGFzcyBEYXRhU291cmNlUGFyc2VyIHtcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgZnVsbCB1cmwuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMucHJvdG9jb2wgdGhlIHByb3RvY29sIHByb3RvY29sXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgdGhlIGVuZHBvaW50IHVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnNlcnZpY2UgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5vZmZlcmluZ0lEIHRoZSBvZmZlcmluZ0lEXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2JzZXJ2ZWRQcm9wZXJ0eSB0aGUgb2JzZXJ2ZWQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zdGFydFRpbWUgdGhlIHN0YXJ0IHRpbWUgKElTTyBmb3JtYXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kVGltZSB0aGUgZW5kIHRpbWUgKElTTyBmb3JtYXQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVwbGF5U3BlZWQgdGhlIHJlcGxheSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5yZXNwb25zZUZvcm1hdCB0aGUgcmVzcG9uc2UgZm9ybWF0IChlLmcgdmlkZW8vbXA0KVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gcHJvcGVydGllcy5sYXN0VGltZVN0YW1wIC0gdGhlIGxhc3QgdGltZXN0YW1wIHRvIHN0YXJ0IGF0IHRoaXMgdGltZSAoSVNPIFN0cmluZylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMgLSB0aGUgZW5jb2Rpbmcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb19iaXRyYXRlIC0gZGVmaW5lIGEgY3VzdG9tIGJpdHJhdGUgKGluIGIvcylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9fc2NhbGUgLSBkZWZpbmUgYSBjdXN0b20gc2NhbGUsIDAuMCA8IHZhbHVlIDwgMS4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX3dpZHRoIC0gZGVmaW5lIGEgY3VzdG9tIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX2hlaWdodCAtIGRlZmluZSBhIGN1c3RvbSBoZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmdWxsIHVybFxuICAgICAqL1xuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG5cbiAgICAgICAgLy8gYWRkcyBwcm90b2NvbFxuICAgICAgICB1cmwgKz0gcHJvcGVydGllcy5wcm90b2NvbCArIFwiOi8vXCI7XG5cbiAgICAgICAgLy8gYWRkcyBlbmRwb2ludCB1cmxcbiAgICAgICAgdXJsICs9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgKyBcIj9cIjtcblxuICAgICAgICAvLyBhZGRzIHNlcnZpY2VcbiAgICAgICAgdXJsICs9IFwic2VydmljZT1cIiArIHByb3BlcnRpZXMuc2VydmljZTtcblxuICAgICAgICAvLyBhZGRzIHZlcnNpb25cbiAgICAgICAgdXJsICs9IFwiJnZlcnNpb249Mi4wJlwiO1xuXG4gICAgICAgIC8vIGFkZHMgcmVzcG9uc2VGb3JtYXQgKG9wdGlvbmFsKVxuICAgICAgICBpZiAocHJvcGVydGllcy5yZXNwb25zZUZvcm1hdCkge1xuICAgICAgICAgICAgdXJsICs9IFwiJnJlc3BvbnNlRm9ybWF0PVwiICsgcHJvcGVydGllcy5yZXNwb25zZUZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzRGVmaW5lZChwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcykgJiYgT2JqZWN0LmtleXMocHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0ga2V5Kyc9Jytwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtc1trZXldKycmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHVybC5lbmRzV2l0aCgnJicpKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVNvdXJjZVBhcnNlcjtcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHNcIjtcbmltcG9ydCBEYXRhU291cmNlUGFyc2VyIGZyb20gXCIuL0RhdGFTb3VyY2VQYXJzZXJcIjtcblxuY2xhc3MgVGltZVNlcmllc1BhcnNlclBhcnNlciBleHRlbmRzIERhdGFTb3VyY2VQYXJzZXJ7XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGZ1bGwgdXJsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnByb3RvY29sIHRoZSBwcm90b2NvbCBwcm90b2NvbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZHBvaW50VXJsIHRoZSBlbmRwb2ludCB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zZXJ2aWNlIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2ZmZXJpbmdJRCB0aGUgb2ZmZXJpbmdJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHkgdGhlIG9ic2VydmVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuc3RhcnRUaW1lIHRoZSBzdGFydCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZFRpbWUgdGhlIGVuZCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnJlcGxheVNwZWVkIHRoZSByZXBsYXkgZmFjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQgdGhlIHJlc3BvbnNlIGZvcm1hdCAoZS5nIHZpZGVvL21wNClcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCAtIHRoZSBsYXN0IHRpbWVzdGFtcCB0byBzdGFydCBhdCB0aGlzIHRpbWUgKElTTyBTdHJpbmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zIC0gdGhlIGVuY29kaW5nIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmdWxsIHVybFxuICAgICAqL1xuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHVybCA9IHN1cGVyLmJ1aWxkVXJsKHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIGFkZHMgcmVxdWVzdFxuICAgICAgICB1cmwgKz0gXCImcmVxdWVzdD1HZXRSZXN1bHRcIjtcblxuICAgICAgICAvLyBhZGRzIG9mZmVyaW5nXG4gICAgICAgIHVybCArPSBcIiZvZmZlcmluZz1cIiArIHByb3BlcnRpZXMub2ZmZXJpbmdJRDtcblxuICAgICAgICAvLyBhZGRzIG9ic2VydmVkUHJvcGVydHlcbiAgICAgICAgdXJsICs9IFwiJm9ic2VydmVkUHJvcGVydHk9XCIgKyBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHk7XG5cbiAgICAgICAgLy8gYWRkcyB0ZW1wb3JhbEZpbHRlclxuICAgICAgICBjb25zdCBzdFRpbWUgPSAoaXNEZWZpbmVkKHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCkpID8gcHJvcGVydGllcy5sYXN0VGltZVN0YW1wIDogIHByb3BlcnRpZXMuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmxhc3RTdGFydFRpbWUgPSBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBwcm9wZXJ0aWVzLmVuZFRpbWU7XG4gICAgICAgIHVybCArPSBcIiZ0ZW1wb3JhbEZpbHRlcj1waGVub21lbm9uVGltZSxcIiArIHN0VGltZSsgXCIvXCIgKyBlbmRUaW1lO1xuICAgICAgICBpZiAocHJvcGVydGllcy5yZXBsYXlTcGVlZCkge1xuICAgICAgICAgICAgLy8gYWRkcyByZXBsYXlTcGVlZFxuICAgICAgICAgICAgdXJsICs9IFwiJnJlcGxheVNwZWVkPVwiICsgcHJvcGVydGllcy5yZXBsYXlTcGVlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzUGFyc2VyUGFyc2VyO1xuIiwiaW1wb3J0IERhdGFTb3VyY2VQYXJzZXIgZnJvbSBcIi4vRGF0YVNvdXJjZVBhcnNlci5qc1wiO1xuaW1wb3J0IFRpbWVTZXJpZXNQYXJzZXIgZnJvbSBcIi4vVGltZVNlcmllc1BhcnNlci5wYXJzZXJcIjtcblxuY2xhc3MgVmlkZW9QYXJzZXIgZXh0ZW5kcyBUaW1lU2VyaWVzUGFyc2VyIHtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRpbWVzdGFtcCBmcm9tIHRoZSBtZXNzYWdlLiBUaGUgdGltZXN0YW1wIGlzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpcnN0IDY0Yml0cyBvZiB0aGUgYmluYXJ5IG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSAtIHRoZSBkYXRhIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgZXh0cmFjdGVkIHRpbWVzdGFtcFxuICAgICAqL1xuICAgIHBhcnNlVGltZVN0YW1wKGRhdGEpIHtcbiAgICAgICAgLy8gcmVhZCBkb3VibGUgdGltZSBzdGFtcCBhcyBiaWcgZW5kaWFuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YSkuZ2V0RmxvYXQ2NCgwLCBmYWxzZSkgKiAxMDAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgZGF0YSBmcm9tIHRoZSBtZXNzYWdlLiBUaGUgSDI2NCBOQUwgdW5pdCBzdGFydHMgYXQgb2Zmc2V0IDEyIGFmdGVyIDgtYnl0ZXMgdGltZSBzdGFtcCBhbmQgNC1ieXRlcyBmcmFtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSAtIHRoZSBkYXRhIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHBhcnNlZCBkYXRhXG4gICAgICovXG4gICAgcGFyc2VEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIEgyNjQgTkFMIHVuaXQgc3RhcnRzIGF0IG9mZnNldCAxMiBhZnRlciA4LWJ5dGVzIHRpbWUgc3RhbXAgYW5kIDQtYnl0ZXMgZnJhbWUgbGVuZ3RoXG4gICAgICAgICAgICBmcmFtZURhdGE6IG5ldyBVaW50OEFycmF5KGRhdGEsIDEyLCBkYXRhLmJ5dGVMZW5ndGggLSAxMiksXG4gICAgICAgICAgICByb2xsOiAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGZ1bGwgdXJsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnByb3RvY29sIHRoZSBwcm90b2NvbCBwcm90b2NvbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZHBvaW50VXJsIHRoZSBlbmRwb2ludCB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zZXJ2aWNlIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2ZmZXJpbmdJRCB0aGUgb2ZmZXJpbmdJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHkgdGhlIG9ic2VydmVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuc3RhcnRUaW1lIHRoZSBzdGFydCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZFRpbWUgdGhlIGVuZCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnJlcGxheVNwZWVkIHRoZSByZXBsYXkgZmFjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZm9pSWQgdGhlIGZvaUlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQgdGhlIHJlc3BvbnNlIGZvcm1hdCAoZS5nIHZpZGVvL21wNClcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCAtIHRoZSBsYXN0IHRpbWVzdGFtcCB0byBzdGFydCBhdCB0aGlzIHRpbWUgKElTTyBTdHJpbmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zIC0gdGhlIGVuY29kaW5nIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9fYml0cmF0ZSAtIGRlZmluZSBhIGN1c3RvbSBiaXRyYXRlIChpbiBiL3MpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX3NjYWxlIC0gZGVmaW5lIGEgY3VzdG9tIHNjYWxlLCAwLjAgPCB2YWx1ZSA8IDEuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb193aWR0aCAtIGRlZmluZSBhIGN1c3RvbSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb19oZWlnaHQgLSBkZWZpbmUgYSBjdXN0b20gaGVpZ2h0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgZnVsbCB1cmxcbiAgICAgKi9cbiAgICBidWlsZFVybChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxldCB1cmwgPSBzdXBlci5idWlsZFVybChwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBhZGRzIGZlYXR1cmUgb2YgaW50ZXJlc3QgdXJuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmZvaUlkICYmIHByb3BlcnRpZXMub2YgIT09ICcnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZmZWF0dXJlT2ZJbnRlcmVzdD0nICsgcHJvcGVydGllcy5mb2lJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgIFZpZGVvUGFyc2VyO1xuIiwiLyoqXG4gKiBFbnVtIGZvciBjb25uZWN0aW9uIHN0YXR1cy5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3tuYW1lOiBzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgU3RhdHVzID0ge1xuICAgIENPTk5FQ1RJTkc6IFwiY29ubmVjdGluZ1wiLFxuICAgIENPTk5FQ1RFRDogIFwiY29ubmVjdGVkXCIsXG4gICAgRElTQ09OTkVDVEVEOiBcImRpc2Nvbm5lY3RlZFwiXG59O1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQge3JhbmRvbVVVSUR9IGZyb20gJy4uL3V0aWxzL1V0aWxzLmpzJztcbmltcG9ydCB7U3RhdHVzfSBmcm9tICcuL1N0YXR1cy5qcyc7XG5cbi8qKlxuICogVGhlIERhdGFDb25uZWN0b3IgaXMgdGhlIGFic3RyYWN0IGNsYXNzIHVzZWQgdG8gY3JlYXRlIGRpZmZlcmVudCBjb25uZWN0b3JzLlxuICovXG5jbGFzcyBEYXRhQ29ubmVjdG9yIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgZnVsbCB1cmwgdXNlZCB0byBjb25uZWN0IHRvIHRoZSBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5pZCA9IFwiRGF0YUNvbm5lY3Rvci1cIiArIHJhbmRvbVVVSUQoKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gMTAwMCAqIDYwICogMjsgLy8yIG1pblxuICAgICAgICB0aGlzLnN0YXR1cyA9ICBTdGF0dXMuRElTQ09OTkVDVEVEO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkludGVydmFsID0gLTE7XG4gICAgfVxuXG4gICAgY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkludGVydmFsID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICB0aGlzLmNoZWNrQW5kQ2xlYXJSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1cmxcbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICovXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBwcm90b2NvbCBkZWZhdWx0IGlkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVhbSB1cmwuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgLSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHJlY29ubmVjdGluZyBkYXRhU291cmNlXG4gICAgICovXG4gICAgc2V0UmVjb25uZWN0VGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuXG4gICAgb25SZWNvbm5lY3QoKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHt9XG5cbiAgICBmb3JjZVJlY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIFNUQVRVUyBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICovXG4gICAgb25DaGFuZ2VTdGF0dXMoc3RhdHVzKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBhIGNoYW5nZSBvZiB0aGUgc3RhdHVzIGFuZCBjYWxsIHRoZSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIGN1cnJlbnRTdGF0dXNcbiAgICAgKi9cbiAgICBjaGVja1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYoc3RhdHVzICE9PSB0aGlzLnN0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHByb3RvY29sIGhhcyBiZWVuIGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdCgpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBwcm90b2NvbCBoYXMgYmVlbiBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNvbm5lY3QoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFDb25uZWN0b3I7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC5cbiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmVcbiBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cbiBTb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlXG4gZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIENvcHlyaWdodCAoQykgMjAxNS0yMDIwIE1hdGhpZXUgRGhhaW5hdXQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiBBdXRob3I6IE1hdGhpZXUgRGhhaW5hdXQgPG1hdGhpZXUuZGhhaW5hdXRAZ21haWwuY29tPlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCBEYXRhQ29ubmVjdG9yIGZyb20gJy4vRGF0YUNvbm5lY3Rvci5qcyc7XG5pbXBvcnQge2lzV2ViV29ya2VyfSBmcm9tICcuLi91dGlscy9VdGlscy5qcyc7XG5pbXBvcnQge1N0YXR1c30gZnJvbSAnLi9TdGF0dXMuanMnO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIFdlYlNvY2tldENvbm5lY3RvciB0byBjb25uZWN0IHRvIGEgcmVtb3RlIHNlcnZlciBieSBjcmVhdGluZyBhIFdlYlNvY2tldCBjaGFubmVsLlxuICogQGV4dGVuZHMgRGF0YUNvbm5lY3RvclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBXZWJTb2NrZXRDb25uZWN0b3IgZnJvbSAnb3NoLWpzL2RhdGFjb25uZWN0b3IvV2ViU29ja2V0Q29ubmVjdG9yLmpzJztcbiAqXG4gKiBsZXQgdXJsID0gLi4uO1xuICogbGV0IGNvbm5lY3RvciA9IG5ldyBXZWJTb2NrZXRDb25uZWN0b3IodXJsKTtcbiAqXG4gKiAvLyBjb25uZWN0XG4gKiBjb25uZWN0b3IuY29ubmVjdCgpO1xuICpcbiAqIC8vIGRpc2Nvbm5lY3RcbiAqIGNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gKlxuICogLy8gY2xvc2VcbiAqIGNvbm5lY3Rvci5jbG9zZSgpO1xuICpcbiAqL1xuXG5jbGFzcyBXZWJTb2NrZXRDb25uZWN0b3IgZXh0ZW5kcyBEYXRhQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIC1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHN1cGVyKHByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMubGFzdFJlY2VpdmVUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSB3ZWJTb2NrZXQuIElmIHRoZSBzeXN0ZW0gc3VwcG9ydHMgV2ViV29ya2VyLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBvbmUgb3RoZXJ3aXNlIHVzZVxuICAgICAqIHRoZSBtYWluIHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IHRydWU7XG4gICAgICAgICAgICAvL2NyZWF0ZXMgV2ViIFNvY2tldFxuICAgICAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5nZXRVcmwoKSk7XG4gICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0YXR1cyhTdGF0dXMuQ09OTkVDVElORyk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBzdHJlYW0gY29ubmVjdGluZycpO1xuICAgICAgICAgICAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RFRCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgc3RyZWFtIGNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlY2VpdmVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGRhdGEgb24gbWVzc2FnZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gY2xvc2VzIHNvY2tldCBpZiBhbnkgZXJyb3JzIG9jY3VyXG4gICAgICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgc3RyZWFtIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1N0YXR1cyhTdGF0dXMuRElTQ09OTkVDVEVEKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVjb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgc3RyZWFtIGNsb3NlZDogJyxldmVudC5yZWFzb24sIGV2ZW50LmNvZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKGV2ZW50LmNvZGUgIT09IDEwMDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVjb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZVJlY29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYoIXRoaXMuY2xvc2VkICYmIHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgPT09IC0xICYmIHRoaXMub25SZWNvbm5lY3QoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9ICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlY2VpdmVUaW1lO1xuICAgICAgICAgICAgICAgIC8vIC0xIG1lYW5zIHRoZSBXUyB3ZW50IGluIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdFJlY2VpdmVUaW1lID09PSAtMSB8fCAoZGVsdGEgPj0gdGhpcy5yZWNvbm5lY3RUaW1lb3V0KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RyeWluZyB0byByZWNvbm5lY3QnLCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGFuZCBjbG9zZSB0aGUgd2Vic29ja2V0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgc3VwZXIuZGlzY29ubmVjdCgpO1xuICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICBpZiAodGhpcy53cyAhPSBudWxsICYmIHRoaXMud3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvbk1lc3NhZ2UgbWV0aG9kIHVzZWQgYnkgdGhlIHdlYnNvY2tldCB0byBjYWxsYmFjayB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBjYWxsYmFjayBkYXRhXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25NZXNzYWdlKGRhdGEpIHtcbiAgICB9XG5cblxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMud3MgIT0gbnVsbCAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYlNvY2tldENvbm5lY3RvcjtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IERhdGFDb25uZWN0b3IgZnJvbSAnLi9EYXRhQ29ubmVjdG9yLmpzJztcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tICcuLi91dGlscy9VdGlscy5qcyc7XG5pbXBvcnQge1N0YXR1c30gZnJvbSAnLi9TdGF0dXMuanMnO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIEFqYXhDb25uZWN0b3IgdG8gY29ubmVjdCB0byBhIHJlbW90ZSBzZXJ2ZXIgYnkgbWFraW5nIEFqYXhSZXF1ZXN0LlxuICogQGV4dGVuZHMgRGF0YUNvbm5lY3RvclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBBamF4IGZyb20gJ2NvcmUvcHJvdG9jb2wvQWpheC5qcyc7XG4gKlxuICogbGV0IHJlcXVlc3QgPSAuLi47XG4gKiBsZXQgcHJvdG9jb2wgPSBuZXcgQWpheCh1cmwpO1xuICpcbiAqIC8vIGhhbmRsZSBvblN1Y2Nlc3NcbiAqIHByb3RvY29sLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgLy8gZG9lcyBzb21ldGhpbmdcbiAqIH1cbiAqXG4gKiBwcm90b2NvbC5vbkVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAvLyBkb2VzIHNvbWV0aGluZ1xuICogfVxuICpcbiAqIC8vIHNlbmQgcmVxdWVzdFxuICogcHJvdG9jb2wuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gKlxuICovXG5jbGFzcyBBamF4IGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIEFqYXguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm1ldGhvZCAtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlIC1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIodXJsKTtcblxuICAgICAgICB0aGlzLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IHByb3BlcnRpZXMubWV0aG9kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIGRlZmluZWQgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0IC0gVGhlIEh0dHAgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHRyYVVybCAtIGdldCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgZXh0cmFVcmwpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4bWxodHRwLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIHhtbGh0dHAudGltZW91dCA9IDYwMDAwO1xuICAgICAgICBpZiAocmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChleHRyYVVybCkpIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdGhpcy5nZXRVcmwoKSArIFwiP1wiICsgZXh0cmFVcmwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdGhpcy5nZXRVcmwoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxodHRwLnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgeG1saHR0cC5vbmxvYWQgPSAob0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhtbGh0dHAucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbk1lc3NhZ2UoeG1saHR0cC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeG1saHR0cC5vbnRpbWVvdXQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGltZW91dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RFRCk7XG4gICAgICAgICAgICB4bWxodHRwLnNlbmQobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJQT1NUXCIsIHRoaXMuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICAgICAgeG1saHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcblxuICAgICAgICAgICAgeG1saHR0cC5zZW5kKHJlcXVlc3QpO1xuICAgICAgICAgICAgc2VsZi5jaGVja1N0YXR1cyhTdGF0dXMuQ09OTkVDVEVEKTtcbiAgICAgICAgICAgIHhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PT0gNCkgeyAgICAgICAgICAgICAgICAvLyA0ID0gUmVzcG9uc2UgZnJvbSBzZXJ2ZXIgaGFzIGJlZW4gY29tcGxldGVseSBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnN0YXR1cyA9PT0gMjAwICYmIHhtbGh0dHAuc3RhdHVzIDwgMzAwKSB7IC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25TdWNjZXNzKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25FcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjYWxsYmFjayBtZXRob2QgaW4gY2FzZSBvZiBnZXR0aW5nIGVycm9yIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBlcnJvciBkZXRhaWxzXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25FcnJvcihldmVudCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY2FsbGJhY2sgbWV0aG9kIGluIGNhc2Ugb2YgZ2V0dGluZyBzdWNjZXNzIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25TdWNjZXNzKGV2ZW50KSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgcmVxdWVzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChudWxsKTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFqYXg7XG4iLCJpbXBvcnQgRGF0YUNvbm5lY3RvciBmcm9tIFwiLi9EYXRhQ29ubmVjdG9yXCI7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgRmlsZUNvbm5lY3RvciB0byByZWFkIGEgRmlsZSBjb250ZW50XG4gKiBAZXh0ZW5kcyBEYXRhQ29ubmVjdG9yXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IEZpbGVDb25uZWN0b3IgZnJvbSAnY29yZS9wcm90b2NvbC9Ub3BpY0Nvbm5lY3Rvci5qcyc7XG4gKlxuICogbGV0IHByb3RvY29sID0gbmV3IFRvcGljQ29ubmVjdG9yKDx0b3BpY19uYW1lPik7XG4gKlxuICogLy8gY29ubmVjdFxuICogcHJvdG9jb2wuY29ubmVjdCgpO1xuICpcbiAqIC8vIGRpc2Nvbm5lY3RcbiAqIHByb3RvY29sLmRpc2Nvbm5lY3QoKTtcbiAqXG4gKiAvLyBjbG9zZVxuICogcHJvdG9jb2wuY2xvc2UoKTtcbiAqXG4gKi9cbmNsYXNzIFRvcGljQ29ubmVjdG9yIGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyAtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIGJyb2FkY2FzdENoYW5uZWwuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jcmVhdGVzIGJyb2FkY2FzdENoYW5uZWxcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRoaXMuZ2V0VXJsKCkpO1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLm9ubWVzc2FnZSA9ICAoZXZlbnQpICA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgZGF0YSBvbiBtZXNzYWdlIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoZXZlbnQuZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGNsb3NlcyBzb2NrZXQgaWYgYW55IGVycm9ycyBvY2N1clxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLm9uZXJyb3IgPSAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQnJvYWRjYXN0Q2hhbm5lbCBzdHJlYW0gZXJyb3I6ICcgKyBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9pbml0IHRoZSByZWNvbm5lY3QgaGFuZGxlclxuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlY2VpdmVUaW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyAtMSBtZWFucyB0aGUgV1Mgd2VudCBpbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0UmVjZWl2ZVRpbWUgPT09IC0xIHx8IChkZWx0YSA+PSB0aGlzLnJlY29ubmVjdFRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHRyeWluZyB0byByZWNvbm5lY3QgYWZ0ZXIgJHt0aGlzLnJlY29ubmVjdFRpbWVvdXR9IC4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHdlYnNvY2tldC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmZ1bGxEaXNjb25uZWN0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bGx5IGRpc2Nvbm5lY3QgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGJ5IHNlbmRpbmcgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSB3ZWJXb3JrZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVJbnRlcnZhbCAgLSBmb3JjZSByZW1vdmluZyB0aGUgaW50ZXJ2YWxcbiAgICAgKi9cbiAgICBmdWxsRGlzY29ubmVjdChyZW1vdmVJbnRlcnZhbCkge1xuICAgICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gcmVjb25uZWN0IGlmIHRoZSBjb25uZXhpb24gaWYgY2xvc2VkXG4gICAgICovXG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICB0aGlzLm9uUmVjb25uZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbERpc2Nvbm5lY3QoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9uTWVzc2FnZSBtZXRob2QgdXNlZCBieSB0aGUgd2Vic29ja2V0IHRvIGNhbGxiYWNrIHRoZSBkYXRhXG4gICAgICogQHBhcmFtIGRhdGEgdGhlIGNhbGxiYWNrIGRhdGFcbiAgICAgKiBAZXZlbnRcbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UoZGF0YSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgd2ViU29ja2V0LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCAhPT0gbnVsbCAmJiB0aGlzLm9wZW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvcGljQ29ubmVjdG9yO1xuIiwiZXhwb3J0IGNvbnN0IEV2ZW50VHlwZSA9IHtcbiAgICBEQVRBOiAnZGF0YScsXG4gICAgU1RBVFVTOiAnc3RhdHVzJ1xufTtcbiIsImltcG9ydCBEYXRhQ29ubmVjdG9yIGZyb20gXCIuL0RhdGFDb25uZWN0b3JcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi9TdGF0dXNcIjtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBGaWxlQ29ubmVjdG9yIHRvIHJlYWQgYSBGaWxlIGNvbnRlbnRcbiAqIEBleHRlbmRzIERhdGFDb25uZWN0b3JcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgRmlsZUNvbm5lY3RvciBmcm9tICdjb3JlL3Byb3RvY29sL0ZpbGVDb25uZWN0b3IuanMnO1xuICpcbiAqIGxldCBwYXRocyA9IFsncGF0aDEnLCdwYXRoMl0uLi5dO1xuICogbGV0IHByb3RvY29sID0gbmV3IEZpbGVDb25uZWN0b3IocGF0aHMpO1xuICpcbiAqIC8vIGNvbm5lY3RcbiAqIHByb3RvY29sLmNvbm5lY3QoKTtcbiAqXG4gKiAvLyBkaXNjb25uZWN0XG4gKiBwcm90b2NvbC5kaXNjb25uZWN0KCk7XG4gKlxuICogLy8gY2xvc2VcbiAqIHByb3RvY29sLmNsb3NlKCk7XG4gKlxuICovXG5jbGFzcyBGaWxlQ29ubmVjdG9yIGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIChzdHJpbmdbXSkgcGF0aHMgLSBsaXN0IG9mIGZpbGUgcGF0aHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXRocykge1xuICAgICAgICBzdXBlcihwYXRocyk7XG4gICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgcmVhZGluZyBmaWxlIGNvbnRlbnRcbiAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZighdGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VTdGF0dXMoU3RhdHVzLkNPTk5FQ1RFRCk7XG4gICAgICAgICAgICBjb25zdCB1cmxzID0gdGhpcy5nZXRVcmwoKTtcbiAgICAgICAgICAgIGZvcihsZXQgdXJsIG9mIHVybHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShhd2FpdCBmZXRjaCh1cmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICAvLyByZWFkIGlzIGRvbmVcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsZUNvbm5lY3RvcjtcbiIsImltcG9ydCBXZWJTb2NrZXRDb25uZWN0b3IgZnJvbSBcIi4uLy4uL3Byb3RvY29sL1dlYlNvY2tldENvbm5lY3Rvci5qc1wiO1xuaW1wb3J0IEFqYXggZnJvbSBcIi4uLy4uL3Byb3RvY29sL0FqYXguanNcIjtcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCBUb3BpY0Nvbm5lY3RvciBmcm9tIFwiLi4vLi4vcHJvdG9jb2wvVG9waWNDb25uZWN0b3IuanNcIjtcbmltcG9ydCB7RXZlbnRUeXBlfSBmcm9tIFwiLi4vLi4vZXZlbnQvRXZlbnRUeXBlLmpzXCI7XG5pbXBvcnQge1N0YXR1c30gZnJvbSBcIi4uLy4uL3Byb3RvY29sL1N0YXR1c1wiO1xuaW1wb3J0IEZpbGVDb25uZWN0b3IgZnJvbSBcIi4uLy4uL3Byb3RvY29sL0ZpbGVDb25uZWN0b3JcIjtcblxuY2xhc3MgRGF0YVNvdXJjZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IDEwMDAgKiAxMDsgLy8gMTAgc2Vjc1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29ubmVjdG9yKHByb3BlcnRpZXNTdHIsIHRvcGljLCBkYXRhU291cmNlSWQpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlSWQgPSBkYXRhU291cmNlSWQ7XG4gICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGluZyBwcm90b2NvbFxuICAgICAgICBpZih0aGlzLmNvbm5lY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodG9waWMpO1xuXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBKU09OLnBhcnNlKHByb3BlcnRpZXNTdHIpO1xuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy50aW1lU2hpZnQpKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVTaGlmdCA9IHByb3BlcnRpZXMudGltZVNoaWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLmJ1ZmZlcmluZ1RpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmluZ1RpbWUgPSBwcm9wZXJ0aWVzLmJ1ZmZlcmluZ1RpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMudGltZU91dCkpIHtcbiAgICAgICAgICAgIHRoaXMudGltZU91dCA9IHByb3BlcnRpZXMudGltZU91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy5yZWNvbm5lY3RUaW1lb3V0KSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gcHJvcGVydGllcy5yZWNvbm5lY3RUaW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocHJvcGVydGllcy5zdGFydFRpbWUgPT09ICdub3cnKSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMucmVwbGF5U3BlZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQocHJvcGVydGllcy5iYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy5iYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBwcm9wZXJ0aWVzLmJhdGNoU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNvbm5lY3Rvcih0aGlzLnByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlRGF0YUNvbm5lY3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMucGFyc2VyLmJ1aWxkVXJsKHtcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICB0aW1lU2hpZnQ6IHRoaXMudGltZVNoaWZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrcyBpZiB0eXBlIGlzIFdlYlNvY2tldENvbm5lY3RvclxuICAgICAgICBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCd3cycpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBXZWJTb2NrZXRDb25uZWN0b3IodXJsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgQWpheCh1cmwpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVzcG9uc2VUeXBlID0gcHJvcGVydGllcy5yZXNwb25zZVR5cGUgfHwgJ2FycmF5YnVmZmVyJztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnByb3RvY29sLnN0YXJ0c1dpdGgoJ3RvcGljJykpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IFRvcGljQ29ubmVjdG9yKHVybCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCdmaWxlJykpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IEZpbGVDb25uZWN0b3IodXJsLHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHJlY29ubmVjdFRpbWVvdXRcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnNldFJlY29ubmVjdFRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcblxuICAgICAgICAgICAgLy8gY29ubmVjdHMgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBiaW5kIGNoYW5nZSBjb25uZWN0aW9uIFNUQVRVU1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iub25DaGFuZ2VTdGF0dXMgICA9IHRoaXMub25DaGFuZ2VTdGF0dXMuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdG9waWMgdG8gbGlzdGVuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIC0gdGhlIHRvcGljIHRvIGxpc3RlblxuICAgICAqL1xuICAgIHNldFRvcGljKHRvcGljKSB7XG4gICAgICAgIGlmKGlzRGVmaW5lZCh0aGlzLmJyb2FkY2FzdENoYW5uZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCh0b3BpYyk7XG4gICAgICAgIHRoaXMudG9waWMgPSB0b3BpYztcbiAgICB9XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZih0aGlzLmNvbm5lY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYodGhpcy5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBkYXRhICAgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUodGhpcy5wYXJzZXIucGFyc2VEYXRhKGV2ZW50KSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZGF0YSBpcyBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7aSA8IGRhdGEubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2ldLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMuYmF0Y2hTaXplKSAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPj0gdGhpcy5iYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWNhdXNlIHBhcnNlRGF0YSBpcyBBU1lOQywgdGhlIHByb3RvY29sIGNhbiBmaW5pc2ggYmVmb3JlIHRoZSBwYXJzaW5nIG1ldGhvZC4gSW4gdGhhdCBjYXNlLCB3ZSBoYXZlIHRvIGZsdXNoQUxsIGRhdGFcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hBbGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQodGhpcy5iYXRjaFNpemUpICYmIHRoaXMudmFsdWVzLmxlbmd0aCAhPT0gMCAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPj0gdGhpcy5iYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjaGFuZ2Ugc3RhdHVzIGV2ZW50IGludG8gdGhlIGJyb2FkY2FzdCBjaGFubmVsXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICovXG4gICAgb25DaGFuZ2VTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmKHN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5TVEFUVVMsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIGRhdGFTb3VyY2VJZDogdGhpcy5kYXRhU291cmNlSWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNvbm5lY3Rvcih7XG4gICAgICAgICAgICAuLi50aGlzLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAuLi5wcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBmbHVzaEFsbCgpIHtcbiAgICAgICAgd2hpbGUodGhpcy52YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCBuYkVsZW1lbnRzID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMuYmF0Y2hTaXplKSAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPiB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgbmJFbGVtZW50cyA9IHRoaXMuYmF0Y2hTaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhU291cmNlSWQ6IHRoaXMuZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRBVEEsXG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLnNwbGljZSgwLCBuYkVsZW1lbnRzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbm5lY3RvciA9PT0gbnVsbCk/IGZhbHNlOiB0aGlzLmNvbm5lY3Rvci5pc0Nvbm5lY3RlZCgpO1xuICAgIH07XG5cbiAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIHdvcmtlcikge1xuICAgICAgICBpZihtZXNzYWdlLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb25uZWN0b3IobWVzc2FnZS5wcm9wZXJ0aWVzLCBtZXNzYWdlLnRvcGljLCBtZXNzYWdlLmlkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnZGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ3RvcGljJykge1xuICAgICAgICAgICAgdGhpcy5zZXRUb3BpYyhtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICd1cGRhdGUtdXJsJykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnaXMtY29ubmVjdGVkJykge1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaXMtY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmlzQ29ubmVjdGVkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBEYXRhU291cmNlSGFuZGxlcjtcblxuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IERhdGFTb3VyY2VIYW5kbGVyIGZyb20gXCIuL0RhdGFTb3VyY2VIYW5kbGVyXCI7XG5cbmNsYXNzIFRpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlciBleHRlbmRzIERhdGFTb3VyY2VIYW5kbGVye1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHRoaXMubGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFN0YXJ0VGltZSA9ICdub3cnO1xuICAgICAgICB0aGlzLnRpbWVTaGlmdCA9IDA7XG4gICAgICAgIHRoaXMudGltZUJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlRGF0YUNvbm5lY3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHN1cGVyLmNyZWF0ZURhdGFDb25uZWN0b3Ioe1xuICAgICAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgICAgIHRpbWVTaGlmdDogdGhpcy50aW1lU2hpZnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbGFzdFN0YXJ0VGltZUNzdCA9IHRoaXMucGFyc2VyLmxhc3RTdGFydFRpbWU7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yLm9uUmVjb25uZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm90IHJlYWwgdGltZSwgcHJlc2VydmUgbGFzdCB0aW1lc3RhbXAgdG8gcmVjb25uZWN0IGF0IHRoZSBsYXN0IHRpbWUgcmVjZWl2ZWRcbiAgICAgICAgICAgIC8vIGZvciB0aGF0LCB3ZSB1cGRhdGUgdGhlIFVSTCB3aXRoIHRoZSBuZXcgbGFzdCB0aW1lIHJlY2VpdmVkXG4gICAgICAgICAgICBpZiAobGFzdFN0YXJ0VGltZUNzdCAhPT0gJ25vdycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRVcmwodGhpcy5wYXJzZXIuYnVpbGRVcmwoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGltZVN0YW1wOiBpc0RlZmluZWQodGhpcy5sYXN0VGltZVN0YW1wKSA/IG5ldyBEYXRlKHRoaXMubGFzdFRpbWVTdGFtcCkudG9JU09TdHJpbmcoKTogcHJvcGVydGllcy5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcnNlci5wYXJzZVRpbWVTdGFtcChldmVudCkgKyB0aGlzLnRpbWVTaGlmdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgICAgICA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcnNlci5wYXJzZURhdGEoZXZlbnQpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGlzIGFycmF5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpIDwgZGF0YS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgdGltZVN0YW1wOiB0aW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RUaW1lU3RhbXAgPSB0aW1lU3RhbXA7XG5cbiAgICAgICAgaWYodGhpcy5wYXJzZXIubGFzdFN0YXJ0VGltZSA9PT0gJ25vdycgfHwgKChpc0RlZmluZWQodGhpcy5iYXRjaFNpemUpICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICBpZih0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5sYXN0VGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMYXN0VGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0VGltZVN0YW1wO1xuICAgIH1cblxuICAgIHVwZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICBsZXQgbGFzdFRpbWVzdGFtcCA9ICBuZXcgRGF0ZSh0aGlzLmxhc3RUaW1lU3RhbXApLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgaWYocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgnc3RhcnRUaW1lJykpIHtcbiAgICAgICAgICAgIGxhc3RUaW1lc3RhbXAgPSBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucHJvcGVydGllcy5zdGFydFRpbWUgPT09ICdub3cnKXtcbiAgICAgICAgICAgIC8vaGFuZGxlIFJlYWxUaW1lXG4gICAgICAgICAgICBsYXN0VGltZXN0YW1wID0gJ25vdyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnNpb24rKztcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ29ubmVjdG9yKHtcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBsYXN0VGltZVN0YW1wOiBsYXN0VGltZXN0YW1wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGlzRGVmaW5lZChwcm9wZXJ0aWVzKSAmJiBpc0RlZmluZWQocHJvcGVydGllcy5yZWNvbm5lY3QpICYmIHByb3BlcnRpZXMucmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgd29ya2VyKSB7XG4gICAgICAgIHN1cGVyLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgd29ya2VyKTtcblxuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnbGFzdC10aW1lc3RhbXAnKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VGltZVN0YW1wID0gdGhpcy5nZXRMYXN0VGltZVN0YW1wKCk7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdsYXN0LXRpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgZGF0YTogbGFzdFRpbWVTdGFtcFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICd0b3BpYycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZVRvcGljKG1lc3NhZ2UudGltZVRvcGljKTtcbiAgICAgICAgICAgIHN1cGVyLnNldFRvcGljKG1lc3NhZ2UudG9waWMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGltZVRvcGljKHRpbWVUb3BpYykge1xuICAgICAgICBpZih0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRpbWVUb3BpYyk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyO1xuXG4iLCJpbXBvcnQgU29zR2V0UmVzdWx0VmlkZW9QYXJzZXIgZnJvbSAnLi4vcGFyc2Vycy9Tb3NHZXRSZXN1bHRWaWRlby5wYXJzZXIuanMnO1xuaW1wb3J0IFRpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlciBmcm9tIFwiLi9UaW1lU2VyaWVzRGF0YVNvdXJjZUhhbmRsZXJcIjtcblxuY29uc3QgZGF0YVNvdXJjZUhhbmRsZXIgPSBuZXcgVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyKG5ldyBTb3NHZXRSZXN1bHRWaWRlb1BhcnNlcigpKTtcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBkYXRhU291cmNlSGFuZGxlci5oYW5kbGVNZXNzYWdlKGV2ZW50LmRhdGEsIHNlbGYpO1xufVxuXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);