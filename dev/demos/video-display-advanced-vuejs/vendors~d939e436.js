(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{166:function(module,exports,__webpack_require__){eval("/*!\n * Chart.js v2.9.4\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\n(function (global, factory) {\n   true ? module.exports = factory(function () {\n    try {\n      return __webpack_require__(1);\n    } catch (e) {}\n  }()) : undefined;\n})(this, function (moment) {\n  'use strict';\n\n  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  function getCjsExportFromNamespace(n) {\n    return n && n['default'] || n;\n  }\n\n  var colorName = {\n    \"aliceblue\": [240, 248, 255],\n    \"antiquewhite\": [250, 235, 215],\n    \"aqua\": [0, 255, 255],\n    \"aquamarine\": [127, 255, 212],\n    \"azure\": [240, 255, 255],\n    \"beige\": [245, 245, 220],\n    \"bisque\": [255, 228, 196],\n    \"black\": [0, 0, 0],\n    \"blanchedalmond\": [255, 235, 205],\n    \"blue\": [0, 0, 255],\n    \"blueviolet\": [138, 43, 226],\n    \"brown\": [165, 42, 42],\n    \"burlywood\": [222, 184, 135],\n    \"cadetblue\": [95, 158, 160],\n    \"chartreuse\": [127, 255, 0],\n    \"chocolate\": [210, 105, 30],\n    \"coral\": [255, 127, 80],\n    \"cornflowerblue\": [100, 149, 237],\n    \"cornsilk\": [255, 248, 220],\n    \"crimson\": [220, 20, 60],\n    \"cyan\": [0, 255, 255],\n    \"darkblue\": [0, 0, 139],\n    \"darkcyan\": [0, 139, 139],\n    \"darkgoldenrod\": [184, 134, 11],\n    \"darkgray\": [169, 169, 169],\n    \"darkgreen\": [0, 100, 0],\n    \"darkgrey\": [169, 169, 169],\n    \"darkkhaki\": [189, 183, 107],\n    \"darkmagenta\": [139, 0, 139],\n    \"darkolivegreen\": [85, 107, 47],\n    \"darkorange\": [255, 140, 0],\n    \"darkorchid\": [153, 50, 204],\n    \"darkred\": [139, 0, 0],\n    \"darksalmon\": [233, 150, 122],\n    \"darkseagreen\": [143, 188, 143],\n    \"darkslateblue\": [72, 61, 139],\n    \"darkslategray\": [47, 79, 79],\n    \"darkslategrey\": [47, 79, 79],\n    \"darkturquoise\": [0, 206, 209],\n    \"darkviolet\": [148, 0, 211],\n    \"deeppink\": [255, 20, 147],\n    \"deepskyblue\": [0, 191, 255],\n    \"dimgray\": [105, 105, 105],\n    \"dimgrey\": [105, 105, 105],\n    \"dodgerblue\": [30, 144, 255],\n    \"firebrick\": [178, 34, 34],\n    \"floralwhite\": [255, 250, 240],\n    \"forestgreen\": [34, 139, 34],\n    \"fuchsia\": [255, 0, 255],\n    \"gainsboro\": [220, 220, 220],\n    \"ghostwhite\": [248, 248, 255],\n    \"gold\": [255, 215, 0],\n    \"goldenrod\": [218, 165, 32],\n    \"gray\": [128, 128, 128],\n    \"green\": [0, 128, 0],\n    \"greenyellow\": [173, 255, 47],\n    \"grey\": [128, 128, 128],\n    \"honeydew\": [240, 255, 240],\n    \"hotpink\": [255, 105, 180],\n    \"indianred\": [205, 92, 92],\n    \"indigo\": [75, 0, 130],\n    \"ivory\": [255, 255, 240],\n    \"khaki\": [240, 230, 140],\n    \"lavender\": [230, 230, 250],\n    \"lavenderblush\": [255, 240, 245],\n    \"lawngreen\": [124, 252, 0],\n    \"lemonchiffon\": [255, 250, 205],\n    \"lightblue\": [173, 216, 230],\n    \"lightcoral\": [240, 128, 128],\n    \"lightcyan\": [224, 255, 255],\n    \"lightgoldenrodyellow\": [250, 250, 210],\n    \"lightgray\": [211, 211, 211],\n    \"lightgreen\": [144, 238, 144],\n    \"lightgrey\": [211, 211, 211],\n    \"lightpink\": [255, 182, 193],\n    \"lightsalmon\": [255, 160, 122],\n    \"lightseagreen\": [32, 178, 170],\n    \"lightskyblue\": [135, 206, 250],\n    \"lightslategray\": [119, 136, 153],\n    \"lightslategrey\": [119, 136, 153],\n    \"lightsteelblue\": [176, 196, 222],\n    \"lightyellow\": [255, 255, 224],\n    \"lime\": [0, 255, 0],\n    \"limegreen\": [50, 205, 50],\n    \"linen\": [250, 240, 230],\n    \"magenta\": [255, 0, 255],\n    \"maroon\": [128, 0, 0],\n    \"mediumaquamarine\": [102, 205, 170],\n    \"mediumblue\": [0, 0, 205],\n    \"mediumorchid\": [186, 85, 211],\n    \"mediumpurple\": [147, 112, 219],\n    \"mediumseagreen\": [60, 179, 113],\n    \"mediumslateblue\": [123, 104, 238],\n    \"mediumspringgreen\": [0, 250, 154],\n    \"mediumturquoise\": [72, 209, 204],\n    \"mediumvioletred\": [199, 21, 133],\n    \"midnightblue\": [25, 25, 112],\n    \"mintcream\": [245, 255, 250],\n    \"mistyrose\": [255, 228, 225],\n    \"moccasin\": [255, 228, 181],\n    \"navajowhite\": [255, 222, 173],\n    \"navy\": [0, 0, 128],\n    \"oldlace\": [253, 245, 230],\n    \"olive\": [128, 128, 0],\n    \"olivedrab\": [107, 142, 35],\n    \"orange\": [255, 165, 0],\n    \"orangered\": [255, 69, 0],\n    \"orchid\": [218, 112, 214],\n    \"palegoldenrod\": [238, 232, 170],\n    \"palegreen\": [152, 251, 152],\n    \"paleturquoise\": [175, 238, 238],\n    \"palevioletred\": [219, 112, 147],\n    \"papayawhip\": [255, 239, 213],\n    \"peachpuff\": [255, 218, 185],\n    \"peru\": [205, 133, 63],\n    \"pink\": [255, 192, 203],\n    \"plum\": [221, 160, 221],\n    \"powderblue\": [176, 224, 230],\n    \"purple\": [128, 0, 128],\n    \"rebeccapurple\": [102, 51, 153],\n    \"red\": [255, 0, 0],\n    \"rosybrown\": [188, 143, 143],\n    \"royalblue\": [65, 105, 225],\n    \"saddlebrown\": [139, 69, 19],\n    \"salmon\": [250, 128, 114],\n    \"sandybrown\": [244, 164, 96],\n    \"seagreen\": [46, 139, 87],\n    \"seashell\": [255, 245, 238],\n    \"sienna\": [160, 82, 45],\n    \"silver\": [192, 192, 192],\n    \"skyblue\": [135, 206, 235],\n    \"slateblue\": [106, 90, 205],\n    \"slategray\": [112, 128, 144],\n    \"slategrey\": [112, 128, 144],\n    \"snow\": [255, 250, 250],\n    \"springgreen\": [0, 255, 127],\n    \"steelblue\": [70, 130, 180],\n    \"tan\": [210, 180, 140],\n    \"teal\": [0, 128, 128],\n    \"thistle\": [216, 191, 216],\n    \"tomato\": [255, 99, 71],\n    \"turquoise\": [64, 224, 208],\n    \"violet\": [238, 130, 238],\n    \"wheat\": [245, 222, 179],\n    \"white\": [255, 255, 255],\n    \"whitesmoke\": [245, 245, 245],\n    \"yellow\": [255, 255, 0],\n    \"yellowgreen\": [154, 205, 50]\n  };\n  var conversions = createCommonjsModule(function (module) {\n    /* MIT license */\n    // NOTE: conversions should only return primitive values (i.e. arrays, or\n    //       values that give correct `typeof` results).\n    //       do not use box values types (i.e. Number(), String(), etc.)\n    var reverseKeywords = {};\n\n    for (var key in colorName) {\n      if (colorName.hasOwnProperty(key)) {\n        reverseKeywords[colorName[key]] = key;\n      }\n    }\n\n    var convert = module.exports = {\n      rgb: {\n        channels: 3,\n        labels: 'rgb'\n      },\n      hsl: {\n        channels: 3,\n        labels: 'hsl'\n      },\n      hsv: {\n        channels: 3,\n        labels: 'hsv'\n      },\n      hwb: {\n        channels: 3,\n        labels: 'hwb'\n      },\n      cmyk: {\n        channels: 4,\n        labels: 'cmyk'\n      },\n      xyz: {\n        channels: 3,\n        labels: 'xyz'\n      },\n      lab: {\n        channels: 3,\n        labels: 'lab'\n      },\n      lch: {\n        channels: 3,\n        labels: 'lch'\n      },\n      hex: {\n        channels: 1,\n        labels: ['hex']\n      },\n      keyword: {\n        channels: 1,\n        labels: ['keyword']\n      },\n      ansi16: {\n        channels: 1,\n        labels: ['ansi16']\n      },\n      ansi256: {\n        channels: 1,\n        labels: ['ansi256']\n      },\n      hcg: {\n        channels: 3,\n        labels: ['h', 'c', 'g']\n      },\n      apple: {\n        channels: 3,\n        labels: ['r16', 'g16', 'b16']\n      },\n      gray: {\n        channels: 1,\n        labels: ['gray']\n      }\n    }; // hide .channels and .labels properties\n\n    for (var model in convert) {\n      if (convert.hasOwnProperty(model)) {\n        if (!('channels' in convert[model])) {\n          throw new Error('missing channels property: ' + model);\n        }\n\n        if (!('labels' in convert[model])) {\n          throw new Error('missing channel labels property: ' + model);\n        }\n\n        if (convert[model].labels.length !== convert[model].channels) {\n          throw new Error('channel and label counts mismatch: ' + model);\n        }\n\n        var channels = convert[model].channels;\n        var labels = convert[model].labels;\n        delete convert[model].channels;\n        delete convert[model].labels;\n        Object.defineProperty(convert[model], 'channels', {\n          value: channels\n        });\n        Object.defineProperty(convert[model], 'labels', {\n          value: labels\n        });\n      }\n    }\n\n    convert.rgb.hsl = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var min = Math.min(r, g, b);\n      var max = Math.max(r, g, b);\n      var delta = max - min;\n      var h;\n      var s;\n      var l;\n\n      if (max === min) {\n        h = 0;\n      } else if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h = Math.min(h * 60, 360);\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      l = (min + max) / 2;\n\n      if (max === min) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max + min);\n      } else {\n        s = delta / (2 - max - min);\n      }\n\n      return [h, s * 100, l * 100];\n    };\n\n    convert.rgb.hsv = function (rgb) {\n      var rdif;\n      var gdif;\n      var bdif;\n      var h;\n      var s;\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var v = Math.max(r, g, b);\n      var diff = v - Math.min(r, g, b);\n\n      var diffc = function (c) {\n        return (v - c) / 6 / diff + 1 / 2;\n      };\n\n      if (diff === 0) {\n        h = s = 0;\n      } else {\n        s = diff / v;\n        rdif = diffc(r);\n        gdif = diffc(g);\n        bdif = diffc(b);\n\n        if (r === v) {\n          h = bdif - gdif;\n        } else if (g === v) {\n          h = 1 / 3 + rdif - bdif;\n        } else if (b === v) {\n          h = 2 / 3 + gdif - rdif;\n        }\n\n        if (h < 0) {\n          h += 1;\n        } else if (h > 1) {\n          h -= 1;\n        }\n      }\n\n      return [h * 360, s * 100, v * 100];\n    };\n\n    convert.rgb.hwb = function (rgb) {\n      var r = rgb[0];\n      var g = rgb[1];\n      var b = rgb[2];\n      var h = convert.rgb.hsl(rgb)[0];\n      var w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n\n    convert.rgb.cmyk = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var c;\n      var m;\n      var y;\n      var k;\n      k = Math.min(1 - r, 1 - g, 1 - b);\n      c = (1 - r - k) / (1 - k) || 0;\n      m = (1 - g - k) / (1 - k) || 0;\n      y = (1 - b - k) / (1 - k) || 0;\n      return [c * 100, m * 100, y * 100, k * 100];\n    };\n    /**\n     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n     * */\n\n\n    function comparativeDistance(x, y) {\n      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);\n    }\n\n    convert.rgb.keyword = function (rgb) {\n      var reversed = reverseKeywords[rgb];\n\n      if (reversed) {\n        return reversed;\n      }\n\n      var currentClosestDistance = Infinity;\n      var currentClosestKeyword;\n\n      for (var keyword in colorName) {\n        if (colorName.hasOwnProperty(keyword)) {\n          var value = colorName[keyword]; // Compute comparative distance\n\n          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest\n\n          if (distance < currentClosestDistance) {\n            currentClosestDistance = distance;\n            currentClosestKeyword = keyword;\n          }\n        }\n      }\n\n      return currentClosestKeyword;\n    };\n\n    convert.keyword.rgb = function (keyword) {\n      return colorName[keyword];\n    };\n\n    convert.rgb.xyz = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255; // assume sRGB\n\n      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n\n    convert.rgb.lab = function (rgb) {\n      var xyz = convert.rgb.xyz(rgb);\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n\n    convert.hsl.rgb = function (hsl) {\n      var h = hsl[0] / 360;\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var t1;\n      var t2;\n      var t3;\n      var rgb;\n      var val;\n\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n\n      t1 = 2 * l - t2;\n      rgb = [0, 0, 0];\n\n      for (var i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n\n        if (t3 < 0) {\n          t3++;\n        }\n\n        if (t3 > 1) {\n          t3--;\n        }\n\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n\n        rgb[i] = val * 255;\n      }\n\n      return rgb;\n    };\n\n    convert.hsl.hsv = function (hsl) {\n      var h = hsl[0];\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var smin = s;\n      var lmin = Math.max(l, 0.01);\n      var sv;\n      var v;\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      v = (l + s) / 2;\n      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n\n    convert.hsv.rgb = function (hsv) {\n      var h = hsv[0] / 60;\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var hi = Math.floor(h) % 6;\n      var f = h - Math.floor(h);\n      var p = 255 * v * (1 - s);\n      var q = 255 * v * (1 - s * f);\n      var t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n\n        case 1:\n          return [q, v, p];\n\n        case 2:\n          return [p, v, t];\n\n        case 3:\n          return [p, q, v];\n\n        case 4:\n          return [t, p, v];\n\n        case 5:\n          return [v, p, q];\n      }\n    };\n\n    convert.hsv.hsl = function (hsv) {\n      var h = hsv[0];\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var vmin = Math.max(v, 0.01);\n      var lmin;\n      var sl;\n      var l;\n      l = (2 - s) * v;\n      lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\n\n    convert.hwb.rgb = function (hwb) {\n      var h = hwb[0] / 360;\n      var wh = hwb[1] / 100;\n      var bl = hwb[2] / 100;\n      var ratio = wh + bl;\n      var i;\n      var v;\n      var f;\n      var n; // wh + bl cant be > 1\n\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n\n      i = Math.floor(6 * h);\n      v = 1 - bl;\n      f = 6 * h - i;\n\n      if ((i & 0x01) !== 0) {\n        f = 1 - f;\n      }\n\n      n = wh + f * (v - wh); // linear interpolation\n\n      var r;\n      var g;\n      var b;\n\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.cmyk.rgb = function (cmyk) {\n      var c = cmyk[0] / 100;\n      var m = cmyk[1] / 100;\n      var y = cmyk[2] / 100;\n      var k = cmyk[3] / 100;\n      var r;\n      var g;\n      var b;\n      r = 1 - Math.min(1, c * (1 - k) + k);\n      g = 1 - Math.min(1, m * (1 - k) + k);\n      b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.xyz.rgb = function (xyz) {\n      var x = xyz[0] / 100;\n      var y = xyz[1] / 100;\n      var z = xyz[2] / 100;\n      var r;\n      var g;\n      var b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB\n\n      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;\n      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;\n      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.xyz.lab = function (xyz) {\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n\n    convert.lab.xyz = function (lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var x;\n      var y;\n      var z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      var y2 = Math.pow(y, 3);\n      var x2 = Math.pow(x, 3);\n      var z2 = Math.pow(z, 3);\n      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n\n    convert.lab.lch = function (lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var hr;\n      var h;\n      var c;\n      hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      c = Math.sqrt(a * a + b * b);\n      return [l, c, h];\n    };\n\n    convert.lch.lab = function (lch) {\n      var l = lch[0];\n      var c = lch[1];\n      var h = lch[2];\n      var a;\n      var b;\n      var hr;\n      hr = h / 360 * 2 * Math.PI;\n      a = c * Math.cos(hr);\n      b = c * Math.sin(hr);\n      return [l, a, b];\n    };\n\n    convert.rgb.ansi16 = function (args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n      value = Math.round(value / 50);\n\n      if (value === 0) {\n        return 30;\n      }\n\n      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n\n      if (value === 2) {\n        ansi += 60;\n      }\n\n      return ansi;\n    };\n\n    convert.hsv.ansi16 = function (args) {\n      // optimization here; we already know the value and don't need to get\n      // it converted for us.\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n\n    convert.rgb.ansi256 = function (args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2]; // we use the extended greyscale palette here, with the exception of\n      // black and white. normal palette only has 4 greyscale shades.\n\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n\n        if (r > 248) {\n          return 231;\n        }\n\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n\n      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n\n    convert.ansi16.rgb = function (args) {\n      var color = args % 10; // handle greyscale\n\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n\n      var mult = (~~(args > 50) + 1) * 0.5;\n      var r = (color & 1) * mult * 255;\n      var g = (color >> 1 & 1) * mult * 255;\n      var b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n\n    convert.ansi256.rgb = function (args) {\n      // handle greyscale\n      if (args >= 232) {\n        var c = (args - 232) * 10 + 8;\n        return [c, c, c];\n      }\n\n      args -= 16;\n      var rem;\n      var r = Math.floor(args / 36) / 5 * 255;\n      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      var b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n\n    convert.rgb.hex = function (args) {\n      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);\n      var string = integer.toString(16).toUpperCase();\n      return '000000'.substring(string.length) + string;\n    };\n\n    convert.hex.rgb = function (args) {\n      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\n      if (!match) {\n        return [0, 0, 0];\n      }\n\n      var colorString = match[0];\n\n      if (match[0].length === 3) {\n        colorString = colorString.split('').map(function (char) {\n          return char + char;\n        }).join('');\n      }\n\n      var integer = parseInt(colorString, 16);\n      var r = integer >> 16 & 0xFF;\n      var g = integer >> 8 & 0xFF;\n      var b = integer & 0xFF;\n      return [r, g, b];\n    };\n\n    convert.rgb.hcg = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var max = Math.max(Math.max(r, g), b);\n      var min = Math.min(Math.min(r, g), b);\n      var chroma = max - min;\n      var grayscale;\n      var hue;\n\n      if (chroma < 1) {\n        grayscale = min / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma + 4;\n      }\n\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n\n    convert.hsl.hcg = function (hsl) {\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var c = 1;\n      var f = 0;\n\n      if (l < 0.5) {\n        c = 2.0 * s * l;\n      } else {\n        c = 2.0 * s * (1.0 - l);\n      }\n\n      if (c < 1.0) {\n        f = (l - 0.5 * c) / (1.0 - c);\n      }\n\n      return [hsl[0], c * 100, f * 100];\n    };\n\n    convert.hsv.hcg = function (hsv) {\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var c = s * v;\n      var f = 0;\n\n      if (c < 1.0) {\n        f = (v - c) / (1 - c);\n      }\n\n      return [hsv[0], c * 100, f * 100];\n    };\n\n    convert.hcg.rgb = function (hcg) {\n      var h = hcg[0] / 360;\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n\n      if (c === 0.0) {\n        return [g * 255, g * 255, g * 255];\n      }\n\n      var pure = [0, 0, 0];\n      var hi = h % 1 * 6;\n      var v = hi % 1;\n      var w = 1 - v;\n      var mg = 0;\n\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n\n      mg = (1.0 - c) * g;\n      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];\n    };\n\n    convert.hcg.hsv = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1.0 - c);\n      var f = 0;\n\n      if (v > 0.0) {\n        f = c / v;\n      }\n\n      return [hcg[0], f * 100, v * 100];\n    };\n\n    convert.hcg.hsl = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var l = g * (1.0 - c) + 0.5 * c;\n      var s = 0;\n\n      if (l > 0.0 && l < 0.5) {\n        s = c / (2 * l);\n      } else if (l >= 0.5 && l < 1.0) {\n        s = c / (2 * (1 - l));\n      }\n\n      return [hcg[0], s * 100, l * 100];\n    };\n\n    convert.hcg.hwb = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1.0 - c);\n      return [hcg[0], (v - c) * 100, (1 - v) * 100];\n    };\n\n    convert.hwb.hcg = function (hwb) {\n      var w = hwb[1] / 100;\n      var b = hwb[2] / 100;\n      var v = 1 - b;\n      var c = v - w;\n      var g = 0;\n\n      if (c < 1) {\n        g = (v - c) / (1 - c);\n      }\n\n      return [hwb[0], c * 100, g * 100];\n    };\n\n    convert.apple.rgb = function (apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n\n    convert.rgb.apple = function (rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n\n    convert.gray.rgb = function (args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n\n    convert.gray.hsl = convert.gray.hsv = function (args) {\n      return [0, 0, args[0]];\n    };\n\n    convert.gray.hwb = function (gray) {\n      return [0, 100, gray[0]];\n    };\n\n    convert.gray.cmyk = function (gray) {\n      return [0, 0, 0, gray[0]];\n    };\n\n    convert.gray.lab = function (gray) {\n      return [gray[0], 0, 0];\n    };\n\n    convert.gray.hex = function (gray) {\n      var val = Math.round(gray[0] / 100 * 255) & 0xFF;\n      var integer = (val << 16) + (val << 8) + val;\n      var string = integer.toString(16).toUpperCase();\n      return '000000'.substring(string.length) + string;\n    };\n\n    convert.rgb.gray = function (rgb) {\n      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  });\n  var conversions_1 = conversions.rgb;\n  var conversions_2 = conversions.hsl;\n  var conversions_3 = conversions.hsv;\n  var conversions_4 = conversions.hwb;\n  var conversions_5 = conversions.cmyk;\n  var conversions_6 = conversions.xyz;\n  var conversions_7 = conversions.lab;\n  var conversions_8 = conversions.lch;\n  var conversions_9 = conversions.hex;\n  var conversions_10 = conversions.keyword;\n  var conversions_11 = conversions.ansi16;\n  var conversions_12 = conversions.ansi256;\n  var conversions_13 = conversions.hcg;\n  var conversions_14 = conversions.apple;\n  var conversions_15 = conversions.gray;\n  /*\n  \tthis function routes a model to all other models.\n  \n  \tall functions that are routed have a property `.conversion` attached\n  \tto the returned synthetic function. This property is an array\n  \tof strings, each with the steps in between the 'from' and 'to'\n  \tcolor models (inclusive).\n  \n  \tconversions that are not possible simply are not included.\n  */\n\n  function buildGraph() {\n    var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\n    var models = Object.keys(conversions);\n\n    for (var len = models.length, i = 0; i < len; i++) {\n      graph[models[i]] = {\n        // http://jsperf.com/1-vs-infinity\n        // micro-opt, but this is simple.\n        distance: -1,\n        parent: null\n      };\n    }\n\n    return graph;\n  } // https://en.wikipedia.org/wiki/Breadth-first_search\n\n\n  function deriveBFS(fromModel) {\n    var graph = buildGraph();\n    var queue = [fromModel]; // unshift -> queue -> pop\n\n    graph[fromModel].distance = 0;\n\n    while (queue.length) {\n      var current = queue.pop();\n      var adjacents = Object.keys(conversions[current]);\n\n      for (var len = adjacents.length, i = 0; i < len; i++) {\n        var adjacent = adjacents[i];\n        var node = graph[adjacent];\n\n        if (node.distance === -1) {\n          node.distance = graph[current].distance + 1;\n          node.parent = current;\n          queue.unshift(adjacent);\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  function link(from, to) {\n    return function (args) {\n      return to(from(args));\n    };\n  }\n\n  function wrapConversion(toModel, graph) {\n    var path = [graph[toModel].parent, toModel];\n    var fn = conversions[graph[toModel].parent][toModel];\n    var cur = graph[toModel].parent;\n\n    while (graph[cur].parent) {\n      path.unshift(graph[cur].parent);\n      fn = link(conversions[graph[cur].parent][cur], fn);\n      cur = graph[cur].parent;\n    }\n\n    fn.conversion = path;\n    return fn;\n  }\n\n  var route = function (fromModel) {\n    var graph = deriveBFS(fromModel);\n    var conversion = {};\n    var models = Object.keys(graph);\n\n    for (var len = models.length, i = 0; i < len; i++) {\n      var toModel = models[i];\n      var node = graph[toModel];\n\n      if (node.parent === null) {\n        // no possible conversion, or this node is the source model.\n        continue;\n      }\n\n      conversion[toModel] = wrapConversion(toModel, graph);\n    }\n\n    return conversion;\n  };\n\n  var convert = {};\n  var models = Object.keys(conversions);\n\n  function wrapRaw(fn) {\n    var wrappedFn = function (args) {\n      if (args === undefined || args === null) {\n        return args;\n      }\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      }\n\n      return fn(args);\n    }; // preserve .conversion property if there is one\n\n\n    if ('conversion' in fn) {\n      wrappedFn.conversion = fn.conversion;\n    }\n\n    return wrappedFn;\n  }\n\n  function wrapRounded(fn) {\n    var wrappedFn = function (args) {\n      if (args === undefined || args === null) {\n        return args;\n      }\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      }\n\n      var result = fn(args); // we're assuming the result is an array here.\n      // see notice in conversions.js; don't use box types\n      // in conversion functions.\n\n      if (typeof result === 'object') {\n        for (var len = result.length, i = 0; i < len; i++) {\n          result[i] = Math.round(result[i]);\n        }\n      }\n\n      return result;\n    }; // preserve .conversion property if there is one\n\n\n    if ('conversion' in fn) {\n      wrappedFn.conversion = fn.conversion;\n    }\n\n    return wrappedFn;\n  }\n\n  models.forEach(function (fromModel) {\n    convert[fromModel] = {};\n    Object.defineProperty(convert[fromModel], 'channels', {\n      value: conversions[fromModel].channels\n    });\n    Object.defineProperty(convert[fromModel], 'labels', {\n      value: conversions[fromModel].labels\n    });\n    var routes = route(fromModel);\n    var routeModels = Object.keys(routes);\n    routeModels.forEach(function (toModel) {\n      var fn = routes[toModel];\n      convert[fromModel][toModel] = wrapRounded(fn);\n      convert[fromModel][toModel].raw = wrapRaw(fn);\n    });\n  });\n  var colorConvert = convert;\n  var colorName$1 = {\n    \"aliceblue\": [240, 248, 255],\n    \"antiquewhite\": [250, 235, 215],\n    \"aqua\": [0, 255, 255],\n    \"aquamarine\": [127, 255, 212],\n    \"azure\": [240, 255, 255],\n    \"beige\": [245, 245, 220],\n    \"bisque\": [255, 228, 196],\n    \"black\": [0, 0, 0],\n    \"blanchedalmond\": [255, 235, 205],\n    \"blue\": [0, 0, 255],\n    \"blueviolet\": [138, 43, 226],\n    \"brown\": [165, 42, 42],\n    \"burlywood\": [222, 184, 135],\n    \"cadetblue\": [95, 158, 160],\n    \"chartreuse\": [127, 255, 0],\n    \"chocolate\": [210, 105, 30],\n    \"coral\": [255, 127, 80],\n    \"cornflowerblue\": [100, 149, 237],\n    \"cornsilk\": [255, 248, 220],\n    \"crimson\": [220, 20, 60],\n    \"cyan\": [0, 255, 255],\n    \"darkblue\": [0, 0, 139],\n    \"darkcyan\": [0, 139, 139],\n    \"darkgoldenrod\": [184, 134, 11],\n    \"darkgray\": [169, 169, 169],\n    \"darkgreen\": [0, 100, 0],\n    \"darkgrey\": [169, 169, 169],\n    \"darkkhaki\": [189, 183, 107],\n    \"darkmagenta\": [139, 0, 139],\n    \"darkolivegreen\": [85, 107, 47],\n    \"darkorange\": [255, 140, 0],\n    \"darkorchid\": [153, 50, 204],\n    \"darkred\": [139, 0, 0],\n    \"darksalmon\": [233, 150, 122],\n    \"darkseagreen\": [143, 188, 143],\n    \"darkslateblue\": [72, 61, 139],\n    \"darkslategray\": [47, 79, 79],\n    \"darkslategrey\": [47, 79, 79],\n    \"darkturquoise\": [0, 206, 209],\n    \"darkviolet\": [148, 0, 211],\n    \"deeppink\": [255, 20, 147],\n    \"deepskyblue\": [0, 191, 255],\n    \"dimgray\": [105, 105, 105],\n    \"dimgrey\": [105, 105, 105],\n    \"dodgerblue\": [30, 144, 255],\n    \"firebrick\": [178, 34, 34],\n    \"floralwhite\": [255, 250, 240],\n    \"forestgreen\": [34, 139, 34],\n    \"fuchsia\": [255, 0, 255],\n    \"gainsboro\": [220, 220, 220],\n    \"ghostwhite\": [248, 248, 255],\n    \"gold\": [255, 215, 0],\n    \"goldenrod\": [218, 165, 32],\n    \"gray\": [128, 128, 128],\n    \"green\": [0, 128, 0],\n    \"greenyellow\": [173, 255, 47],\n    \"grey\": [128, 128, 128],\n    \"honeydew\": [240, 255, 240],\n    \"hotpink\": [255, 105, 180],\n    \"indianred\": [205, 92, 92],\n    \"indigo\": [75, 0, 130],\n    \"ivory\": [255, 255, 240],\n    \"khaki\": [240, 230, 140],\n    \"lavender\": [230, 230, 250],\n    \"lavenderblush\": [255, 240, 245],\n    \"lawngreen\": [124, 252, 0],\n    \"lemonchiffon\": [255, 250, 205],\n    \"lightblue\": [173, 216, 230],\n    \"lightcoral\": [240, 128, 128],\n    \"lightcyan\": [224, 255, 255],\n    \"lightgoldenrodyellow\": [250, 250, 210],\n    \"lightgray\": [211, 211, 211],\n    \"lightgreen\": [144, 238, 144],\n    \"lightgrey\": [211, 211, 211],\n    \"lightpink\": [255, 182, 193],\n    \"lightsalmon\": [255, 160, 122],\n    \"lightseagreen\": [32, 178, 170],\n    \"lightskyblue\": [135, 206, 250],\n    \"lightslategray\": [119, 136, 153],\n    \"lightslategrey\": [119, 136, 153],\n    \"lightsteelblue\": [176, 196, 222],\n    \"lightyellow\": [255, 255, 224],\n    \"lime\": [0, 255, 0],\n    \"limegreen\": [50, 205, 50],\n    \"linen\": [250, 240, 230],\n    \"magenta\": [255, 0, 255],\n    \"maroon\": [128, 0, 0],\n    \"mediumaquamarine\": [102, 205, 170],\n    \"mediumblue\": [0, 0, 205],\n    \"mediumorchid\": [186, 85, 211],\n    \"mediumpurple\": [147, 112, 219],\n    \"mediumseagreen\": [60, 179, 113],\n    \"mediumslateblue\": [123, 104, 238],\n    \"mediumspringgreen\": [0, 250, 154],\n    \"mediumturquoise\": [72, 209, 204],\n    \"mediumvioletred\": [199, 21, 133],\n    \"midnightblue\": [25, 25, 112],\n    \"mintcream\": [245, 255, 250],\n    \"mistyrose\": [255, 228, 225],\n    \"moccasin\": [255, 228, 181],\n    \"navajowhite\": [255, 222, 173],\n    \"navy\": [0, 0, 128],\n    \"oldlace\": [253, 245, 230],\n    \"olive\": [128, 128, 0],\n    \"olivedrab\": [107, 142, 35],\n    \"orange\": [255, 165, 0],\n    \"orangered\": [255, 69, 0],\n    \"orchid\": [218, 112, 214],\n    \"palegoldenrod\": [238, 232, 170],\n    \"palegreen\": [152, 251, 152],\n    \"paleturquoise\": [175, 238, 238],\n    \"palevioletred\": [219, 112, 147],\n    \"papayawhip\": [255, 239, 213],\n    \"peachpuff\": [255, 218, 185],\n    \"peru\": [205, 133, 63],\n    \"pink\": [255, 192, 203],\n    \"plum\": [221, 160, 221],\n    \"powderblue\": [176, 224, 230],\n    \"purple\": [128, 0, 128],\n    \"rebeccapurple\": [102, 51, 153],\n    \"red\": [255, 0, 0],\n    \"rosybrown\": [188, 143, 143],\n    \"royalblue\": [65, 105, 225],\n    \"saddlebrown\": [139, 69, 19],\n    \"salmon\": [250, 128, 114],\n    \"sandybrown\": [244, 164, 96],\n    \"seagreen\": [46, 139, 87],\n    \"seashell\": [255, 245, 238],\n    \"sienna\": [160, 82, 45],\n    \"silver\": [192, 192, 192],\n    \"skyblue\": [135, 206, 235],\n    \"slateblue\": [106, 90, 205],\n    \"slategray\": [112, 128, 144],\n    \"slategrey\": [112, 128, 144],\n    \"snow\": [255, 250, 250],\n    \"springgreen\": [0, 255, 127],\n    \"steelblue\": [70, 130, 180],\n    \"tan\": [210, 180, 140],\n    \"teal\": [0, 128, 128],\n    \"thistle\": [216, 191, 216],\n    \"tomato\": [255, 99, 71],\n    \"turquoise\": [64, 224, 208],\n    \"violet\": [238, 130, 238],\n    \"wheat\": [245, 222, 179],\n    \"white\": [255, 255, 255],\n    \"whitesmoke\": [245, 245, 245],\n    \"yellow\": [255, 255, 0],\n    \"yellowgreen\": [154, 205, 50]\n  };\n  /* MIT license */\n\n  var colorString = {\n    getRgba: getRgba,\n    getHsla: getHsla,\n    getRgb: getRgb,\n    getHsl: getHsl,\n    getHwb: getHwb,\n    getAlpha: getAlpha,\n    hexString: hexString,\n    rgbString: rgbString,\n    rgbaString: rgbaString,\n    percentString: percentString,\n    percentaString: percentaString,\n    hslString: hslString,\n    hslaString: hslaString,\n    hwbString: hwbString,\n    keyword: keyword\n  };\n\n  function getRgba(string) {\n    if (!string) {\n      return;\n    }\n\n    var abbr = /^#([a-fA-F0-9]{3,4})$/i,\n        hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n        rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n        per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n        keyword = /(\\w+)/;\n    var rgb = [0, 0, 0],\n        a = 1,\n        match = string.match(abbr),\n        hexAlpha = \"\";\n\n    if (match) {\n      match = match[1];\n      hexAlpha = match[3];\n\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n\n      if (hexAlpha) {\n        a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;\n      }\n    } else if (match = string.match(hex)) {\n      hexAlpha = match[2];\n      match = match[1];\n\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n\n      if (hexAlpha) {\n        a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;\n      }\n    } else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = parseInt(match[i + 1]);\n      }\n\n      a = parseFloat(match[4]);\n    } else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n\n      a = parseFloat(match[4]);\n    } else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n        return [0, 0, 0, 0];\n      }\n\n      rgb = colorName$1[match[1]];\n\n      if (!rgb) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n    }\n\n    if (!a && a != 0) {\n      a = 1;\n    } else {\n      a = scale(a, 0, 1);\n    }\n\n    rgb[3] = a;\n    return rgb;\n  }\n\n  function getHsla(string) {\n    if (!string) {\n      return;\n    }\n\n    var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n    var match = string.match(hsl);\n\n    if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n    }\n  }\n\n  function getHwb(string) {\n    if (!string) {\n      return;\n    }\n\n    var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n    var match = string.match(hwb);\n\n    if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n    }\n  }\n\n  function getRgb(string) {\n    var rgba = getRgba(string);\n    return rgba && rgba.slice(0, 3);\n  }\n\n  function getHsl(string) {\n    var hsla = getHsla(string);\n    return hsla && hsla.slice(0, 3);\n  }\n\n  function getAlpha(string) {\n    var vals = getRgba(string);\n\n    if (vals) {\n      return vals[3];\n    } else if (vals = getHsla(string)) {\n      return vals[3];\n    } else if (vals = getHwb(string)) {\n      return vals[3];\n    }\n  } // generators\n\n\n  function hexString(rgba, a) {\n    var a = a !== undefined && rgba.length === 3 ? a : rgba[3];\n    return \"#\" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : \"\");\n  }\n\n  function rgbString(rgba, alpha) {\n    if (alpha < 1 || rgba[3] && rgba[3] < 1) {\n      return rgbaString(rgba, alpha);\n    }\n\n    return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n  }\n\n  function rgbaString(rgba, alpha) {\n    if (alpha === undefined) {\n      alpha = rgba[3] !== undefined ? rgba[3] : 1;\n    }\n\n    return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \", \" + alpha + \")\";\n  }\n\n  function percentString(rgba, alpha) {\n    if (alpha < 1 || rgba[3] && rgba[3] < 1) {\n      return percentaString(rgba, alpha);\n    }\n\n    var r = Math.round(rgba[0] / 255 * 100),\n        g = Math.round(rgba[1] / 255 * 100),\n        b = Math.round(rgba[2] / 255 * 100);\n    return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n  }\n\n  function percentaString(rgba, alpha) {\n    var r = Math.round(rgba[0] / 255 * 100),\n        g = Math.round(rgba[1] / 255 * 100),\n        b = Math.round(rgba[2] / 255 * 100);\n    return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n  }\n\n  function hslString(hsla, alpha) {\n    if (alpha < 1 || hsla[3] && hsla[3] < 1) {\n      return hslaString(hsla, alpha);\n    }\n\n    return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n  }\n\n  function hslaString(hsla, alpha) {\n    if (alpha === undefined) {\n      alpha = hsla[3] !== undefined ? hsla[3] : 1;\n    }\n\n    return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \" + alpha + \")\";\n  } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n  // (hwb have alpha optional & 1 is default value)\n\n\n  function hwbString(hwb, alpha) {\n    if (alpha === undefined) {\n      alpha = hwb[3] !== undefined ? hwb[3] : 1;\n    }\n\n    return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\" + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n  }\n\n  function keyword(rgb) {\n    return reverseNames[rgb.slice(0, 3)];\n  } // helpers\n\n\n  function scale(num, min, max) {\n    return Math.min(Math.max(min, num), max);\n  }\n\n  function hexDouble(num) {\n    var str = num.toString(16).toUpperCase();\n    return str.length < 2 ? \"0\" + str : str;\n  } //create a list of reverse color names\n\n\n  var reverseNames = {};\n\n  for (var name in colorName$1) {\n    reverseNames[colorName$1[name]] = name;\n  }\n  /* MIT license */\n\n\n  var Color = function (obj) {\n    if (obj instanceof Color) {\n      return obj;\n    }\n\n    if (!(this instanceof Color)) {\n      return new Color(obj);\n    }\n\n    this.valid = false;\n    this.values = {\n      rgb: [0, 0, 0],\n      hsl: [0, 0, 0],\n      hsv: [0, 0, 0],\n      hwb: [0, 0, 0],\n      cmyk: [0, 0, 0, 0],\n      alpha: 1\n    }; // parse Color() argument\n\n    var vals;\n\n    if (typeof obj === 'string') {\n      vals = colorString.getRgba(obj);\n\n      if (vals) {\n        this.setValues('rgb', vals);\n      } else if (vals = colorString.getHsla(obj)) {\n        this.setValues('hsl', vals);\n      } else if (vals = colorString.getHwb(obj)) {\n        this.setValues('hwb', vals);\n      }\n    } else if (typeof obj === 'object') {\n      vals = obj;\n\n      if (vals.r !== undefined || vals.red !== undefined) {\n        this.setValues('rgb', vals);\n      } else if (vals.l !== undefined || vals.lightness !== undefined) {\n        this.setValues('hsl', vals);\n      } else if (vals.v !== undefined || vals.value !== undefined) {\n        this.setValues('hsv', vals);\n      } else if (vals.w !== undefined || vals.whiteness !== undefined) {\n        this.setValues('hwb', vals);\n      } else if (vals.c !== undefined || vals.cyan !== undefined) {\n        this.setValues('cmyk', vals);\n      }\n    }\n  };\n\n  Color.prototype = {\n    isValid: function () {\n      return this.valid;\n    },\n    rgb: function () {\n      return this.setSpace('rgb', arguments);\n    },\n    hsl: function () {\n      return this.setSpace('hsl', arguments);\n    },\n    hsv: function () {\n      return this.setSpace('hsv', arguments);\n    },\n    hwb: function () {\n      return this.setSpace('hwb', arguments);\n    },\n    cmyk: function () {\n      return this.setSpace('cmyk', arguments);\n    },\n    rgbArray: function () {\n      return this.values.rgb;\n    },\n    hslArray: function () {\n      return this.values.hsl;\n    },\n    hsvArray: function () {\n      return this.values.hsv;\n    },\n    hwbArray: function () {\n      var values = this.values;\n\n      if (values.alpha !== 1) {\n        return values.hwb.concat([values.alpha]);\n      }\n\n      return values.hwb;\n    },\n    cmykArray: function () {\n      return this.values.cmyk;\n    },\n    rgbaArray: function () {\n      var values = this.values;\n      return values.rgb.concat([values.alpha]);\n    },\n    hslaArray: function () {\n      var values = this.values;\n      return values.hsl.concat([values.alpha]);\n    },\n    alpha: function (val) {\n      if (val === undefined) {\n        return this.values.alpha;\n      }\n\n      this.setValues('alpha', val);\n      return this;\n    },\n    red: function (val) {\n      return this.setChannel('rgb', 0, val);\n    },\n    green: function (val) {\n      return this.setChannel('rgb', 1, val);\n    },\n    blue: function (val) {\n      return this.setChannel('rgb', 2, val);\n    },\n    hue: function (val) {\n      if (val) {\n        val %= 360;\n        val = val < 0 ? 360 + val : val;\n      }\n\n      return this.setChannel('hsl', 0, val);\n    },\n    saturation: function (val) {\n      return this.setChannel('hsl', 1, val);\n    },\n    lightness: function (val) {\n      return this.setChannel('hsl', 2, val);\n    },\n    saturationv: function (val) {\n      return this.setChannel('hsv', 1, val);\n    },\n    whiteness: function (val) {\n      return this.setChannel('hwb', 1, val);\n    },\n    blackness: function (val) {\n      return this.setChannel('hwb', 2, val);\n    },\n    value: function (val) {\n      return this.setChannel('hsv', 2, val);\n    },\n    cyan: function (val) {\n      return this.setChannel('cmyk', 0, val);\n    },\n    magenta: function (val) {\n      return this.setChannel('cmyk', 1, val);\n    },\n    yellow: function (val) {\n      return this.setChannel('cmyk', 2, val);\n    },\n    black: function (val) {\n      return this.setChannel('cmyk', 3, val);\n    },\n    hexString: function () {\n      return colorString.hexString(this.values.rgb);\n    },\n    rgbString: function () {\n      return colorString.rgbString(this.values.rgb, this.values.alpha);\n    },\n    rgbaString: function () {\n      return colorString.rgbaString(this.values.rgb, this.values.alpha);\n    },\n    percentString: function () {\n      return colorString.percentString(this.values.rgb, this.values.alpha);\n    },\n    hslString: function () {\n      return colorString.hslString(this.values.hsl, this.values.alpha);\n    },\n    hslaString: function () {\n      return colorString.hslaString(this.values.hsl, this.values.alpha);\n    },\n    hwbString: function () {\n      return colorString.hwbString(this.values.hwb, this.values.alpha);\n    },\n    keyword: function () {\n      return colorString.keyword(this.values.rgb, this.values.alpha);\n    },\n    rgbNumber: function () {\n      var rgb = this.values.rgb;\n      return rgb[0] << 16 | rgb[1] << 8 | rgb[2];\n    },\n    luminosity: function () {\n      // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n      var rgb = this.values.rgb;\n      var lum = [];\n\n      for (var i = 0; i < rgb.length; i++) {\n        var chan = rgb[i] / 255;\n        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);\n      }\n\n      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n    },\n    contrast: function (color2) {\n      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n      var lum1 = this.luminosity();\n      var lum2 = color2.luminosity();\n\n      if (lum1 > lum2) {\n        return (lum1 + 0.05) / (lum2 + 0.05);\n      }\n\n      return (lum2 + 0.05) / (lum1 + 0.05);\n    },\n    level: function (color2) {\n      var contrastRatio = this.contrast(color2);\n\n      if (contrastRatio >= 7.1) {\n        return 'AAA';\n      }\n\n      return contrastRatio >= 4.5 ? 'AA' : '';\n    },\n    dark: function () {\n      // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n      var rgb = this.values.rgb;\n      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n      return yiq < 128;\n    },\n    light: function () {\n      return !this.dark();\n    },\n    negate: function () {\n      var rgb = [];\n\n      for (var i = 0; i < 3; i++) {\n        rgb[i] = 255 - this.values.rgb[i];\n      }\n\n      this.setValues('rgb', rgb);\n      return this;\n    },\n    lighten: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[2] += hsl[2] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    darken: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[2] -= hsl[2] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    saturate: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[1] += hsl[1] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    desaturate: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[1] -= hsl[1] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    whiten: function (ratio) {\n      var hwb = this.values.hwb;\n      hwb[1] += hwb[1] * ratio;\n      this.setValues('hwb', hwb);\n      return this;\n    },\n    blacken: function (ratio) {\n      var hwb = this.values.hwb;\n      hwb[2] += hwb[2] * ratio;\n      this.setValues('hwb', hwb);\n      return this;\n    },\n    greyscale: function () {\n      var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\n      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n      this.setValues('rgb', [val, val, val]);\n      return this;\n    },\n    clearer: function (ratio) {\n      var alpha = this.values.alpha;\n      this.setValues('alpha', alpha - alpha * ratio);\n      return this;\n    },\n    opaquer: function (ratio) {\n      var alpha = this.values.alpha;\n      this.setValues('alpha', alpha + alpha * ratio);\n      return this;\n    },\n    rotate: function (degrees) {\n      var hsl = this.values.hsl;\n      var hue = (hsl[0] + degrees) % 360;\n      hsl[0] = hue < 0 ? 360 + hue : hue;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n\n    /**\n     * Ported from sass implementation in C\n     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n     */\n    mix: function (mixinColor, weight) {\n      var color1 = this;\n      var color2 = mixinColor;\n      var p = weight === undefined ? 0.5 : weight;\n      var w = 2 * p - 1;\n      var a = color1.alpha() - color2.alpha();\n      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      var w2 = 1 - w1;\n      return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n    },\n    toJSON: function () {\n      return this.rgb();\n    },\n    clone: function () {\n      // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n      // making the final build way to big to embed in Chart.js. So let's do it manually,\n      // assuming that values to clone are 1 dimension arrays containing only numbers,\n      // except 'alpha' which is a number.\n      var result = new Color();\n      var source = this.values;\n      var target = result.values;\n      var value, type;\n\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          value = source[prop];\n          type = {}.toString.call(value);\n\n          if (type === '[object Array]') {\n            target[prop] = value.slice(0);\n          } else if (type === '[object Number]') {\n            target[prop] = value;\n          } else {\n            console.error('unexpected color value:', value);\n          }\n        }\n      }\n\n      return result;\n    }\n  };\n  Color.prototype.spaces = {\n    rgb: ['red', 'green', 'blue'],\n    hsl: ['hue', 'saturation', 'lightness'],\n    hsv: ['hue', 'saturation', 'value'],\n    hwb: ['hue', 'whiteness', 'blackness'],\n    cmyk: ['cyan', 'magenta', 'yellow', 'black']\n  };\n  Color.prototype.maxes = {\n    rgb: [255, 255, 255],\n    hsl: [360, 100, 100],\n    hsv: [360, 100, 100],\n    hwb: [360, 100, 100],\n    cmyk: [100, 100, 100, 100]\n  };\n\n  Color.prototype.getValues = function (space) {\n    var values = this.values;\n    var vals = {};\n\n    for (var i = 0; i < space.length; i++) {\n      vals[space.charAt(i)] = values[space][i];\n    }\n\n    if (values.alpha !== 1) {\n      vals.a = values.alpha;\n    } // {r: 255, g: 255, b: 255, a: 0.4}\n\n\n    return vals;\n  };\n\n  Color.prototype.setValues = function (space, vals) {\n    var values = this.values;\n    var spaces = this.spaces;\n    var maxes = this.maxes;\n    var alpha = 1;\n    var i;\n    this.valid = true;\n\n    if (space === 'alpha') {\n      alpha = vals;\n    } else if (vals.length) {\n      // [10, 10, 10]\n      values[space] = vals.slice(0, space.length);\n      alpha = vals[space.length];\n    } else if (vals[space.charAt(0)] !== undefined) {\n      // {r: 10, g: 10, b: 10}\n      for (i = 0; i < space.length; i++) {\n        values[space][i] = vals[space.charAt(i)];\n      }\n\n      alpha = vals.a;\n    } else if (vals[spaces[space][0]] !== undefined) {\n      // {red: 10, green: 10, blue: 10}\n      var chans = spaces[space];\n\n      for (i = 0; i < space.length; i++) {\n        values[space][i] = vals[chans[i]];\n      }\n\n      alpha = vals.alpha;\n    }\n\n    values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));\n\n    if (space === 'alpha') {\n      return false;\n    }\n\n    var capped; // cap values of the space prior converting all values\n\n    for (i = 0; i < space.length; i++) {\n      capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n      values[space][i] = Math.round(capped);\n    } // convert to all the other color spaces\n\n\n    for (var sname in spaces) {\n      if (sname !== space) {\n        values[sname] = colorConvert[space][sname](values[space]);\n      }\n    }\n\n    return true;\n  };\n\n  Color.prototype.setSpace = function (space, args) {\n    var vals = args[0];\n\n    if (vals === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n    } // color.rgb(10, 10, 10)\n\n\n    if (typeof vals === 'number') {\n      vals = Array.prototype.slice.call(args);\n    }\n\n    this.setValues(space, vals);\n    return this;\n  };\n\n  Color.prototype.setChannel = function (space, index, val) {\n    var svalues = this.values[space];\n\n    if (val === undefined) {\n      // color.red()\n      return svalues[index];\n    } else if (val === svalues[index]) {\n      // color.red(color.red())\n      return this;\n    } // color.red(100)\n\n\n    svalues[index] = val;\n    this.setValues(space, svalues);\n    return this;\n  };\n\n  if (typeof window !== 'undefined') {\n    window.Color = Color;\n  }\n\n  var chartjsColor = Color;\n\n  function isValidKey(key) {\n    return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n  }\n  /**\r\n   * @namespace Chart.helpers\r\n   */\n\n\n  var helpers = {\n    /**\r\n     * An empty function that can be used, for example, for optional callback.\r\n     */\n    noop: function () {},\n\n    /**\r\n     * Returns a unique id, sequentially generated from a global variable.\r\n     * @returns {number}\r\n     * @function\r\n     */\n    uid: function () {\n      var id = 0;\n      return function () {\n        return id++;\n      };\n    }(),\n\n    /**\r\n     * Returns true if `value` is neither null nor undefined, else returns false.\r\n     * @param {*} value - The value to test.\r\n     * @returns {boolean}\r\n     * @since 2.7.0\r\n     */\n    isNullOrUndef: function (value) {\n      return value === null || typeof value === 'undefined';\n    },\n\n    /**\r\n     * Returns true if `value` is an array (including typed arrays), else returns false.\r\n     * @param {*} value - The value to test.\r\n     * @returns {boolean}\r\n     * @function\r\n     */\n    isArray: function (value) {\n      if (Array.isArray && Array.isArray(value)) {\n        return true;\n      }\n\n      var type = Object.prototype.toString.call(value);\n\n      if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\r\n     * Returns true if `value` is an object (excluding null), else returns false.\r\n     * @param {*} value - The value to test.\r\n     * @returns {boolean}\r\n     * @since 2.7.0\r\n     */\n    isObject: function (value) {\n      return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n    },\n\n    /**\r\n     * Returns true if `value` is a finite number, else returns false\r\n     * @param {*} value  - The value to test.\r\n     * @returns {boolean}\r\n     */\n    isFinite: function (value) {\n      return (typeof value === 'number' || value instanceof Number) && isFinite(value);\n    },\n\n    /**\r\n     * Returns `value` if defined, else returns `defaultValue`.\r\n     * @param {*} value - The value to return if defined.\r\n     * @param {*} defaultValue - The value to return if `value` is undefined.\r\n     * @returns {*}\r\n     */\n    valueOrDefault: function (value, defaultValue) {\n      return typeof value === 'undefined' ? defaultValue : value;\n    },\n\n    /**\r\n     * Returns value at the given `index` in array if defined, else returns `defaultValue`.\r\n     * @param {Array} value - The array to lookup for value at `index`.\r\n     * @param {number} index - The index in `value` to lookup for value.\r\n     * @param {*} defaultValue - The value to return if `value[index]` is undefined.\r\n     * @returns {*}\r\n     */\n    valueAtIndexOrDefault: function (value, index, defaultValue) {\n      return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n    },\n\n    /**\r\n     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\r\n     * value returned by `fn`. If `fn` is not a function, this method returns undefined.\r\n     * @param {function} fn - The function to call.\r\n     * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\r\n     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n     * @returns {*}\r\n     */\n    callback: function (fn, args, thisArg) {\n      if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n      }\n    },\n\n    /**\r\n     * Note(SB) for performance sake, this method should only be used when loopable type\r\n     * is unknown or in none intensive code (not called often and small loopable). Else\r\n     * it's preferable to use a regular for() loop and save extra function calls.\r\n     * @param {object|Array} loopable - The object or array to be iterated.\r\n     * @param {function} fn - The function to call for each item.\r\n     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n     * @param {boolean} [reverse] - If true, iterates backward on the loopable.\r\n     */\n    each: function (loopable, fn, thisArg, reverse) {\n      var i, len, keys;\n\n      if (helpers.isArray(loopable)) {\n        len = loopable.length;\n\n        if (reverse) {\n          for (i = len - 1; i >= 0; i--) {\n            fn.call(thisArg, loopable[i], i);\n          }\n        } else {\n          for (i = 0; i < len; i++) {\n            fn.call(thisArg, loopable[i], i);\n          }\n        }\n      } else if (helpers.isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n\n        for (i = 0; i < len; i++) {\n          fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n      }\n    },\n\n    /**\r\n     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\r\n     * @see https://stackoverflow.com/a/14853974\r\n     * @param {Array} a0 - The array to compare\r\n     * @param {Array} a1 - The array to compare\r\n     * @returns {boolean}\r\n     */\n    arrayEquals: function (a0, a1) {\n      var i, ilen, v0, v1;\n\n      if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n      }\n\n      for (i = 0, ilen = a0.length; i < ilen; ++i) {\n        v0 = a0[i];\n        v1 = a1[i];\n\n        if (v0 instanceof Array && v1 instanceof Array) {\n          if (!helpers.arrayEquals(v0, v1)) {\n            return false;\n          }\n        } else if (v0 !== v1) {\n          // NOTE: two different object instances will never be equal: {x:20} != {x:20}\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\r\n     * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n     * @param {*} source - The value to clone.\r\n     * @returns {*}\r\n     */\n    clone: function (source) {\n      if (helpers.isArray(source)) {\n        return source.map(helpers.clone);\n      }\n\n      if (helpers.isObject(source)) {\n        var target = Object.create(source);\n        var keys = Object.keys(source);\n        var klen = keys.length;\n        var k = 0;\n\n        for (; k < klen; ++k) {\n          target[keys[k]] = helpers.clone(source[keys[k]]);\n        }\n\n        return target;\n      }\n\n      return source;\n    },\n\n    /**\r\n     * The default merger when Chart.helpers.merge is called without merger option.\r\n     * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\r\n     * @private\r\n     */\n    _merger: function (key, target, source, options) {\n      if (!isValidKey(key)) {\n        // We want to ensure we do not copy prototypes over\n        // as this can pollute global namespaces\n        return;\n      }\n\n      var tval = target[key];\n      var sval = source[key];\n\n      if (helpers.isObject(tval) && helpers.isObject(sval)) {\n        helpers.merge(tval, sval, options);\n      } else {\n        target[key] = helpers.clone(sval);\n      }\n    },\n\n    /**\r\n     * Merges source[key] in target[key] only if target[key] is undefined.\r\n     * @private\r\n     */\n    _mergerIf: function (key, target, source) {\n      if (!isValidKey(key)) {\n        // We want to ensure we do not copy prototypes over\n        // as this can pollute global namespaces\n        return;\n      }\n\n      var tval = target[key];\n      var sval = source[key];\n\n      if (helpers.isObject(tval) && helpers.isObject(sval)) {\n        helpers.mergeIf(tval, sval);\n      } else if (!target.hasOwnProperty(key)) {\n        target[key] = helpers.clone(sval);\n      }\n    },\n\n    /**\r\n     * Recursively deep copies `source` properties into `target` with the given `options`.\r\n     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n     * @param {object} target - The target object in which all sources are merged into.\r\n     * @param {object|object[]} source - Object(s) to merge into `target`.\r\n     * @param {object} [options] - Merging options:\r\n     * @param {function} [options.merger] - The merge method (key, target, source, options)\r\n     * @returns {object} The `target` object.\r\n     */\n    merge: function (target, source, options) {\n      var sources = helpers.isArray(source) ? source : [source];\n      var ilen = sources.length;\n      var merge, i, keys, klen, k;\n\n      if (!helpers.isObject(target)) {\n        return target;\n      }\n\n      options = options || {};\n      merge = options.merger || helpers._merger;\n\n      for (i = 0; i < ilen; ++i) {\n        source = sources[i];\n\n        if (!helpers.isObject(source)) {\n          continue;\n        }\n\n        keys = Object.keys(source);\n\n        for (k = 0, klen = keys.length; k < klen; ++k) {\n          merge(keys[k], target, source, options);\n        }\n      }\n\n      return target;\n    },\n\n    /**\r\n     * Recursively deep copies `source` properties into `target` *only* if not defined in target.\r\n     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n     * @param {object} target - The target object in which all sources are merged into.\r\n     * @param {object|object[]} source - Object(s) to merge into `target`.\r\n     * @returns {object} The `target` object.\r\n     */\n    mergeIf: function (target, source) {\n      return helpers.merge(target, source, {\n        merger: helpers._mergerIf\n      });\n    },\n\n    /**\r\n     * Applies the contents of two or more objects together into the first object.\r\n     * @param {object} target - The target object in which all objects are merged into.\r\n     * @param {object} arg1 - Object containing additional properties to merge in target.\r\n     * @param {object} argN - Additional objects containing properties to merge in target.\r\n     * @returns {object} The `target` object.\r\n     */\n    extend: Object.assign || function (target) {\n      return helpers.merge(target, [].slice.call(arguments, 1), {\n        merger: function (key, dst, src) {\n          dst[key] = src[key];\n        }\n      });\n    },\n\n    /**\r\n     * Basic javascript inheritance based on the model created in Backbone.js\r\n     */\n    inherits: function (extensions) {\n      var me = this;\n      var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {\n        return me.apply(this, arguments);\n      };\n\n      var Surrogate = function () {\n        this.constructor = ChartElement;\n      };\n\n      Surrogate.prototype = me.prototype;\n      ChartElement.prototype = new Surrogate();\n      ChartElement.extend = helpers.inherits;\n\n      if (extensions) {\n        helpers.extend(ChartElement.prototype, extensions);\n      }\n\n      ChartElement.__super__ = me.prototype;\n      return ChartElement;\n    },\n    _deprecated: function (scope, value, previous, current) {\n      if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n      }\n    }\n  };\n  var helpers_core = helpers; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.callback instead.\r\n   * @function Chart.helpers.callCallback\r\n   * @deprecated since version 2.6.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers.callCallback = helpers.callback;\n  /**\r\n   * Provided for backward compatibility, use Array.prototype.indexOf instead.\r\n   * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\r\n   * @function Chart.helpers.indexOf\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers.indexOf = function (array, item, fromIndex) {\n    return Array.prototype.indexOf.call(array, item, fromIndex);\n  };\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\r\n   * @function Chart.helpers.getValueOrDefault\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n\n  helpers.getValueOrDefault = helpers.valueOrDefault;\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\r\n   * @function Chart.helpers.getValueAtIndexOrDefault\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n  /**\r\n   * Easing functions adapted from Robert Penner's easing equations.\r\n   * @namespace Chart.helpers.easingEffects\r\n   * @see http://www.robertpenner.com/easing/\r\n   */\n\n  var effects = {\n    linear: function (t) {\n      return t;\n    },\n    easeInQuad: function (t) {\n      return t * t;\n    },\n    easeOutQuad: function (t) {\n      return -t * (t - 2);\n    },\n    easeInOutQuad: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t;\n      }\n\n      return -0.5 * (--t * (t - 2) - 1);\n    },\n    easeInCubic: function (t) {\n      return t * t * t;\n    },\n    easeOutCubic: function (t) {\n      return (t = t - 1) * t * t + 1;\n    },\n    easeInOutCubic: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t * t;\n      }\n\n      return 0.5 * ((t -= 2) * t * t + 2);\n    },\n    easeInQuart: function (t) {\n      return t * t * t * t;\n    },\n    easeOutQuart: function (t) {\n      return -((t = t - 1) * t * t * t - 1);\n    },\n    easeInOutQuart: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t * t * t;\n      }\n\n      return -0.5 * ((t -= 2) * t * t * t - 2);\n    },\n    easeInQuint: function (t) {\n      return t * t * t * t * t;\n    },\n    easeOutQuint: function (t) {\n      return (t = t - 1) * t * t * t * t + 1;\n    },\n    easeInOutQuint: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t * t * t * t;\n      }\n\n      return 0.5 * ((t -= 2) * t * t * t * t + 2);\n    },\n    easeInSine: function (t) {\n      return -Math.cos(t * (Math.PI / 2)) + 1;\n    },\n    easeOutSine: function (t) {\n      return Math.sin(t * (Math.PI / 2));\n    },\n    easeInOutSine: function (t) {\n      return -0.5 * (Math.cos(Math.PI * t) - 1);\n    },\n    easeInExpo: function (t) {\n      return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));\n    },\n    easeOutExpo: function (t) {\n      return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n    },\n    easeInOutExpo: function (t) {\n      if (t === 0) {\n        return 0;\n      }\n\n      if (t === 1) {\n        return 1;\n      }\n\n      if ((t /= 0.5) < 1) {\n        return 0.5 * Math.pow(2, 10 * (t - 1));\n      }\n\n      return 0.5 * (-Math.pow(2, -10 * --t) + 2);\n    },\n    easeInCirc: function (t) {\n      if (t >= 1) {\n        return t;\n      }\n\n      return -(Math.sqrt(1 - t * t) - 1);\n    },\n    easeOutCirc: function (t) {\n      return Math.sqrt(1 - (t = t - 1) * t);\n    },\n    easeInOutCirc: function (t) {\n      if ((t /= 0.5) < 1) {\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n      }\n\n      return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n    },\n    easeInElastic: function (t) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n\n      if (t === 0) {\n        return 0;\n      }\n\n      if (t === 1) {\n        return 1;\n      }\n\n      if (!p) {\n        p = 0.3;\n      }\n\n      if (a < 1) {\n        a = 1;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(1 / a);\n      }\n\n      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n    },\n    easeOutElastic: function (t) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n\n      if (t === 0) {\n        return 0;\n      }\n\n      if (t === 1) {\n        return 1;\n      }\n\n      if (!p) {\n        p = 0.3;\n      }\n\n      if (a < 1) {\n        a = 1;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(1 / a);\n      }\n\n      return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n    },\n    easeInOutElastic: function (t) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n\n      if (t === 0) {\n        return 0;\n      }\n\n      if ((t /= 0.5) === 2) {\n        return 1;\n      }\n\n      if (!p) {\n        p = 0.45;\n      }\n\n      if (a < 1) {\n        a = 1;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(1 / a);\n      }\n\n      if (t < 1) {\n        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n      }\n\n      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n    },\n    easeInBack: function (t) {\n      var s = 1.70158;\n      return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack: function (t) {\n      var s = 1.70158;\n      return (t = t - 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack: function (t) {\n      var s = 1.70158;\n\n      if ((t /= 0.5) < 1) {\n        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n      }\n\n      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: function (t) {\n      return 1 - effects.easeOutBounce(1 - t);\n    },\n    easeOutBounce: function (t) {\n      if (t < 1 / 2.75) {\n        return 7.5625 * t * t;\n      }\n\n      if (t < 2 / 2.75) {\n        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n      }\n\n      if (t < 2.5 / 2.75) {\n        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n      }\n\n      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n    },\n    easeInOutBounce: function (t) {\n      if (t < 0.5) {\n        return effects.easeInBounce(t * 2) * 0.5;\n      }\n\n      return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n    }\n  };\n  var helpers_easing = {\n    effects: effects\n  }; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\r\n   * @function Chart.helpers.easingEffects\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers_core.easingEffects = effects;\n  var PI = Math.PI;\n  var RAD_PER_DEG = PI / 180;\n  var DOUBLE_PI = PI * 2;\n  var HALF_PI = PI / 2;\n  var QUARTER_PI = PI / 4;\n  var TWO_THIRDS_PI = PI * 2 / 3;\n  /**\r\n   * @namespace Chart.helpers.canvas\r\n   */\n\n  var exports$1 = {\n    /**\r\n     * Clears the entire canvas associated to the given `chart`.\r\n     * @param {Chart} chart - The chart for which to clear the canvas.\r\n     */\n    clear: function (chart) {\n      chart.ctx.clearRect(0, 0, chart.width, chart.height);\n    },\n\n    /**\r\n     * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\r\n     * given size (width, height) and the same `radius` for all corners.\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n     * @param {number} x - The x axis of the coordinate for the rectangle starting point.\r\n     * @param {number} y - The y axis of the coordinate for the rectangle starting point.\r\n     * @param {number} width - The rectangle's width.\r\n     * @param {number} height - The rectangle's height.\r\n     * @param {number} radius - The rounded amount (in pixels) for the four corners.\r\n     * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\r\n     */\n    roundedRect: function (ctx, x, y, width, height, radius) {\n      if (radius) {\n        var r = Math.min(radius, height / 2, width / 2);\n        var left = x + r;\n        var top = y + r;\n        var right = x + width - r;\n        var bottom = y + height - r;\n        ctx.moveTo(x, top);\n\n        if (left < right && top < bottom) {\n          ctx.arc(left, top, r, -PI, -HALF_PI);\n          ctx.arc(right, top, r, -HALF_PI, 0);\n          ctx.arc(right, bottom, r, 0, HALF_PI);\n          ctx.arc(left, bottom, r, HALF_PI, PI);\n        } else if (left < right) {\n          ctx.moveTo(left, y);\n          ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n          ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\n        } else if (top < bottom) {\n          ctx.arc(left, top, r, -PI, 0);\n          ctx.arc(left, bottom, r, 0, PI);\n        } else {\n          ctx.arc(left, top, r, -PI, PI);\n        }\n\n        ctx.closePath();\n        ctx.moveTo(x, y);\n      } else {\n        ctx.rect(x, y, width, height);\n      }\n    },\n    drawPoint: function (ctx, style, radius, x, y, rotation) {\n      var type, xOffset, yOffset, size, cornerRadius;\n      var rad = (rotation || 0) * RAD_PER_DEG;\n\n      if (style && typeof style === 'object') {\n        type = style.toString();\n\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n          ctx.save();\n          ctx.translate(x, y);\n          ctx.rotate(rad);\n          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n          ctx.restore();\n          return;\n        }\n      }\n\n      if (isNaN(radius) || radius <= 0) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      switch (style) {\n        // Default includes circle\n        default:\n          ctx.arc(x, y, radius, 0, DOUBLE_PI);\n          ctx.closePath();\n          break;\n\n        case 'triangle':\n          ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n          rad += TWO_THIRDS_PI;\n          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n          rad += TWO_THIRDS_PI;\n          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n          ctx.closePath();\n          break;\n\n        case 'rectRounded':\n          // NOTE: the rounded rect implementation changed to use `arc` instead of\n          // `quadraticCurveTo` since it generates better results when rect is\n          // almost a circle. 0.516 (instead of 0.5) produces results with visually\n          // closer proportion to the previous impl and it is inscribed in the\n          // circle with `radius`. For more details, see the following PRs:\n          // https://github.com/chartjs/Chart.js/issues/5597\n          // https://github.com/chartjs/Chart.js/issues/5858\n          cornerRadius = radius * 0.516;\n          size = radius - cornerRadius;\n          xOffset = Math.cos(rad + QUARTER_PI) * size;\n          yOffset = Math.sin(rad + QUARTER_PI) * size;\n          ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n          ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n          ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n          ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n          ctx.closePath();\n          break;\n\n        case 'rect':\n          if (!rotation) {\n            size = Math.SQRT1_2 * radius;\n            ctx.rect(x - size, y - size, 2 * size, 2 * size);\n            break;\n          }\n\n          rad += QUARTER_PI;\n\n        /* falls through */\n\n        case 'rectRot':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          ctx.closePath();\n          break;\n\n        case 'crossRot':\n          rad += QUARTER_PI;\n\n        /* falls through */\n\n        case 'cross':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.moveTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          break;\n\n        case 'star':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.moveTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          rad += QUARTER_PI;\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.moveTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          break;\n\n        case 'line':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          break;\n\n        case 'dash':\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n          break;\n      }\n\n      ctx.fill();\n      ctx.stroke();\n    },\n\n    /**\r\n     * Returns true if the point is inside the rectangle\r\n     * @param {object} point - The point to test\r\n     * @param {object} area - The rectangle\r\n     * @returns {boolean}\r\n     * @private\r\n     */\n    _isPointInArea: function (point, area) {\n      var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n\n      return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;\n    },\n    clipArea: function (ctx, area) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n      ctx.clip();\n    },\n    unclipArea: function (ctx) {\n      ctx.restore();\n    },\n    lineTo: function (ctx, previous, target, flip) {\n      var stepped = target.steppedLine;\n\n      if (stepped) {\n        if (stepped === 'middle') {\n          var midpoint = (previous.x + target.x) / 2.0;\n          ctx.lineTo(midpoint, flip ? target.y : previous.y);\n          ctx.lineTo(midpoint, flip ? previous.y : target.y);\n        } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {\n          ctx.lineTo(previous.x, target.y);\n        } else {\n          ctx.lineTo(target.x, previous.y);\n        }\n\n        ctx.lineTo(target.x, target.y);\n        return;\n      }\n\n      if (!target.tension) {\n        ctx.lineTo(target.x, target.y);\n        return;\n      }\n\n      ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);\n    }\n  };\n  var helpers_canvas = exports$1; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\r\n   * @namespace Chart.helpers.clear\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers_core.clear = exports$1.clear;\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\r\n   * @namespace Chart.helpers.drawRoundedRectangle\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers_core.drawRoundedRectangle = function (ctx) {\n    ctx.beginPath();\n    exports$1.roundedRect.apply(exports$1, arguments);\n  };\n\n  var defaults = {\n    /**\r\n     * @private\r\n     */\n    _set: function (scope, values) {\n      return helpers_core.merge(this[scope] || (this[scope] = {}), values);\n    }\n  }; // TODO(v3): remove 'global' from namespace.  all default are global and\n  // there's inconsistency around which options are under 'global'\n\n  defaults._set('global', {\n    defaultColor: 'rgba(0,0,0,0.1)',\n    defaultFontColor: '#666',\n    defaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n    defaultFontSize: 12,\n    defaultFontStyle: 'normal',\n    defaultLineHeight: 1.2,\n    showLines: true\n  });\n\n  var core_defaults = defaults;\n  var valueOrDefault = helpers_core.valueOrDefault;\n  /**\r\n   * Converts the given font object into a CSS font string.\r\n   * @param {object} font - A font object.\r\n   * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n   * @private\r\n   */\n\n  function toFontString(font) {\n    if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {\n      return null;\n    }\n\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n  }\n  /**\r\n   * @alias Chart.helpers.options\r\n   * @namespace\r\n   */\n\n\n  var helpers_options = {\n    /**\r\n     * Converts the given line height `value` in pixels for a specific font `size`.\r\n     * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\r\n     * @param {number} size - The font size (in pixels) used to resolve relative `value`.\r\n     * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\r\n     * @since 2.7.0\r\n     */\n    toLineHeight: function (value, size) {\n      var matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\n      if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n      }\n\n      value = +matches[2];\n\n      switch (matches[3]) {\n        case 'px':\n          return value;\n\n        case '%':\n          value /= 100;\n          break;\n      }\n\n      return size * value;\n    },\n\n    /**\r\n     * Converts the given value into a padding object with pre-computed width/height.\r\n     * @param {number|object} value - If a number, set the value to all TRBL component,\r\n     *  else, if and object, use defined properties and sets undefined ones to 0.\r\n     * @returns {object} The padding values (top, right, bottom, left, width, height)\r\n     * @since 2.7.0\r\n     */\n    toPadding: function (value) {\n      var t, r, b, l;\n\n      if (helpers_core.isObject(value)) {\n        t = +value.top || 0;\n        r = +value.right || 0;\n        b = +value.bottom || 0;\n        l = +value.left || 0;\n      } else {\n        t = r = b = l = +value || 0;\n      }\n\n      return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        height: t + b,\n        width: l + r\n      };\n    },\n\n    /**\r\n     * Parses font options and returns the font object.\r\n     * @param {object} options - A object that contains font options to be parsed.\r\n     * @return {object} The font object.\r\n     * @todo Support font.* options and renamed to toFont().\r\n     * @private\r\n     */\n    _parseFont: function (options) {\n      var globalDefaults = core_defaults.global;\n      var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n      var font = {\n        family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\n        lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\n        size: size,\n        style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\n        weight: null,\n        string: ''\n      };\n      font.string = toFontString(font);\n      return font;\n    },\n\n    /**\r\n     * Evaluates the given `inputs` sequentially and returns the first defined value.\r\n     * @param {Array} inputs - An array of values, falling back to the last value.\r\n     * @param {object} [context] - If defined and the current value is a function, the value\r\n     * is called with `context` as first argument and the result becomes the new input.\r\n     * @param {number} [index] - If defined and the current value is an array, the value\r\n     * at `index` become the new input.\r\n     * @param {object} [info] - object to return information about resolution in\r\n     * @param {boolean} [info.cacheable] - Will be set to `false` if option is not cacheable.\r\n     * @since 2.7.0\r\n     */\n    resolve: function (inputs, context, index, info) {\n      var cacheable = true;\n      var i, ilen, value;\n\n      for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n        value = inputs[i];\n\n        if (value === undefined) {\n          continue;\n        }\n\n        if (context !== undefined && typeof value === 'function') {\n          value = value(context);\n          cacheable = false;\n        }\n\n        if (index !== undefined && helpers_core.isArray(value)) {\n          value = value[index];\n          cacheable = false;\n        }\n\n        if (value !== undefined) {\n          if (info && !cacheable) {\n            info.cacheable = false;\n          }\n\n          return value;\n        }\n      }\n    }\n  };\n  /**\r\n   * @alias Chart.helpers.math\r\n   * @namespace\r\n   */\n\n  var exports$2 = {\n    /**\r\n     * Returns an array of factors sorted from 1 to sqrt(value)\r\n     * @private\r\n     */\n    _factorize: function (value) {\n      var result = [];\n      var sqrt = Math.sqrt(value);\n      var i;\n\n      for (i = 1; i < sqrt; i++) {\n        if (value % i === 0) {\n          result.push(i);\n          result.push(value / i);\n        }\n      }\n\n      if (sqrt === (sqrt | 0)) {\n        // if value is a square number\n        result.push(sqrt);\n      }\n\n      result.sort(function (a, b) {\n        return a - b;\n      }).pop();\n      return result;\n    },\n    log10: Math.log10 || function (x) {\n      var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n      // Check for whole powers of 10,\n      // which due to floating point rounding error should be corrected.\n\n      var powerOf10 = Math.round(exponent);\n      var isPowerOf10 = x === Math.pow(10, powerOf10);\n      return isPowerOf10 ? powerOf10 : exponent;\n    }\n  };\n  var helpers_math = exports$2; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.math.log10 instead.\r\n   * @namespace Chart.helpers.log10\r\n   * @deprecated since version 2.9.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers_core.log10 = exports$2.log10;\n\n  var getRtlAdapter = function (rectX, width) {\n    return {\n      x: function (x) {\n        return rectX + rectX + width - x;\n      },\n      setWidth: function (w) {\n        width = w;\n      },\n      textAlign: function (align) {\n        if (align === 'center') {\n          return align;\n        }\n\n        return align === 'right' ? 'left' : 'right';\n      },\n      xPlus: function (x, value) {\n        return x - value;\n      },\n      leftForLtr: function (x, itemWidth) {\n        return x - itemWidth;\n      }\n    };\n  };\n\n  var getLtrAdapter = function () {\n    return {\n      x: function (x) {\n        return x;\n      },\n      setWidth: function (w) {// eslint-disable-line no-unused-vars\n      },\n      textAlign: function (align) {\n        return align;\n      },\n      xPlus: function (x, value) {\n        return x + value;\n      },\n      leftForLtr: function (x, _itemWidth) {\n        // eslint-disable-line no-unused-vars\n        return x;\n      }\n    };\n  };\n\n  var getAdapter = function (rtl, rectX, width) {\n    return rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();\n  };\n\n  var overrideTextDirection = function (ctx, direction) {\n    var style, original;\n\n    if (direction === 'ltr' || direction === 'rtl') {\n      style = ctx.canvas.style;\n      original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];\n      style.setProperty('direction', direction, 'important');\n      ctx.prevTextDirection = original;\n    }\n  };\n\n  var restoreTextDirection = function (ctx) {\n    var original = ctx.prevTextDirection;\n\n    if (original !== undefined) {\n      delete ctx.prevTextDirection;\n      ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n  };\n\n  var helpers_rtl = {\n    getRtlAdapter: getAdapter,\n    overrideTextDirection: overrideTextDirection,\n    restoreTextDirection: restoreTextDirection\n  };\n  var helpers$1 = helpers_core;\n  var easing = helpers_easing;\n  var canvas = helpers_canvas;\n  var options = helpers_options;\n  var math = helpers_math;\n  var rtl = helpers_rtl;\n  helpers$1.easing = easing;\n  helpers$1.canvas = canvas;\n  helpers$1.options = options;\n  helpers$1.math = math;\n  helpers$1.rtl = rtl;\n\n  function interpolate(start, view, model, ease) {\n    var keys = Object.keys(model);\n    var i, ilen, key, actual, origin, target, type, c0, c1;\n\n    for (i = 0, ilen = keys.length; i < ilen; ++i) {\n      key = keys[i];\n      target = model[key]; // if a value is added to the model after pivot() has been called, the view\n      // doesn't contain it, so let's initialize the view to the target value.\n\n      if (!view.hasOwnProperty(key)) {\n        view[key] = target;\n      }\n\n      actual = view[key];\n\n      if (actual === target || key[0] === '_') {\n        continue;\n      }\n\n      if (!start.hasOwnProperty(key)) {\n        start[key] = actual;\n      }\n\n      origin = start[key];\n      type = typeof target;\n\n      if (type === typeof origin) {\n        if (type === 'string') {\n          c0 = chartjsColor(origin);\n\n          if (c0.valid) {\n            c1 = chartjsColor(target);\n\n            if (c1.valid) {\n              view[key] = c1.mix(c0, ease).rgbString();\n              continue;\n            }\n          }\n        } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\n          view[key] = origin + (target - origin) * ease;\n          continue;\n        }\n      }\n\n      view[key] = target;\n    }\n  }\n\n  var Element = function (configuration) {\n    helpers$1.extend(this, configuration);\n    this.initialize.apply(this, arguments);\n  };\n\n  helpers$1.extend(Element.prototype, {\n    _type: undefined,\n    initialize: function () {\n      this.hidden = false;\n    },\n    pivot: function () {\n      var me = this;\n\n      if (!me._view) {\n        me._view = helpers$1.extend({}, me._model);\n      }\n\n      me._start = {};\n      return me;\n    },\n    transition: function (ease) {\n      var me = this;\n      var model = me._model;\n      var start = me._start;\n      var view = me._view; // No animation -> No Transition\n\n      if (!model || ease === 1) {\n        me._view = helpers$1.extend({}, model);\n        me._start = null;\n        return me;\n      }\n\n      if (!view) {\n        view = me._view = {};\n      }\n\n      if (!start) {\n        start = me._start = {};\n      }\n\n      interpolate(start, view, model, ease);\n      return me;\n    },\n    tooltipPosition: function () {\n      return {\n        x: this._model.x,\n        y: this._model.y\n      };\n    },\n    hasValue: function () {\n      return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\n    }\n  });\n  Element.extend = helpers$1.inherits;\n  var core_element = Element;\n  var exports$3 = core_element.extend({\n    chart: null,\n    // the animation associated chart instance\n    currentStep: 0,\n    // the current animation step\n    numSteps: 60,\n    // default number of steps\n    easing: '',\n    // the easing to use for this animation\n    render: null,\n    // render function used by the animation service\n    onAnimationProgress: null,\n    // user specified callback to fire on each step of the animation\n    onAnimationComplete: null // user specified callback to fire when the animation finishes\n\n  });\n  var core_animation = exports$3; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use Chart.Animation instead\r\n   * @prop Chart.Animation#animationObject\r\n   * @deprecated since version 2.6.0\r\n   * @todo remove at version 3\r\n   */\n\n  Object.defineProperty(exports$3.prototype, 'animationObject', {\n    get: function () {\n      return this;\n    }\n  });\n  /**\r\n   * Provided for backward compatibility, use Chart.Animation#chart instead\r\n   * @prop Chart.Animation#chartInstance\r\n   * @deprecated since version 2.6.0\r\n   * @todo remove at version 3\r\n   */\n\n  Object.defineProperty(exports$3.prototype, 'chartInstance', {\n    get: function () {\n      return this.chart;\n    },\n    set: function (value) {\n      this.chart = value;\n    }\n  });\n\n  core_defaults._set('global', {\n    animation: {\n      duration: 1000,\n      easing: 'easeOutQuart',\n      onProgress: helpers$1.noop,\n      onComplete: helpers$1.noop\n    }\n  });\n\n  var core_animations = {\n    animations: [],\n    request: null,\n\n    /**\r\n     * @param {Chart} chart - The chart to animate.\r\n     * @param {Chart.Animation} animation - The animation that we will animate.\r\n     * @param {number} duration - The animation duration in ms.\r\n     * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\r\n     */\n    addAnimation: function (chart, animation, duration, lazy) {\n      var animations = this.animations;\n      var i, ilen;\n      animation.chart = chart;\n      animation.startTime = Date.now();\n      animation.duration = duration;\n\n      if (!lazy) {\n        chart.animating = true;\n      }\n\n      for (i = 0, ilen = animations.length; i < ilen; ++i) {\n        if (animations[i].chart === chart) {\n          animations[i] = animation;\n          return;\n        }\n      }\n\n      animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word\n\n      if (animations.length === 1) {\n        this.requestAnimationFrame();\n      }\n    },\n    cancelAnimation: function (chart) {\n      var index = helpers$1.findIndex(this.animations, function (animation) {\n        return animation.chart === chart;\n      });\n\n      if (index !== -1) {\n        this.animations.splice(index, 1);\n        chart.animating = false;\n      }\n    },\n    requestAnimationFrame: function () {\n      var me = this;\n\n      if (me.request === null) {\n        // Skip animation frame requests until the active one is executed.\n        // This can happen when processing mouse events, e.g. 'mousemove'\n        // and 'mouseout' events will trigger multiple renders.\n        me.request = helpers$1.requestAnimFrame.call(window, function () {\n          me.request = null;\n          me.startDigest();\n        });\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    startDigest: function () {\n      var me = this;\n      me.advance(); // Do we have more stuff to animate?\n\n      if (me.animations.length > 0) {\n        me.requestAnimationFrame();\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    advance: function () {\n      var animations = this.animations;\n      var animation, chart, numSteps, nextStep;\n      var i = 0; // 1 animation per chart, so we are looping charts here\n\n      while (i < animations.length) {\n        animation = animations[i];\n        chart = animation.chart;\n        numSteps = animation.numSteps; // Make sure that currentStep starts at 1\n        // https://github.com/chartjs/Chart.js/issues/6104\n\n        nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;\n        animation.currentStep = Math.min(nextStep, numSteps);\n        helpers$1.callback(animation.render, [chart, animation], chart);\n        helpers$1.callback(animation.onAnimationProgress, [animation], chart);\n\n        if (animation.currentStep >= numSteps) {\n          helpers$1.callback(animation.onAnimationComplete, [animation], chart);\n          chart.animating = false;\n          animations.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n  };\n  var resolve = helpers$1.options.resolve;\n  var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n  /**\r\n   * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\r\n   * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\r\n   * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\r\n   */\n\n  function listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n      array._chartjs.listeners.push(listener);\n\n      return;\n    }\n\n    Object.defineProperty(array, '_chartjs', {\n      configurable: true,\n      enumerable: false,\n      value: {\n        listeners: [listener]\n      }\n    });\n    arrayEvents.forEach(function (key) {\n      var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n      var base = array[key];\n      Object.defineProperty(array, key, {\n        configurable: true,\n        enumerable: false,\n        value: function () {\n          var args = Array.prototype.slice.call(arguments);\n          var res = base.apply(this, args);\n          helpers$1.each(array._chartjs.listeners, function (object) {\n            if (typeof object[method] === 'function') {\n              object[method].apply(object, args);\n            }\n          });\n          return res;\n        }\n      });\n    });\n  }\n  /**\r\n   * Removes the given array event listener and cleanup extra attached properties (such as\r\n   * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\r\n   */\n\n\n  function unlistenArrayEvents(array, listener) {\n    var stub = array._chartjs;\n\n    if (!stub) {\n      return;\n    }\n\n    var listeners = stub.listeners;\n    var index = listeners.indexOf(listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length > 0) {\n      return;\n    }\n\n    arrayEvents.forEach(function (key) {\n      delete array[key];\n    });\n    delete array._chartjs;\n  } // Base class for all dataset controllers (line, bar, etc)\n\n\n  var DatasetController = function (chart, datasetIndex) {\n    this.initialize(chart, datasetIndex);\n  };\n\n  helpers$1.extend(DatasetController.prototype, {\n    /**\r\n     * Element type used to generate a meta dataset (e.g. Chart.element.Line).\r\n     * @type {Chart.core.element}\r\n     */\n    datasetElementType: null,\n\n    /**\r\n     * Element type used to generate a meta data (e.g. Chart.element.Point).\r\n     * @type {Chart.core.element}\r\n     */\n    dataElementType: null,\n\n    /**\r\n     * Dataset element option keys to be resolved in _resolveDatasetElementOptions.\r\n     * A derived controller may override this to resolve controller-specific options.\r\n     * The keys defined here are for backward compatibility for legend styles.\r\n     * @private\r\n     */\n    _datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth'],\n\n    /**\r\n     * Data element option keys to be resolved in _resolveDataElementOptions.\r\n     * A derived controller may override this to resolve controller-specific options.\r\n     * The keys defined here are for backward compatibility for legend styles.\r\n     * @private\r\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'pointStyle'],\n    initialize: function (chart, datasetIndex) {\n      var me = this;\n      me.chart = chart;\n      me.index = datasetIndex;\n      me.linkScales();\n      me.addElements();\n      me._type = me.getMeta().type;\n    },\n    updateIndex: function (datasetIndex) {\n      this.index = datasetIndex;\n    },\n    linkScales: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var chart = me.chart;\n      var scales = chart.scales;\n      var dataset = me.getDataset();\n      var scalesOpts = chart.options.scales;\n\n      if (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {\n        meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;\n      }\n\n      if (meta.yAxisID === null || !(meta.yAxisID in scales) || dataset.yAxisID) {\n        meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;\n      }\n    },\n    getDataset: function () {\n      return this.chart.data.datasets[this.index];\n    },\n    getMeta: function () {\n      return this.chart.getDatasetMeta(this.index);\n    },\n    getScaleForId: function (scaleID) {\n      return this.chart.scales[scaleID];\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getValueScaleId: function () {\n      return this.getMeta().yAxisID;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getIndexScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getValueScale: function () {\n      return this.getScaleForId(this._getValueScaleId());\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getIndexScale: function () {\n      return this.getScaleForId(this._getIndexScaleId());\n    },\n    reset: function () {\n      this._update(true);\n    },\n\n    /**\r\n     * @private\r\n     */\n    destroy: function () {\n      if (this._data) {\n        unlistenArrayEvents(this._data, this);\n      }\n    },\n    createMetaDataset: function () {\n      var me = this;\n      var type = me.datasetElementType;\n      return type && new type({\n        _chart: me.chart,\n        _datasetIndex: me.index\n      });\n    },\n    createMetaData: function (index) {\n      var me = this;\n      var type = me.dataElementType;\n      return type && new type({\n        _chart: me.chart,\n        _datasetIndex: me.index,\n        _index: index\n      });\n    },\n    addElements: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var data = me.getDataset().data || [];\n      var metaData = meta.data;\n      var i, ilen;\n\n      for (i = 0, ilen = data.length; i < ilen; ++i) {\n        metaData[i] = metaData[i] || me.createMetaData(i);\n      }\n\n      meta.dataset = meta.dataset || me.createMetaDataset();\n    },\n    addElementAndReset: function (index) {\n      var element = this.createMetaData(index);\n      this.getMeta().data.splice(index, 0, element);\n      this.updateElement(element, index, true);\n    },\n    buildOrUpdateElements: function () {\n      var me = this;\n      var dataset = me.getDataset();\n      var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate\n      // real-time charts), we need to monitor these data modifications and synchronize\n      // the internal meta data accordingly.\n\n      if (me._data !== data) {\n        if (me._data) {\n          // This case happens when the user replaced the data array instance.\n          unlistenArrayEvents(me._data, me);\n        }\n\n        if (data && Object.isExtensible(data)) {\n          listenArrayEvents(data, me);\n        }\n\n        me._data = data;\n      } // Re-sync meta data in case the user replaced the data array or if we missed\n      // any updates and so make sure that we handle number of datapoints changing.\n\n\n      me.resyncElements();\n    },\n\n    /**\r\n     * Returns the merged user-supplied and default dataset-level options\r\n     * @private\r\n     */\n    _configure: function () {\n      var me = this;\n      me._config = helpers$1.merge(Object.create(null), [me.chart.options.datasets[me._type], me.getDataset()], {\n        merger: function (key, target, source) {\n          if (key !== '_meta' && key !== 'data') {\n            helpers$1._merger(key, target, source);\n          }\n        }\n      });\n    },\n    _update: function (reset) {\n      var me = this;\n\n      me._configure();\n\n      me._cachedDataOpts = null;\n      me.update(reset);\n    },\n    update: helpers$1.noop,\n    transition: function (easingValue) {\n      var meta = this.getMeta();\n      var elements = meta.data || [];\n      var ilen = elements.length;\n      var i = 0;\n\n      for (; i < ilen; ++i) {\n        elements[i].transition(easingValue);\n      }\n\n      if (meta.dataset) {\n        meta.dataset.transition(easingValue);\n      }\n    },\n    draw: function () {\n      var meta = this.getMeta();\n      var elements = meta.data || [];\n      var ilen = elements.length;\n      var i = 0;\n\n      if (meta.dataset) {\n        meta.dataset.draw();\n      }\n\n      for (; i < ilen; ++i) {\n        elements[i].draw();\n      }\n    },\n\n    /**\r\n     * Returns a set of predefined style properties that should be used to represent the dataset\r\n     * or the data if the index is specified\r\n     * @param {number} index - data index\r\n     * @return {IStyleInterface} style object\r\n     */\n    getStyle: function (index) {\n      var me = this;\n      var meta = me.getMeta();\n      var dataset = meta.dataset;\n      var style;\n\n      me._configure();\n\n      if (dataset && index === undefined) {\n        style = me._resolveDatasetElementOptions(dataset || {});\n      } else {\n        index = index || 0;\n        style = me._resolveDataElementOptions(meta.data[index] || {}, index);\n      }\n\n      if (style.fill === false || style.fill === null) {\n        style.backgroundColor = style.borderColor;\n      }\n\n      return style;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _resolveDatasetElementOptions: function (element, hover) {\n      var me = this;\n      var chart = me.chart;\n      var datasetOpts = me._config;\n      var custom = element.custom || {};\n      var options = chart.options.elements[me.datasetElementType.prototype._type] || {};\n      var elementOptions = me._datasetElementOptions;\n      var values = {};\n      var i, ilen, key, readKey; // Scriptable options\n\n      var context = {\n        chart: chart,\n        dataset: me.getDataset(),\n        datasetIndex: me.index,\n        hover: hover\n      };\n\n      for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\n        key = elementOptions[i];\n        readKey = hover ? 'hover' + key.charAt(0).toUpperCase() + key.slice(1) : key;\n        values[key] = resolve([custom[readKey], datasetOpts[readKey], options[readKey]], context);\n      }\n\n      return values;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _resolveDataElementOptions: function (element, index) {\n      var me = this;\n      var custom = element && element.custom;\n      var cached = me._cachedDataOpts;\n\n      if (cached && !custom) {\n        return cached;\n      }\n\n      var chart = me.chart;\n      var datasetOpts = me._config;\n      var options = chart.options.elements[me.dataElementType.prototype._type] || {};\n      var elementOptions = me._dataElementOptions;\n      var values = {}; // Scriptable options\n\n      var context = {\n        chart: chart,\n        dataIndex: index,\n        dataset: me.getDataset(),\n        datasetIndex: me.index\n      }; // `resolve` sets cacheable to `false` if any option is indexed or scripted\n\n      var info = {\n        cacheable: !custom\n      };\n      var keys, i, ilen, key;\n      custom = custom || {};\n\n      if (helpers$1.isArray(elementOptions)) {\n        for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\n          key = elementOptions[i];\n          values[key] = resolve([custom[key], datasetOpts[key], options[key]], context, index, info);\n        }\n      } else {\n        keys = Object.keys(elementOptions);\n\n        for (i = 0, ilen = keys.length; i < ilen; ++i) {\n          key = keys[i];\n          values[key] = resolve([custom[key], datasetOpts[elementOptions[key]], datasetOpts[key], options[key]], context, index, info);\n        }\n      }\n\n      if (info.cacheable) {\n        me._cachedDataOpts = Object.freeze(values);\n      }\n\n      return values;\n    },\n    removeHoverStyle: function (element) {\n      helpers$1.merge(element._model, element.$previousStyle || {});\n      delete element.$previousStyle;\n    },\n    setHoverStyle: function (element) {\n      var dataset = this.chart.data.datasets[element._datasetIndex];\n      var index = element._index;\n      var custom = element.custom || {};\n      var model = element._model;\n      var getHoverColor = helpers$1.getHoverColor;\n      element.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth\n      };\n      model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);\n      model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);\n      model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _removeDatasetHoverStyle: function () {\n      var element = this.getMeta().dataset;\n\n      if (element) {\n        this.removeHoverStyle(element);\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    _setDatasetHoverStyle: function () {\n      var element = this.getMeta().dataset;\n      var prev = {};\n      var i, ilen, key, keys, hoverOptions, model;\n\n      if (!element) {\n        return;\n      }\n\n      model = element._model;\n      hoverOptions = this._resolveDatasetElementOptions(element, true);\n      keys = Object.keys(hoverOptions);\n\n      for (i = 0, ilen = keys.length; i < ilen; ++i) {\n        key = keys[i];\n        prev[key] = model[key];\n        model[key] = hoverOptions[key];\n      }\n\n      element.$previousStyle = prev;\n    },\n\n    /**\r\n     * @private\r\n     */\n    resyncElements: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var data = me.getDataset().data;\n      var numMeta = meta.data.length;\n      var numData = data.length;\n\n      if (numData < numMeta) {\n        meta.data.splice(numData, numMeta - numData);\n      } else if (numData > numMeta) {\n        me.insertElements(numMeta, numData - numMeta);\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    insertElements: function (start, count) {\n      for (var i = 0; i < count; ++i) {\n        this.addElementAndReset(start + i);\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    onDataPush: function () {\n      var count = arguments.length;\n      this.insertElements(this.getDataset().data.length - count, count);\n    },\n\n    /**\r\n     * @private\r\n     */\n    onDataPop: function () {\n      this.getMeta().data.pop();\n    },\n\n    /**\r\n     * @private\r\n     */\n    onDataShift: function () {\n      this.getMeta().data.shift();\n    },\n\n    /**\r\n     * @private\r\n     */\n    onDataSplice: function (start, count) {\n      this.getMeta().data.splice(start, count);\n      this.insertElements(start, arguments.length - 2);\n    },\n\n    /**\r\n     * @private\r\n     */\n    onDataUnshift: function () {\n      this.insertElements(0, arguments.length);\n    }\n  });\n  DatasetController.extend = helpers$1.inherits;\n  var core_datasetController = DatasetController;\n  var TAU = Math.PI * 2;\n\n  core_defaults._set('global', {\n    elements: {\n      arc: {\n        backgroundColor: core_defaults.global.defaultColor,\n        borderColor: '#fff',\n        borderWidth: 2,\n        borderAlign: 'center'\n      }\n    }\n  });\n\n  function clipArc(ctx, arc) {\n    var startAngle = arc.startAngle;\n    var endAngle = arc.endAngle;\n    var pixelMargin = arc.pixelMargin;\n    var angleMargin = pixelMargin / arc.outerRadius;\n    var x = arc.x;\n    var y = arc.y; // Draw an inner border by cliping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n\n    ctx.beginPath();\n    ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n\n    if (arc.innerRadius > pixelMargin) {\n      angleMargin = pixelMargin / arc.innerRadius;\n      ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n      ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);\n    }\n\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  function drawFullCircleBorders(ctx, vm, arc, inner) {\n    var endAngle = arc.endAngle;\n    var i;\n\n    if (inner) {\n      arc.endAngle = arc.startAngle + TAU;\n      clipArc(ctx, arc);\n      arc.endAngle = endAngle;\n\n      if (arc.endAngle === arc.startAngle && arc.fullCircles) {\n        arc.endAngle += TAU;\n        arc.fullCircles--;\n      }\n    }\n\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);\n\n    for (i = 0; i < arc.fullCircles; ++i) {\n      ctx.stroke();\n    }\n\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);\n\n    for (i = 0; i < arc.fullCircles; ++i) {\n      ctx.stroke();\n    }\n  }\n\n  function drawBorder(ctx, vm, arc) {\n    var inner = vm.borderAlign === 'inner';\n\n    if (inner) {\n      ctx.lineWidth = vm.borderWidth * 2;\n      ctx.lineJoin = 'round';\n    } else {\n      ctx.lineWidth = vm.borderWidth;\n      ctx.lineJoin = 'bevel';\n    }\n\n    if (arc.fullCircles) {\n      drawFullCircleBorders(ctx, vm, arc, inner);\n    }\n\n    if (inner) {\n      clipArc(ctx, arc);\n    }\n\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);\n    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  var element_arc = core_element.extend({\n    _type: 'arc',\n    inLabelRange: function (mouseX) {\n      var vm = this._view;\n\n      if (vm) {\n        return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);\n      }\n\n      return false;\n    },\n    inRange: function (chartX, chartY) {\n      var vm = this._view;\n\n      if (vm) {\n        var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {\n          x: chartX,\n          y: chartY\n        });\n        var angle = pointRelativePosition.angle;\n        var distance = pointRelativePosition.distance; // Sanitise angle range\n\n        var startAngle = vm.startAngle;\n        var endAngle = vm.endAngle;\n\n        while (endAngle < startAngle) {\n          endAngle += TAU;\n        }\n\n        while (angle > endAngle) {\n          angle -= TAU;\n        }\n\n        while (angle < startAngle) {\n          angle += TAU;\n        } // Check if within the range of the open/close angle\n\n\n        var betweenAngles = angle >= startAngle && angle <= endAngle;\n        var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;\n        return betweenAngles && withinRadius;\n      }\n\n      return false;\n    },\n    getCenterPoint: function () {\n      var vm = this._view;\n      var halfAngle = (vm.startAngle + vm.endAngle) / 2;\n      var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n      return {\n        x: vm.x + Math.cos(halfAngle) * halfRadius,\n        y: vm.y + Math.sin(halfAngle) * halfRadius\n      };\n    },\n    getArea: function () {\n      var vm = this._view;\n      return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;\n      var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n      return {\n        x: vm.x + Math.cos(centreAngle) * rangeFromCentre,\n        y: vm.y + Math.sin(centreAngle) * rangeFromCentre\n      };\n    },\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;\n      var arc = {\n        x: vm.x,\n        y: vm.y,\n        innerRadius: vm.innerRadius,\n        outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),\n        pixelMargin: pixelMargin,\n        startAngle: vm.startAngle,\n        endAngle: vm.endAngle,\n        fullCircles: Math.floor(vm.circumference / TAU)\n      };\n      var i;\n      ctx.save();\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.strokeStyle = vm.borderColor;\n\n      if (arc.fullCircles) {\n        arc.endAngle = arc.startAngle + TAU;\n        ctx.beginPath();\n        ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\n        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\n        ctx.closePath();\n\n        for (i = 0; i < arc.fullCircles; ++i) {\n          ctx.fill();\n        }\n\n        arc.endAngle = arc.startAngle + vm.circumference % TAU;\n      }\n\n      ctx.beginPath();\n      ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\n      ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\n      ctx.closePath();\n      ctx.fill();\n\n      if (vm.borderWidth) {\n        drawBorder(ctx, vm, arc);\n      }\n\n      ctx.restore();\n    }\n  });\n  var valueOrDefault$1 = helpers$1.valueOrDefault;\n  var defaultColor = core_defaults.global.defaultColor;\n\n  core_defaults._set('global', {\n    elements: {\n      line: {\n        tension: 0.4,\n        backgroundColor: defaultColor,\n        borderWidth: 3,\n        borderColor: defaultColor,\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderJoinStyle: 'miter',\n        capBezierPoints: true,\n        fill: true // do we fill in the area between the line and its base axis\n\n      }\n    }\n  });\n\n  var element_line = core_element.extend({\n    _type: 'line',\n    draw: function () {\n      var me = this;\n      var vm = me._view;\n      var ctx = me._chart.ctx;\n      var spanGaps = vm.spanGaps;\n\n      var points = me._children.slice(); // clone array\n\n\n      var globalDefaults = core_defaults.global;\n      var globalOptionLineElements = globalDefaults.elements.line;\n      var lastDrawnIndex = -1;\n      var closePath = me._loop;\n      var index, previous, currentVM;\n\n      if (!points.length) {\n        return;\n      }\n\n      if (me._loop) {\n        for (index = 0; index < points.length; ++index) {\n          previous = helpers$1.previousItem(points, index); // If the line has an open path, shift the point array\n\n          if (!points[index]._view.skip && previous._view.skip) {\n            points = points.slice(index).concat(points.slice(0, index));\n            closePath = spanGaps;\n            break;\n          }\n        } // If the line has a close path, add the first point again\n\n\n        if (closePath) {\n          points.push(points[0]);\n        }\n      }\n\n      ctx.save(); // Stroke Line Options\n\n      ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n      }\n\n      ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\n      ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n      ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\n      ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line\n\n      ctx.beginPath(); // First point moves to it's starting position no matter what\n\n      currentVM = points[0]._view;\n\n      if (!currentVM.skip) {\n        ctx.moveTo(currentVM.x, currentVM.y);\n        lastDrawnIndex = 0;\n      }\n\n      for (index = 1; index < points.length; ++index) {\n        currentVM = points[index]._view;\n        previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];\n\n        if (!currentVM.skip) {\n          if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n            // There was a gap and this is the first point after the gap\n            ctx.moveTo(currentVM.x, currentVM.y);\n          } else {\n            // Line to next point\n            helpers$1.canvas.lineTo(ctx, previous._view, currentVM);\n          }\n\n          lastDrawnIndex = index;\n        }\n      }\n\n      if (closePath) {\n        ctx.closePath();\n      }\n\n      ctx.stroke();\n      ctx.restore();\n    }\n  });\n  var valueOrDefault$2 = helpers$1.valueOrDefault;\n  var defaultColor$1 = core_defaults.global.defaultColor;\n\n  core_defaults._set('global', {\n    elements: {\n      point: {\n        radius: 3,\n        pointStyle: 'circle',\n        backgroundColor: defaultColor$1,\n        borderColor: defaultColor$1,\n        borderWidth: 1,\n        // Hover\n        hitRadius: 1,\n        hoverRadius: 4,\n        hoverBorderWidth: 1\n      }\n    }\n  });\n\n  function xRange(mouseX) {\n    var vm = this._view;\n    return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;\n  }\n\n  function yRange(mouseY) {\n    var vm = this._view;\n    return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;\n  }\n\n  var element_point = core_element.extend({\n    _type: 'point',\n    inRange: function (mouseX, mouseY) {\n      var vm = this._view;\n      return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;\n    },\n    inLabelRange: xRange,\n    inXRange: xRange,\n    inYRange: yRange,\n    getCenterPoint: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y\n      };\n    },\n    getArea: function () {\n      return Math.PI * Math.pow(this._view.radius, 2);\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y,\n        padding: vm.radius + vm.borderWidth\n      };\n    },\n    draw: function (chartArea) {\n      var vm = this._view;\n      var ctx = this._chart.ctx;\n      var pointStyle = vm.pointStyle;\n      var rotation = vm.rotation;\n      var radius = vm.radius;\n      var x = vm.x;\n      var y = vm.y;\n      var globalDefaults = core_defaults.global;\n      var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow\n\n      if (vm.skip) {\n        return;\n      } // Clipping for Points.\n\n\n      if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {\n        ctx.strokeStyle = vm.borderColor || defaultColor;\n        ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\n        ctx.fillStyle = vm.backgroundColor || defaultColor;\n        helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);\n      }\n    }\n  });\n  var defaultColor$2 = core_defaults.global.defaultColor;\n\n  core_defaults._set('global', {\n    elements: {\n      rectangle: {\n        backgroundColor: defaultColor$2,\n        borderColor: defaultColor$2,\n        borderSkipped: 'bottom',\n        borderWidth: 0\n      }\n    }\n  });\n\n  function isVertical(vm) {\n    return vm && vm.width !== undefined;\n  }\n  /**\r\n   * Helper function to get the bounds of the bar regardless of the orientation\r\n   * @param bar {Chart.Element.Rectangle} the bar\r\n   * @return {Bounds} bounds of the bar\r\n   * @private\r\n   */\n\n\n  function getBarBounds(vm) {\n    var x1, x2, y1, y2, half;\n\n    if (isVertical(vm)) {\n      half = vm.width / 2;\n      x1 = vm.x - half;\n      x2 = vm.x + half;\n      y1 = Math.min(vm.y, vm.base);\n      y2 = Math.max(vm.y, vm.base);\n    } else {\n      half = vm.height / 2;\n      x1 = Math.min(vm.x, vm.base);\n      x2 = Math.max(vm.x, vm.base);\n      y1 = vm.y - half;\n      y2 = vm.y + half;\n    }\n\n    return {\n      left: x1,\n      top: y1,\n      right: x2,\n      bottom: y2\n    };\n  }\n\n  function swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n  }\n\n  function parseBorderSkipped(vm) {\n    var edge = vm.borderSkipped;\n    var res = {};\n\n    if (!edge) {\n      return res;\n    }\n\n    if (vm.horizontal) {\n      if (vm.base > vm.x) {\n        edge = swap(edge, 'left', 'right');\n      }\n    } else if (vm.base < vm.y) {\n      edge = swap(edge, 'bottom', 'top');\n    }\n\n    res[edge] = true;\n    return res;\n  }\n\n  function parseBorderWidth(vm, maxW, maxH) {\n    var value = vm.borderWidth;\n    var skip = parseBorderSkipped(vm);\n    var t, r, b, l;\n\n    if (helpers$1.isObject(value)) {\n      t = +value.top || 0;\n      r = +value.right || 0;\n      b = +value.bottom || 0;\n      l = +value.left || 0;\n    } else {\n      t = r = b = l = +value || 0;\n    }\n\n    return {\n      t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,\n      r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,\n      b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,\n      l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l\n    };\n  }\n\n  function boundingRects(vm) {\n    var bounds = getBarBounds(vm);\n    var width = bounds.right - bounds.left;\n    var height = bounds.bottom - bounds.top;\n    var border = parseBorderWidth(vm, width / 2, height / 2);\n    return {\n      outer: {\n        x: bounds.left,\n        y: bounds.top,\n        w: width,\n        h: height\n      },\n      inner: {\n        x: bounds.left + border.l,\n        y: bounds.top + border.t,\n        w: width - border.l - border.r,\n        h: height - border.t - border.b\n      }\n    };\n  }\n\n  function inRange(vm, x, y) {\n    var skipX = x === null;\n    var skipY = y === null;\n    var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);\n    return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);\n  }\n\n  var element_rectangle = core_element.extend({\n    _type: 'rectangle',\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var rects = boundingRects(vm);\n      var outer = rects.outer;\n      var inner = rects.inner;\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.fillRect(outer.x, outer.y, outer.w, outer.h);\n\n      if (outer.w === inner.w && outer.h === inner.h) {\n        return;\n      }\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(outer.x, outer.y, outer.w, outer.h);\n      ctx.clip();\n      ctx.fillStyle = vm.borderColor;\n      ctx.rect(inner.x, inner.y, inner.w, inner.h);\n      ctx.fill('evenodd');\n      ctx.restore();\n    },\n    height: function () {\n      var vm = this._view;\n      return vm.base - vm.y;\n    },\n    inRange: function (mouseX, mouseY) {\n      return inRange(this._view, mouseX, mouseY);\n    },\n    inLabelRange: function (mouseX, mouseY) {\n      var vm = this._view;\n      return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);\n    },\n    inXRange: function (mouseX) {\n      return inRange(this._view, mouseX, null);\n    },\n    inYRange: function (mouseY) {\n      return inRange(this._view, null, mouseY);\n    },\n    getCenterPoint: function () {\n      var vm = this._view;\n      var x, y;\n\n      if (isVertical(vm)) {\n        x = vm.x;\n        y = (vm.y + vm.base) / 2;\n      } else {\n        x = (vm.x + vm.base) / 2;\n        y = vm.y;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    getArea: function () {\n      var vm = this._view;\n      return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y\n      };\n    }\n  });\n  var elements = {};\n  var Arc = element_arc;\n  var Line = element_line;\n  var Point = element_point;\n  var Rectangle = element_rectangle;\n  elements.Arc = Arc;\n  elements.Line = Line;\n  elements.Point = Point;\n  elements.Rectangle = Rectangle;\n  var deprecated = helpers$1._deprecated;\n  var valueOrDefault$3 = helpers$1.valueOrDefault;\n\n  core_defaults._set('bar', {\n    hover: {\n      mode: 'label'\n    },\n    scales: {\n      xAxes: [{\n        type: 'category',\n        offset: true,\n        gridLines: {\n          offsetGridLines: true\n        }\n      }],\n      yAxes: [{\n        type: 'linear'\n      }]\n    }\n  });\n\n  core_defaults._set('global', {\n    datasets: {\n      bar: {\n        categoryPercentage: 0.8,\n        barPercentage: 0.9\n      }\n    }\n  });\n  /**\r\n   * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\r\n   * @private\r\n   */\n\n\n  function computeMinSampleSize(scale, pixels) {\n    var min = scale._length;\n    var prev, curr, i, ilen;\n\n    for (i = 1, ilen = pixels.length; i < ilen; ++i) {\n      min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n    }\n\n    for (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {\n      curr = scale.getPixelForTick(i);\n      min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;\n      prev = curr;\n    }\n\n    return min;\n  }\n  /**\r\n   * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\r\n   * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\r\n   * mode currently always generates bars equally sized (until we introduce scriptable options?).\r\n   * @private\r\n   */\n\n\n  function computeFitCategoryTraits(index, ruler, options) {\n    var thickness = options.barThickness;\n    var count = ruler.stackCount;\n    var curr = ruler.pixels[index];\n    var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;\n    var size, ratio;\n\n    if (helpers$1.isNullOrUndef(thickness)) {\n      size = min * options.categoryPercentage;\n      ratio = options.barPercentage;\n    } else {\n      // When bar thickness is enforced, category and bar percentages are ignored.\n      // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n      // and deprecate barPercentage since this value is ignored when thickness is absolute.\n      size = thickness * count;\n      ratio = 1;\n    }\n\n    return {\n      chunk: size / count,\n      ratio: ratio,\n      start: curr - size / 2\n    };\n  }\n  /**\r\n   * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\r\n   * percentage options are 1), based on the previous and following categories. This mode\r\n   * generates bars with different widths when data are not evenly spaced.\r\n   * @private\r\n   */\n\n\n  function computeFlexCategoryTraits(index, ruler, options) {\n    var pixels = ruler.pixels;\n    var curr = pixels[index];\n    var prev = index > 0 ? pixels[index - 1] : null;\n    var next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    var percent = options.categoryPercentage;\n    var start, size;\n\n    if (prev === null) {\n      // first data: its size is double based on the next point or,\n      // if it's also the last data, we use the scale size.\n      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n\n    if (next === null) {\n      // last data: its size is also double based on the previous point.\n      next = curr + curr - prev;\n    }\n\n    start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    size = Math.abs(next - prev) / 2 * percent;\n    return {\n      chunk: size / ruler.stackCount,\n      ratio: options.barPercentage,\n      start: start\n    };\n  }\n\n  var controller_bar = core_datasetController.extend({\n    dataElementType: elements.Rectangle,\n\n    /**\r\n     * @private\r\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'barPercentage', 'barThickness', 'categoryPercentage', 'maxBarThickness', 'minBarLength'],\n    initialize: function () {\n      var me = this;\n      var meta, scaleOpts;\n      core_datasetController.prototype.initialize.apply(me, arguments);\n      meta = me.getMeta();\n      meta.stack = me.getDataset().stack;\n      meta.bar = true;\n      scaleOpts = me._getIndexScale().options;\n      deprecated('bar chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');\n      deprecated('bar chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');\n      deprecated('bar chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');\n      deprecated('bar chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength', 'dataset.minBarLength');\n      deprecated('bar chart', scaleOpts.maxBarThickness, 'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');\n    },\n    update: function (reset) {\n      var me = this;\n      var rects = me.getMeta().data;\n      var i, ilen;\n      me._ruler = me.getRuler();\n\n      for (i = 0, ilen = rects.length; i < ilen; ++i) {\n        me.updateElement(rects[i], i, reset);\n      }\n    },\n    updateElement: function (rectangle, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var dataset = me.getDataset();\n\n      var options = me._resolveDataElementOptions(rectangle, index);\n\n      rectangle._xScale = me.getScaleForId(meta.xAxisID);\n      rectangle._yScale = me.getScaleForId(meta.yAxisID);\n      rectangle._datasetIndex = me.index;\n      rectangle._index = index;\n      rectangle._model = {\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderSkipped: options.borderSkipped,\n        borderWidth: options.borderWidth,\n        datasetLabel: dataset.label,\n        label: me.chart.data.labels[index]\n      };\n\n      if (helpers$1.isArray(dataset.data[index])) {\n        rectangle._model.borderSkipped = null;\n      }\n\n      me._updateElementGeometry(rectangle, index, reset, options);\n\n      rectangle.pivot();\n    },\n\n    /**\r\n     * @private\r\n     */\n    _updateElementGeometry: function (rectangle, index, reset, options) {\n      var me = this;\n      var model = rectangle._model;\n\n      var vscale = me._getValueScale();\n\n      var base = vscale.getBasePixel();\n      var horizontal = vscale.isHorizontal();\n      var ruler = me._ruler || me.getRuler();\n      var vpixels = me.calculateBarValuePixels(me.index, index, options);\n      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);\n      model.horizontal = horizontal;\n      model.base = reset ? base : vpixels.base;\n      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n      model.height = horizontal ? ipixels.size : undefined;\n      model.width = horizontal ? undefined : ipixels.size;\n    },\n\n    /**\r\n     * Returns the stacks based on groups and bar visibility.\r\n     * @param {number} [last] - The dataset index\r\n     * @returns {string[]} The list of stack IDs\r\n     * @private\r\n     */\n    _getStacks: function (last) {\n      var me = this;\n\n      var scale = me._getIndexScale();\n\n      var metasets = scale._getMatchingVisibleMetas(me._type);\n\n      var stacked = scale.options.stacked;\n      var ilen = metasets.length;\n      var stacks = [];\n      var i, meta;\n\n      for (i = 0; i < ilen; ++i) {\n        meta = metasets[i]; // stacked   | meta.stack\n        //           | found | not found | undefined\n        // false     |   x   |     x     |     x\n        // true      |       |     x     |\n        // undefined |       |     x     |     x\n\n        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n          stacks.push(meta.stack);\n        }\n\n        if (meta.index === last) {\n          break;\n        }\n      }\n\n      return stacks;\n    },\n\n    /**\r\n     * Returns the effective number of stacks based on groups and bar visibility.\r\n     * @private\r\n     */\n    getStackCount: function () {\n      return this._getStacks().length;\n    },\n\n    /**\r\n     * Returns the stack index for the given dataset based on groups and bar visibility.\r\n     * @param {number} [datasetIndex] - The dataset index\r\n     * @param {string} [name] - The stack name to find\r\n     * @returns {number} The stack index\r\n     * @private\r\n     */\n    getStackIndex: function (datasetIndex, name) {\n      var stacks = this._getStacks(datasetIndex);\n\n      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present\n\n      return index === -1 ? stacks.length - 1 : index;\n    },\n\n    /**\r\n     * @private\r\n     */\n    getRuler: function () {\n      var me = this;\n\n      var scale = me._getIndexScale();\n\n      var pixels = [];\n      var i, ilen;\n\n      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n        pixels.push(scale.getPixelForValue(null, i, me.index));\n      }\n\n      return {\n        pixels: pixels,\n        start: scale._startPixel,\n        end: scale._endPixel,\n        stackCount: me.getStackCount(),\n        scale: scale\n      };\n    },\n\n    /**\r\n     * Note: pixel values are not clamped to the scale area.\r\n     * @private\r\n     */\n    calculateBarValuePixels: function (datasetIndex, index, options) {\n      var me = this;\n      var chart = me.chart;\n\n      var scale = me._getValueScale();\n\n      var isHorizontal = scale.isHorizontal();\n      var datasets = chart.data.datasets;\n\n      var metasets = scale._getMatchingVisibleMetas(me._type);\n\n      var value = scale._parseValue(datasets[datasetIndex].data[index]);\n\n      var minBarLength = options.minBarLength;\n      var stacked = scale.options.stacked;\n      var stack = me.getMeta().stack;\n      var start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;\n      var length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;\n      var ilen = metasets.length;\n      var i, imeta, ivalue, base, head, size, stackLength;\n\n      if (stacked || stacked === undefined && stack !== undefined) {\n        for (i = 0; i < ilen; ++i) {\n          imeta = metasets[i];\n\n          if (imeta.index === datasetIndex) {\n            break;\n          }\n\n          if (imeta.stack === stack) {\n            stackLength = scale._parseValue(datasets[imeta.index].data[index]);\n            ivalue = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;\n\n            if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {\n              start += ivalue;\n            }\n          }\n        }\n      }\n\n      base = scale.getPixelForValue(start);\n      head = scale.getPixelForValue(start + length);\n      size = head - base;\n\n      if (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n        size = minBarLength;\n\n        if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {\n          head = base - minBarLength;\n        } else {\n          head = base + minBarLength;\n        }\n      }\n\n      return {\n        size: size,\n        base: base,\n        head: head,\n        center: head + size / 2\n      };\n    },\n\n    /**\r\n     * @private\r\n     */\n    calculateBarIndexPixels: function (datasetIndex, index, ruler, options) {\n      var me = this;\n      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);\n      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n      var center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      var size = Math.min(valueOrDefault$3(options.maxBarThickness, Infinity), range.chunk * range.ratio);\n      return {\n        base: center - size / 2,\n        head: center + size / 2,\n        center: center,\n        size: size\n      };\n    },\n    draw: function () {\n      var me = this;\n      var chart = me.chart;\n\n      var scale = me._getValueScale();\n\n      var rects = me.getMeta().data;\n      var dataset = me.getDataset();\n      var ilen = rects.length;\n      var i = 0;\n      helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);\n\n      for (; i < ilen; ++i) {\n        var val = scale._parseValue(dataset.data[i]);\n\n        if (!isNaN(val.min) && !isNaN(val.max)) {\n          rects[i].draw();\n        }\n      }\n\n      helpers$1.canvas.unclipArea(chart.ctx);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _resolveDataElementOptions: function () {\n      var me = this;\n      var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));\n\n      var indexOpts = me._getIndexScale().options;\n\n      var valueOpts = me._getValueScale().options;\n\n      values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);\n      values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);\n      values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);\n      values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);\n      values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);\n      return values;\n    }\n  });\n  var valueOrDefault$4 = helpers$1.valueOrDefault;\n  var resolve$1 = helpers$1.options.resolve;\n\n  core_defaults._set('bubble', {\n    hover: {\n      mode: 'single'\n    },\n    scales: {\n      xAxes: [{\n        type: 'linear',\n        // bubble should probably use a linear scale by default\n        position: 'bottom',\n        id: 'x-axis-0' // need an ID so datasets can reference the scale\n\n      }],\n      yAxes: [{\n        type: 'linear',\n        position: 'left',\n        id: 'y-axis-0'\n      }]\n    },\n    tooltips: {\n      callbacks: {\n        title: function () {\n          // Title doesn't make sense for scatter since we format the data as a point\n          return '';\n        },\n        label: function (item, data) {\n          var datasetLabel = data.datasets[item.datasetIndex].label || '';\n          var dataPoint = data.datasets[item.datasetIndex].data[item.index];\n          return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n        }\n      }\n    }\n  });\n\n  var controller_bubble = core_datasetController.extend({\n    /**\r\n     * @protected\r\n     */\n    dataElementType: elements.Point,\n\n    /**\r\n     * @private\r\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'],\n\n    /**\r\n     * @protected\r\n     */\n    update: function (reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var points = meta.data; // Update Points\n\n      helpers$1.each(points, function (point, index) {\n        me.updateElement(point, index, reset);\n      });\n    },\n\n    /**\r\n     * @protected\r\n     */\n    updateElement: function (point, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var custom = point.custom || {};\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var yScale = me.getScaleForId(meta.yAxisID);\n\n      var options = me._resolveDataElementOptions(point, index);\n\n      var data = me.getDataset().data[index];\n      var dsIndex = me.index;\n      var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n      var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n      point._xScale = xScale;\n      point._yScale = yScale;\n      point._options = options;\n      point._datasetIndex = dsIndex;\n      point._index = index;\n      point._model = {\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderWidth: options.borderWidth,\n        hitRadius: options.hitRadius,\n        pointStyle: options.pointStyle,\n        rotation: options.rotation,\n        radius: reset ? 0 : options.radius,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        x: x,\n        y: y\n      };\n      point.pivot();\n    },\n\n    /**\r\n     * @protected\r\n     */\n    setHoverStyle: function (point) {\n      var model = point._model;\n      var options = point._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      point.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth,\n        radius: model.radius\n      };\n      model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\n      model.radius = options.radius + options.hoverRadius;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _resolveDataElementOptions: function (point, index) {\n      var me = this;\n      var chart = me.chart;\n      var dataset = me.getDataset();\n      var custom = point.custom || {};\n      var data = dataset.data[index] || {};\n\n      var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments); // Scriptable options\n\n\n      var context = {\n        chart: chart,\n        dataIndex: index,\n        dataset: dataset,\n        datasetIndex: me.index\n      }; // In case values were cached (and thus frozen), we need to clone the values\n\n      if (me._cachedDataOpts === values) {\n        values = helpers$1.extend({}, values);\n      } // Custom radius resolution\n\n\n      values.radius = resolve$1([custom.radius, data.r, me._config.radius, chart.options.elements.point.radius], context, index);\n      return values;\n    }\n  });\n  var valueOrDefault$5 = helpers$1.valueOrDefault;\n  var PI$1 = Math.PI;\n  var DOUBLE_PI$1 = PI$1 * 2;\n  var HALF_PI$1 = PI$1 / 2;\n\n  core_defaults._set('doughnut', {\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    hover: {\n      mode: 'single'\n    },\n    legendCallback: function (chart) {\n      var list = document.createElement('ul');\n      var data = chart.data;\n      var datasets = data.datasets;\n      var labels = data.labels;\n      var i, ilen, listItem, listItemSpan;\n      list.setAttribute('class', chart.id + '-legend');\n\n      if (datasets.length) {\n        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {\n          listItem = list.appendChild(document.createElement('li'));\n          listItemSpan = listItem.appendChild(document.createElement('span'));\n          listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];\n\n          if (labels[i]) {\n            listItem.appendChild(document.createTextNode(labels[i]));\n          }\n        }\n      }\n\n      return list.outerHTML;\n    },\n    legend: {\n      labels: {\n        generateLabels: function (chart) {\n          var data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            return data.labels.map(function (label, i) {\n              var meta = chart.getDatasetMeta(0);\n              var style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\n                // Extra data used for toggling the correct item\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n      },\n      onClick: function (e, legendItem) {\n        var index = legendItem.index;\n        var chart = this.chart;\n        var i, ilen, meta;\n\n        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n          meta = chart.getDatasetMeta(i); // toggle visibility of index if exists\n\n          if (meta.data[index]) {\n            meta.data[index].hidden = !meta.data[index].hidden;\n          }\n        }\n\n        chart.update();\n      }\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutoutPercentage: 50,\n    // The rotation of the chart, where the first data arc begins.\n    rotation: -HALF_PI$1,\n    // The total circumference of the chart.\n    circumference: DOUBLE_PI$1,\n    // Need to override these to give a nice default\n    tooltips: {\n      callbacks: {\n        title: function () {\n          return '';\n        },\n        label: function (tooltipItem, data) {\n          var dataLabel = data.labels[tooltipItem.index];\n          var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n          if (helpers$1.isArray(dataLabel)) {\n            // show value on first line of multiline label\n            // need to clone because we are changing the value\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return dataLabel;\n        }\n      }\n    }\n  });\n\n  var controller_doughnut = core_datasetController.extend({\n    dataElementType: elements.Arc,\n    linkScales: helpers$1.noop,\n\n    /**\r\n     * @private\r\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'],\n    // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n    getRingIndex: function (datasetIndex) {\n      var ringIndex = 0;\n\n      for (var j = 0; j < datasetIndex; ++j) {\n        if (this.chart.isDatasetVisible(j)) {\n          ++ringIndex;\n        }\n      }\n\n      return ringIndex;\n    },\n    update: function (reset) {\n      var me = this;\n      var chart = me.chart;\n      var chartArea = chart.chartArea;\n      var opts = chart.options;\n      var ratioX = 1;\n      var ratioY = 1;\n      var offsetX = 0;\n      var offsetY = 0;\n      var meta = me.getMeta();\n      var arcs = meta.data;\n      var cutout = opts.cutoutPercentage / 100 || 0;\n      var circumference = opts.circumference;\n\n      var chartWeight = me._getRingWeight(me.index);\n\n      var maxWidth, maxHeight, i, ilen; // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n\n      if (circumference < DOUBLE_PI$1) {\n        var startAngle = opts.rotation % DOUBLE_PI$1;\n        startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;\n        var endAngle = startAngle + circumference;\n        var startX = Math.cos(startAngle);\n        var startY = Math.sin(startAngle);\n        var endX = Math.cos(endAngle);\n        var endY = Math.sin(endAngle);\n        var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;\n        var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;\n        var contains180 = startAngle === -PI$1 || endAngle >= PI$1;\n        var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;\n        var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);\n        var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);\n        var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);\n        var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n      }\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);\n      }\n\n      chart.borderWidth = me.getMaxBorderWidth();\n      maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;\n      maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;\n      chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n      chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);\n      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);\n      chart.offsetX = offsetX * chart.outerRadius;\n      chart.offsetY = offsetY * chart.outerRadius;\n      meta.total = me.calculateTotal();\n      me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);\n      me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        me.updateElement(arcs[i], i, reset);\n      }\n    },\n    updateElement: function (arc, index, reset) {\n      var me = this;\n      var chart = me.chart;\n      var chartArea = chart.chartArea;\n      var opts = chart.options;\n      var animationOpts = opts.animation;\n      var centerX = (chartArea.left + chartArea.right) / 2;\n      var centerY = (chartArea.top + chartArea.bottom) / 2;\n      var startAngle = opts.rotation; // non reset case handled later\n\n      var endAngle = opts.rotation; // non reset case handled later\n\n      var dataset = me.getDataset();\n      var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);\n      var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n      var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n      var options = arc._options || {};\n      helpers$1.extend(arc, {\n        // Utility\n        _datasetIndex: me.index,\n        _index: index,\n        // Desired view properties\n        _model: {\n          backgroundColor: options.backgroundColor,\n          borderColor: options.borderColor,\n          borderWidth: options.borderWidth,\n          borderAlign: options.borderAlign,\n          x: centerX + chart.offsetX,\n          y: centerY + chart.offsetY,\n          startAngle: startAngle,\n          endAngle: endAngle,\n          circumference: circumference,\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n        }\n      });\n      var model = arc._model; // Set correct angles if not resetting\n\n      if (!reset || !animationOpts.animateRotate) {\n        if (index === 0) {\n          model.startAngle = opts.rotation;\n        } else {\n          model.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n        }\n\n        model.endAngle = model.startAngle + model.circumference;\n      }\n\n      arc.pivot();\n    },\n    calculateTotal: function () {\n      var dataset = this.getDataset();\n      var meta = this.getMeta();\n      var total = 0;\n      var value;\n      helpers$1.each(meta.data, function (element, index) {\n        value = dataset.data[index];\n\n        if (!isNaN(value) && !element.hidden) {\n          total += Math.abs(value);\n        }\n      });\n      /* if (total === 0) {\r\n      \ttotal = NaN;\r\n      }*/\n\n      return total;\n    },\n    calculateCircumference: function (value) {\n      var total = this.getMeta().total;\n\n      if (total > 0 && !isNaN(value)) {\n        return DOUBLE_PI$1 * (Math.abs(value) / total);\n      }\n\n      return 0;\n    },\n    // gets the max border or hover width to properly scale pie charts\n    getMaxBorderWidth: function (arcs) {\n      var me = this;\n      var max = 0;\n      var chart = me.chart;\n      var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;\n\n      if (!arcs) {\n        // Find the outmost visible dataset\n        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n          if (chart.isDatasetVisible(i)) {\n            meta = chart.getDatasetMeta(i);\n            arcs = meta.data;\n\n            if (i !== me.index) {\n              controller = meta.controller;\n            }\n\n            break;\n          }\n        }\n      }\n\n      if (!arcs) {\n        return 0;\n      }\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        arc = arcs[i];\n\n        if (controller) {\n          controller._configure();\n\n          options = controller._resolveDataElementOptions(arc, i);\n        } else {\n          options = arc._options;\n        }\n\n        if (options.borderAlign !== 'inner') {\n          borderWidth = options.borderWidth;\n          hoverWidth = options.hoverBorderWidth;\n          max = borderWidth > max ? borderWidth : max;\n          max = hoverWidth > max ? hoverWidth : max;\n        }\n      }\n\n      return max;\n    },\n\n    /**\r\n     * @protected\r\n     */\n    setHoverStyle: function (arc) {\n      var model = arc._model;\n      var options = arc._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      arc.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth\n      };\n      model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);\n    },\n\n    /**\r\n     * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\r\n     * @private\r\n     */\n    _getRingWeightOffset: function (datasetIndex) {\n      var ringWeightOffset = 0;\n\n      for (var i = 0; i < datasetIndex; ++i) {\n        if (this.chart.isDatasetVisible(i)) {\n          ringWeightOffset += this._getRingWeight(i);\n        }\n      }\n\n      return ringWeightOffset;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getRingWeight: function (dataSetIndex) {\n      return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\n    },\n\n    /**\r\n     * Returns the sum of all visibile data set weights.  This value can be 0.\r\n     * @private\r\n     */\n    _getVisibleDatasetWeightTotal: function () {\n      return this._getRingWeightOffset(this.chart.data.datasets.length);\n    }\n  });\n\n  core_defaults._set('horizontalBar', {\n    hover: {\n      mode: 'index',\n      axis: 'y'\n    },\n    scales: {\n      xAxes: [{\n        type: 'linear',\n        position: 'bottom'\n      }],\n      yAxes: [{\n        type: 'category',\n        position: 'left',\n        offset: true,\n        gridLines: {\n          offsetGridLines: true\n        }\n      }]\n    },\n    elements: {\n      rectangle: {\n        borderSkipped: 'left'\n      }\n    },\n    tooltips: {\n      mode: 'index',\n      axis: 'y'\n    }\n  });\n\n  core_defaults._set('global', {\n    datasets: {\n      horizontalBar: {\n        categoryPercentage: 0.8,\n        barPercentage: 0.9\n      }\n    }\n  });\n\n  var controller_horizontalBar = controller_bar.extend({\n    /**\r\n     * @private\r\n     */\n    _getValueScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getIndexScaleId: function () {\n      return this.getMeta().yAxisID;\n    }\n  });\n  var valueOrDefault$6 = helpers$1.valueOrDefault;\n  var resolve$2 = helpers$1.options.resolve;\n  var isPointInArea = helpers$1.canvas._isPointInArea;\n\n  core_defaults._set('line', {\n    showLines: true,\n    spanGaps: false,\n    hover: {\n      mode: 'label'\n    },\n    scales: {\n      xAxes: [{\n        type: 'category',\n        id: 'x-axis-0'\n      }],\n      yAxes: [{\n        type: 'linear',\n        id: 'y-axis-0'\n      }]\n    }\n  });\n\n  function scaleClip(scale, halfBorderWidth) {\n    var tickOpts = scale && scale.options.ticks || {};\n    var reverse = tickOpts.reverse;\n    var min = tickOpts.min === undefined ? halfBorderWidth : 0;\n    var max = tickOpts.max === undefined ? halfBorderWidth : 0;\n    return {\n      start: reverse ? max : min,\n      end: reverse ? min : max\n    };\n  }\n\n  function defaultClip(xScale, yScale, borderWidth) {\n    var halfBorderWidth = borderWidth / 2;\n    var x = scaleClip(xScale, halfBorderWidth);\n    var y = scaleClip(yScale, halfBorderWidth);\n    return {\n      top: y.end,\n      right: x.end,\n      bottom: y.start,\n      left: x.start\n    };\n  }\n\n  function toClip(value) {\n    var t, r, b, l;\n\n    if (helpers$1.isObject(value)) {\n      t = value.top;\n      r = value.right;\n      b = value.bottom;\n      l = value.left;\n    } else {\n      t = r = b = l = value;\n    }\n\n    return {\n      top: t,\n      right: r,\n      bottom: b,\n      left: l\n    };\n  }\n\n  var controller_line = core_datasetController.extend({\n    datasetElementType: elements.Line,\n    dataElementType: elements.Point,\n\n    /**\r\n     * @private\r\n     */\n    _datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth', 'cubicInterpolationMode', 'fill'],\n\n    /**\r\n     * @private\r\n     */\n    _dataElementOptions: {\n      backgroundColor: 'pointBackgroundColor',\n      borderColor: 'pointBorderColor',\n      borderWidth: 'pointBorderWidth',\n      hitRadius: 'pointHitRadius',\n      hoverBackgroundColor: 'pointHoverBackgroundColor',\n      hoverBorderColor: 'pointHoverBorderColor',\n      hoverBorderWidth: 'pointHoverBorderWidth',\n      hoverRadius: 'pointHoverRadius',\n      pointStyle: 'pointStyle',\n      radius: 'pointRadius',\n      rotation: 'pointRotation'\n    },\n    update: function (reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var line = meta.dataset;\n      var points = meta.data || [];\n      var options = me.chart.options;\n      var config = me._config;\n      var showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);\n      var i, ilen;\n      me._xScale = me.getScaleForId(meta.xAxisID);\n      me._yScale = me.getScaleForId(meta.yAxisID); // Update Line\n\n      if (showLine) {\n        // Compatibility: If the properties are defined with only the old name, use those values\n        if (config.tension !== undefined && config.lineTension === undefined) {\n          config.lineTension = config.tension;\n        } // Utility\n\n\n        line._scale = me._yScale;\n        line._datasetIndex = me.index; // Data\n\n        line._children = points; // Model\n\n        line._model = me._resolveDatasetElementOptions(line);\n        line.pivot();\n      } // Update Points\n\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        me.updateElement(points[i], i, reset);\n      }\n\n      if (showLine && line._model.tension !== 0) {\n        me.updateBezierControlPoints();\n      } // Now pivot the point for animation\n\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        points[i].pivot();\n      }\n    },\n    updateElement: function (point, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var custom = point.custom || {};\n      var dataset = me.getDataset();\n      var datasetIndex = me.index;\n      var value = dataset.data[index];\n      var xScale = me._xScale;\n      var yScale = me._yScale;\n      var lineModel = meta.dataset._model;\n      var x, y;\n\n      var options = me._resolveDataElementOptions(point, index);\n\n      x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n      y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility\n\n      point._xScale = xScale;\n      point._yScale = yScale;\n      point._options = options;\n      point._datasetIndex = datasetIndex;\n      point._index = index; // Desired view properties\n\n      point._model = {\n        x: x,\n        y: y,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        // Appearance\n        radius: options.radius,\n        pointStyle: options.pointStyle,\n        rotation: options.rotation,\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderWidth: options.borderWidth,\n        tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),\n        steppedLine: lineModel ? lineModel.steppedLine : false,\n        // Tooltip\n        hitRadius: options.hitRadius\n      };\n    },\n\n    /**\r\n     * @private\r\n     */\n    _resolveDatasetElementOptions: function (element) {\n      var me = this;\n      var config = me._config;\n      var custom = element.custom || {};\n      var options = me.chart.options;\n      var lineOptions = options.elements.line;\n\n      var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments); // The default behavior of lines is to break at null values, according\n      // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n      // This option gives lines the ability to span gaps\n\n\n      values.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);\n      values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);\n      values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);\n      values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));\n      return values;\n    },\n    calculatePointY: function (value, index, datasetIndex) {\n      var me = this;\n      var chart = me.chart;\n      var yScale = me._yScale;\n      var sumPos = 0;\n      var sumNeg = 0;\n      var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;\n\n      if (yScale.options.stacked) {\n        rightValue = +yScale.getRightValue(value);\n        metasets = chart._getSortedVisibleDatasetMetas();\n        ilen = metasets.length;\n\n        for (i = 0; i < ilen; ++i) {\n          dsMeta = metasets[i];\n\n          if (dsMeta.index === datasetIndex) {\n            break;\n          }\n\n          ds = chart.data.datasets[dsMeta.index];\n\n          if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {\n            stackedRightValue = +yScale.getRightValue(ds.data[index]);\n\n            if (stackedRightValue < 0) {\n              sumNeg += stackedRightValue || 0;\n            } else {\n              sumPos += stackedRightValue || 0;\n            }\n          }\n        }\n\n        if (rightValue < 0) {\n          return yScale.getPixelForValue(sumNeg + rightValue);\n        }\n\n        return yScale.getPixelForValue(sumPos + rightValue);\n      }\n\n      return yScale.getPixelForValue(value);\n    },\n    updateBezierControlPoints: function () {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var lineModel = meta.dataset._model;\n      var area = chart.chartArea;\n      var points = meta.data || [];\n      var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used\n\n      if (lineModel.spanGaps) {\n        points = points.filter(function (pt) {\n          return !pt._model.skip;\n        });\n      }\n\n      function capControlPoint(pt, min, max) {\n        return Math.max(Math.min(pt, max), min);\n      }\n\n      if (lineModel.cubicInterpolationMode === 'monotone') {\n        helpers$1.splineCurveMonotone(points);\n      } else {\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\n          model = points[i]._model;\n          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);\n          model.controlPointPreviousX = controlPoints.previous.x;\n          model.controlPointPreviousY = controlPoints.previous.y;\n          model.controlPointNextX = controlPoints.next.x;\n          model.controlPointNextY = controlPoints.next.y;\n        }\n      }\n\n      if (chart.options.elements.line.capBezierPoints) {\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\n          model = points[i]._model;\n\n          if (isPointInArea(model, area)) {\n            if (i > 0 && isPointInArea(points[i - 1]._model, area)) {\n              model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n              model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n            }\n\n            if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\n              model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n              model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n            }\n          }\n        }\n      }\n    },\n    draw: function () {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var points = meta.data || [];\n      var area = chart.chartArea;\n      var canvas = chart.canvas;\n      var i = 0;\n      var ilen = points.length;\n      var clip;\n\n      if (me._showLine) {\n        clip = meta.dataset._model.clip;\n        helpers$1.canvas.clipArea(chart.ctx, {\n          left: clip.left === false ? 0 : area.left - clip.left,\n          right: clip.right === false ? canvas.width : area.right + clip.right,\n          top: clip.top === false ? 0 : area.top - clip.top,\n          bottom: clip.bottom === false ? canvas.height : area.bottom + clip.bottom\n        });\n        meta.dataset.draw();\n        helpers$1.canvas.unclipArea(chart.ctx);\n      } // Draw the points\n\n\n      for (; i < ilen; ++i) {\n        points[i].draw(area);\n      }\n    },\n\n    /**\r\n     * @protected\r\n     */\n    setHoverStyle: function (point) {\n      var model = point._model;\n      var options = point._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      point.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth,\n        radius: model.radius\n      };\n      model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\n      model.radius = valueOrDefault$6(options.hoverRadius, options.radius);\n    }\n  });\n  var resolve$3 = helpers$1.options.resolve;\n\n  core_defaults._set('polarArea', {\n    scale: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      gridLines: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      ticks: {\n        beginAtZero: true\n      }\n    },\n    // Boolean - Whether to animate the rotation of the chart\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    startAngle: -0.5 * Math.PI,\n    legendCallback: function (chart) {\n      var list = document.createElement('ul');\n      var data = chart.data;\n      var datasets = data.datasets;\n      var labels = data.labels;\n      var i, ilen, listItem, listItemSpan;\n      list.setAttribute('class', chart.id + '-legend');\n\n      if (datasets.length) {\n        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {\n          listItem = list.appendChild(document.createElement('li'));\n          listItemSpan = listItem.appendChild(document.createElement('span'));\n          listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];\n\n          if (labels[i]) {\n            listItem.appendChild(document.createTextNode(labels[i]));\n          }\n        }\n      }\n\n      return list.outerHTML;\n    },\n    legend: {\n      labels: {\n        generateLabels: function (chart) {\n          var data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            return data.labels.map(function (label, i) {\n              var meta = chart.getDatasetMeta(0);\n              var style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\n                // Extra data used for toggling the correct item\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n      },\n      onClick: function (e, legendItem) {\n        var index = legendItem.index;\n        var chart = this.chart;\n        var i, ilen, meta;\n\n        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n          meta = chart.getDatasetMeta(i);\n          meta.data[index].hidden = !meta.data[index].hidden;\n        }\n\n        chart.update();\n      }\n    },\n    // Need to override these to give a nice default\n    tooltips: {\n      callbacks: {\n        title: function () {\n          return '';\n        },\n        label: function (item, data) {\n          return data.labels[item.index] + ': ' + item.yLabel;\n        }\n      }\n    }\n  });\n\n  var controller_polarArea = core_datasetController.extend({\n    dataElementType: elements.Arc,\n    linkScales: helpers$1.noop,\n\n    /**\r\n     * @private\r\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'],\n\n    /**\r\n     * @private\r\n     */\n    _getIndexScaleId: function () {\n      return this.chart.scale.id;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getValueScaleId: function () {\n      return this.chart.scale.id;\n    },\n    update: function (reset) {\n      var me = this;\n      var dataset = me.getDataset();\n      var meta = me.getMeta();\n      var start = me.chart.options.startAngle || 0;\n      var starts = me._starts = [];\n      var angles = me._angles = [];\n      var arcs = meta.data;\n      var i, ilen, angle;\n\n      me._updateRadius();\n\n      meta.count = me.countVisibleElements();\n\n      for (i = 0, ilen = dataset.data.length; i < ilen; i++) {\n        starts[i] = start;\n        angle = me._computeAngle(i);\n        angles[i] = angle;\n        start += angle;\n      }\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);\n        me.updateElement(arcs[i], i, reset);\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    _updateRadius: function () {\n      var me = this;\n      var chart = me.chart;\n      var chartArea = chart.chartArea;\n      var opts = chart.options;\n      var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n      chart.outerRadius = Math.max(minSize / 2, 0);\n      chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n      me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;\n      me.innerRadius = me.outerRadius - chart.radiusLength;\n    },\n    updateElement: function (arc, index, reset) {\n      var me = this;\n      var chart = me.chart;\n      var dataset = me.getDataset();\n      var opts = chart.options;\n      var animationOpts = opts.animation;\n      var scale = chart.scale;\n      var labels = chart.data.labels;\n      var centerX = scale.xCenter;\n      var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;\n\n      var datasetStartAngle = opts.startAngle;\n      var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n      var startAngle = me._starts[index];\n      var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);\n      var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n      var options = arc._options || {};\n      helpers$1.extend(arc, {\n        // Utility\n        _datasetIndex: me.index,\n        _index: index,\n        _scale: scale,\n        // Desired view properties\n        _model: {\n          backgroundColor: options.backgroundColor,\n          borderColor: options.borderColor,\n          borderWidth: options.borderWidth,\n          borderAlign: options.borderAlign,\n          x: centerX,\n          y: centerY,\n          innerRadius: 0,\n          outerRadius: reset ? resetRadius : distance,\n          startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n          endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n          label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\n        }\n      });\n      arc.pivot();\n    },\n    countVisibleElements: function () {\n      var dataset = this.getDataset();\n      var meta = this.getMeta();\n      var count = 0;\n      helpers$1.each(meta.data, function (element, index) {\n        if (!isNaN(dataset.data[index]) && !element.hidden) {\n          count++;\n        }\n      });\n      return count;\n    },\n\n    /**\r\n     * @protected\r\n     */\n    setHoverStyle: function (arc) {\n      var model = arc._model;\n      var options = arc._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      var valueOrDefault = helpers$1.valueOrDefault;\n      arc.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth\n      };\n      model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _computeAngle: function (index) {\n      var me = this;\n      var count = this.getMeta().count;\n      var dataset = me.getDataset();\n      var meta = me.getMeta();\n\n      if (isNaN(dataset.data[index]) || meta.data[index].hidden) {\n        return 0;\n      } // Scriptable options\n\n\n      var context = {\n        chart: me.chart,\n        dataIndex: index,\n        dataset: dataset,\n        datasetIndex: me.index\n      };\n      return resolve$3([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);\n    }\n  });\n\n  core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));\n\n  core_defaults._set('pie', {\n    cutoutPercentage: 0\n  }); // Pie charts are Doughnut chart with different defaults\n\n\n  var controller_pie = controller_doughnut;\n  var valueOrDefault$7 = helpers$1.valueOrDefault;\n\n  core_defaults._set('radar', {\n    spanGaps: false,\n    scale: {\n      type: 'radialLinear'\n    },\n    elements: {\n      line: {\n        fill: 'start',\n        tension: 0 // no bezier in radar\n\n      }\n    }\n  });\n\n  var controller_radar = core_datasetController.extend({\n    datasetElementType: elements.Line,\n    dataElementType: elements.Point,\n    linkScales: helpers$1.noop,\n\n    /**\r\n     * @private\r\n     */\n    _datasetElementOptions: ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'],\n\n    /**\r\n     * @private\r\n     */\n    _dataElementOptions: {\n      backgroundColor: 'pointBackgroundColor',\n      borderColor: 'pointBorderColor',\n      borderWidth: 'pointBorderWidth',\n      hitRadius: 'pointHitRadius',\n      hoverBackgroundColor: 'pointHoverBackgroundColor',\n      hoverBorderColor: 'pointHoverBorderColor',\n      hoverBorderWidth: 'pointHoverBorderWidth',\n      hoverRadius: 'pointHoverRadius',\n      pointStyle: 'pointStyle',\n      radius: 'pointRadius',\n      rotation: 'pointRotation'\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getIndexScaleId: function () {\n      return this.chart.scale.id;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getValueScaleId: function () {\n      return this.chart.scale.id;\n    },\n    update: function (reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var line = meta.dataset;\n      var points = meta.data || [];\n      var scale = me.chart.scale;\n      var config = me._config;\n      var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values\n\n      if (config.tension !== undefined && config.lineTension === undefined) {\n        config.lineTension = config.tension;\n      } // Utility\n\n\n      line._scale = scale;\n      line._datasetIndex = me.index; // Data\n\n      line._children = points;\n      line._loop = true; // Model\n\n      line._model = me._resolveDatasetElementOptions(line);\n      line.pivot(); // Update Points\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        me.updateElement(points[i], i, reset);\n      } // Update bezier control points\n\n\n      me.updateBezierControlPoints(); // Now pivot the point for animation\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        points[i].pivot();\n      }\n    },\n    updateElement: function (point, index, reset) {\n      var me = this;\n      var custom = point.custom || {};\n      var dataset = me.getDataset();\n      var scale = me.chart.scale;\n      var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n      var options = me._resolveDataElementOptions(point, index);\n\n      var lineModel = me.getMeta().dataset._model;\n\n      var x = reset ? scale.xCenter : pointPosition.x;\n      var y = reset ? scale.yCenter : pointPosition.y; // Utility\n\n      point._scale = scale;\n      point._options = options;\n      point._datasetIndex = me.index;\n      point._index = index; // Desired view properties\n\n      point._model = {\n        x: x,\n        // value not used in dataset scale, but we want a consistent API between scales\n        y: y,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        // Appearance\n        radius: options.radius,\n        pointStyle: options.pointStyle,\n        rotation: options.rotation,\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderWidth: options.borderWidth,\n        tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),\n        // Tooltip\n        hitRadius: options.hitRadius\n      };\n    },\n\n    /**\r\n     * @private\r\n     */\n    _resolveDatasetElementOptions: function () {\n      var me = this;\n      var config = me._config;\n      var options = me.chart.options;\n\n      var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);\n\n      values.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);\n      values.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);\n      return values;\n    },\n    updateBezierControlPoints: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var area = me.chart.chartArea;\n      var points = meta.data || [];\n      var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used\n\n      if (meta.dataset._model.spanGaps) {\n        points = points.filter(function (pt) {\n          return !pt._model.skip;\n        });\n      }\n\n      function capControlPoint(pt, min, max) {\n        return Math.max(Math.min(pt, max), min);\n      }\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        model = points[i]._model;\n        controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph\n\n        model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\n        model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\n        model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\n        model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\n      }\n    },\n    setHoverStyle: function (point) {\n      var model = point._model;\n      var options = point._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      point.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth,\n        radius: model.radius\n      };\n      model.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);\n      model.radius = valueOrDefault$7(options.hoverRadius, options.radius);\n    }\n  });\n\n  core_defaults._set('scatter', {\n    hover: {\n      mode: 'single'\n    },\n    scales: {\n      xAxes: [{\n        id: 'x-axis-1',\n        // need an ID so datasets can reference the scale\n        type: 'linear',\n        // scatter should not use a category axis\n        position: 'bottom'\n      }],\n      yAxes: [{\n        id: 'y-axis-1',\n        type: 'linear',\n        position: 'left'\n      }]\n    },\n    tooltips: {\n      callbacks: {\n        title: function () {\n          return ''; // doesn't make sense for scatter since data are formatted as a point\n        },\n        label: function (item) {\n          return '(' + item.xLabel + ', ' + item.yLabel + ')';\n        }\n      }\n    }\n  });\n\n  core_defaults._set('global', {\n    datasets: {\n      scatter: {\n        showLine: false\n      }\n    }\n  }); // Scatter charts use line controllers\n\n\n  var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not\n  // the class, and so must be CamelCase in order to be correctly retrieved\n  // by the controller in core.controller.js (`controllers[meta.type]`).\n\n  var controllers = {\n    bar: controller_bar,\n    bubble: controller_bubble,\n    doughnut: controller_doughnut,\n    horizontalBar: controller_horizontalBar,\n    line: controller_line,\n    polarArea: controller_polarArea,\n    pie: controller_pie,\n    radar: controller_radar,\n    scatter: controller_scatter\n  };\n  /**\r\n   * Helper function to get relative position for an event\r\n   * @param {Event|IEvent} event - The event to get the position for\r\n   * @param {Chart} chart - The chart\r\n   * @returns {object} the event position\r\n   */\n\n  function getRelativePosition(e, chart) {\n    if (e.native) {\n      return {\n        x: e.x,\n        y: e.y\n      };\n    }\n\n    return helpers$1.getRelativePosition(e, chart);\n  }\n  /**\r\n   * Helper function to traverse all of the visible elements in the chart\r\n   * @param {Chart} chart - the chart\r\n   * @param {function} handler - the callback to execute for each visible item\r\n   */\n\n\n  function parseVisibleItems(chart, handler) {\n    var metasets = chart._getSortedVisibleDatasetMetas();\n\n    var metadata, i, j, ilen, jlen, element;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      metadata = metasets[i].data;\n\n      for (j = 0, jlen = metadata.length; j < jlen; ++j) {\n        element = metadata[j];\n\n        if (!element._view.skip) {\n          handler(element);\n        }\n      }\n    }\n  }\n  /**\r\n   * Helper function to get the items that intersect the event position\r\n   * @param {ChartElement[]} items - elements to filter\r\n   * @param {object} position - the point to be nearest to\r\n   * @return {ChartElement[]} the nearest items\r\n   */\n\n\n  function getIntersectItems(chart, position) {\n    var elements = [];\n    parseVisibleItems(chart, function (element) {\n      if (element.inRange(position.x, position.y)) {\n        elements.push(element);\n      }\n    });\n    return elements;\n  }\n  /**\r\n   * Helper function to get the items nearest to the event position considering all visible items in teh chart\r\n   * @param {Chart} chart - the chart to look at elements from\r\n   * @param {object} position - the point to be nearest to\r\n   * @param {boolean} intersect - if true, only consider items that intersect the position\r\n   * @param {function} distanceMetric - function to provide the distance between points\r\n   * @return {ChartElement[]} the nearest items\r\n   */\n\n\n  function getNearestItems(chart, position, intersect, distanceMetric) {\n    var minDistance = Number.POSITIVE_INFINITY;\n    var nearestItems = [];\n    parseVisibleItems(chart, function (element) {\n      if (intersect && !element.inRange(position.x, position.y)) {\n        return;\n      }\n\n      var center = element.getCenterPoint();\n      var distance = distanceMetric(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n    });\n    return nearestItems;\n  }\n  /**\r\n   * Get a distance metric function for two points based on the\r\n   * axis mode setting\r\n   * @param {string} axis - the axis mode. x|y|xy\r\n   */\n\n\n  function getDistanceMetricForAxis(axis) {\n    var useX = axis.indexOf('x') !== -1;\n    var useY = axis.indexOf('y') !== -1;\n    return function (pt1, pt2) {\n      var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n      var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n  }\n\n  function indexMode(chart, e, options) {\n    var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour\n\n    options.axis = options.axis || 'x';\n    var distanceMetric = getDistanceMetricForAxis(options.axis);\n    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n    var elements = [];\n\n    if (!items.length) {\n      return [];\n    }\n\n    chart._getSortedVisibleDatasetMetas().forEach(function (meta) {\n      var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)\n\n      if (element && !element._view.skip) {\n        elements.push(element);\n      }\n    });\n\n    return elements;\n  }\n  /**\r\n   * @interface IInteractionOptions\r\n   */\n\n  /**\r\n   * If true, only consider items that intersect the point\r\n   * @name IInterfaceOptions#boolean\r\n   * @type Boolean\r\n   */\n\n  /**\r\n   * Contains interaction related functions\r\n   * @namespace Chart.Interaction\r\n   */\n\n\n  var core_interaction = {\n    // Helper function for different modes\n    modes: {\n      single: function (chart, e) {\n        var position = getRelativePosition(e, chart);\n        var elements = [];\n        parseVisibleItems(chart, function (element) {\n          if (element.inRange(position.x, position.y)) {\n            elements.push(element);\n            return elements;\n          }\n        });\n        return elements.slice(0, 1);\n      },\n\n      /**\r\n       * @function Chart.Interaction.modes.label\r\n       * @deprecated since version 2.4.0\r\n       * @todo remove at version 3\r\n       * @private\r\n       */\n      label: indexMode,\n\n      /**\r\n       * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\r\n       * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\r\n       * @function Chart.Interaction.modes.index\r\n       * @since v2.4.0\r\n       * @param {Chart} chart - the chart we are returning items from\r\n       * @param {Event} e - the event we are find things at\r\n       * @param {IInteractionOptions} options - options to use during interaction\r\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n       */\n      index: indexMode,\n\n      /**\r\n       * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n       * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n       * @function Chart.Interaction.modes.dataset\r\n       * @param {Chart} chart - the chart we are returning items from\r\n       * @param {Event} e - the event we are find things at\r\n       * @param {IInteractionOptions} options - options to use during interaction\r\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n       */\n      dataset: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        options.axis = options.axis || 'xy';\n        var distanceMetric = getDistanceMetricForAxis(options.axis);\n        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n        if (items.length > 0) {\n          items = chart.getDatasetMeta(items[0]._datasetIndex).data;\n        }\n\n        return items;\n      },\n\n      /**\r\n       * @function Chart.Interaction.modes.x-axis\r\n       * @deprecated since version 2.4.0. Use index mode and intersect == true\r\n       * @todo remove at version 3\r\n       * @private\r\n       */\n      'x-axis': function (chart, e) {\n        return indexMode(chart, e, {\n          intersect: false\n        });\n      },\n\n      /**\r\n       * Point mode returns all elements that hit test based on the event position\r\n       * of the event\r\n       * @function Chart.Interaction.modes.intersect\r\n       * @param {Chart} chart - the chart we are returning items from\r\n       * @param {Event} e - the event we are find things at\r\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n       */\n      point: function (chart, e) {\n        var position = getRelativePosition(e, chart);\n        return getIntersectItems(chart, position);\n      },\n\n      /**\r\n       * nearest mode returns the element closest to the point\r\n       * @function Chart.Interaction.modes.intersect\r\n       * @param {Chart} chart - the chart we are returning items from\r\n       * @param {Event} e - the event we are find things at\r\n       * @param {IInteractionOptions} options - options to use\r\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n       */\n      nearest: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        options.axis = options.axis || 'xy';\n        var distanceMetric = getDistanceMetricForAxis(options.axis);\n        return getNearestItems(chart, position, options.intersect, distanceMetric);\n      },\n\n      /**\r\n       * x mode returns the elements that hit-test at the current x coordinate\r\n       * @function Chart.Interaction.modes.x\r\n       * @param {Chart} chart - the chart we are returning items from\r\n       * @param {Event} e - the event we are find things at\r\n       * @param {IInteractionOptions} options - options to use\r\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n       */\n      x: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        var items = [];\n        var intersectsItem = false;\n        parseVisibleItems(chart, function (element) {\n          if (element.inXRange(position.x)) {\n            items.push(element);\n          }\n\n          if (element.inRange(position.x, position.y)) {\n            intersectsItem = true;\n          }\n        }); // If we want to trigger on an intersect and we don't have any items\n        // that intersect the position, return nothing\n\n        if (options.intersect && !intersectsItem) {\n          items = [];\n        }\n\n        return items;\n      },\n\n      /**\r\n       * y mode returns the elements that hit-test at the current y coordinate\r\n       * @function Chart.Interaction.modes.y\r\n       * @param {Chart} chart - the chart we are returning items from\r\n       * @param {Event} e - the event we are find things at\r\n       * @param {IInteractionOptions} options - options to use\r\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n       */\n      y: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        var items = [];\n        var intersectsItem = false;\n        parseVisibleItems(chart, function (element) {\n          if (element.inYRange(position.y)) {\n            items.push(element);\n          }\n\n          if (element.inRange(position.x, position.y)) {\n            intersectsItem = true;\n          }\n        }); // If we want to trigger on an intersect and we don't have any items\n        // that intersect the position, return nothing\n\n        if (options.intersect && !intersectsItem) {\n          items = [];\n        }\n\n        return items;\n      }\n    }\n  };\n  var extend = helpers$1.extend;\n\n  function filterByPosition(array, position) {\n    return helpers$1.where(array, function (v) {\n      return v.pos === position;\n    });\n  }\n\n  function sortByWeight(array, reverse) {\n    return array.sort(function (a, b) {\n      var v0 = reverse ? b : a;\n      var v1 = reverse ? a : b;\n      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n  }\n\n  function wrapBoxes(boxes) {\n    var layoutBoxes = [];\n    var i, ilen, box;\n\n    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n      box = boxes[i];\n      layoutBoxes.push({\n        index: i,\n        box: box,\n        pos: box.position,\n        horizontal: box.isHorizontal(),\n        weight: box.weight\n      });\n    }\n\n    return layoutBoxes;\n  }\n\n  function setLayoutDims(layouts, params) {\n    var i, ilen, layout;\n\n    for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n      layout = layouts[i]; // store width used instead of chartArea.w in fitBoxes\n\n      layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth; // store height used instead of chartArea.h in fitBoxes\n\n      layout.height = layout.horizontal && params.hBoxMaxHeight;\n    }\n  }\n\n  function buildLayoutBoxes(boxes) {\n    var layoutBoxes = wrapBoxes(boxes);\n    var left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    var right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    var top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    var bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    return {\n      leftAndTop: left.concat(top),\n      rightAndBottom: right.concat(bottom),\n      chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n      vertical: left.concat(right),\n      horizontal: top.concat(bottom)\n    };\n  }\n\n  function getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n  }\n\n  function updateDims(chartArea, params, layout) {\n    var box = layout.box;\n    var maxPadding = chartArea.maxPadding;\n    var newWidth, newHeight;\n\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[layout.pos] -= layout.size;\n    }\n\n    layout.size = layout.horizontal ? box.height : box.width;\n    chartArea[layout.pos] += layout.size;\n\n    if (box.getPadding) {\n      var boxPadding = box.getPadding();\n      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n    }\n\n    newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right');\n    newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');\n\n    if (newWidth !== chartArea.w || newHeight !== chartArea.h) {\n      chartArea.w = newWidth;\n      chartArea.h = newHeight; // return true if chart area changed in layout's direction\n\n      var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];\n      return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));\n    }\n  }\n\n  function handleMaxPadding(chartArea) {\n    var maxPadding = chartArea.maxPadding;\n\n    function updatePos(pos) {\n      var change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n      chartArea[pos] += change;\n      return change;\n    }\n\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n  }\n\n  function getMargins(horizontal, chartArea) {\n    var maxPadding = chartArea.maxPadding;\n\n    function marginForPositions(positions) {\n      var margin = {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      };\n      positions.forEach(function (pos) {\n        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n      });\n      return margin;\n    }\n\n    return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);\n  }\n\n  function fitBoxes(boxes, chartArea, params) {\n    var refitBoxes = [];\n    var i, ilen, layout, box, refit, changed;\n\n    for (i = 0, ilen = boxes.length; i < ilen; ++i) {\n      layout = boxes[i];\n      box = layout.box;\n      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n\n      if (updateDims(chartArea, params, layout)) {\n        changed = true;\n\n        if (refitBoxes.length) {\n          // Dimensions changed and there were non full width boxes before this\n          // -> we have to refit those\n          refit = true;\n        }\n      }\n\n      if (!box.fullWidth) {\n        // fullWidth boxes don't need to be re-fitted in any case\n        refitBoxes.push(layout);\n      }\n    }\n\n    return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;\n  }\n\n  function placeBoxes(boxes, chartArea, params) {\n    var userPadding = params.padding;\n    var x = chartArea.x;\n    var y = chartArea.y;\n    var i, ilen, layout, box;\n\n    for (i = 0, ilen = boxes.length; i < ilen; ++i) {\n      layout = boxes[i];\n      box = layout.box;\n\n      if (layout.horizontal) {\n        box.left = box.fullWidth ? userPadding.left : chartArea.left;\n        box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;\n        box.top = y;\n        box.bottom = y + box.height;\n        box.width = box.right - box.left;\n        y = box.bottom;\n      } else {\n        box.left = x;\n        box.right = x + box.width;\n        box.top = chartArea.top;\n        box.bottom = chartArea.top + chartArea.h;\n        box.height = box.bottom - box.top;\n        x = box.right;\n      }\n    }\n\n    chartArea.x = x;\n    chartArea.y = y;\n  }\n\n  core_defaults._set('global', {\n    layout: {\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      }\n    }\n  });\n  /**\r\n   * @interface ILayoutItem\r\n   * @prop {string} position - The position of the item in the chart layout. Possible values are\r\n   * 'left', 'top', 'right', 'bottom', and 'chartArea'\r\n   * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\r\n   * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\r\n   * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\r\n   * @prop {function} update - Takes two parameters: width and height. Returns size of item\r\n   * @prop {function} getPadding -  Returns an object with padding on the edges\r\n   * @prop {number} width - Width of item. Must be valid after update()\r\n   * @prop {number} height - Height of item. Must be valid after update()\r\n   * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\r\n   * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\r\n   * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\r\n   * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\r\n   */\n  // The layout service is very self explanatory.  It's responsible for the layout within a chart.\n  // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n  // It is this service's responsibility of carrying out that layout.\n\n\n  var core_layouts = {\n    defaults: {},\n\n    /**\r\n     * Register a box to a chart.\r\n     * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\r\n     * @param {Chart} chart - the chart to use\r\n     * @param {ILayoutItem} item - the item to add to be layed out\r\n     */\n    addBox: function (chart, item) {\n      if (!chart.boxes) {\n        chart.boxes = [];\n      } // initialize item with default values\n\n\n      item.fullWidth = item.fullWidth || false;\n      item.position = item.position || 'top';\n      item.weight = item.weight || 0;\n\n      item._layers = item._layers || function () {\n        return [{\n          z: 0,\n          draw: function () {\n            item.draw.apply(item, arguments);\n          }\n        }];\n      };\n\n      chart.boxes.push(item);\n    },\n\n    /**\r\n     * Remove a layoutItem from a chart\r\n     * @param {Chart} chart - the chart to remove the box from\r\n     * @param {ILayoutItem} layoutItem - the item to remove from the layout\r\n     */\n    removeBox: function (chart, layoutItem) {\n      var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\n      if (index !== -1) {\n        chart.boxes.splice(index, 1);\n      }\n    },\n\n    /**\r\n     * Sets (or updates) options on the given `item`.\r\n     * @param {Chart} chart - the chart in which the item lives (or will be added to)\r\n     * @param {ILayoutItem} item - the item to configure with the given options\r\n     * @param {object} options - the new item options.\r\n     */\n    configure: function (chart, item, options) {\n      var props = ['fullWidth', 'position', 'weight'];\n      var ilen = props.length;\n      var i = 0;\n      var prop;\n\n      for (; i < ilen; ++i) {\n        prop = props[i];\n\n        if (options.hasOwnProperty(prop)) {\n          item[prop] = options[prop];\n        }\n      }\n    },\n\n    /**\r\n     * Fits boxes of the given chart into the given size by having each box measure itself\r\n     * then running a fitting algorithm\r\n     * @param {Chart} chart - the chart\r\n     * @param {number} width - the width to fit into\r\n     * @param {number} height - the height to fit into\r\n     */\n    update: function (chart, width, height) {\n      if (!chart) {\n        return;\n      }\n\n      var layoutOptions = chart.options.layout || {};\n      var padding = helpers$1.options.toPadding(layoutOptions.padding);\n      var availableWidth = width - padding.width;\n      var availableHeight = height - padding.height;\n      var boxes = buildLayoutBoxes(chart.boxes);\n      var verticalBoxes = boxes.vertical;\n      var horizontalBoxes = boxes.horizontal; // Essentially we now have any number of boxes on each of the 4 sides.\n      // Our canvas looks like the following.\n      // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n      // B1 is the bottom axis\n      // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n      // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n      // an error will be thrown.\n      //\n      // |----------------------------------------------------|\n      // |                  T1 (Full Width)                   |\n      // |----------------------------------------------------|\n      // |    |    |                 T2                  |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    | C1 |                           | C2 |    |\n      // |    |    |----|                           |----|    |\n      // |    |    |                                     |    |\n      // | L1 | L2 |           ChartArea (C0)            | R1 |\n      // |    |    |                                     |    |\n      // |    |    |----|                           |----|    |\n      // |    |    | C3 |                           | C4 |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    |                 B1                  |    |\n      // |----------------------------------------------------|\n      // |                  B2 (Full Width)                   |\n      // |----------------------------------------------------|\n      //\n\n      var params = Object.freeze({\n        outerWidth: width,\n        outerHeight: height,\n        padding: padding,\n        availableWidth: availableWidth,\n        vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,\n        hBoxMaxHeight: availableHeight / 2\n      });\n      var chartArea = extend({\n        maxPadding: extend({}, padding),\n        w: availableWidth,\n        h: availableHeight,\n        x: padding.left,\n        y: padding.top\n      }, padding);\n      setLayoutDims(verticalBoxes.concat(horizontalBoxes), params); // First fit vertical boxes\n\n      fitBoxes(verticalBoxes, chartArea, params); // Then fit horizontal boxes\n\n      if (fitBoxes(horizontalBoxes, chartArea, params)) {\n        // if the area changed, re-fit vertical boxes\n        fitBoxes(verticalBoxes, chartArea, params);\n      }\n\n      handleMaxPadding(chartArea); // Finally place the boxes to correct coordinates\n\n      placeBoxes(boxes.leftAndTop, chartArea, params); // Move to opposite side of chart\n\n      chartArea.x += chartArea.w;\n      chartArea.y += chartArea.h;\n      placeBoxes(boxes.rightAndBottom, chartArea, params);\n      chart.chartArea = {\n        left: chartArea.left,\n        top: chartArea.top,\n        right: chartArea.left + chartArea.w,\n        bottom: chartArea.top + chartArea.h\n      }; // Finally update boxes in chartArea (radial scale for example)\n\n      helpers$1.each(boxes.chartArea, function (layout) {\n        var box = layout.box;\n        extend(box, chart.chartArea);\n        box.update(chartArea.w, chartArea.h);\n      });\n    }\n  };\n  /**\r\n   * Platform fallback implementation (minimal).\r\n   * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\r\n   */\n\n  var platform_basic = {\n    acquireContext: function (item) {\n      if (item && item.canvas) {\n        // Support for any object associated to a canvas (including a context2d)\n        item = item.canvas;\n      }\n\n      return item && item.getContext('2d') || null;\n    }\n  };\n  var platform_dom = \"/*\\r\\n * DOM element rendering detection\\r\\n * https://davidwalsh.name/detect-node-insertion\\r\\n */\\r\\n@keyframes chartjs-render-animation {\\r\\n\\tfrom { opacity: 0.99; }\\r\\n\\tto { opacity: 1; }\\r\\n}\\r\\n\\r\\n.chartjs-render-monitor {\\r\\n\\tanimation: chartjs-render-animation 0.001s;\\r\\n}\\r\\n\\r\\n/*\\r\\n * DOM element resizing detection\\r\\n * https://github.com/marcj/css-element-queries\\r\\n */\\r\\n.chartjs-size-monitor,\\r\\n.chartjs-size-monitor-expand,\\r\\n.chartjs-size-monitor-shrink {\\r\\n\\tposition: absolute;\\r\\n\\tdirection: ltr;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tbottom: 0;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\tvisibility: hidden;\\r\\n\\tz-index: -1;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-expand > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 1000000px;\\r\\n\\theight: 1000000px;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-shrink > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 200%;\\r\\n\\theight: 200%;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\";\n  var platform_dom$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': platform_dom\n  });\n  var stylesheet = getCjsExportFromNamespace(platform_dom$1);\n  var EXPANDO_KEY = '$chartjs';\n  var CSS_PREFIX = 'chartjs-';\n  var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';\n  var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\n  var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\n  var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n  /**\r\n   * DOM event types -> Chart.js event types.\r\n   * Note: only events with different types are mapped.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/Events\r\n   */\n\n  var EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n  };\n  /**\r\n   * The \"used\" size is the final value of a dimension property after all calculations have\r\n   * been performed. This method uses the computed style of `element` but returns undefined\r\n   * if the computed style is not expressed in pixels. That can happen in some cases where\r\n   * `element` has a size relative to its parent and this last one is not yet displayed,\r\n   * for example because of `display: none` on a parent node.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n   * @returns {number} Size in pixels or undefined if unknown.\r\n   */\n\n  function readUsedSize(element, property) {\n    var value = helpers$1.getStyle(element, property);\n    var matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? Number(matches[1]) : undefined;\n  }\n  /**\r\n   * Initializes the canvas style and render size without modifying the canvas display size,\r\n   * since responsiveness is handled by the controller.resize() method. The config is used\r\n   * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n   */\n\n\n  function initCanvas(canvas, config) {\n    var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n    // returns null or '' if no explicit value has been set to the canvas attribute.\n\n    var renderHeight = canvas.getAttribute('height');\n    var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy\n\n    canvas[EXPANDO_KEY] = {\n      initial: {\n        height: renderHeight,\n        width: renderWidth,\n        style: {\n          display: style.display,\n          height: style.height,\n          width: style.width\n        }\n      }\n    }; // Force canvas to display as block to avoid extra space caused by inline\n    // elements, which would interfere with the responsive resize process.\n    // https://github.com/chartjs/Chart.js/issues/2538\n\n    style.display = style.display || 'block';\n\n    if (renderWidth === null || renderWidth === '') {\n      var displayWidth = readUsedSize(canvas, 'width');\n\n      if (displayWidth !== undefined) {\n        canvas.width = displayWidth;\n      }\n    }\n\n    if (renderHeight === null || renderHeight === '') {\n      if (canvas.style.height === '') {\n        // If no explicit render height and style height, let's apply the aspect ratio,\n        // which one can be specified by the user but also by charts as default option\n        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n        canvas.height = canvas.width / (config.options.aspectRatio || 2);\n      } else {\n        var displayHeight = readUsedSize(canvas, 'height');\n\n        if (displayWidth !== undefined) {\n          canvas.height = displayHeight;\n        }\n      }\n    }\n\n    return canvas;\n  }\n  /**\r\n   * Detects support for options object argument in addEventListener.\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n   * @private\r\n   */\n\n\n  var supportsEventListenerOptions = function () {\n    var supports = false;\n\n    try {\n      var options = Object.defineProperty({}, 'passive', {\n        // eslint-disable-next-line getter-return\n        get: function () {\n          supports = true;\n        }\n      });\n      window.addEventListener('e', null, options);\n    } catch (e) {// continue regardless of error\n    }\n\n    return supports;\n  }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n  // https://github.com/chartjs/Chart.js/issues/4287\n\n\n  var eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n  } : false;\n\n  function addListener(node, type, listener) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n\n  function removeListener(node, type, listener) {\n    node.removeEventListener(type, listener, eventListenerOptions);\n  }\n\n  function createEvent(type, chart, x, y, nativeEvent) {\n    return {\n      type: type,\n      chart: chart,\n      native: nativeEvent || null,\n      x: x !== undefined ? x : null,\n      y: y !== undefined ? y : null\n    };\n  }\n\n  function fromNativeEvent(event, chart) {\n    var type = EVENT_TYPES[event.type] || event.type;\n    var pos = helpers$1.getRelativePosition(event, chart);\n    return createEvent(type, chart, pos.x, pos.y, event);\n  }\n\n  function throttled(fn, thisArg) {\n    var ticking = false;\n    var args = [];\n    return function () {\n      args = Array.prototype.slice.call(arguments);\n      thisArg = thisArg || this;\n\n      if (!ticking) {\n        ticking = true;\n        helpers$1.requestAnimFrame.call(window, function () {\n          ticking = false;\n          fn.apply(thisArg, args);\n        });\n      }\n    };\n  }\n\n  function createDiv(cls) {\n    var el = document.createElement('div');\n    el.className = cls || '';\n    return el;\n  } // Implementation based on https://github.com/marcj/css-element-queries\n\n\n  function createResizer(handler) {\n    var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.\n    // https://github.com/chartjs/Chart.js/issues/5902\n\n    var resizer = createDiv(CSS_SIZE_MONITOR);\n    var expand = createDiv(CSS_SIZE_MONITOR + '-expand');\n    var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\n    expand.appendChild(createDiv());\n    shrink.appendChild(createDiv());\n    resizer.appendChild(expand);\n    resizer.appendChild(shrink);\n\n    resizer._reset = function () {\n      expand.scrollLeft = maxSize;\n      expand.scrollTop = maxSize;\n      shrink.scrollLeft = maxSize;\n      shrink.scrollTop = maxSize;\n    };\n\n    var onScroll = function () {\n      resizer._reset();\n\n      handler();\n    };\n\n    addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n    addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n    return resizer;\n  } // https://davidwalsh.name/detect-node-insertion\n\n\n  function watchForRender(node, handler) {\n    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n    var proxy = expando.renderProxy = function (e) {\n      if (e.animationName === CSS_RENDER_ANIMATION) {\n        handler();\n      }\n    };\n\n    helpers$1.each(ANIMATION_START_EVENTS, function (type) {\n      addListener(node, type, proxy);\n    }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n    // is removed then added back immediately (same animation frame?). Accessing the\n    // `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n    // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n    // https://github.com/chartjs/Chart.js/issues/4737\n\n    expando.reflow = !!node.offsetParent;\n    node.classList.add(CSS_RENDER_MONITOR);\n  }\n\n  function unwatchForRender(node) {\n    var expando = node[EXPANDO_KEY] || {};\n    var proxy = expando.renderProxy;\n\n    if (proxy) {\n      helpers$1.each(ANIMATION_START_EVENTS, function (type) {\n        removeListener(node, type, proxy);\n      });\n      delete expando.renderProxy;\n    }\n\n    node.classList.remove(CSS_RENDER_MONITOR);\n  }\n\n  function addResizeListener(node, listener, chart) {\n    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\n    var resizer = expando.resizer = createResizer(throttled(function () {\n      if (expando.resizer) {\n        var container = chart.options.maintainAspectRatio && node.parentNode;\n        var w = container ? container.clientWidth : 0;\n        listener(createEvent('resize', chart));\n\n        if (container && container.clientWidth < w && chart.canvas) {\n          // If the container size shrank during chart resize, let's assume\n          // scrollbar appeared. So we resize again with the scrollbar visible -\n          // effectively making chart smaller and the scrollbar hidden again.\n          // Because we are inside `throttled`, and currently `ticking`, scroll\n          // events are ignored during this whole 2 resize process.\n          // If we assumed wrong and something else happened, we are resizing\n          // twice in a frame (potential performance issue)\n          listener(createEvent('resize', chart));\n        }\n      }\n    })); // The resizer needs to be attached to the node parent, so we first need to be\n    // sure that `node` is attached to the DOM before injecting the resizer element.\n\n    watchForRender(node, function () {\n      if (expando.resizer) {\n        var container = node.parentNode;\n\n        if (container && container !== resizer.parentNode) {\n          container.insertBefore(resizer, container.firstChild);\n        } // The container size might have changed, let's reset the resizer state.\n\n\n        resizer._reset();\n      }\n    });\n  }\n\n  function removeResizeListener(node) {\n    var expando = node[EXPANDO_KEY] || {};\n    var resizer = expando.resizer;\n    delete expando.resizer;\n    unwatchForRender(node);\n\n    if (resizer && resizer.parentNode) {\n      resizer.parentNode.removeChild(resizer);\n    }\n  }\n  /**\r\n   * Injects CSS styles inline if the styles are not already present.\r\n   * @param {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.\r\n   * @param {string} css - the CSS to be injected.\r\n   */\n\n\n  function injectCSS(rootNode, css) {\n    // https://stackoverflow.com/q/3922139\n    var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});\n\n    if (!expando.containsStyles) {\n      expando.containsStyles = true;\n      css = '/* Chart.js */\\n' + css;\n      var style = document.createElement('style');\n      style.setAttribute('type', 'text/css');\n      style.appendChild(document.createTextNode(css));\n      rootNode.appendChild(style);\n    }\n  }\n\n  var platform_dom$2 = {\n    /**\r\n     * When `true`, prevents the automatic injection of the stylesheet required to\r\n     * correctly detect when the chart is added to the DOM and then resized. This\r\n     * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)\r\n     * to be manually imported to make this library compatible with any CSP.\r\n     * See https://github.com/chartjs/Chart.js/issues/5208\r\n     */\n    disableCSSInjection: false,\n\n    /**\r\n     * This property holds whether this platform is enabled for the current environment.\r\n     * Currently used by platform.js to select the proper implementation.\r\n     * @private\r\n     */\n    _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n    /**\r\n     * Initializes resources that depend on platform options.\r\n     * @param {HTMLCanvasElement} canvas - The Canvas element.\r\n     * @private\r\n     */\n    _ensureLoaded: function (canvas) {\n      if (!this.disableCSSInjection) {\n        // If the canvas is in a shadow DOM, then the styles must also be inserted\n        // into the same shadow DOM.\n        // https://github.com/chartjs/Chart.js/issues/5763\n        var root = canvas.getRootNode ? canvas.getRootNode() : document;\n        var targetNode = root.host ? root : document.head;\n        injectCSS(targetNode, stylesheet);\n      }\n    },\n    acquireContext: function (item, config) {\n      if (typeof item === 'string') {\n        item = document.getElementById(item);\n      } else if (item.length) {\n        // Support for array based queries (such as jQuery)\n        item = item[0];\n      }\n\n      if (item && item.canvas) {\n        // Support for any object associated to a canvas (including a context2d)\n        item = item.canvas;\n      } // To prevent canvas fingerprinting, some add-ons undefine the getContext\n      // method, for example: https://github.com/kkapsner/CanvasBlocker\n      // https://github.com/chartjs/Chart.js/issues/2807\n\n\n      var context = item && item.getContext && item.getContext('2d'); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n      // inside an iframe or when running in a protected environment. We could guess the\n      // types from their toString() value but let's keep things flexible and assume it's\n      // a sufficient condition if the item has a context2D which has item as `canvas`.\n      // https://github.com/chartjs/Chart.js/issues/3887\n      // https://github.com/chartjs/Chart.js/issues/4102\n      // https://github.com/chartjs/Chart.js/issues/4152\n\n      if (context && context.canvas === item) {\n        // Load platform resources on first chart creation, to make it possible to\n        // import the library before setting platform options.\n        this._ensureLoaded(item);\n\n        initCanvas(item, config);\n        return context;\n      }\n\n      return null;\n    },\n    releaseContext: function (context) {\n      var canvas = context.canvas;\n\n      if (!canvas[EXPANDO_KEY]) {\n        return;\n      }\n\n      var initial = canvas[EXPANDO_KEY].initial;\n      ['height', 'width'].forEach(function (prop) {\n        var value = initial[prop];\n\n        if (helpers$1.isNullOrUndef(value)) {\n          canvas.removeAttribute(prop);\n        } else {\n          canvas.setAttribute(prop, value);\n        }\n      });\n      helpers$1.each(initial.style || {}, function (value, key) {\n        canvas.style[key] = value;\n      }); // The canvas render size might have been changed (and thus the state stack discarded),\n      // we can't use save() and restore() to restore the initial state. So make sure that at\n      // least the canvas context is reset to the default state by setting the canvas width.\n      // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n      // eslint-disable-next-line no-self-assign\n\n      canvas.width = canvas.width;\n      delete canvas[EXPANDO_KEY];\n    },\n    addEventListener: function (chart, type, listener) {\n      var canvas = chart.canvas;\n\n      if (type === 'resize') {\n        // Note: the resize event is not supported on all browsers.\n        addResizeListener(canvas, listener, chart);\n        return;\n      }\n\n      var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n      var proxies = expando.proxies || (expando.proxies = {});\n\n      var proxy = proxies[chart.id + '_' + type] = function (event) {\n        listener(fromNativeEvent(event, chart));\n      };\n\n      addListener(canvas, type, proxy);\n    },\n    removeEventListener: function (chart, type, listener) {\n      var canvas = chart.canvas;\n\n      if (type === 'resize') {\n        // Note: the resize event is not supported on all browsers.\n        removeResizeListener(canvas);\n        return;\n      }\n\n      var expando = listener[EXPANDO_KEY] || {};\n      var proxies = expando.proxies || {};\n      var proxy = proxies[chart.id + '_' + type];\n\n      if (!proxy) {\n        return;\n      }\n\n      removeListener(canvas, type, proxy);\n    }\n  }; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use EventTarget.addEventListener instead.\r\n   * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\r\n   * @function Chart.helpers.addEvent\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers$1.addEvent = addListener;\n  /**\r\n   * Provided for backward compatibility, use EventTarget.removeEventListener instead.\r\n   * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\r\n   * @function Chart.helpers.removeEvent\r\n   * @deprecated since version 2.7.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.\n\n  var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\n  /**\r\n   * @namespace Chart.platform\r\n   * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\r\n   * @since 2.4.0\r\n   */\n\n  var platform = helpers$1.extend({\n    /**\r\n     * @since 2.7.0\r\n     */\n    initialize: function () {},\n\n    /**\r\n     * Called at chart construction time, returns a context2d instance implementing\r\n     * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\r\n     * @param {*} item - The native item from which to acquire context (platform specific)\r\n     * @param {object} options - The chart options\r\n     * @returns {CanvasRenderingContext2D} context2d instance\r\n     */\n    acquireContext: function () {},\n\n    /**\r\n     * Called at chart destruction time, releases any resources associated to the context\r\n     * previously returned by the acquireContext() method.\r\n     * @param {CanvasRenderingContext2D} context - The context2d instance\r\n     * @returns {boolean} true if the method succeeded, else false\r\n     */\n    releaseContext: function () {},\n\n    /**\r\n     * Registers the specified listener on the given chart.\r\n     * @param {Chart} chart - Chart from which to listen for event\r\n     * @param {string} type - The ({@link IEvent}) type to listen for\r\n     * @param {function} listener - Receives a notification (an object that implements\r\n     * the {@link IEvent} interface) when an event of the specified type occurs.\r\n     */\n    addEventListener: function () {},\n\n    /**\r\n     * Removes the specified listener previously registered with addEventListener.\r\n     * @param {Chart} chart - Chart from which to remove the listener\r\n     * @param {string} type - The ({@link IEvent}) type to remove\r\n     * @param {function} listener - The listener function to remove from the event target.\r\n     */\n    removeEventListener: function () {}\n  }, implementation);\n\n  core_defaults._set('global', {\n    plugins: {}\n  });\n  /**\r\n   * The plugin service singleton\r\n   * @namespace Chart.plugins\r\n   * @since 2.1.0\r\n   */\n\n\n  var core_plugins = {\n    /**\r\n     * Globally registered plugins.\r\n     * @private\r\n     */\n    _plugins: [],\n\n    /**\r\n     * This identifier is used to invalidate the descriptors cache attached to each chart\r\n     * when a global plugin is registered or unregistered. In this case, the cache ID is\r\n     * incremented and descriptors are regenerated during following API calls.\r\n     * @private\r\n     */\n    _cacheId: 0,\n\n    /**\r\n     * Registers the given plugin(s) if not already registered.\r\n     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\r\n     */\n    register: function (plugins) {\n      var p = this._plugins;\n      [].concat(plugins).forEach(function (plugin) {\n        if (p.indexOf(plugin) === -1) {\n          p.push(plugin);\n        }\n      });\n      this._cacheId++;\n    },\n\n    /**\r\n     * Unregisters the given plugin(s) only if registered.\r\n     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\r\n     */\n    unregister: function (plugins) {\n      var p = this._plugins;\n      [].concat(plugins).forEach(function (plugin) {\n        var idx = p.indexOf(plugin);\n\n        if (idx !== -1) {\n          p.splice(idx, 1);\n        }\n      });\n      this._cacheId++;\n    },\n\n    /**\r\n     * Remove all registered plugins.\r\n     * @since 2.1.5\r\n     */\n    clear: function () {\n      this._plugins = [];\n      this._cacheId++;\n    },\n\n    /**\r\n     * Returns the number of registered plugins?\r\n     * @returns {number}\r\n     * @since 2.1.5\r\n     */\n    count: function () {\n      return this._plugins.length;\n    },\n\n    /**\r\n     * Returns all registered plugin instances.\r\n     * @returns {IPlugin[]} array of plugin objects.\r\n     * @since 2.1.5\r\n     */\n    getAll: function () {\n      return this._plugins;\n    },\n\n    /**\r\n     * Calls enabled plugins for `chart` on the specified hook and with the given args.\r\n     * This method immediately returns as soon as a plugin explicitly returns false. The\r\n     * returned value can be used, for instance, to interrupt the current action.\r\n     * @param {Chart} chart - The chart instance for which plugins should be called.\r\n     * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n     * @param {Array} [args] - Extra arguments to apply to the hook call.\r\n     * @returns {boolean} false if any of the plugins return false, else returns true.\r\n     */\n    notify: function (chart, hook, args) {\n      var descriptors = this.descriptors(chart);\n      var ilen = descriptors.length;\n      var i, descriptor, plugin, params, method;\n\n      for (i = 0; i < ilen; ++i) {\n        descriptor = descriptors[i];\n        plugin = descriptor.plugin;\n        method = plugin[hook];\n\n        if (typeof method === 'function') {\n          params = [chart].concat(args || []);\n          params.push(descriptor.options);\n\n          if (method.apply(plugin, params) === false) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\r\n     * Returns descriptors of enabled plugins for the given chart.\r\n     * @returns {object[]} [{ plugin, options }]\r\n     * @private\r\n     */\n    descriptors: function (chart) {\n      var cache = chart.$plugins || (chart.$plugins = {});\n\n      if (cache.id === this._cacheId) {\n        return cache.descriptors;\n      }\n\n      var plugins = [];\n      var descriptors = [];\n      var config = chart && chart.config || {};\n      var options = config.options && config.options.plugins || {};\n\n      this._plugins.concat(config.plugins || []).forEach(function (plugin) {\n        var idx = plugins.indexOf(plugin);\n\n        if (idx !== -1) {\n          return;\n        }\n\n        var id = plugin.id;\n        var opts = options[id];\n\n        if (opts === false) {\n          return;\n        }\n\n        if (opts === true) {\n          opts = helpers$1.clone(core_defaults.global.plugins[id]);\n        }\n\n        plugins.push(plugin);\n        descriptors.push({\n          plugin: plugin,\n          options: opts || {}\n        });\n      });\n\n      cache.descriptors = descriptors;\n      cache.id = this._cacheId;\n      return descriptors;\n    },\n\n    /**\r\n     * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\r\n     * but in some cases, this reference can be changed by the user when updating options.\r\n     * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n     * @private\r\n     */\n    _invalidate: function (chart) {\n      delete chart.$plugins;\n    }\n  };\n  var core_scaleService = {\n    // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n    // use the new chart options to grab the correct scale\n    constructors: {},\n    // Use a registration function so that we can move to an ES6 map when we no longer need to support\n    // old browsers\n    // Scale config defaults\n    defaults: {},\n    registerScaleType: function (type, scaleConstructor, scaleDefaults) {\n      this.constructors[type] = scaleConstructor;\n      this.defaults[type] = helpers$1.clone(scaleDefaults);\n    },\n    getScaleConstructor: function (type) {\n      return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n    },\n    getScaleDefaults: function (type) {\n      // Return the scale defaults merged with the global settings so that we always use the latest ones\n      return this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};\n    },\n    updateScaleDefaults: function (type, additions) {\n      var me = this;\n\n      if (me.defaults.hasOwnProperty(type)) {\n        me.defaults[type] = helpers$1.extend(me.defaults[type], additions);\n      }\n    },\n    addScalesToLayout: function (chart) {\n      // Adds each scale to the chart.boxes array to be sized accordingly\n      helpers$1.each(chart.scales, function (scale) {\n        // Set ILayoutItem parameters for backwards compatibility\n        scale.fullWidth = scale.options.fullWidth;\n        scale.position = scale.options.position;\n        scale.weight = scale.options.weight;\n        core_layouts.addBox(chart, scale);\n      });\n    }\n  };\n  var valueOrDefault$8 = helpers$1.valueOrDefault;\n  var getRtlHelper = helpers$1.rtl.getRtlAdapter;\n\n  core_defaults._set('global', {\n    tooltips: {\n      enabled: true,\n      custom: null,\n      mode: 'nearest',\n      position: 'average',\n      intersect: true,\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      titleFontStyle: 'bold',\n      titleSpacing: 2,\n      titleMarginBottom: 6,\n      titleFontColor: '#fff',\n      titleAlign: 'left',\n      bodySpacing: 2,\n      bodyFontColor: '#fff',\n      bodyAlign: 'left',\n      footerFontStyle: 'bold',\n      footerSpacing: 2,\n      footerMarginTop: 6,\n      footerFontColor: '#fff',\n      footerAlign: 'left',\n      yPadding: 6,\n      xPadding: 6,\n      caretPadding: 2,\n      caretSize: 5,\n      cornerRadius: 6,\n      multiKeyBackground: '#fff',\n      displayColors: true,\n      borderColor: 'rgba(0,0,0,0)',\n      borderWidth: 0,\n      callbacks: {\n        // Args are: (tooltipItems, data)\n        beforeTitle: helpers$1.noop,\n        title: function (tooltipItems, data) {\n          var title = '';\n          var labels = data.labels;\n          var labelCount = labels ? labels.length : 0;\n\n          if (tooltipItems.length > 0) {\n            var item = tooltipItems[0];\n\n            if (item.label) {\n              title = item.label;\n            } else if (item.xLabel) {\n              title = item.xLabel;\n            } else if (labelCount > 0 && item.index < labelCount) {\n              title = labels[item.index];\n            }\n          }\n\n          return title;\n        },\n        afterTitle: helpers$1.noop,\n        // Args are: (tooltipItems, data)\n        beforeBody: helpers$1.noop,\n        // Args are: (tooltipItem, data)\n        beforeLabel: helpers$1.noop,\n        label: function (tooltipItem, data) {\n          var label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n          if (label) {\n            label += ': ';\n          }\n\n          if (!helpers$1.isNullOrUndef(tooltipItem.value)) {\n            label += tooltipItem.value;\n          } else {\n            label += tooltipItem.yLabel;\n          }\n\n          return label;\n        },\n        labelColor: function (tooltipItem, chart) {\n          var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n          var activeElement = meta.data[tooltipItem.index];\n          var view = activeElement._view;\n          return {\n            borderColor: view.borderColor,\n            backgroundColor: view.backgroundColor\n          };\n        },\n        labelTextColor: function () {\n          return this._options.bodyFontColor;\n        },\n        afterLabel: helpers$1.noop,\n        // Args are: (tooltipItems, data)\n        afterBody: helpers$1.noop,\n        // Args are: (tooltipItems, data)\n        beforeFooter: helpers$1.noop,\n        footer: helpers$1.noop,\n        afterFooter: helpers$1.noop\n      }\n    }\n  });\n\n  var positioners = {\n    /**\r\n     * Average mode places the tooltip at the average position of the elements shown\r\n     * @function Chart.Tooltip.positioners.average\r\n     * @param elements {ChartElement[]} the elements being displayed in the tooltip\r\n     * @returns {object} tooltip position\r\n     */\n    average: function (elements) {\n      if (!elements.length) {\n        return false;\n      }\n\n      var i, len;\n      var x = 0;\n      var y = 0;\n      var count = 0;\n\n      for (i = 0, len = elements.length; i < len; ++i) {\n        var el = elements[i];\n\n        if (el && el.hasValue()) {\n          var pos = el.tooltipPosition();\n          x += pos.x;\n          y += pos.y;\n          ++count;\n        }\n      }\n\n      return {\n        x: x / count,\n        y: y / count\n      };\n    },\n\n    /**\r\n     * Gets the tooltip position nearest of the item nearest to the event position\r\n     * @function Chart.Tooltip.positioners.nearest\r\n     * @param elements {Chart.Element[]} the tooltip elements\r\n     * @param eventPosition {object} the position of the event in canvas coordinates\r\n     * @returns {object} the tooltip position\r\n     */\n    nearest: function (elements, eventPosition) {\n      var x = eventPosition.x;\n      var y = eventPosition.y;\n      var minDistance = Number.POSITIVE_INFINITY;\n      var i, len, nearestElement;\n\n      for (i = 0, len = elements.length; i < len; ++i) {\n        var el = elements[i];\n\n        if (el && el.hasValue()) {\n          var center = el.getCenterPoint();\n          var d = helpers$1.distanceBetweenPoints(eventPosition, center);\n\n          if (d < minDistance) {\n            minDistance = d;\n            nearestElement = el;\n          }\n        }\n      }\n\n      if (nearestElement) {\n        var tp = nearestElement.tooltipPosition();\n        x = tp.x;\n        y = tp.y;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }; // Helper to push or concat based on if the 2nd parameter is an array or not\n\n  function pushOrConcat(base, toPush) {\n    if (toPush) {\n      if (helpers$1.isArray(toPush)) {\n        // base = base.concat(toPush);\n        Array.prototype.push.apply(base, toPush);\n      } else {\n        base.push(toPush);\n      }\n    }\n\n    return base;\n  }\n  /**\r\n   * Returns array of strings split by newline\r\n   * @param {string} value - The value to split by newline.\r\n   * @returns {string[]} value if newline present - Returned from String split() method\r\n   * @function\r\n   */\n\n\n  function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n      return str.split('\\n');\n    }\n\n    return str;\n  }\n  /**\r\n   * Private helper to create a tooltip item model\r\n   * @param element - the chart element (point, arc, bar) to create the tooltip item for\r\n   * @return new tooltip item\r\n   */\n\n\n  function createTooltipItem(element) {\n    var xScale = element._xScale;\n    var yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\n    var index = element._index;\n    var datasetIndex = element._datasetIndex;\n\n    var controller = element._chart.getDatasetMeta(datasetIndex).controller;\n\n    var indexScale = controller._getIndexScale();\n\n    var valueScale = controller._getValueScale();\n\n    return {\n      xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n      yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n      label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\n      value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\n      index: index,\n      datasetIndex: datasetIndex,\n      x: element._model.x,\n      y: element._model.y\n    };\n  }\n  /**\r\n   * Helper to get the reset model for the tooltip\r\n   * @param tooltipOpts {object} the tooltip options\r\n   */\n\n\n  function getBaseModel(tooltipOpts) {\n    var globalDefaults = core_defaults.global;\n    return {\n      // Positioning\n      xPadding: tooltipOpts.xPadding,\n      yPadding: tooltipOpts.yPadding,\n      xAlign: tooltipOpts.xAlign,\n      yAlign: tooltipOpts.yAlign,\n      // Drawing direction and text direction\n      rtl: tooltipOpts.rtl,\n      textDirection: tooltipOpts.textDirection,\n      // Body\n      bodyFontColor: tooltipOpts.bodyFontColor,\n      _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n      _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n      _bodyAlign: tooltipOpts.bodyAlign,\n      bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n      bodySpacing: tooltipOpts.bodySpacing,\n      // Title\n      titleFontColor: tooltipOpts.titleFontColor,\n      _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n      _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n      titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n      _titleAlign: tooltipOpts.titleAlign,\n      titleSpacing: tooltipOpts.titleSpacing,\n      titleMarginBottom: tooltipOpts.titleMarginBottom,\n      // Footer\n      footerFontColor: tooltipOpts.footerFontColor,\n      _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n      _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n      footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n      _footerAlign: tooltipOpts.footerAlign,\n      footerSpacing: tooltipOpts.footerSpacing,\n      footerMarginTop: tooltipOpts.footerMarginTop,\n      // Appearance\n      caretSize: tooltipOpts.caretSize,\n      cornerRadius: tooltipOpts.cornerRadius,\n      backgroundColor: tooltipOpts.backgroundColor,\n      opacity: 0,\n      legendColorBackground: tooltipOpts.multiKeyBackground,\n      displayColors: tooltipOpts.displayColors,\n      borderColor: tooltipOpts.borderColor,\n      borderWidth: tooltipOpts.borderWidth\n    };\n  }\n  /**\r\n   * Get the size of the tooltip\r\n   */\n\n\n  function getTooltipSize(tooltip, model) {\n    var ctx = tooltip._chart.ctx;\n    var height = model.yPadding * 2; // Tooltip Padding\n\n    var width = 0; // Count of all lines in the body\n\n    var body = model.body;\n    var combinedBodyLength = body.reduce(function (count, bodyItem) {\n      return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n    }, 0);\n    combinedBodyLength += model.beforeBody.length + model.afterBody.length;\n    var titleLineCount = model.title.length;\n    var footerLineCount = model.footer.length;\n    var titleFontSize = model.titleFontSize;\n    var bodyFontSize = model.bodyFontSize;\n    var footerFontSize = model.footerFontSize;\n    height += titleLineCount * titleFontSize; // Title Lines\n\n    height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\n    height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\n    height += combinedBodyLength * bodyFontSize; // Body Lines\n\n    height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\n    height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\n    height += footerLineCount * footerFontSize; // Footer Lines\n\n    height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n    // Title width\n\n    var widthPadding = 0;\n\n    var maxLineWidth = function (line) {\n      width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n\n    ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n    helpers$1.each(model.title, maxLineWidth); // Body width\n\n    ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n    helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box\n\n    widthPadding = model.displayColors ? bodyFontSize + 2 : 0;\n    helpers$1.each(body, function (bodyItem) {\n      helpers$1.each(bodyItem.before, maxLineWidth);\n      helpers$1.each(bodyItem.lines, maxLineWidth);\n      helpers$1.each(bodyItem.after, maxLineWidth);\n    }); // Reset back to 0\n\n    widthPadding = 0; // Footer width\n\n    ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n    helpers$1.each(model.footer, maxLineWidth); // Add padding\n\n    width += 2 * model.xPadding;\n    return {\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Helper to get the alignment of a tooltip given the size\r\n   */\n\n\n  function determineAlignment(tooltip, size) {\n    var model = tooltip._model;\n    var chart = tooltip._chart;\n    var chartArea = tooltip._chart.chartArea;\n    var xAlign = 'center';\n    var yAlign = 'center';\n\n    if (model.y < size.height) {\n      yAlign = 'top';\n    } else if (model.y > chart.height - size.height) {\n      yAlign = 'bottom';\n    }\n\n    var lf, rf; // functions to determine left, right alignment\n\n    var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\n    var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\n    var midX = (chartArea.left + chartArea.right) / 2;\n    var midY = (chartArea.top + chartArea.bottom) / 2;\n\n    if (yAlign === 'center') {\n      lf = function (x) {\n        return x <= midX;\n      };\n\n      rf = function (x) {\n        return x > midX;\n      };\n    } else {\n      lf = function (x) {\n        return x <= size.width / 2;\n      };\n\n      rf = function (x) {\n        return x >= chart.width - size.width / 2;\n      };\n    }\n\n    olf = function (x) {\n      return x + size.width + model.caretSize + model.caretPadding > chart.width;\n    };\n\n    orf = function (x) {\n      return x - size.width - model.caretSize - model.caretPadding < 0;\n    };\n\n    yf = function (y) {\n      return y <= midY ? 'top' : 'bottom';\n    };\n\n    if (lf(model.x)) {\n      xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?\n\n      if (olf(model.x)) {\n        xAlign = 'center';\n        yAlign = yf(model.y);\n      }\n    } else if (rf(model.x)) {\n      xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?\n\n      if (orf(model.x)) {\n        xAlign = 'center';\n        yAlign = yf(model.y);\n      }\n    }\n\n    var opts = tooltip._options;\n    return {\n      xAlign: opts.xAlign ? opts.xAlign : xAlign,\n      yAlign: opts.yAlign ? opts.yAlign : yAlign\n    };\n  }\n  /**\r\n   * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\r\n   */\n\n\n  function getBackgroundPoint(vm, size, alignment, chart) {\n    // Background Position\n    var x = vm.x;\n    var y = vm.y;\n    var caretSize = vm.caretSize;\n    var caretPadding = vm.caretPadding;\n    var cornerRadius = vm.cornerRadius;\n    var xAlign = alignment.xAlign;\n    var yAlign = alignment.yAlign;\n    var paddingAndSize = caretSize + caretPadding;\n    var radiusAndPadding = cornerRadius + caretPadding;\n\n    if (xAlign === 'right') {\n      x -= size.width;\n    } else if (xAlign === 'center') {\n      x -= size.width / 2;\n\n      if (x + size.width > chart.width) {\n        x = chart.width - size.width;\n      }\n\n      if (x < 0) {\n        x = 0;\n      }\n    }\n\n    if (yAlign === 'top') {\n      y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n      y -= size.height + paddingAndSize;\n    } else {\n      y -= size.height / 2;\n    }\n\n    if (yAlign === 'center') {\n      if (xAlign === 'left') {\n        x += paddingAndSize;\n      } else if (xAlign === 'right') {\n        x -= paddingAndSize;\n      }\n    } else if (xAlign === 'left') {\n      x -= radiusAndPadding;\n    } else if (xAlign === 'right') {\n      x += radiusAndPadding;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  function getAlignedX(vm, align) {\n    return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;\n  }\n  /**\r\n   * Helper to build before and after body lines\r\n   */\n\n\n  function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n  }\n\n  var exports$4 = core_element.extend({\n    initialize: function () {\n      this._model = getBaseModel(this._options);\n      this._lastActive = [];\n    },\n    // Get the title\n    // Args are: (tooltipItem, data)\n    getTitle: function () {\n      var me = this;\n      var opts = me._options;\n      var callbacks = opts.callbacks;\n      var beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n      var title = callbacks.title.apply(me, arguments);\n      var afterTitle = callbacks.afterTitle.apply(me, arguments);\n      var lines = [];\n      lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n      lines = pushOrConcat(lines, splitNewlines(title));\n      lines = pushOrConcat(lines, splitNewlines(afterTitle));\n      return lines;\n    },\n    // Args are: (tooltipItem, data)\n    getBeforeBody: function () {\n      return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\n    },\n    // Args are: (tooltipItem, data)\n    getBody: function (tooltipItems, data) {\n      var me = this;\n      var callbacks = me._options.callbacks;\n      var bodyItems = [];\n      helpers$1.each(tooltipItems, function (tooltipItem) {\n        var bodyItem = {\n          before: [],\n          lines: [],\n          after: []\n        };\n        pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\n        pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n        pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\n        bodyItems.push(bodyItem);\n      });\n      return bodyItems;\n    },\n    // Args are: (tooltipItem, data)\n    getAfterBody: function () {\n      return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\n    },\n    // Get the footer and beforeFooter and afterFooter lines\n    // Args are: (tooltipItem, data)\n    getFooter: function () {\n      var me = this;\n      var callbacks = me._options.callbacks;\n      var beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n      var footer = callbacks.footer.apply(me, arguments);\n      var afterFooter = callbacks.afterFooter.apply(me, arguments);\n      var lines = [];\n      lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n      lines = pushOrConcat(lines, splitNewlines(footer));\n      lines = pushOrConcat(lines, splitNewlines(afterFooter));\n      return lines;\n    },\n    update: function (changed) {\n      var me = this;\n      var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n      // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n      // which breaks any animations.\n\n      var existingModel = me._model;\n      var model = me._model = getBaseModel(opts);\n      var active = me._active;\n      var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations\n\n      var alignment = {\n        xAlign: existingModel.xAlign,\n        yAlign: existingModel.yAlign\n      };\n      var backgroundPoint = {\n        x: existingModel.x,\n        y: existingModel.y\n      };\n      var tooltipSize = {\n        width: existingModel.width,\n        height: existingModel.height\n      };\n      var tooltipPosition = {\n        x: existingModel.caretX,\n        y: existingModel.caretY\n      };\n      var i, len;\n\n      if (active.length) {\n        model.opacity = 1;\n        var labelColors = [];\n        var labelTextColors = [];\n        tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\n        var tooltipItems = [];\n\n        for (i = 0, len = active.length; i < len; ++i) {\n          tooltipItems.push(createTooltipItem(active[i]));\n        } // If the user provided a filter function, use it to modify the tooltip items\n\n\n        if (opts.filter) {\n          tooltipItems = tooltipItems.filter(function (a) {\n            return opts.filter(a, data);\n          });\n        } // If the user provided a sorting function, use it to modify the tooltip items\n\n\n        if (opts.itemSort) {\n          tooltipItems = tooltipItems.sort(function (a, b) {\n            return opts.itemSort(a, b, data);\n          });\n        } // Determine colors for boxes\n\n\n        helpers$1.each(tooltipItems, function (tooltipItem) {\n          labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n          labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n        }); // Build the Text Lines\n\n        model.title = me.getTitle(tooltipItems, data);\n        model.beforeBody = me.getBeforeBody(tooltipItems, data);\n        model.body = me.getBody(tooltipItems, data);\n        model.afterBody = me.getAfterBody(tooltipItems, data);\n        model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors\n\n        model.x = tooltipPosition.x;\n        model.y = tooltipPosition.y;\n        model.caretPadding = opts.caretPadding;\n        model.labelColors = labelColors;\n        model.labelTextColors = labelTextColors; // data points\n\n        model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip\n\n        tooltipSize = getTooltipSize(this, model);\n        alignment = determineAlignment(this, tooltipSize); // Final Size and Position\n\n        backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n      } else {\n        model.opacity = 0;\n      }\n\n      model.xAlign = alignment.xAlign;\n      model.yAlign = alignment.yAlign;\n      model.x = backgroundPoint.x;\n      model.y = backgroundPoint.y;\n      model.width = tooltipSize.width;\n      model.height = tooltipSize.height; // Point where the caret on the tooltip points to\n\n      model.caretX = tooltipPosition.x;\n      model.caretY = tooltipPosition.y;\n      me._model = model;\n\n      if (changed && opts.custom) {\n        opts.custom.call(me, model);\n      }\n\n      return me;\n    },\n    drawCaret: function (tooltipPoint, size) {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n      ctx.lineTo(caretPosition.x1, caretPosition.y1);\n      ctx.lineTo(caretPosition.x2, caretPosition.y2);\n      ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    },\n    getCaretPosition: function (tooltipPoint, size, vm) {\n      var x1, x2, x3, y1, y2, y3;\n      var caretSize = vm.caretSize;\n      var cornerRadius = vm.cornerRadius;\n      var xAlign = vm.xAlign;\n      var yAlign = vm.yAlign;\n      var ptX = tooltipPoint.x;\n      var ptY = tooltipPoint.y;\n      var width = size.width;\n      var height = size.height;\n\n      if (yAlign === 'center') {\n        y2 = ptY + height / 2;\n\n        if (xAlign === 'left') {\n          x1 = ptX;\n          x2 = x1 - caretSize;\n          x3 = x1;\n          y1 = y2 + caretSize;\n          y3 = y2 - caretSize;\n        } else {\n          x1 = ptX + width;\n          x2 = x1 + caretSize;\n          x3 = x1;\n          y1 = y2 - caretSize;\n          y3 = y2 + caretSize;\n        }\n      } else {\n        if (xAlign === 'left') {\n          x2 = ptX + cornerRadius + caretSize;\n          x1 = x2 - caretSize;\n          x3 = x2 + caretSize;\n        } else if (xAlign === 'right') {\n          x2 = ptX + width - cornerRadius - caretSize;\n          x1 = x2 - caretSize;\n          x3 = x2 + caretSize;\n        } else {\n          x2 = vm.caretX;\n          x1 = x2 - caretSize;\n          x3 = x2 + caretSize;\n        }\n\n        if (yAlign === 'top') {\n          y1 = ptY;\n          y2 = y1 - caretSize;\n          y3 = y1;\n        } else {\n          y1 = ptY + height;\n          y2 = y1 + caretSize;\n          y3 = y1; // invert drawing order\n\n          var tmp = x3;\n          x3 = x1;\n          x1 = tmp;\n        }\n      }\n\n      return {\n        x1: x1,\n        x2: x2,\n        x3: x3,\n        y1: y1,\n        y2: y2,\n        y3: y3\n      };\n    },\n    drawTitle: function (pt, vm, ctx) {\n      var title = vm.title;\n      var length = title.length;\n      var titleFontSize, titleSpacing, i;\n\n      if (length) {\n        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\n        pt.x = getAlignedX(vm, vm._titleAlign);\n        ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);\n        ctx.textBaseline = 'middle';\n        titleFontSize = vm.titleFontSize;\n        titleSpacing = vm.titleSpacing;\n        ctx.fillStyle = vm.titleFontColor;\n        ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n        for (i = 0; i < length; ++i) {\n          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);\n          pt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n          if (i + 1 === length) {\n            pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n          }\n        }\n      }\n    },\n    drawBody: function (pt, vm, ctx) {\n      var bodyFontSize = vm.bodyFontSize;\n      var bodySpacing = vm.bodySpacing;\n      var bodyAlign = vm._bodyAlign;\n      var body = vm.body;\n      var drawColorBoxes = vm.displayColors;\n      var xLinePadding = 0;\n      var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n      var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\n\n      var fillLineOfText = function (line) {\n        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);\n        pt.y += bodyFontSize + bodySpacing;\n      };\n\n      var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;\n      var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n      ctx.textAlign = bodyAlign;\n      ctx.textBaseline = 'middle';\n      ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n      pt.x = getAlignedX(vm, bodyAlignForCalculation); // Before body lines\n\n      ctx.fillStyle = vm.bodyFontColor;\n      helpers$1.each(vm.beforeBody, fillLineOfText);\n      xLinePadding = drawColorBoxes && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now\n\n      for (i = 0, ilen = body.length; i < ilen; ++i) {\n        bodyItem = body[i];\n        textColor = vm.labelTextColors[i];\n        labelColors = vm.labelColors[i];\n        ctx.fillStyle = textColor;\n        helpers$1.each(bodyItem.before, fillLineOfText);\n        lines = bodyItem.lines;\n\n        for (j = 0, jlen = lines.length; j < jlen; ++j) {\n          // Draw Legend-like boxes if needed\n          if (drawColorBoxes) {\n            var rtlColorX = rtlHelper.x(colorX); // Fill a white rect so that colours merge nicely if the opacity is < 1\n\n            ctx.fillStyle = vm.legendColorBackground;\n            ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize); // Border\n\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize); // Inner square\n\n            ctx.fillStyle = labelColors.backgroundColor;\n            ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n            ctx.fillStyle = textColor;\n          }\n\n          fillLineOfText(lines[j]);\n        }\n\n        helpers$1.each(bodyItem.after, fillLineOfText);\n      } // Reset back to 0 for after body\n\n\n      xLinePadding = 0; // After body lines\n\n      helpers$1.each(vm.afterBody, fillLineOfText);\n      pt.y -= bodySpacing; // Remove last body spacing\n    },\n    drawFooter: function (pt, vm, ctx) {\n      var footer = vm.footer;\n      var length = footer.length;\n      var footerFontSize, i;\n\n      if (length) {\n        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\n        pt.x = getAlignedX(vm, vm._footerAlign);\n        pt.y += vm.footerMarginTop;\n        ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);\n        ctx.textBaseline = 'middle';\n        footerFontSize = vm.footerFontSize;\n        ctx.fillStyle = vm.footerFontColor;\n        ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n        for (i = 0; i < length; ++i) {\n          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);\n          pt.y += footerFontSize + vm.footerSpacing;\n        }\n      }\n    },\n    drawBackground: function (pt, vm, ctx, tooltipSize) {\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.strokeStyle = vm.borderColor;\n      ctx.lineWidth = vm.borderWidth;\n      var xAlign = vm.xAlign;\n      var yAlign = vm.yAlign;\n      var x = pt.x;\n      var y = pt.y;\n      var width = tooltipSize.width;\n      var height = tooltipSize.height;\n      var radius = vm.cornerRadius;\n      ctx.beginPath();\n      ctx.moveTo(x + radius, y);\n\n      if (yAlign === 'top') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x + width - radius, y);\n      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n      if (yAlign === 'center' && xAlign === 'right') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x + width, y + height - radius);\n      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\n      if (yAlign === 'bottom') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x + radius, y + height);\n      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\n      if (yAlign === 'center' && xAlign === 'left') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x, y + radius);\n      ctx.quadraticCurveTo(x, y, x + radius, y);\n      ctx.closePath();\n      ctx.fill();\n\n      if (vm.borderWidth > 0) {\n        ctx.stroke();\n      }\n    },\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n\n      if (vm.opacity === 0) {\n        return;\n      }\n\n      var tooltipSize = {\n        width: vm.width,\n        height: vm.height\n      };\n      var pt = {\n        x: vm.x,\n        y: vm.y\n      }; // IE11/Edge does not like very small opacities, so snap to 0\n\n      var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip\n\n      var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n      if (this._options.enabled && hasTooltipContent) {\n        ctx.save();\n        ctx.globalAlpha = opacity; // Draw Background\n\n        this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer\n\n        pt.y += vm.yPadding;\n        helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection); // Titles\n\n        this.drawTitle(pt, vm, ctx); // Body\n\n        this.drawBody(pt, vm, ctx); // Footer\n\n        this.drawFooter(pt, vm, ctx);\n        helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);\n        ctx.restore();\n      }\n    },\n\n    /**\r\n     * Handle an event\r\n     * @private\r\n     * @param {IEvent} event - The event to handle\r\n     * @returns {boolean} true if the tooltip changed\r\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var options = me._options;\n      var changed = false;\n      me._lastActive = me._lastActive || []; // Find Active Elements for tooltips\n\n      if (e.type === 'mouseout') {\n        me._active = [];\n      } else {\n        me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\n        if (options.reverse) {\n          me._active.reverse();\n        }\n      } // Remember Last Actives\n\n\n      changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change\n\n      if (changed) {\n        me._lastActive = me._active;\n\n        if (options.enabled || options.custom) {\n          me._eventPosition = {\n            x: e.x,\n            y: e.y\n          };\n          me.update(true);\n          me.pivot();\n        }\n      }\n\n      return changed;\n    }\n  });\n  /**\r\n   * @namespace Chart.Tooltip.positioners\r\n   */\n\n  var positioners_1 = positioners;\n  var core_tooltip = exports$4;\n  core_tooltip.positioners = positioners_1;\n  var valueOrDefault$9 = helpers$1.valueOrDefault;\n\n  core_defaults._set('global', {\n    elements: {},\n    events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n    hover: {\n      onHover: null,\n      mode: 'nearest',\n      intersect: true,\n      animationDuration: 400\n    },\n    onClick: null,\n    maintainAspectRatio: true,\n    responsive: true,\n    responsiveAnimationDuration: 0\n  });\n  /**\r\n   * Recursively merge the given config objects representing the `scales` option\r\n   * by incorporating scale defaults in `xAxes` and `yAxes` array items, then\r\n   * returns a deep copy of the result, thus doesn't alter inputs.\r\n   */\n\n\n  function mergeScaleConfig()\n  /* config objects ... */\n  {\n    return helpers$1.merge(Object.create(null), [].slice.call(arguments), {\n      merger: function (key, target, source, options) {\n        if (key === 'xAxes' || key === 'yAxes') {\n          var slen = source[key].length;\n          var i, type, scale;\n\n          if (!target[key]) {\n            target[key] = [];\n          }\n\n          for (i = 0; i < slen; ++i) {\n            scale = source[key][i];\n            type = valueOrDefault$9(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n            if (i >= target[key].length) {\n              target[key].push({});\n            }\n\n            if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {\n              // new/untyped scale or type changed: let's apply the new defaults\n              // then merge source scale to correctly overwrite the defaults.\n              helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);\n            } else {\n              // scales type are the same\n              helpers$1.merge(target[key][i], scale);\n            }\n          }\n        } else {\n          helpers$1._merger(key, target, source, options);\n        }\n      }\n    });\n  }\n  /**\r\n   * Recursively merge the given config objects as the root options by handling\r\n   * default scale options for the `scales` and `scale` properties, then returns\r\n   * a deep copy of the result, thus doesn't alter inputs.\r\n   */\n\n\n  function mergeConfig()\n  /* config objects ... */\n  {\n    return helpers$1.merge(Object.create(null), [].slice.call(arguments), {\n      merger: function (key, target, source, options) {\n        var tval = target[key] || Object.create(null);\n        var sval = source[key];\n\n        if (key === 'scales') {\n          // scale config merging is complex. Add our own function here for that\n          target[key] = mergeScaleConfig(tval, sval);\n        } else if (key === 'scale') {\n          // used in polar area & radar charts since there is only one scale\n          target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);\n        } else {\n          helpers$1._merger(key, target, source, options);\n        }\n      }\n    });\n  }\n\n  function initConfig(config) {\n    config = config || Object.create(null); // Do NOT use mergeConfig for the data object because this method merges arrays\n    // and so would change references to labels and datasets, preventing data updates.\n\n    var data = config.data = config.data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});\n    return config;\n  }\n\n  function updateConfig(chart) {\n    var newOptions = chart.options;\n    helpers$1.each(chart.scales, function (scale) {\n      core_layouts.removeBox(chart, scale);\n    });\n    newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);\n    chart.options = chart.config.options = newOptions;\n    chart.ensureScalesHaveIDs();\n    chart.buildOrUpdateScales(); // Tooltip\n\n    chart.tooltip._options = newOptions.tooltips;\n    chart.tooltip.initialize();\n  }\n\n  function nextAvailableScaleId(axesOpts, prefix, index) {\n    var id;\n\n    var hasId = function (obj) {\n      return obj.id === id;\n    };\n\n    do {\n      id = prefix + index++;\n    } while (helpers$1.findIndex(axesOpts, hasId) >= 0);\n\n    return id;\n  }\n\n  function positionIsHorizontal(position) {\n    return position === 'top' || position === 'bottom';\n  }\n\n  function compare2Level(l1, l2) {\n    return function (a, b) {\n      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n  }\n\n  var Chart = function (item, config) {\n    this.construct(item, config);\n    return this;\n  };\n\n  helpers$1.extend(Chart.prototype,\n  /** @lends Chart */\n  {\n    /**\r\n     * @private\r\n     */\n    construct: function (item, config) {\n      var me = this;\n      config = initConfig(config);\n      var context = platform.acquireContext(item, config);\n      var canvas = context && context.canvas;\n      var height = canvas && canvas.height;\n      var width = canvas && canvas.width;\n      me.id = helpers$1.uid();\n      me.ctx = context;\n      me.canvas = canvas;\n      me.config = config;\n      me.width = width;\n      me.height = height;\n      me.aspectRatio = height ? width / height : null;\n      me.options = config.options;\n      me._bufferedRender = false;\n      me._layers = [];\n      /**\r\n       * Provided for backward compatibility, Chart and Chart.Controller have been merged,\r\n       * the \"instance\" still need to be defined since it might be called from plugins.\r\n       * @prop Chart#chart\r\n       * @deprecated since version 2.6.0\r\n       * @todo remove at version 3\r\n       * @private\r\n       */\n\n      me.chart = me;\n      me.controller = me; // chart.chart.controller #inception\n      // Add the chart instance to the global namespace\n\n      Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`\n\n      Object.defineProperty(me, 'data', {\n        get: function () {\n          return me.config.data;\n        },\n        set: function (value) {\n          me.config.data = value;\n        }\n      });\n\n      if (!context || !canvas) {\n        // The given item is not a compatible context2d element, let's return before finalizing\n        // the chart initialization but after setting basic chart / controller properties that\n        // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n        // https://github.com/chartjs/Chart.js/issues/2807\n        console.error(\"Failed to create chart: can't acquire context from the given item\");\n        return;\n      }\n\n      me.initialize();\n      me.update();\n    },\n\n    /**\r\n     * @private\r\n     */\n    initialize: function () {\n      var me = this; // Before init plugin notification\n\n      core_plugins.notify(me, 'beforeInit');\n      helpers$1.retinaScale(me, me.options.devicePixelRatio);\n      me.bindEvents();\n\n      if (me.options.responsive) {\n        // Initial resize before chart draws (must be silent to preserve initial animations).\n        me.resize(true);\n      }\n\n      me.initToolTip(); // After init plugin notification\n\n      core_plugins.notify(me, 'afterInit');\n      return me;\n    },\n    clear: function () {\n      helpers$1.canvas.clear(this);\n      return this;\n    },\n    stop: function () {\n      // Stops any current animation loop occurring\n      core_animations.cancelAnimation(this);\n      return this;\n    },\n    resize: function (silent) {\n      var me = this;\n      var options = me.options;\n      var canvas = me.canvas;\n      var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that\n      // the canvas display style uses the same integer values to avoid blurring effect.\n      // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed\n\n      var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\n      var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\n\n      if (me.width === newWidth && me.height === newHeight) {\n        return;\n      }\n\n      canvas.width = me.width = newWidth;\n      canvas.height = me.height = newHeight;\n      canvas.style.width = newWidth + 'px';\n      canvas.style.height = newHeight + 'px';\n      helpers$1.retinaScale(me, options.devicePixelRatio);\n\n      if (!silent) {\n        // Notify any plugins about the resize\n        var newSize = {\n          width: newWidth,\n          height: newHeight\n        };\n        core_plugins.notify(me, 'resize', [newSize]); // Notify of resize\n\n        if (options.onResize) {\n          options.onResize(me, newSize);\n        }\n\n        me.stop();\n        me.update({\n          duration: options.responsiveAnimationDuration\n        });\n      }\n    },\n    ensureScalesHaveIDs: function () {\n      var options = this.options;\n      var scalesOptions = options.scales || {};\n      var scaleOptions = options.scale;\n      helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {\n        if (!xAxisOptions.id) {\n          xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);\n        }\n      });\n      helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {\n        if (!yAxisOptions.id) {\n          yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);\n        }\n      });\n\n      if (scaleOptions) {\n        scaleOptions.id = scaleOptions.id || 'scale';\n      }\n    },\n\n    /**\r\n     * Builds a map of scale ID to scale object for future lookup.\r\n     */\n    buildOrUpdateScales: function () {\n      var me = this;\n      var options = me.options;\n      var scales = me.scales || {};\n      var items = [];\n      var updated = Object.keys(scales).reduce(function (obj, id) {\n        obj[id] = false;\n        return obj;\n      }, {});\n\n      if (options.scales) {\n        items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {\n          return {\n            options: xAxisOptions,\n            dtype: 'category',\n            dposition: 'bottom'\n          };\n        }), (options.scales.yAxes || []).map(function (yAxisOptions) {\n          return {\n            options: yAxisOptions,\n            dtype: 'linear',\n            dposition: 'left'\n          };\n        }));\n      }\n\n      if (options.scale) {\n        items.push({\n          options: options.scale,\n          dtype: 'radialLinear',\n          isDefault: true,\n          dposition: 'chartArea'\n        });\n      }\n\n      helpers$1.each(items, function (item) {\n        var scaleOptions = item.options;\n        var id = scaleOptions.id;\n        var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);\n\n        if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n          scaleOptions.position = item.dposition;\n        }\n\n        updated[id] = true;\n        var scale = null;\n\n        if (id in scales && scales[id].type === scaleType) {\n          scale = scales[id];\n          scale.options = scaleOptions;\n          scale.ctx = me.ctx;\n          scale.chart = me;\n        } else {\n          var scaleClass = core_scaleService.getScaleConstructor(scaleType);\n\n          if (!scaleClass) {\n            return;\n          }\n\n          scale = new scaleClass({\n            id: id,\n            type: scaleType,\n            options: scaleOptions,\n            ctx: me.ctx,\n            chart: me\n          });\n          scales[scale.id] = scale;\n        }\n\n        scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)\n        // and consider it as a regular scale part of the \"scales\"\" map only! This would\n        // make the logic easier and remove some useless? custom code.\n\n        if (item.isDefault) {\n          me.scale = scale;\n        }\n      }); // clear up discarded scales\n\n      helpers$1.each(updated, function (hasUpdated, id) {\n        if (!hasUpdated) {\n          delete scales[id];\n        }\n      });\n      me.scales = scales;\n      core_scaleService.addScalesToLayout(this);\n    },\n    buildOrUpdateControllers: function () {\n      var me = this;\n      var newControllers = [];\n      var datasets = me.data.datasets;\n      var i, ilen;\n\n      for (i = 0, ilen = datasets.length; i < ilen; i++) {\n        var dataset = datasets[i];\n        var meta = me.getDatasetMeta(i);\n        var type = dataset.type || me.config.type;\n\n        if (meta.type && meta.type !== type) {\n          me.destroyDatasetMeta(i);\n          meta = me.getDatasetMeta(i);\n        }\n\n        meta.type = type;\n        meta.order = dataset.order || 0;\n        meta.index = i;\n\n        if (meta.controller) {\n          meta.controller.updateIndex(i);\n          meta.controller.linkScales();\n        } else {\n          var ControllerClass = controllers[meta.type];\n\n          if (ControllerClass === undefined) {\n            throw new Error('\"' + meta.type + '\" is not a chart type.');\n          }\n\n          meta.controller = new ControllerClass(me, i);\n          newControllers.push(meta.controller);\n        }\n      }\n\n      return newControllers;\n    },\n\n    /**\r\n     * Reset the elements of all datasets\r\n     * @private\r\n     */\n    resetElements: function () {\n      var me = this;\n      helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {\n        me.getDatasetMeta(datasetIndex).controller.reset();\n      }, me);\n    },\n\n    /**\r\n    * Resets the chart back to it's state before the initial animation\r\n    */\n    reset: function () {\n      this.resetElements();\n      this.tooltip.initialize();\n    },\n    update: function (config) {\n      var me = this;\n      var i, ilen;\n\n      if (!config || typeof config !== 'object') {\n        // backwards compatibility\n        config = {\n          duration: config,\n          lazy: arguments[1]\n        };\n      }\n\n      updateConfig(me); // plugins options references might have change, let's invalidate the cache\n      // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\n      core_plugins._invalidate(me);\n\n      if (core_plugins.notify(me, 'beforeUpdate') === false) {\n        return;\n      } // In case the entire data object changed\n\n\n      me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset\n\n      var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts\n\n      for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\n        me.getDatasetMeta(i).controller.buildOrUpdateElements();\n      }\n\n      me.updateLayout(); // Can only reset the new controllers after the scales have been updated\n\n      if (me.options.animation && me.options.animation.duration) {\n        helpers$1.each(newControllers, function (controller) {\n          controller.reset();\n        });\n      }\n\n      me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed\n      // after update.\n\n      me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.\n      // When we reset the tooltip, we need to clear it\n\n      me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it\n\n      core_plugins.notify(me, 'afterUpdate');\n\n      me._layers.sort(compare2Level('z', '_idx'));\n\n      if (me._bufferedRender) {\n        me._bufferedRequest = {\n          duration: config.duration,\n          easing: config.easing,\n          lazy: config.lazy\n        };\n      } else {\n        me.render(config);\n      }\n    },\n\n    /**\r\n     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\r\n     * hook, in which case, plugins will not be called on `afterLayout`.\r\n     * @private\r\n     */\n    updateLayout: function () {\n      var me = this;\n\n      if (core_plugins.notify(me, 'beforeLayout') === false) {\n        return;\n      }\n\n      core_layouts.update(this, this.width, this.height);\n      me._layers = [];\n      helpers$1.each(me.boxes, function (box) {\n        // _configure is called twice, once in core.scale.update and once here.\n        // Here the boxes are fully updated and at their final positions.\n        if (box._configure) {\n          box._configure();\n        }\n\n        me._layers.push.apply(me._layers, box._layers());\n      }, me);\n\n      me._layers.forEach(function (item, index) {\n        item._idx = index;\n      });\n      /**\r\n       * Provided for backward compatibility, use `afterLayout` instead.\r\n       * @method IPlugin#afterScaleUpdate\r\n       * @deprecated since version 2.5.0\r\n       * @todo remove at version 3\r\n       * @private\r\n       */\n\n\n      core_plugins.notify(me, 'afterScaleUpdate');\n      core_plugins.notify(me, 'afterLayout');\n    },\n\n    /**\r\n     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\r\n     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\r\n     * @private\r\n     */\n    updateDatasets: function () {\n      var me = this;\n\n      if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n        return;\n      }\n\n      for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n        me.updateDataset(i);\n      }\n\n      core_plugins.notify(me, 'afterDatasetsUpdate');\n    },\n\n    /**\r\n     * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\r\n     * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\r\n     * @private\r\n     */\n    updateDataset: function (index) {\n      var me = this;\n      var meta = me.getDatasetMeta(index);\n      var args = {\n        meta: meta,\n        index: index\n      };\n\n      if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n        return;\n      }\n\n      meta.controller._update();\n\n      core_plugins.notify(me, 'afterDatasetUpdate', [args]);\n    },\n    render: function (config) {\n      var me = this;\n\n      if (!config || typeof config !== 'object') {\n        // backwards compatibility\n        config = {\n          duration: config,\n          lazy: arguments[1]\n        };\n      }\n\n      var animationOptions = me.options.animation;\n      var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);\n      var lazy = config.lazy;\n\n      if (core_plugins.notify(me, 'beforeRender') === false) {\n        return;\n      }\n\n      var onComplete = function (animation) {\n        core_plugins.notify(me, 'afterRender');\n        helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);\n      };\n\n      if (animationOptions && duration) {\n        var animation = new core_animation({\n          numSteps: duration / 16.66,\n          // 60 fps\n          easing: config.easing || animationOptions.easing,\n          render: function (chart, animationObject) {\n            var easingFunction = helpers$1.easing.effects[animationObject.easing];\n            var currentStep = animationObject.currentStep;\n            var stepDecimal = currentStep / animationObject.numSteps;\n            chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n          },\n          onAnimationProgress: animationOptions.onProgress,\n          onAnimationComplete: onComplete\n        });\n        core_animations.addAnimation(me, animation, duration, lazy);\n      } else {\n        me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781\n\n        onComplete(new core_animation({\n          numSteps: 0,\n          chart: me\n        }));\n      }\n\n      return me;\n    },\n    draw: function (easingValue) {\n      var me = this;\n      var i, layers;\n      me.clear();\n\n      if (helpers$1.isNullOrUndef(easingValue)) {\n        easingValue = 1;\n      }\n\n      me.transition(easingValue);\n\n      if (me.width <= 0 || me.height <= 0) {\n        return;\n      }\n\n      if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n        return;\n      } // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n      // currently be part of layers. Instead, we draw\n      // layers <= 0 before(default, backward compat), and the rest after\n\n\n      layers = me._layers;\n\n      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n        layers[i].draw(me.chartArea);\n      }\n\n      me.drawDatasets(easingValue); // Rest of layers\n\n      for (; i < layers.length; ++i) {\n        layers[i].draw(me.chartArea);\n      }\n\n      me._drawTooltip(easingValue);\n\n      core_plugins.notify(me, 'afterDraw', [easingValue]);\n    },\n\n    /**\r\n     * @private\r\n     */\n    transition: function (easingValue) {\n      var me = this;\n\n      for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n        if (me.isDatasetVisible(i)) {\n          me.getDatasetMeta(i).controller.transition(easingValue);\n        }\n      }\n\n      me.tooltip.transition(easingValue);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getSortedDatasetMetas: function (filterVisible) {\n      var me = this;\n      var datasets = me.data.datasets || [];\n      var result = [];\n      var i, ilen;\n\n      for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n        if (!filterVisible || me.isDatasetVisible(i)) {\n          result.push(me.getDatasetMeta(i));\n        }\n      }\n\n      result.sort(compare2Level('order', 'index'));\n      return result;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getSortedVisibleDatasetMetas: function () {\n      return this._getSortedDatasetMetas(true);\n    },\n\n    /**\r\n     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\r\n     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\r\n     * @private\r\n     */\n    drawDatasets: function (easingValue) {\n      var me = this;\n      var metasets, i;\n\n      if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n        return;\n      }\n\n      metasets = me._getSortedVisibleDatasetMetas();\n\n      for (i = metasets.length - 1; i >= 0; --i) {\n        me.drawDataset(metasets[i], easingValue);\n      }\n\n      core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n    },\n\n    /**\r\n     * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\r\n     * hook, in which case, plugins will not be called on `afterDatasetDraw`.\r\n     * @private\r\n     */\n    drawDataset: function (meta, easingValue) {\n      var me = this;\n      var args = {\n        meta: meta,\n        index: meta.index,\n        easingValue: easingValue\n      };\n\n      if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n        return;\n      }\n\n      meta.controller.draw(easingValue);\n      core_plugins.notify(me, 'afterDatasetDraw', [args]);\n    },\n\n    /**\r\n     * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\r\n     * hook, in which case, plugins will not be called on `afterTooltipDraw`.\r\n     * @private\r\n     */\n    _drawTooltip: function (easingValue) {\n      var me = this;\n      var tooltip = me.tooltip;\n      var args = {\n        tooltip: tooltip,\n        easingValue: easingValue\n      };\n\n      if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n        return;\n      }\n\n      tooltip.draw();\n      core_plugins.notify(me, 'afterTooltipDraw', [args]);\n    },\n\n    /**\r\n     * Get the single element that was clicked on\r\n     * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\r\n     */\n    getElementAtEvent: function (e) {\n      return core_interaction.modes.single(this, e);\n    },\n    getElementsAtEvent: function (e) {\n      return core_interaction.modes.label(this, e, {\n        intersect: true\n      });\n    },\n    getElementsAtXAxis: function (e) {\n      return core_interaction.modes['x-axis'](this, e, {\n        intersect: true\n      });\n    },\n    getElementsAtEventForMode: function (e, mode, options) {\n      var method = core_interaction.modes[mode];\n\n      if (typeof method === 'function') {\n        return method(this, e, options);\n      }\n\n      return [];\n    },\n    getDatasetAtEvent: function (e) {\n      return core_interaction.modes.dataset(this, e, {\n        intersect: true\n      });\n    },\n    getDatasetMeta: function (datasetIndex) {\n      var me = this;\n      var dataset = me.data.datasets[datasetIndex];\n\n      if (!dataset._meta) {\n        dataset._meta = {};\n      }\n\n      var meta = dataset._meta[me.id];\n\n      if (!meta) {\n        meta = dataset._meta[me.id] = {\n          type: null,\n          data: [],\n          dataset: null,\n          controller: null,\n          hidden: null,\n          // See isDatasetVisible() comment\n          xAxisID: null,\n          yAxisID: null,\n          order: dataset.order || 0,\n          index: datasetIndex\n        };\n      }\n\n      return meta;\n    },\n    getVisibleDatasetCount: function () {\n      var count = 0;\n\n      for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n        if (this.isDatasetVisible(i)) {\n          count++;\n        }\n      }\n\n      return count;\n    },\n    isDatasetVisible: function (datasetIndex) {\n      var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n      // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\n      return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n    },\n    generateLegend: function () {\n      return this.options.legendCallback(this);\n    },\n\n    /**\r\n     * @private\r\n     */\n    destroyDatasetMeta: function (datasetIndex) {\n      var id = this.id;\n      var dataset = this.data.datasets[datasetIndex];\n      var meta = dataset._meta && dataset._meta[id];\n\n      if (meta) {\n        meta.controller.destroy();\n        delete dataset._meta[id];\n      }\n    },\n    destroy: function () {\n      var me = this;\n      var canvas = me.canvas;\n      var i, ilen;\n      me.stop(); // dataset controllers need to cleanup associated data\n\n      for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n        me.destroyDatasetMeta(i);\n      }\n\n      if (canvas) {\n        me.unbindEvents();\n        helpers$1.canvas.clear(me);\n        platform.releaseContext(me.ctx);\n        me.canvas = null;\n        me.ctx = null;\n      }\n\n      core_plugins.notify(me, 'destroy');\n      delete Chart.instances[me.id];\n    },\n    toBase64Image: function () {\n      return this.canvas.toDataURL.apply(this.canvas, arguments);\n    },\n    initToolTip: function () {\n      var me = this;\n      me.tooltip = new core_tooltip({\n        _chart: me,\n        _chartInstance: me,\n        // deprecated, backward compatibility\n        _data: me.data,\n        _options: me.options.tooltips\n      }, me);\n    },\n\n    /**\r\n     * @private\r\n     */\n    bindEvents: function () {\n      var me = this;\n      var listeners = me._listeners = {};\n\n      var listener = function () {\n        me.eventHandler.apply(me, arguments);\n      };\n\n      helpers$1.each(me.options.events, function (type) {\n        platform.addEventListener(me, type, listener);\n        listeners[type] = listener;\n      }); // Elements used to detect size change should not be injected for non responsive charts.\n      // See https://github.com/chartjs/Chart.js/issues/2210\n\n      if (me.options.responsive) {\n        listener = function () {\n          me.resize();\n        };\n\n        platform.addEventListener(me, 'resize', listener);\n        listeners.resize = listener;\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    unbindEvents: function () {\n      var me = this;\n      var listeners = me._listeners;\n\n      if (!listeners) {\n        return;\n      }\n\n      delete me._listeners;\n      helpers$1.each(listeners, function (listener, type) {\n        platform.removeEventListener(me, type, listener);\n      });\n    },\n    updateHoverStyle: function (elements, mode, enabled) {\n      var prefix = enabled ? 'set' : 'remove';\n      var element, i, ilen;\n\n      for (i = 0, ilen = elements.length; i < ilen; ++i) {\n        element = elements[i];\n\n        if (element) {\n          this.getDatasetMeta(element._datasetIndex).controller[prefix + 'HoverStyle'](element);\n        }\n      }\n\n      if (mode === 'dataset') {\n        this.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix + 'DatasetHoverStyle']();\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    eventHandler: function (e) {\n      var me = this;\n      var tooltip = me.tooltip;\n\n      if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {\n        return;\n      } // Buffer any update calls so that renders do not occur\n\n\n      me._bufferedRender = true;\n      me._bufferedRequest = null;\n      var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989\n      // the tooltip should be the source of change\n      // Animation check workaround:\n      // tooltip._start will be null when tooltip isn't animating\n\n      if (tooltip) {\n        changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);\n      }\n\n      core_plugins.notify(me, 'afterEvent', [e]);\n      var bufferedRequest = me._bufferedRequest;\n\n      if (bufferedRequest) {\n        // If we have an update that was triggered, we need to do a normal render\n        me.render(bufferedRequest);\n      } else if (changed && !me.animating) {\n        // If entering, leaving, or changing elements, animate the change via pivot\n        me.stop(); // We only need to render at this point. Updating will cause scales to be\n        // recomputed generating flicker & using more memory than necessary.\n\n        me.render({\n          duration: me.options.hover.animationDuration,\n          lazy: true\n        });\n      }\n\n      me._bufferedRender = false;\n      me._bufferedRequest = null;\n      return me;\n    },\n\n    /**\r\n     * Handle an event\r\n     * @private\r\n     * @param {IEvent} event the event to handle\r\n     * @return {boolean} true if the chart needs to re-render\r\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var options = me.options || {};\n      var hoverOptions = options.hover;\n      var changed = false;\n      me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips\n\n      if (e.type === 'mouseout') {\n        me.active = [];\n      } else {\n        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n      } // Invoke onHover hook\n      // Need to call with native event here to not break backwards compatibility\n\n\n      helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n      if (e.type === 'mouseup' || e.type === 'click') {\n        if (options.onClick) {\n          // Use e.native here for backwards compatibility\n          options.onClick.call(me, e.native, me.active);\n        }\n      } // Remove styling for last active (even if it may still be active)\n\n\n      if (me.lastActive.length) {\n        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n      } // Built in hover styling\n\n\n      if (me.active.length && hoverOptions.mode) {\n        me.updateHoverStyle(me.active, hoverOptions.mode, true);\n      }\n\n      changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives\n\n      me.lastActive = me.active;\n      return changed;\n    }\n  });\n  /**\r\n   * NOTE(SB) We actually don't use this container anymore but we need to keep it\r\n   * for backward compatibility. Though, it can still be useful for plugins that\r\n   * would need to work on multiple charts?!\r\n   */\n\n  Chart.instances = {};\n  var core_controller = Chart; // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, use Chart instead.\r\n   * @class Chart.Controller\r\n   * @deprecated since version 2.6\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  Chart.Controller = Chart;\n  /**\r\n   * Provided for backward compatibility, not available anymore.\r\n   * @namespace Chart\r\n   * @deprecated since version 2.8\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  Chart.types = {};\n  /**\r\n   * Provided for backward compatibility, not available anymore.\r\n   * @namespace Chart.helpers.configMerge\r\n   * @deprecated since version 2.8.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers$1.configMerge = mergeConfig;\n  /**\r\n   * Provided for backward compatibility, not available anymore.\r\n   * @namespace Chart.helpers.scaleMerge\r\n   * @deprecated since version 2.8.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  helpers$1.scaleMerge = mergeScaleConfig;\n\n  var core_helpers = function () {\n    // -- Basic js utility methods\n    helpers$1.where = function (collection, filterCallback) {\n      if (helpers$1.isArray(collection) && Array.prototype.filter) {\n        return collection.filter(filterCallback);\n      }\n\n      var filtered = [];\n      helpers$1.each(collection, function (item) {\n        if (filterCallback(item)) {\n          filtered.push(item);\n        }\n      });\n      return filtered;\n    };\n\n    helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {\n      return array.findIndex(callback, scope);\n    } : function (array, callback, scope) {\n      scope = scope === undefined ? array : scope;\n\n      for (var i = 0, ilen = array.length; i < ilen; ++i) {\n        if (callback.call(scope, array[i], i, array)) {\n          return i;\n        }\n      }\n\n      return -1;\n    };\n\n    helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {\n      // Default to start of the array\n      if (helpers$1.isNullOrUndef(startIndex)) {\n        startIndex = -1;\n      }\n\n      for (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n        var currentItem = arrayToSearch[i];\n\n        if (filterCallback(currentItem)) {\n          return currentItem;\n        }\n      }\n    };\n\n    helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {\n      // Default to end of the array\n      if (helpers$1.isNullOrUndef(startIndex)) {\n        startIndex = arrayToSearch.length;\n      }\n\n      for (var i = startIndex - 1; i >= 0; i--) {\n        var currentItem = arrayToSearch[i];\n\n        if (filterCallback(currentItem)) {\n          return currentItem;\n        }\n      }\n    }; // -- Math methods\n\n\n    helpers$1.isNumber = function (n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    };\n\n    helpers$1.almostEquals = function (x, y, epsilon) {\n      return Math.abs(x - y) < epsilon;\n    };\n\n    helpers$1.almostWhole = function (x, epsilon) {\n      var rounded = Math.round(x);\n      return rounded - epsilon <= x && rounded + epsilon >= x;\n    };\n\n    helpers$1.max = function (array) {\n      return array.reduce(function (max, value) {\n        if (!isNaN(value)) {\n          return Math.max(max, value);\n        }\n\n        return max;\n      }, Number.NEGATIVE_INFINITY);\n    };\n\n    helpers$1.min = function (array) {\n      return array.reduce(function (min, value) {\n        if (!isNaN(value)) {\n          return Math.min(min, value);\n        }\n\n        return min;\n      }, Number.POSITIVE_INFINITY);\n    };\n\n    helpers$1.sign = Math.sign ? function (x) {\n      return Math.sign(x);\n    } : function (x) {\n      x = +x; // convert to a number\n\n      if (x === 0 || isNaN(x)) {\n        return x;\n      }\n\n      return x > 0 ? 1 : -1;\n    };\n\n    helpers$1.toRadians = function (degrees) {\n      return degrees * (Math.PI / 180);\n    };\n\n    helpers$1.toDegrees = function (radians) {\n      return radians * (180 / Math.PI);\n    };\n    /**\r\n     * Returns the number of decimal places\r\n     * i.e. the number of digits after the decimal point, of the value of this Number.\r\n     * @param {number} x - A number.\r\n     * @returns {number} The number of decimal places.\r\n     * @private\r\n     */\n\n\n    helpers$1._decimalPlaces = function (x) {\n      if (!helpers$1.isFinite(x)) {\n        return;\n      }\n\n      var e = 1;\n      var p = 0;\n\n      while (Math.round(x * e) / e !== x) {\n        e *= 10;\n        p++;\n      }\n\n      return p;\n    }; // Gets the angle from vertical upright to the point about a centre.\n\n\n    helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {\n      var distanceFromXCenter = anglePoint.x - centrePoint.x;\n      var distanceFromYCenter = anglePoint.y - centrePoint.y;\n      var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n      var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n      if (angle < -0.5 * Math.PI) {\n        angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n      }\n\n      return {\n        angle: angle,\n        distance: radialDistanceFromCenter\n      };\n    };\n\n    helpers$1.distanceBetweenPoints = function (pt1, pt2) {\n      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n    };\n    /**\r\n     * Provided for backward compatibility, not available anymore\r\n     * @function Chart.helpers.aliasPixel\r\n     * @deprecated since version 2.8.0\r\n     * @todo remove at version 3\r\n     */\n\n\n    helpers$1.aliasPixel = function (pixelWidth) {\n      return pixelWidth % 2 === 0 ? 0 : 0.5;\n    };\n    /**\r\n     * Returns the aligned pixel value to avoid anti-aliasing blur\r\n     * @param {Chart} chart - The chart instance.\r\n     * @param {number} pixel - A pixel value.\r\n     * @param {number} width - The width of the element.\r\n     * @returns {number} The aligned pixel value.\r\n     * @private\r\n     */\n\n\n    helpers$1._alignPixel = function (chart, pixel, width) {\n      var devicePixelRatio = chart.currentDevicePixelRatio;\n      var halfWidth = width / 2;\n      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n    };\n\n    helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {\n      // Props to Rob Spencer at scaled innovation for his post on splining between points\n      // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n      // This function must also respect \"skipped\" points\n      var previous = firstPoint.skip ? middlePoint : firstPoint;\n      var current = middlePoint;\n      var next = afterPoint.skip ? middlePoint : afterPoint;\n      var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n      var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n      var s01 = d01 / (d01 + d12);\n      var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf\n\n      s01 = isNaN(s01) ? 0 : s01;\n      s12 = isNaN(s12) ? 0 : s12;\n      var fa = t * s01; // scaling factor for triangle Ta\n\n      var fb = t * s12;\n      return {\n        previous: {\n          x: current.x - fa * (next.x - previous.x),\n          y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n          x: current.x + fb * (next.x - previous.x),\n          y: current.y + fb * (next.y - previous.y)\n        }\n      };\n    };\n\n    helpers$1.EPSILON = Number.EPSILON || 1e-14;\n\n    helpers$1.splineCurveMonotone = function (points) {\n      // This function calculates Bzier control points in a similar way than |splineCurve|,\n      // but preserves monotonicity of the provided data and ensures no local extremums are added\n      // between the dataset discrete points due to the interpolation.\n      // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n      var pointsWithTangents = (points || []).map(function (point) {\n        return {\n          model: point._model,\n          deltaK: 0,\n          mK: 0\n        };\n      }); // Calculate slopes (deltaK) and initialize tangents (mK)\n\n      var pointsLen = pointsWithTangents.length;\n      var i, pointBefore, pointCurrent, pointAfter;\n\n      for (i = 0; i < pointsLen; ++i) {\n        pointCurrent = pointsWithTangents[i];\n\n        if (pointCurrent.model.skip) {\n          continue;\n        }\n\n        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\n        if (pointAfter && !pointAfter.model.skip) {\n          var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\n          pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n        }\n\n        if (!pointBefore || pointBefore.model.skip) {\n          pointCurrent.mK = pointCurrent.deltaK;\n        } else if (!pointAfter || pointAfter.model.skip) {\n          pointCurrent.mK = pointBefore.deltaK;\n        } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n          pointCurrent.mK = 0;\n        } else {\n          pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n        }\n      } // Adjust tangents to ensure monotonic properties\n\n\n      var alphaK, betaK, tauK, squaredMagnitude;\n\n      for (i = 0; i < pointsLen - 1; ++i) {\n        pointCurrent = pointsWithTangents[i];\n        pointAfter = pointsWithTangents[i + 1];\n\n        if (pointCurrent.model.skip || pointAfter.model.skip) {\n          continue;\n        }\n\n        if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n          pointCurrent.mK = pointAfter.mK = 0;\n          continue;\n        }\n\n        alphaK = pointCurrent.mK / pointCurrent.deltaK;\n        betaK = pointAfter.mK / pointCurrent.deltaK;\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\n        if (squaredMagnitude <= 9) {\n          continue;\n        }\n\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n        pointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n      } // Compute control points\n\n\n      var deltaX;\n\n      for (i = 0; i < pointsLen; ++i) {\n        pointCurrent = pointsWithTangents[i];\n\n        if (pointCurrent.model.skip) {\n          continue;\n        }\n\n        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\n        if (pointBefore && !pointBefore.model.skip) {\n          deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n          pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n          pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n        }\n\n        if (pointAfter && !pointAfter.model.skip) {\n          deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n          pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n          pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n        }\n      }\n    };\n\n    helpers$1.nextItem = function (collection, index, loop) {\n      if (loop) {\n        return index >= collection.length - 1 ? collection[0] : collection[index + 1];\n      }\n\n      return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n    };\n\n    helpers$1.previousItem = function (collection, index, loop) {\n      if (loop) {\n        return index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n      }\n\n      return index <= 0 ? collection[0] : collection[index - 1];\n    }; // Implementation of the nice number algorithm used in determining where axis labels will go\n\n\n    helpers$1.niceNum = function (range, round) {\n      var exponent = Math.floor(helpers$1.log10(range));\n      var fraction = range / Math.pow(10, exponent);\n      var niceFraction;\n\n      if (round) {\n        if (fraction < 1.5) {\n          niceFraction = 1;\n        } else if (fraction < 3) {\n          niceFraction = 2;\n        } else if (fraction < 7) {\n          niceFraction = 5;\n        } else {\n          niceFraction = 10;\n        }\n      } else if (fraction <= 1.0) {\n        niceFraction = 1;\n      } else if (fraction <= 2) {\n        niceFraction = 2;\n      } else if (fraction <= 5) {\n        niceFraction = 5;\n      } else {\n        niceFraction = 10;\n      }\n\n      return niceFraction * Math.pow(10, exponent);\n    }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n\n    helpers$1.requestAnimFrame = function () {\n      if (typeof window === 'undefined') {\n        return function (callback) {\n          callback();\n        };\n      }\n\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      };\n    }(); // -- DOM methods\n\n\n    helpers$1.getRelativePosition = function (evt, chart) {\n      var mouseX, mouseY;\n      var e = evt.originalEvent || evt;\n      var canvas = evt.target || evt.srcElement;\n      var boundingRect = canvas.getBoundingClientRect();\n      var touches = e.touches;\n\n      if (touches && touches.length > 0) {\n        mouseX = touches[0].clientX;\n        mouseY = touches[0].clientY;\n      } else {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n      } // Scale mouse coordinates into canvas coordinates\n      // by following the pattern laid out by 'jerryj' in the comments of\n      // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\n\n      var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\n      var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\n      var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\n      var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\n      var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n      var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n      // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\n      mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);\n      mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);\n      return {\n        x: mouseX,\n        y: mouseY\n      };\n    }; // Private helper function to convert max-width/max-height values that may be percentages into a number\n\n\n    function parseMaxStyle(styleValue, node, parentProperty) {\n      var valueInPixels;\n\n      if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n\n        if (styleValue.indexOf('%') !== -1) {\n          // percentage * size in dimension\n          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n      } else {\n        valueInPixels = styleValue;\n      }\n\n      return valueInPixels;\n    }\n    /**\r\n     * Returns if the given value contains an effective constraint.\r\n     * @private\r\n     */\n\n\n    function isConstrainedValue(value) {\n      return value !== undefined && value !== null && value !== 'none';\n    }\n    /**\r\n     * Returns the max width or height of the given DOM node in a cross-browser compatible fashion\r\n     * @param {HTMLElement} domNode - the node to check the constraint on\r\n     * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')\r\n     * @param {string} percentageProperty - property of parent to use when calculating width as a percentage\r\n     * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\r\n     */\n\n\n    function getConstraintDimension(domNode, maxStyle, percentageProperty) {\n      var view = document.defaultView;\n\n      var parentNode = helpers$1._getParentNode(domNode);\n\n      var constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n      var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n      var hasCNode = isConstrainedValue(constrainedNode);\n      var hasCContainer = isConstrainedValue(constrainedContainer);\n      var infinity = Number.POSITIVE_INFINITY;\n\n      if (hasCNode || hasCContainer) {\n        return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n      }\n\n      return 'none';\n    } // returns Number or undefined if no constraint\n\n\n    helpers$1.getConstraintWidth = function (domNode) {\n      return getConstraintDimension(domNode, 'max-width', 'clientWidth');\n    }; // returns Number or undefined if no constraint\n\n\n    helpers$1.getConstraintHeight = function (domNode) {\n      return getConstraintDimension(domNode, 'max-height', 'clientHeight');\n    };\n    /**\r\n     * @private\r\n    \t */\n\n\n    helpers$1._calculatePadding = function (container, padding, parentDimension) {\n      padding = helpers$1.getStyle(container, padding);\n      return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);\n    };\n    /**\r\n     * @private\r\n     */\n\n\n    helpers$1._getParentNode = function (domNode) {\n      var parent = domNode.parentNode;\n\n      if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n      }\n\n      return parent;\n    };\n\n    helpers$1.getMaximumWidth = function (domNode) {\n      var container = helpers$1._getParentNode(domNode);\n\n      if (!container) {\n        return domNode.clientWidth;\n      }\n\n      var clientWidth = container.clientWidth;\n\n      var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\n\n      var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\n\n      var w = clientWidth - paddingLeft - paddingRight;\n      var cw = helpers$1.getConstraintWidth(domNode);\n      return isNaN(cw) ? w : Math.min(w, cw);\n    };\n\n    helpers$1.getMaximumHeight = function (domNode) {\n      var container = helpers$1._getParentNode(domNode);\n\n      if (!container) {\n        return domNode.clientHeight;\n      }\n\n      var clientHeight = container.clientHeight;\n\n      var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);\n\n      var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);\n\n      var h = clientHeight - paddingTop - paddingBottom;\n      var ch = helpers$1.getConstraintHeight(domNode);\n      return isNaN(ch) ? h : Math.min(h, ch);\n    };\n\n    helpers$1.getStyle = function (el, property) {\n      return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n    };\n\n    helpers$1.retinaScale = function (chart, forceRatio) {\n      var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;\n\n      if (pixelRatio === 1) {\n        return;\n      }\n\n      var canvas = chart.canvas;\n      var height = chart.height;\n      var width = chart.width;\n      canvas.height = height * pixelRatio;\n      canvas.width = width * pixelRatio;\n      chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,\n      // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n      // See https://github.com/chartjs/Chart.js/issues/3575\n\n      if (!canvas.style.height && !canvas.style.width) {\n        canvas.style.height = height + 'px';\n        canvas.style.width = width + 'px';\n      }\n    }; // -- Canvas methods\n\n\n    helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {\n      return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n    };\n\n    helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {\n      cache = cache || {};\n      var data = cache.data = cache.data || {};\n      var gc = cache.garbageCollect = cache.garbageCollect || [];\n\n      if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n      }\n\n      ctx.font = font;\n      var longest = 0;\n      var ilen = arrayOfThings.length;\n      var i, j, jlen, thing, nestedThing;\n\n      for (i = 0; i < ilen; i++) {\n        thing = arrayOfThings[i]; // Undefined strings and arrays should not be measured\n\n        if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {\n          longest = helpers$1.measureText(ctx, data, gc, longest, thing);\n        } else if (helpers$1.isArray(thing)) {\n          // if it is an array lets measure each element\n          // to do maybe simplify this function a bit so we can do this more recursively?\n          for (j = 0, jlen = thing.length; j < jlen; j++) {\n            nestedThing = thing[j]; // Undefined strings and arrays should not be measured\n\n            if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\n              longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\n            }\n          }\n        }\n      }\n\n      var gcLen = gc.length / 2;\n\n      if (gcLen > arrayOfThings.length) {\n        for (i = 0; i < gcLen; i++) {\n          delete data[gc[i]];\n        }\n\n        gc.splice(0, gcLen);\n      }\n\n      return longest;\n    };\n\n    helpers$1.measureText = function (ctx, data, gc, longest, string) {\n      var textWidth = data[string];\n\n      if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n      }\n\n      if (textWidth > longest) {\n        longest = textWidth;\n      }\n\n      return longest;\n    };\n    /**\r\n     * @deprecated\r\n     */\n\n\n    helpers$1.numberOfLabelLines = function (arrayOfThings) {\n      var numberOfLines = 1;\n      helpers$1.each(arrayOfThings, function (thing) {\n        if (helpers$1.isArray(thing)) {\n          if (thing.length > numberOfLines) {\n            numberOfLines = thing.length;\n          }\n        }\n      });\n      return numberOfLines;\n    };\n\n    helpers$1.color = !chartjsColor ? function (value) {\n      console.error('Color.js not found!');\n      return value;\n    } : function (value) {\n      /* global CanvasGradient */\n      if (value instanceof CanvasGradient) {\n        value = core_defaults.global.defaultColor;\n      }\n\n      return chartjsColor(value);\n    };\n\n    helpers$1.getHoverColor = function (colorValue) {\n      /* global CanvasPattern */\n      return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n    };\n  };\n\n  function abstract() {\n    throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');\n  }\n  /**\r\n   * Date adapter (current used by the time scale)\r\n   * @namespace Chart._adapters._date\r\n   * @memberof Chart._adapters\r\n   * @private\r\n   */\n\n  /**\r\n   * Currently supported unit string values.\r\n   * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\r\n   * @memberof Chart._adapters._date\r\n   * @name Unit\r\n   */\n\n  /**\r\n   * @class\r\n   */\n\n\n  function DateAdapter(options) {\n    this.options = options || {};\n  }\n\n  helpers$1.extend(DateAdapter.prototype,\n  /** @lends DateAdapter */\n  {\n    /**\r\n     * Returns a map of time formats for the supported formatting units defined\r\n     * in Unit as well as 'datetime' representing a detailed date/time string.\r\n     * @returns {{string: string}}\r\n     */\n    formats: abstract,\n\n    /**\r\n     * Parses the given `value` and return the associated timestamp.\r\n     * @param {any} value - the value to parse (usually comes from the data)\r\n     * @param {string} [format] - the expected data format\r\n     * @returns {(number|null)}\r\n     * @function\r\n     */\n    parse: abstract,\n\n    /**\r\n     * Returns the formatted date in the specified `format` for a given `timestamp`.\r\n     * @param {number} timestamp - the timestamp to format\r\n     * @param {string} format - the date/time token\r\n     * @return {string}\r\n     * @function\r\n     */\n    format: abstract,\n\n    /**\r\n     * Adds the specified `amount` of `unit` to the given `timestamp`.\r\n     * @param {number} timestamp - the input timestamp\r\n     * @param {number} amount - the amount to add\r\n     * @param {Unit} unit - the unit as string\r\n     * @return {number}\r\n     * @function\r\n     */\n    add: abstract,\n\n    /**\r\n     * Returns the number of `unit` between the given timestamps.\r\n     * @param {number} max - the input timestamp (reference)\r\n     * @param {number} min - the timestamp to substract\r\n     * @param {Unit} unit - the unit as string\r\n     * @return {number}\r\n     * @function\r\n     */\n    diff: abstract,\n\n    /**\r\n     * Returns start of `unit` for the given `timestamp`.\r\n     * @param {number} timestamp - the input timestamp\r\n     * @param {Unit} unit - the unit as string\r\n     * @param {number} [weekday] - the ISO day of the week with 1 being Monday\r\n     * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\r\n     * @function\r\n     */\n    startOf: abstract,\n\n    /**\r\n     * Returns end of `unit` for the given `timestamp`.\r\n     * @param {number} timestamp - the input timestamp\r\n     * @param {Unit} unit - the unit as string\r\n     * @function\r\n     */\n    endOf: abstract,\n    // DEPRECATIONS\n\n    /**\r\n     * Provided for backward compatibility for scale.getValueForPixel(),\r\n     * this method should be overridden only by the moment adapter.\r\n     * @deprecated since version 2.8.0\r\n     * @todo remove at version 3\r\n     * @private\r\n     */\n    _create: function (value) {\n      return value;\n    }\n  });\n\n  DateAdapter.override = function (members) {\n    helpers$1.extend(DateAdapter.prototype, members);\n  };\n\n  var _date = DateAdapter;\n  var core_adapters = {\n    _date: _date\n  };\n  /**\r\n   * Namespace to hold static tick generation functions\r\n   * @namespace Chart.Ticks\r\n   */\n\n  var core_ticks = {\n    /**\r\n     * Namespace to hold formatters for different types of ticks\r\n     * @namespace Chart.Ticks.formatters\r\n     */\n    formatters: {\n      /**\r\n       * Formatter for value labels\r\n       * @method Chart.Ticks.formatters.values\r\n       * @param value the value to display\r\n       * @return {string|string[]} the label to display\r\n       */\n      values: function (value) {\n        return helpers$1.isArray(value) ? value : '' + value;\n      },\n\n      /**\r\n       * Formatter for linear numeric ticks\r\n       * @method Chart.Ticks.formatters.linear\r\n       * @param tickValue {number} the value to be formatted\r\n       * @param index {number} the position of the tickValue parameter in the ticks array\r\n       * @param ticks {number[]} the list of ticks being converted\r\n       * @return {string} string representation of the tickValue parameter\r\n       */\n      linear: function (tickValue, index, ticks) {\n        // If we have lots of ticks, don't use the ones\n        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\n        if (Math.abs(delta) > 1) {\n          if (tickValue !== Math.floor(tickValue)) {\n            // not an integer\n            delta = tickValue - Math.floor(tickValue);\n          }\n        }\n\n        var logDelta = helpers$1.log10(Math.abs(delta));\n        var tickString = '';\n\n        if (tickValue !== 0) {\n          var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n\n          if (maxTick < 1e-4) {\n            // all ticks are small numbers; use scientific notation\n            var logTick = helpers$1.log10(Math.abs(tickValue));\n            var numExponential = Math.floor(logTick) - Math.floor(logDelta);\n            numExponential = Math.max(Math.min(numExponential, 20), 0);\n            tickString = tickValue.toExponential(numExponential);\n          } else {\n            var numDecimal = -1 * Math.floor(logDelta);\n            numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\n            tickString = tickValue.toFixed(numDecimal);\n          }\n        } else {\n          tickString = '0'; // never show decimal places for 0\n        }\n\n        return tickString;\n      },\n      logarithmic: function (tickValue, index, ticks) {\n        var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));\n\n        if (tickValue === 0) {\n          return '0';\n        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n          return tickValue.toExponential();\n        }\n\n        return '';\n      }\n    }\n  };\n  var isArray = helpers$1.isArray;\n  var isNullOrUndef = helpers$1.isNullOrUndef;\n  var valueOrDefault$a = helpers$1.valueOrDefault;\n  var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\n\n  core_defaults._set('scale', {\n    display: true,\n    position: 'left',\n    offset: false,\n    // grid line settings\n    gridLines: {\n      display: true,\n      color: 'rgba(0,0,0,0.1)',\n      lineWidth: 1,\n      drawBorder: true,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickMarkLength: 10,\n      zeroLineWidth: 1,\n      zeroLineColor: 'rgba(0,0,0,0.25)',\n      zeroLineBorderDash: [],\n      zeroLineBorderDashOffset: 0.0,\n      offsetGridLines: false,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n    // scale label\n    scaleLabel: {\n      // display property\n      display: false,\n      // actual label\n      labelString: '',\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    // label settings\n    ticks: {\n      beginAtZero: false,\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      padding: 0,\n      reverse: false,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 0,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: core_ticks.formatters.values,\n      minor: {},\n      major: {}\n    }\n  });\n  /** Returns a new array containing numItems from arr */\n\n\n  function sample(arr, numItems) {\n    var result = [];\n    var increment = arr.length / numItems;\n    var i = 0;\n    var len = arr.length;\n\n    for (; i < len; i += increment) {\n      result.push(arr[Math.floor(i)]);\n    }\n\n    return result;\n  }\n\n  function getPixelForGridLine(scale, index, offsetGridLines) {\n    var length = scale.getTicks().length;\n    var validIndex = Math.min(index, length - 1);\n    var lineValue = scale.getPixelForTick(validIndex);\n    var start = scale._startPixel;\n    var end = scale._endPixel;\n    var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n\n    var offset;\n\n    if (offsetGridLines) {\n      if (length === 1) {\n        offset = Math.max(lineValue - start, end - lineValue);\n      } else if (index === 0) {\n        offset = (scale.getPixelForTick(1) - lineValue) / 2;\n      } else {\n        offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n      }\n\n      lineValue += validIndex < index ? offset : -offset; // Return undefined if the pixel is out of the range\n\n      if (lineValue < start - epsilon || lineValue > end + epsilon) {\n        return;\n      }\n    }\n\n    return lineValue;\n  }\n\n  function garbageCollect(caches, length) {\n    helpers$1.each(caches, function (cache) {\n      var gc = cache.gc;\n      var gcLen = gc.length / 2;\n      var i;\n\n      if (gcLen > length) {\n        for (i = 0; i < gcLen; ++i) {\n          delete cache.data[gc[i]];\n        }\n\n        gc.splice(0, gcLen);\n      }\n    });\n  }\n  /**\r\n   * Returns {width, height, offset} objects for the first, last, widest, highest tick\r\n   * labels where offset indicates the anchor point offset from the top in pixels.\r\n   */\n\n\n  function computeLabelSizes(ctx, tickFonts, ticks, caches) {\n    var length = ticks.length;\n    var widths = [];\n    var heights = [];\n    var offsets = [];\n    var widestLabelSize = 0;\n    var highestLabelSize = 0;\n    var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;\n\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {\n        data: {},\n        gc: []\n      };\n      lineHeight = tickFont.lineHeight;\n      width = height = 0; // Undefined labels and arrays should not be measured\n\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j]; // Undefined labels and arrays should not be measured\n\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n\n      widths.push(width);\n      heights.push(height);\n      offsets.push(lineHeight / 2);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n\n    garbageCollect(caches, length);\n    widest = widths.indexOf(widestLabelSize);\n    highest = heights.indexOf(highestLabelSize);\n\n    function valueAt(idx) {\n      return {\n        width: widths[idx] || 0,\n        height: heights[idx] || 0,\n        offset: offsets[idx] || 0\n      };\n    }\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest)\n    };\n  }\n\n  function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickMarkLength : 0;\n  }\n\n  function getScaleLabelHeight(options) {\n    var font, padding;\n\n    if (!options.display) {\n      return 0;\n    }\n\n    font = helpers$1.options._parseFont(options);\n    padding = helpers$1.options.toPadding(options.padding);\n    return font.lineHeight + padding.height;\n  }\n\n  function parseFontOptions(options, nestedOpts) {\n    return helpers$1.extend(helpers$1.options._parseFont({\n      fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),\n      fontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),\n      fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),\n      lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight)\n    }), {\n      color: helpers$1.options.resolve([nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor])\n    });\n  }\n\n  function parseTickFontOptions(options) {\n    var minor = parseFontOptions(options, options.minor);\n    var major = options.major.enabled ? parseFontOptions(options, options.major) : minor;\n    return {\n      minor: minor,\n      major: major\n    };\n  }\n\n  function nonSkipped(ticksToFilter) {\n    var filtered = [];\n    var item, index, len;\n\n    for (index = 0, len = ticksToFilter.length; index < len; ++index) {\n      item = ticksToFilter[index];\n\n      if (typeof item._index !== 'undefined') {\n        filtered.push(item);\n      }\n    }\n\n    return filtered;\n  }\n\n  function getEvenSpacing(arr) {\n    var len = arr.length;\n    var i, diff;\n\n    if (len < 2) {\n      return false;\n    }\n\n    for (diff = arr[0], i = 1; i < len; ++i) {\n      if (arr[i] - arr[i - 1] !== diff) {\n        return false;\n      }\n    }\n\n    return diff;\n  }\n\n  function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {\n    var evenMajorSpacing = getEvenSpacing(majorIndices);\n    var spacing = (ticks.length - 1) / ticksLimit;\n    var factors, factor, i, ilen; // If the major ticks are evenly spaced apart, place the minor ticks\n    // so that they divide the major ticks into even chunks\n\n    if (!evenMajorSpacing) {\n      return Math.max(spacing, 1);\n    }\n\n    factors = helpers$1.math._factorize(evenMajorSpacing);\n\n    for (i = 0, ilen = factors.length - 1; i < ilen; i++) {\n      factor = factors[i];\n\n      if (factor > spacing) {\n        return factor;\n      }\n    }\n\n    return Math.max(spacing, 1);\n  }\n\n  function getMajorIndices(ticks) {\n    var result = [];\n    var i, ilen;\n\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (ticks[i].major) {\n        result.push(i);\n      }\n    }\n\n    return result;\n  }\n\n  function skipMajors(ticks, majorIndices, spacing) {\n    var count = 0;\n    var next = majorIndices[0];\n    var i, tick;\n    spacing = Math.ceil(spacing);\n\n    for (i = 0; i < ticks.length; i++) {\n      tick = ticks[i];\n\n      if (i === next) {\n        tick._index = i;\n        count++;\n        next = majorIndices[count * spacing];\n      } else {\n        delete tick.label;\n      }\n    }\n  }\n\n  function skip(ticks, spacing, majorStart, majorEnd) {\n    var start = valueOrDefault$a(majorStart, 0);\n    var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);\n    var count = 0;\n    var length, i, tick, next;\n    spacing = Math.ceil(spacing);\n\n    if (majorEnd) {\n      length = majorEnd - majorStart;\n      spacing = length / Math.floor(length / spacing);\n    }\n\n    next = start;\n\n    while (next < 0) {\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n\n    for (i = Math.max(start, 0); i < end; i++) {\n      tick = ticks[i];\n\n      if (i === next) {\n        tick._index = i;\n        count++;\n        next = Math.round(start + count * spacing);\n      } else {\n        delete tick.label;\n      }\n    }\n  }\n\n  var Scale = core_element.extend({\n    zeroLineIndex: 0,\n\n    /**\r\n     * Get the padding needed for the scale\r\n     * @method getPadding\r\n     * @private\r\n     * @returns {Padding} the necessary padding\r\n     */\n    getPadding: function () {\n      var me = this;\n      return {\n        left: me.paddingLeft || 0,\n        top: me.paddingTop || 0,\n        right: me.paddingRight || 0,\n        bottom: me.paddingBottom || 0\n      };\n    },\n\n    /**\r\n     * Returns the scale tick objects ({label, major})\r\n     * @since 2.7\r\n     */\n    getTicks: function () {\n      return this._ticks;\n    },\n\n    /**\r\n    * @private\r\n    */\n    _getLabels: function () {\n      var data = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    },\n    // These methods are ordered by lifecyle. Utilities then follow.\n    // Any function defined here is inherited by all scale types.\n    // Any function can be extended by the scale type\n\n    /**\r\n     * Provided for backward compatibility, not available anymore\r\n     * @function Chart.Scale.mergeTicksOptions\r\n     * @deprecated since version 2.8.0\r\n     * @todo remove at version 3\r\n     */\n    mergeTicksOptions: function () {// noop\n    },\n    beforeUpdate: function () {\n      helpers$1.callback(this.options.beforeUpdate, [this]);\n    },\n\n    /**\r\n     * @param {number} maxWidth - the max width in pixels\r\n     * @param {number} maxHeight - the max height in pixels\r\n     * @param {object} margins - the space between the edge of the other scales and edge of the chart\r\n     *   This space comes from two sources:\r\n     *     - padding - space that's required to show the labels at the edges of the scale\r\n     *     - thickness of scales or legends in another orientation\r\n     */\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var sampleSize = tickOpts.sampleSize;\n      var i, ilen, labels, ticks, samplingEnabled; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = helpers$1.extend({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, margins);\n      me._ticks = null;\n      me.ticks = null;\n      me._labelSizes = null;\n      me._maxLabelLines = 0;\n      me.longestLabelWidth = 0;\n      me.longestTextCache = me.longestTextCache || {};\n      me._gridLineItems = null;\n      me._labelItems = null; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Data min/max\n\n      me.beforeDataLimits();\n      me.determineDataLimits();\n      me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!\n      // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n      // and must not be accessed directly from outside this class. `this.ticks` being\n      // around for long time and not marked as private, we can't change its structure\n      // without unexpected breaking changes. If you need to access the scale ticks,\n      // use scale.getTicks() instead.\n\n      me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,\n      // we still support no return (`this.ticks` internally set by calling this method).\n\n      ticks = me.buildTicks() || []; // Allow modification of ticks in callback.\n\n      ticks = me.afterBuildTicks(ticks) || ticks; // Ensure ticks contains ticks in new tick format\n\n      if ((!ticks || !ticks.length) && me.ticks) {\n        ticks = [];\n\n        for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {\n          ticks.push({\n            value: me.ticks[i],\n            major: false\n          });\n        }\n      }\n\n      me._ticks = ticks; // Compute tick rotation and fit using a sampled subset of labels\n      // We generally don't need to compute the size of every single label for determining scale size\n\n      samplingEnabled = sampleSize < ticks.length;\n      labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks); // _configure is called twice, once here, once from core.controller.updateLayout.\n      // Here we haven't been positioned yet, but dimensions are correct.\n      // Variables set in _configure are needed for calculateTickRotation, and\n      // it's ok that coordinates are not correct there, only dimensions matter.\n\n      me._configure(); // Tick Rotation\n\n\n      me.beforeCalculateTickRotation();\n      me.calculateTickRotation();\n      me.afterCalculateTickRotation();\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); // Auto-skip\n\n      me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto') ? me._autoSkip(ticks) : ticks;\n\n      if (samplingEnabled) {\n        // Generate labels using all non-skipped ticks\n        labels = me._convertTicksToLabels(me._ticksToDraw);\n      }\n\n      me.ticks = labels; // BACKWARD COMPATIBILITY\n      // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n      me.afterUpdate(); // TODO(v3): remove minSize as a public property and return value from all layout boxes. It is unused\n      // make maxWidth and maxHeight private\n\n      return me.minSize;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _configure: function () {\n      var me = this;\n      var reversePixels = me.options.ticks.reverse;\n      var startPixel, endPixel;\n\n      if (me.isHorizontal()) {\n        startPixel = me.left;\n        endPixel = me.right;\n      } else {\n        startPixel = me.top;\n        endPixel = me.bottom; // by default vertical scales are from bottom to top, so pixels are reversed\n\n        reversePixels = !reversePixels;\n      }\n\n      me._startPixel = startPixel;\n      me._endPixel = endPixel;\n      me._reversePixels = reversePixels;\n      me._length = endPixel - startPixel;\n    },\n    afterUpdate: function () {\n      helpers$1.callback(this.options.afterUpdate, [this]);\n    },\n    //\n    beforeSetDimensions: function () {\n      helpers$1.callback(this.options.beforeSetDimensions, [this]);\n    },\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0;\n    },\n    afterSetDimensions: function () {\n      helpers$1.callback(this.options.afterSetDimensions, [this]);\n    },\n    // Data limits\n    beforeDataLimits: function () {\n      helpers$1.callback(this.options.beforeDataLimits, [this]);\n    },\n    determineDataLimits: helpers$1.noop,\n    afterDataLimits: function () {\n      helpers$1.callback(this.options.afterDataLimits, [this]);\n    },\n    //\n    beforeBuildTicks: function () {\n      helpers$1.callback(this.options.beforeBuildTicks, [this]);\n    },\n    buildTicks: helpers$1.noop,\n    afterBuildTicks: function (ticks) {\n      var me = this; // ticks is empty for old axis implementations here\n\n      if (isArray(ticks) && ticks.length) {\n        return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);\n      } // Support old implementations (that modified `this.ticks` directly in buildTicks)\n\n\n      me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;\n      return ticks;\n    },\n    beforeTickToLabelConversion: function () {\n      helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);\n    },\n    convertTicksToLabels: function () {\n      var me = this; // Convert ticks to strings\n\n      var tickOpts = me.options.ticks;\n      me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n    },\n    afterTickToLabelConversion: function () {\n      helpers$1.callback(this.options.afterTickToLabelConversion, [this]);\n    },\n    //\n    beforeCalculateTickRotation: function () {\n      helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\n    },\n    calculateTickRotation: function () {\n      var me = this;\n      var options = me.options;\n      var tickOpts = options.ticks;\n      var numTicks = me.getTicks().length;\n      var minRotation = tickOpts.minRotation || 0;\n      var maxRotation = tickOpts.maxRotation;\n      var labelRotation = minRotation;\n      var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;\n\n      if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\n        me.labelRotation = minRotation;\n        return;\n      }\n\n      labelSizes = me._getLabelSizes();\n      maxLabelWidth = labelSizes.widest.width;\n      maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset; // Estimate the width of each grid based on the canvas width, the maximum\n      // label width and the number of tick intervals\n\n      maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);\n      tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1); // Allow 3 pixels x2 padding either side for label readability\n\n      if (maxLabelWidth + 6 > tickWidth) {\n        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n        maxHeight = me.maxHeight - getTickMarkLength(options.gridLines) - tickOpts.padding - getScaleLabelHeight(options.scaleLabel);\n        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n        labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));\n        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n      }\n\n      me.labelRotation = labelRotation;\n    },\n    afterCalculateTickRotation: function () {\n      helpers$1.callback(this.options.afterCalculateTickRotation, [this]);\n    },\n    //\n    beforeFit: function () {\n      helpers$1.callback(this.options.beforeFit, [this]);\n    },\n    fit: function () {\n      var me = this; // Reset\n\n      var minSize = me.minSize = {\n        width: 0,\n        height: 0\n      };\n      var chart = me.chart;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var scaleLabelOpts = opts.scaleLabel;\n      var gridLineOpts = opts.gridLines;\n\n      var display = me._isVisible();\n\n      var isBottom = opts.position === 'bottom';\n      var isHorizontal = me.isHorizontal(); // Width\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth;\n      } else if (display) {\n        minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\n      } // height\n\n\n      if (!isHorizontal) {\n        minSize.height = me.maxHeight; // fill all the height\n      } else if (display) {\n        minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\n      } // Don't bother fitting the ticks if we are not showing the labels\n\n\n      if (tickOpts.display && display) {\n        var tickFonts = parseTickFontOptions(tickOpts);\n\n        var labelSizes = me._getLabelSizes();\n\n        var firstLabelSize = labelSizes.first;\n        var lastLabelSize = labelSizes.last;\n        var widestLabelSize = labelSizes.widest;\n        var highestLabelSize = labelSizes.highest;\n        var lineSpace = tickFonts.minor.lineHeight * 0.4;\n        var tickPadding = tickOpts.padding;\n\n        if (isHorizontal) {\n          // A horizontal axis is more constrained by the height.\n          var isRotated = me.labelRotation !== 0;\n          var angleRadians = helpers$1.toRadians(me.labelRotation);\n          var cosRotation = Math.cos(angleRadians);\n          var sinRotation = Math.sin(angleRadians);\n          var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace); // padding\n\n          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n          var offsetLeft = me.getPixelForTick(0) - me.left;\n          var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);\n          var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n          // which means that the right padding is dominated by the font height\n\n          if (isRotated) {\n            paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);\n            paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;\n          } else {\n            paddingLeft = firstLabelSize.width / 2;\n            paddingRight = lastLabelSize.width / 2;\n          } // Adjust padding taking into account changes in offsets\n          // and add 3 px to move away from canvas edges\n\n\n          me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;\n          me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;\n        } else {\n          // A vertical axis is more constrained by the width. Labels are the\n          // dominant factor here, so get that length first and account for padding\n          var labelWidth = tickOpts.mirror ? 0 : // use lineSpace for consistency with horizontal axis\n          // tickPadding is not implemented for horizontal\n          widestLabelSize.width + tickPadding + lineSpace;\n          minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);\n          me.paddingTop = firstLabelSize.height / 2;\n          me.paddingBottom = lastLabelSize.height / 2;\n        }\n      }\n\n      me.handleMargins();\n\n      if (isHorizontal) {\n        me.width = me._length = chart.width - me.margins.left - me.margins.right;\n        me.height = minSize.height;\n      } else {\n        me.width = minSize.width;\n        me.height = me._length = chart.height - me.margins.top - me.margins.bottom;\n      }\n    },\n\n    /**\r\n     * Handle margins and padding interactions\r\n     * @private\r\n     */\n    handleMargins: function () {\n      var me = this;\n\n      if (me.margins) {\n        me.margins.left = Math.max(me.paddingLeft, me.margins.left);\n        me.margins.top = Math.max(me.paddingTop, me.margins.top);\n        me.margins.right = Math.max(me.paddingRight, me.margins.right);\n        me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);\n      }\n    },\n    afterFit: function () {\n      helpers$1.callback(this.options.afterFit, [this]);\n    },\n    // Shared Methods\n    isHorizontal: function () {\n      var pos = this.options.position;\n      return pos === 'top' || pos === 'bottom';\n    },\n    isFullWidth: function () {\n      return this.options.fullWidth;\n    },\n    // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n    getRightValue: function (rawValue) {\n      // Null and undefined values first\n      if (isNullOrUndef(rawValue)) {\n        return NaN;\n      } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\n\n      if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\n        return NaN;\n      } // If it is in fact an object, dive in one more level\n\n\n      if (rawValue) {\n        if (this.isHorizontal()) {\n          if (rawValue.x !== undefined) {\n            return this.getRightValue(rawValue.x);\n          }\n        } else if (rawValue.y !== undefined) {\n          return this.getRightValue(rawValue.y);\n        }\n      } // Value is good, return it\n\n\n      return rawValue;\n    },\n    _convertTicksToLabels: function (ticks) {\n      var me = this;\n      var labels, i, ilen;\n      me.ticks = ticks.map(function (tick) {\n        return tick.value;\n      });\n      me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD\n      // COMPAT, we still support no return (`this.ticks` internally changed by calling\n      // this method and supposed to contain only string values).\n\n      labels = me.convertTicksToLabels(ticks) || me.ticks;\n      me.afterTickToLabelConversion(); // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        ticks[i].label = labels[i];\n      }\n\n      return labels;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getLabelSizes: function () {\n      var me = this;\n      var labelSizes = me._labelSizes;\n\n      if (!labelSizes) {\n        me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);\n        me.longestLabelWidth = labelSizes.widest.width;\n      }\n\n      return labelSizes;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _parseValue: function (value) {\n      var start, end, min, max;\n\n      if (isArray(value)) {\n        start = +this.getRightValue(value[0]);\n        end = +this.getRightValue(value[1]);\n        min = Math.min(start, end);\n        max = Math.max(start, end);\n      } else {\n        value = +this.getRightValue(value);\n        start = undefined;\n        end = value;\n        min = value;\n        max = value;\n      }\n\n      return {\n        min: min,\n        max: max,\n        start: start,\n        end: end\n      };\n    },\n\n    /**\r\n    * @private\r\n    */\n    _getScaleLabel: function (rawValue) {\n      var v = this._parseValue(rawValue);\n\n      if (v.start !== undefined) {\n        return '[' + v.start + ', ' + v.end + ']';\n      }\n\n      return +this.getRightValue(rawValue);\n    },\n\n    /**\r\n     * Used to get the value to display in the tooltip for the data at the given index\r\n     * @param index\r\n     * @param datasetIndex\r\n     */\n    getLabelForIndex: helpers$1.noop,\n\n    /**\r\n     * Returns the location of the given data point. Value can either be an index or a numerical value\r\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n     * @param value\r\n     * @param index\r\n     * @param datasetIndex\r\n     */\n    getPixelForValue: helpers$1.noop,\n\n    /**\r\n     * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\r\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n     * @param pixel\r\n     */\n    getValueForPixel: helpers$1.noop,\n\n    /**\r\n     * Returns the location of the tick at the given index\r\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n     */\n    getPixelForTick: function (index) {\n      var me = this;\n      var offset = me.options.offset;\n      var numTicks = me._ticks.length;\n      var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);\n      return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));\n    },\n\n    /**\r\n     * Utility for getting the pixel location of a percentage of scale\r\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n     */\n    getPixelForDecimal: function (decimal) {\n      var me = this;\n\n      if (me._reversePixels) {\n        decimal = 1 - decimal;\n      }\n\n      return me._startPixel + decimal * me._length;\n    },\n    getDecimalForPixel: function (pixel) {\n      var decimal = (pixel - this._startPixel) / this._length;\n      return this._reversePixels ? 1 - decimal : decimal;\n    },\n\n    /**\r\n     * Returns the pixel for the minimum chart value\r\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n     */\n    getBasePixel: function () {\n      return this.getPixelForValue(this.getBaseValue());\n    },\n    getBaseValue: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    },\n\n    /**\r\n     * Returns a subset of ticks to be plotted to avoid overlapping labels.\r\n     * @private\r\n     */\n    _autoSkip: function (ticks) {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var axisLength = me._length;\n      var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;\n      var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n      var numMajorIndices = majorIndices.length;\n      var first = majorIndices[0];\n      var last = majorIndices[numMajorIndices - 1];\n      var i, ilen, spacing, avgMajorSpacing; // If there are too many major ticks to display them all\n\n      if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);\n        return nonSkipped(ticks);\n      }\n\n      spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);\n\n      if (numMajorIndices > 0) {\n        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n          skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n\n        avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;\n        skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return nonSkipped(ticks);\n      }\n\n      skip(ticks, spacing);\n      return nonSkipped(ticks);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _tickSize: function () {\n      var me = this;\n      var optionTicks = me.options.ticks; // Calculate space needed by label in axis direction.\n\n      var rot = helpers$1.toRadians(me.labelRotation);\n      var cos = Math.abs(Math.cos(rot));\n      var sin = Math.abs(Math.sin(rot));\n\n      var labelSizes = me._getLabelSizes();\n\n      var padding = optionTicks.autoSkipPadding || 0;\n      var w = labelSizes ? labelSizes.widest.width + padding : 0;\n      var h = labelSizes ? labelSizes.highest.height + padding : 0; // Calculate space needed for 1 tick in axis direction.\n\n      return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _isVisible: function () {\n      var me = this;\n      var chart = me.chart;\n      var display = me.options.display;\n      var i, ilen, meta;\n\n      if (display !== 'auto') {\n        return !!display;\n      } // When 'auto', the scale is visible if at least one associated dataset is visible.\n\n\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n\n          if (meta.xAxisID === me.id || meta.yAxisID === me.id) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _computeGridLineItems: function (chartArea) {\n      var me = this;\n      var chart = me.chart;\n      var options = me.options;\n      var gridLines = options.gridLines;\n      var position = options.position;\n      var offsetGridLines = gridLines.offsetGridLines;\n      var isHorizontal = me.isHorizontal();\n      var ticks = me._ticksToDraw;\n      var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);\n      var tl = getTickMarkLength(gridLines);\n      var items = [];\n      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n      var axisHalfWidth = axisWidth / 2;\n      var alignPixel = helpers$1._alignPixel;\n\n      var alignBorderValue = function (pixel) {\n        return alignPixel(chart, pixel, axisWidth);\n      };\n\n      var borderValue, i, tick, lineValue, alignedLineValue;\n      var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;\n\n      if (position === 'top') {\n        borderValue = alignBorderValue(me.bottom);\n        ty1 = me.bottom - tl;\n        ty2 = borderValue - axisHalfWidth;\n        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n        y2 = chartArea.bottom;\n      } else if (position === 'bottom') {\n        borderValue = alignBorderValue(me.top);\n        y1 = chartArea.top;\n        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n        ty1 = borderValue + axisHalfWidth;\n        ty2 = me.top + tl;\n      } else if (position === 'left') {\n        borderValue = alignBorderValue(me.right);\n        tx1 = me.right - tl;\n        tx2 = borderValue - axisHalfWidth;\n        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n        x2 = chartArea.right;\n      } else {\n        borderValue = alignBorderValue(me.left);\n        x1 = chartArea.left;\n        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n        tx1 = borderValue + axisHalfWidth;\n        tx2 = me.left + tl;\n      }\n\n      for (i = 0; i < ticksLength; ++i) {\n        tick = ticks[i] || {}; // autoskipper skipped this tick (#4635)\n\n        if (isNullOrUndef(tick.label) && i < ticks.length) {\n          continue;\n        }\n\n        if (i === me.zeroLineIndex && options.offset === offsetGridLines) {\n          // Draw the first index specially\n          lineWidth = gridLines.zeroLineWidth;\n          lineColor = gridLines.zeroLineColor;\n          borderDash = gridLines.zeroLineBorderDash || [];\n          borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\n        } else {\n          lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);\n          lineColor = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');\n          borderDash = gridLines.borderDash || [];\n          borderDashOffset = gridLines.borderDashOffset || 0.0;\n        }\n\n        lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines); // Skip if the pixel is out of the range\n\n        if (lineValue === undefined) {\n          continue;\n        }\n\n        alignedLineValue = alignPixel(chart, lineValue, lineWidth);\n\n        if (isHorizontal) {\n          tx1 = tx2 = x1 = x2 = alignedLineValue;\n        } else {\n          ty1 = ty2 = y1 = y2 = alignedLineValue;\n        }\n\n        items.push({\n          tx1: tx1,\n          ty1: ty1,\n          tx2: tx2,\n          ty2: ty2,\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          width: lineWidth,\n          color: lineColor,\n          borderDash: borderDash,\n          borderDashOffset: borderDashOffset\n        });\n      }\n\n      items.ticksLength = ticksLength;\n      items.borderValue = borderValue;\n      return items;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _computeLabelItems: function () {\n      var me = this;\n      var options = me.options;\n      var optionTicks = options.ticks;\n      var position = options.position;\n      var isMirrored = optionTicks.mirror;\n      var isHorizontal = me.isHorizontal();\n      var ticks = me._ticksToDraw;\n      var fonts = parseTickFontOptions(optionTicks);\n      var tickPadding = optionTicks.padding;\n      var tl = getTickMarkLength(options.gridLines);\n      var rotation = -helpers$1.toRadians(me.labelRotation);\n      var items = [];\n      var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n\n      if (position === 'top') {\n        y = me.bottom - tl - tickPadding;\n        textAlign = !rotation ? 'center' : 'left';\n      } else if (position === 'bottom') {\n        y = me.top + tl + tickPadding;\n        textAlign = !rotation ? 'center' : 'right';\n      } else if (position === 'left') {\n        x = me.right - (isMirrored ? 0 : tl) - tickPadding;\n        textAlign = isMirrored ? 'left' : 'right';\n      } else {\n        x = me.left + (isMirrored ? 0 : tl) + tickPadding;\n        textAlign = isMirrored ? 'right' : 'left';\n      }\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        tick = ticks[i];\n        label = tick.label; // autoskipper skipped this tick (#4635)\n\n        if (isNullOrUndef(label)) {\n          continue;\n        }\n\n        pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;\n        font = tick.major ? fonts.major : fonts.minor;\n        lineHeight = font.lineHeight;\n        lineCount = isArray(label) ? label.length : 1;\n\n        if (isHorizontal) {\n          x = pixel;\n          textOffset = position === 'top' ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;\n        } else {\n          y = pixel;\n          textOffset = (1 - lineCount) * lineHeight / 2;\n        }\n\n        items.push({\n          x: x,\n          y: y,\n          rotation: rotation,\n          label: label,\n          font: font,\n          textOffset: textOffset,\n          textAlign: textAlign\n        });\n      }\n\n      return items;\n    },\n\n    /**\r\n     * @private\r\n     */\n    _drawGrid: function (chartArea) {\n      var me = this;\n      var gridLines = me.options.gridLines;\n\n      if (!gridLines.display) {\n        return;\n      }\n\n      var ctx = me.ctx;\n      var chart = me.chart;\n      var alignPixel = helpers$1._alignPixel;\n      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n\n      var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\n\n      var width, color, i, ilen, item;\n\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        item = items[i];\n        width = item.width;\n        color = item.color;\n\n        if (width && color) {\n          ctx.save();\n          ctx.lineWidth = width;\n          ctx.strokeStyle = color;\n\n          if (ctx.setLineDash) {\n            ctx.setLineDash(item.borderDash);\n            ctx.lineDashOffset = item.borderDashOffset;\n          }\n\n          ctx.beginPath();\n\n          if (gridLines.drawTicks) {\n            ctx.moveTo(item.tx1, item.ty1);\n            ctx.lineTo(item.tx2, item.ty2);\n          }\n\n          if (gridLines.drawOnChartArea) {\n            ctx.moveTo(item.x1, item.y1);\n            ctx.lineTo(item.x2, item.y2);\n          }\n\n          ctx.stroke();\n          ctx.restore();\n        }\n      }\n\n      if (axisWidth) {\n        // Draw the line at the edge of the axis\n        var firstLineWidth = axisWidth;\n        var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);\n        var borderValue = items.borderValue;\n        var x1, x2, y1, y2;\n\n        if (me.isHorizontal()) {\n          x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n          x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n          y1 = y2 = borderValue;\n        } else {\n          y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n          y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n          x1 = x2 = borderValue;\n        }\n\n        ctx.lineWidth = axisWidth;\n        ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    _drawLabels: function () {\n      var me = this;\n      var optionTicks = me.options.ticks;\n\n      if (!optionTicks.display) {\n        return;\n      }\n\n      var ctx = me.ctx;\n\n      var items = me._labelItems || (me._labelItems = me._computeLabelItems());\n\n      var i, j, ilen, jlen, item, tickFont, label, y;\n\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        item = items[i];\n        tickFont = item.font; // Make sure we draw text in the correct color and font\n\n        ctx.save();\n        ctx.translate(item.x, item.y);\n        ctx.rotate(item.rotation);\n        ctx.font = tickFont.string;\n        ctx.fillStyle = tickFont.color;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = item.textAlign;\n        label = item.label;\n        y = item.textOffset;\n\n        if (isArray(label)) {\n          for (j = 0, jlen = label.length; j < jlen; ++j) {\n            // We just make sure the multiline element is a string here..\n            ctx.fillText('' + label[j], 0, y);\n            y += tickFont.lineHeight;\n          }\n        } else {\n          ctx.fillText(label, 0, y);\n        }\n\n        ctx.restore();\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    _drawTitle: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var options = me.options;\n      var scaleLabel = options.scaleLabel;\n\n      if (!scaleLabel.display) {\n        return;\n      }\n\n      var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);\n\n      var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);\n\n      var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);\n      var halfLineHeight = scaleLabelFont.lineHeight / 2;\n      var position = options.position;\n      var rotation = 0;\n      var scaleLabelX, scaleLabelY;\n\n      if (me.isHorizontal()) {\n        scaleLabelX = me.left + me.width / 2; // midpoint of the width\n\n        scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;\n      } else {\n        var isLeft = position === 'left';\n        scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;\n        scaleLabelY = me.top + me.height / 2;\n        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n      }\n\n      ctx.save();\n      ctx.translate(scaleLabelX, scaleLabelY);\n      ctx.rotate(rotation);\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillStyle = scaleLabelFontColor; // render in correct colour\n\n      ctx.font = scaleLabelFont.string;\n      ctx.fillText(scaleLabel.labelString, 0, 0);\n      ctx.restore();\n    },\n    draw: function (chartArea) {\n      var me = this;\n\n      if (!me._isVisible()) {\n        return;\n      }\n\n      me._drawGrid(chartArea);\n\n      me._drawTitle();\n\n      me._drawLabels();\n    },\n\n    /**\r\n     * @private\r\n     */\n    _layers: function () {\n      var me = this;\n      var opts = me.options;\n      var tz = opts.ticks && opts.ticks.z || 0;\n      var gz = opts.gridLines && opts.gridLines.z || 0;\n\n      if (!me._isVisible() || tz === gz || me.draw !== me._draw) {\n        // backward compatibility: draw has been overridden by custom scale\n        return [{\n          z: tz,\n          draw: function () {\n            me.draw.apply(me, arguments);\n          }\n        }];\n      }\n\n      return [{\n        z: gz,\n        draw: function () {\n          me._drawGrid.apply(me, arguments);\n\n          me._drawTitle.apply(me, arguments);\n        }\n      }, {\n        z: tz,\n        draw: function () {\n          me._drawLabels.apply(me, arguments);\n        }\n      }];\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getMatchingVisibleMetas: function (type) {\n      var me = this;\n      var isHorizontal = me.isHorizontal();\n      return me.chart._getSortedVisibleDatasetMetas().filter(function (meta) {\n        return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);\n      });\n    }\n  });\n  Scale.prototype._draw = Scale.prototype.draw;\n  var core_scale = Scale;\n  var isNullOrUndef$1 = helpers$1.isNullOrUndef;\n  var defaultConfig = {\n    position: 'bottom'\n  };\n  var scale_category = core_scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n\n      var labels = me._getLabels();\n\n      var ticksOpts = me.options.ticks;\n      var min = ticksOpts.min;\n      var max = ticksOpts.max;\n      var minIndex = 0;\n      var maxIndex = labels.length - 1;\n      var findIndex;\n\n      if (min !== undefined) {\n        // user specified min value\n        findIndex = labels.indexOf(min);\n\n        if (findIndex >= 0) {\n          minIndex = findIndex;\n        }\n      }\n\n      if (max !== undefined) {\n        // user specified max value\n        findIndex = labels.indexOf(max);\n\n        if (findIndex >= 0) {\n          maxIndex = findIndex;\n        }\n      }\n\n      me.minIndex = minIndex;\n      me.maxIndex = maxIndex;\n      me.min = labels[minIndex];\n      me.max = labels[maxIndex];\n    },\n    buildTicks: function () {\n      var me = this;\n\n      var labels = me._getLabels();\n\n      var minIndex = me.minIndex;\n      var maxIndex = me.maxIndex; // If we are viewing some subset of labels, slice the original array\n\n      me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var chart = me.chart;\n\n      if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\n        return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\n      }\n\n      return me._getLabels()[index];\n    },\n    _configure: function () {\n      var me = this;\n      var offset = me.options.offset;\n      var ticks = me.ticks;\n\n      core_scale.prototype._configure.call(me);\n\n      if (!me.isHorizontal()) {\n        // For backward compatibility, vertical category scale reverse is inverted.\n        me._reversePixels = !me._reversePixels;\n      }\n\n      if (!ticks) {\n        return;\n      }\n\n      me._startValue = me.minIndex - (offset ? 0.5 : 0);\n      me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);\n    },\n    // Used to get data value locations.  Value can either be an index or a numerical value\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var valueCategory, labels, idx;\n\n      if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {\n        value = me.chart.data.datasets[datasetIndex].data[index];\n      } // If value is a data object, then index is the index in the data array,\n      // not the index of the scale. We need to change that.\n\n\n      if (!isNullOrUndef$1(value)) {\n        valueCategory = me.isHorizontal() ? value.x : value.y;\n      }\n\n      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {\n        labels = me._getLabels();\n        value = helpers$1.valueOrDefault(valueCategory, value);\n        idx = labels.indexOf(value);\n        index = idx !== -1 ? idx : index;\n\n        if (isNaN(index)) {\n          index = value;\n        }\n      }\n\n      return me.getPixelForDecimal((index - me._startValue) / me._valueRange);\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.ticks;\n      return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\n      return Math.min(Math.max(value, 0), me.ticks.length - 1);\n    },\n    getBasePixel: function () {\n      return this.bottom;\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults = defaultConfig;\n  scale_category._defaults = _defaults;\n  var noop = helpers$1.noop;\n  var isNullOrUndef$2 = helpers$1.isNullOrUndef;\n  /**\r\n   * Generate a set of linear ticks\r\n   * @param generationOptions the options used to generate the ticks\r\n   * @param dataRange the range of the data\r\n   * @returns {number[]} array of tick values\r\n   */\n\n  function generateTicks(generationOptions, dataRange) {\n    var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n    // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n    // for details.\n\n    var MIN_SPACING = 1e-14;\n    var stepSize = generationOptions.stepSize;\n    var unit = stepSize || 1;\n    var maxNumSpaces = generationOptions.maxTicks - 1;\n    var min = generationOptions.min;\n    var max = generationOptions.max;\n    var precision = generationOptions.precision;\n    var rmin = dataRange.min;\n    var rmax = dataRange.max;\n    var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n    var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision\n    // such that we can't do the math necessary to generate ticks\n\n    if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {\n      return [rmin, rmax];\n    }\n\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\n    if (numSpaces > maxNumSpaces) {\n      // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n      spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n    }\n\n    if (stepSize || isNullOrUndef$2(precision)) {\n      // If a precision is not specified, calculate factor based on spacing\n      factor = Math.pow(10, helpers$1._decimalPlaces(spacing));\n    } else {\n      // If the user specified a precision, round to that number of decimal places\n      factor = Math.pow(10, precision);\n      spacing = Math.ceil(spacing * factor) / factor;\n    }\n\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n    if (stepSize) {\n      // If very close to our whole number, use it.\n      if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {\n        niceMin = min;\n      }\n\n      if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\n        niceMax = max;\n      }\n    }\n\n    numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n    if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    ticks.push(isNullOrUndef$2(min) ? niceMin : min);\n\n    for (var j = 1; j < numSpaces; ++j) {\n      ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\n    }\n\n    ticks.push(isNullOrUndef$2(max) ? niceMax : max);\n    return ticks;\n  }\n\n  var scale_linearbase = core_scale.extend({\n    getRightValue: function (value) {\n      if (typeof value === 'string') {\n        return +value;\n      }\n\n      return core_scale.prototype.getRightValue.call(this, value);\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n      // do nothing since that would make the chart weird. If the user really wants a weird chart\n      // axis, they can manually override it\n\n      if (tickOpts.beginAtZero) {\n        var minSign = helpers$1.sign(me.min);\n        var maxSign = helpers$1.sign(me.max);\n\n        if (minSign < 0 && maxSign < 0) {\n          // move the top up to 0\n          me.max = 0;\n        } else if (minSign > 0 && maxSign > 0) {\n          // move the bottom down to 0\n          me.min = 0;\n        }\n      }\n\n      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n      if (tickOpts.min !== undefined) {\n        me.min = tickOpts.min;\n      } else if (tickOpts.suggestedMin !== undefined) {\n        if (me.min === null) {\n          me.min = tickOpts.suggestedMin;\n        } else {\n          me.min = Math.min(me.min, tickOpts.suggestedMin);\n        }\n      }\n\n      if (tickOpts.max !== undefined) {\n        me.max = tickOpts.max;\n      } else if (tickOpts.suggestedMax !== undefined) {\n        if (me.max === null) {\n          me.max = tickOpts.suggestedMax;\n        } else {\n          me.max = Math.max(me.max, tickOpts.suggestedMax);\n        }\n      }\n\n      if (setMin !== setMax) {\n        // We set the min or the max but not both.\n        // So ensure that our range is good\n        // Inverted or 0 length range can happen when\n        // ticks.min is set, and no datasets are visible\n        if (me.min >= me.max) {\n          if (setMin) {\n            me.max = me.min + 1;\n          } else {\n            me.min = me.max - 1;\n          }\n        }\n      }\n\n      if (me.min === me.max) {\n        me.max++;\n\n        if (!tickOpts.beginAtZero) {\n          me.min--;\n        }\n      }\n    },\n    getTickLimit: function () {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var stepSize = tickOpts.stepSize;\n      var maxTicksLimit = tickOpts.maxTicksLimit;\n      var maxTicks;\n\n      if (stepSize) {\n        maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n      } else {\n        maxTicks = me._computeTickLimit();\n        maxTicksLimit = maxTicksLimit || 11;\n      }\n\n      if (maxTicksLimit) {\n        maxTicks = Math.min(maxTicksLimit, maxTicks);\n      }\n\n      return maxTicks;\n    },\n    _computeTickLimit: function () {\n      return Number.POSITIVE_INFINITY;\n    },\n    handleDirectionalChanges: noop,\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph. Make sure we always have at least 2 ticks\n\n      var maxTicks = me.getTickLimit();\n      maxTicks = Math.max(2, maxTicks);\n      var numericGeneratorOptions = {\n        maxTicks: maxTicks,\n        min: tickOpts.min,\n        max: tickOpts.max,\n        precision: tickOpts.precision,\n        stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n      };\n      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers$1.max(ticks);\n      me.min = helpers$1.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      me.ticksAsNumbers = me.ticks.slice();\n      me.zeroLineIndex = me.ticks.indexOf(0);\n      core_scale.prototype.convertTicksToLabels.call(me);\n    },\n    _configure: function () {\n      var me = this;\n      var ticks = me.getTicks();\n      var start = me.min;\n      var end = me.max;\n      var offset;\n\n      core_scale.prototype._configure.call(me);\n\n      if (me.options.offset && ticks.length) {\n        offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n        start -= offset;\n        end += offset;\n      }\n\n      me._startValue = start;\n      me._endValue = end;\n      me._valueRange = end - start;\n    }\n  });\n  var defaultConfig$1 = {\n    position: 'left',\n    ticks: {\n      callback: core_ticks.formatters.linear\n    }\n  };\n  var DEFAULT_MIN = 0;\n  var DEFAULT_MAX = 1;\n\n  function getOrCreateStack(stacks, stacked, meta) {\n    var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n    stacked === undefined && meta.stack === undefined ? meta.index : '', meta.stack].join('.');\n\n    if (stacks[key] === undefined) {\n      stacks[key] = {\n        pos: [],\n        neg: []\n      };\n    }\n\n    return stacks[key];\n  }\n\n  function stackData(scale, stacks, meta, data) {\n    var opts = scale.options;\n    var stacked = opts.stacked;\n    var stack = getOrCreateStack(stacks, stacked, meta);\n    var pos = stack.pos;\n    var neg = stack.neg;\n    var ilen = data.length;\n    var i, value;\n\n    for (i = 0; i < ilen; ++i) {\n      value = scale._parseValue(data[i]);\n\n      if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\n        continue;\n      }\n\n      pos[i] = pos[i] || 0;\n      neg[i] = neg[i] || 0;\n\n      if (opts.relativePoints) {\n        pos[i] = 100;\n      } else if (value.min < 0 || value.max < 0) {\n        neg[i] += value.min;\n      } else {\n        pos[i] += value.max;\n      }\n    }\n  }\n\n  function updateMinMax(scale, meta, data) {\n    var ilen = data.length;\n    var i, value;\n\n    for (i = 0; i < ilen; ++i) {\n      value = scale._parseValue(data[i]);\n\n      if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\n        continue;\n      }\n\n      scale.min = Math.min(scale.min, value.min);\n      scale.max = Math.max(scale.max, value.max);\n    }\n  }\n\n  var scale_linear = scale_linearbase.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var datasets = chart.data.datasets;\n\n      var metasets = me._getMatchingVisibleMetas();\n\n      var hasStacks = opts.stacked;\n      var stacks = {};\n      var ilen = metasets.length;\n      var i, meta, data, values;\n      me.min = Number.POSITIVE_INFINITY;\n      me.max = Number.NEGATIVE_INFINITY;\n\n      if (hasStacks === undefined) {\n        for (i = 0; !hasStacks && i < ilen; ++i) {\n          meta = metasets[i];\n          hasStacks = meta.stack !== undefined;\n        }\n      }\n\n      for (i = 0; i < ilen; ++i) {\n        meta = metasets[i];\n        data = datasets[meta.index].data;\n\n        if (hasStacks) {\n          stackData(me, stacks, meta, data);\n        } else {\n          updateMinMax(me, meta, data);\n        }\n      }\n\n      helpers$1.each(stacks, function (stackValues) {\n        values = stackValues.pos.concat(stackValues.neg);\n        me.min = Math.min(me.min, helpers$1.min(values));\n        me.max = Math.max(me.max, helpers$1.max(values));\n      });\n      me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n      me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      me.handleTickRangeOptions();\n    },\n    // Returns the maximum number of ticks based on the scale dimension\n    _computeTickLimit: function () {\n      var me = this;\n      var tickFont;\n\n      if (me.isHorizontal()) {\n        return Math.ceil(me.width / 40);\n      }\n\n      tickFont = helpers$1.options._parseFont(me.options.ticks);\n      return Math.ceil(me.height / tickFont.lineHeight);\n    },\n    // Called after the ticks are built. We need\n    handleDirectionalChanges: function () {\n      if (!this.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        this.ticks.reverse();\n      }\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    // Utils\n    getPixelForValue: function (value) {\n      var me = this;\n      return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);\n    },\n    getValueForPixel: function (pixel) {\n      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.ticksAsNumbers;\n\n      if (index < 0 || index > ticks.length - 1) {\n        return null;\n      }\n\n      return this.getPixelForValue(ticks[index]);\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$1 = defaultConfig$1;\n  scale_linear._defaults = _defaults$1;\n  var valueOrDefault$b = helpers$1.valueOrDefault;\n  var log10 = helpers$1.math.log10;\n  /**\r\n   * Generate a set of logarithmic ticks\r\n   * @param generationOptions the options used to generate the ticks\r\n   * @param dataRange the range of the data\r\n   * @returns {number[]} array of tick values\r\n   */\n\n  function generateTicks$1(generationOptions, dataRange) {\n    var ticks = [];\n    var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n    var endExp = Math.floor(log10(dataRange.max));\n    var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n    var exp, significand;\n\n    if (tickVal === 0) {\n      exp = Math.floor(log10(dataRange.minNotZero));\n      significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n      ticks.push(tickVal);\n      tickVal = significand * Math.pow(10, exp);\n    } else {\n      exp = Math.floor(log10(tickVal));\n      significand = Math.floor(tickVal / Math.pow(10, exp));\n    }\n\n    var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n    do {\n      ticks.push(tickVal);\n      ++significand;\n\n      if (significand === 10) {\n        significand = 1;\n        ++exp;\n        precision = exp >= 0 ? 1 : precision;\n      }\n\n      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n    } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n    var lastTick = valueOrDefault$b(generationOptions.max, tickVal);\n    ticks.push(lastTick);\n    return ticks;\n  }\n\n  var defaultConfig$2 = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: core_ticks.formatters.logarithmic\n    }\n  }; // TODO(v3): change this to positiveOrDefault\n\n  function nonNegativeOrDefault(value, defaultValue) {\n    return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\n  }\n\n  var scale_logarithmic = core_scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var datasets = chart.data.datasets;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      }\n\n      var datasetIndex, meta, value, data, i, ilen; // Calculate Range\n\n      me.min = Number.POSITIVE_INFINITY;\n      me.max = Number.NEGATIVE_INFINITY;\n      me.minNotZero = Number.POSITIVE_INFINITY;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\n          meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n            break;\n          }\n        }\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n\n        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\n          meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            data = datasets[datasetIndex].data;\n\n            for (i = 0, ilen = data.length; i < ilen; i++) {\n              var values = valuesPerStack[key];\n              value = me._parseValue(data[i]); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {\n                continue;\n              }\n\n              values[i] = values[i] || 0;\n              values[i] += value.max;\n            }\n          }\n        }\n\n        helpers$1.each(valuesPerStack, function (valuesForType) {\n          if (valuesForType.length > 0) {\n            var minVal = helpers$1.min(valuesForType);\n            var maxVal = helpers$1.max(valuesForType);\n            me.min = Math.min(me.min, minVal);\n            me.max = Math.max(me.max, maxVal);\n          }\n        });\n      } else {\n        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\n          meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            data = datasets[datasetIndex].data;\n\n            for (i = 0, ilen = data.length; i < ilen; i++) {\n              value = me._parseValue(data[i]); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {\n                continue;\n              }\n\n              me.min = Math.min(value.min, me.min);\n              me.max = Math.max(value.max, me.max);\n\n              if (value.min !== 0) {\n                me.minNotZero = Math.min(value.min, me.minNotZero);\n              }\n            }\n          }\n        }\n      }\n\n      me.min = helpers$1.isFinite(me.min) ? me.min : null;\n      me.max = helpers$1.isFinite(me.max) ? me.max : null;\n      me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null; // Common base implementation to handle ticks.min, ticks.max\n\n      this.handleTickRangeOptions();\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var DEFAULT_MIN = 1;\n      var DEFAULT_MAX = 10;\n      me.min = nonNegativeOrDefault(tickOpts.min, me.min);\n      me.max = nonNegativeOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);\n        } else {\n          me.min = DEFAULT_MIN;\n          me.max = DEFAULT_MAX;\n        }\n      }\n\n      if (me.min === null) {\n        me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);\n      }\n\n      if (me.max === null) {\n        me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX;\n      }\n\n      if (me.minNotZero === null) {\n        if (me.min > 0) {\n          me.minNotZero = me.min;\n        } else if (me.max < 1) {\n          me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));\n        } else {\n          me.minNotZero = DEFAULT_MIN;\n        }\n      }\n    },\n    buildTicks: function () {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var reverse = !me.isHorizontal();\n      var generationOptions = {\n        min: nonNegativeOrDefault(tickOpts.min),\n        max: nonNegativeOrDefault(tickOpts.max)\n      };\n      var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers$1.max(ticks);\n      me.min = helpers$1.min(ticks);\n\n      if (tickOpts.reverse) {\n        reverse = !reverse;\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n\n      if (reverse) {\n        ticks.reverse();\n      }\n    },\n    convertTicksToLabels: function () {\n      this.tickValues = this.ticks.slice();\n      core_scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function (index, datasetIndex) {\n      return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.tickValues;\n\n      if (index < 0 || index > ticks.length - 1) {\n        return null;\n      }\n\n      return this.getPixelForValue(ticks[index]);\n    },\n\n    /**\r\n     * Returns the value of the first tick.\r\n     * @param {number} value - The minimum not zero value.\r\n     * @return {number} The first tick value.\r\n     * @private\r\n     */\n    _getFirstTickValue: function (value) {\n      var exp = Math.floor(log10(value));\n      var significand = Math.floor(value / Math.pow(10, exp));\n      return significand * Math.pow(10, exp);\n    },\n    _configure: function () {\n      var me = this;\n      var start = me.min;\n      var offset = 0;\n\n      core_scale.prototype._configure.call(me);\n\n      if (start === 0) {\n        start = me._getFirstTickValue(me.minNotZero);\n        offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;\n      }\n\n      me._startValue = log10(start);\n      me._valueOffset = offset;\n      me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);\n    },\n    getPixelForValue: function (value) {\n      var me = this;\n      var decimal = 0;\n      value = +me.getRightValue(value);\n\n      if (value > me.min && value > 0) {\n        decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;\n      }\n\n      return me.getPixelForDecimal(decimal);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var decimal = me.getDecimalForPixel(pixel);\n      return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$2 = defaultConfig$2;\n  scale_logarithmic._defaults = _defaults$2;\n  var valueOrDefault$c = helpers$1.valueOrDefault;\n  var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;\n  var resolve$4 = helpers$1.options.resolve;\n  var defaultConfig$3 = {\n    display: true,\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n    angleLines: {\n      display: true,\n      color: 'rgba(0,0,0,0.1)',\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n    gridLines: {\n      circular: false\n    },\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n      // String - The colour of the label backdrop\n      backdropColor: 'rgba(255,255,255,0.75)',\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPaddingY: 2,\n      // Number - The backdrop padding to the side of the label in pixels\n      backdropPaddingX: 2,\n      callback: core_ticks.formatters.linear\n    },\n    pointLabels: {\n      // Boolean - if true, show point labels\n      display: true,\n      // Number - Point label font size in pixels\n      fontSize: 10,\n      // Function - Used to convert point labels\n      callback: function (label) {\n        return label;\n      }\n    }\n  };\n\n  function getTickBackdropHeight(opts) {\n    var tickOpts = opts.ticks;\n\n    if (tickOpts.display && opts.display) {\n      return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\n    }\n\n    return 0;\n  }\n\n  function measureLabelSize(ctx, lineHeight, label) {\n    if (helpers$1.isArray(label)) {\n      return {\n        w: helpers$1.longestText(ctx, ctx.font, label),\n        h: label.length * lineHeight\n      };\n    }\n\n    return {\n      w: ctx.measureText(label).width,\n      h: lineHeight\n    };\n  }\n\n  function determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n      return {\n        start: pos - size / 2,\n        end: pos + size / 2\n      };\n    } else if (angle < min || angle > max) {\n      return {\n        start: pos - size,\n        end: pos\n      };\n    }\n\n    return {\n      start: pos,\n      end: pos + size\n    };\n  }\n  /**\r\n   * Helper function to fit a radial linear scale with point labels\r\n   */\n\n\n  function fitWithPointLabels(scale) {\n    // Right, this is really confusing and there is a lot of maths going on here\n    // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n    //\n    // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n    //\n    // Solution:\n    //\n    // We assume the radius of the polygon is half the size of the canvas at first\n    // at each index we check if the text overlaps.\n    //\n    // Where it does, we store that angle and that index.\n    //\n    // After finding the largest index and angle we calculate how much we need to remove\n    // from the shape radius to move the point inwards by that x.\n    //\n    // We average the left and right distances to get the maximum shape radius that can fit in the box\n    // along with labels.\n    //\n    // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n    // on each side, removing that from the size, halving it and adding the left x protrusion width.\n    //\n    // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n    // and position it in the most space efficient manner\n    //\n    // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n    var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\n\n    var furthestLimits = {\n      l: 0,\n      r: scale.width,\n      t: 0,\n      b: scale.height - scale.paddingTop\n    };\n    var furthestAngles = {};\n    var i, textSize, pointPosition;\n    scale.ctx.font = plFont.string;\n    scale._pointLabelSizes = [];\n    var valueCount = scale.chart.data.labels.length;\n\n    for (i = 0; i < valueCount; i++) {\n      pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n      textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);\n      scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle\n\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers$1.toDegrees(angleRadians) % 360;\n      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n      if (hLimits.start < furthestLimits.l) {\n        furthestLimits.l = hLimits.start;\n        furthestAngles.l = angleRadians;\n      }\n\n      if (hLimits.end > furthestLimits.r) {\n        furthestLimits.r = hLimits.end;\n        furthestAngles.r = angleRadians;\n      }\n\n      if (vLimits.start < furthestLimits.t) {\n        furthestLimits.t = vLimits.start;\n        furthestAngles.t = angleRadians;\n      }\n\n      if (vLimits.end > furthestLimits.b) {\n        furthestLimits.b = vLimits.end;\n        furthestAngles.b = angleRadians;\n      }\n    }\n\n    scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n  }\n\n  function getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n      return 'center';\n    } else if (angle < 180) {\n      return 'left';\n    }\n\n    return 'right';\n  }\n\n  function fillText(ctx, text, position, lineHeight) {\n    var y = position.y + lineHeight / 2;\n    var i, ilen;\n\n    if (helpers$1.isArray(text)) {\n      for (i = 0, ilen = text.length; i < ilen; ++i) {\n        ctx.fillText(text[i], position.x, y);\n        y += lineHeight;\n      }\n    } else {\n      ctx.fillText(text, position.x, y);\n    }\n  }\n\n  function adjustPointPositionForLabelHeight(angle, textSize, position) {\n    if (angle === 90 || angle === 270) {\n      position.y -= textSize.h / 2;\n    } else if (angle > 270 || angle < 90) {\n      position.y -= textSize.h;\n    }\n  }\n\n  function drawPointLabels(scale) {\n    var ctx = scale.ctx;\n    var opts = scale.options;\n    var pointLabelOpts = opts.pointLabels;\n    var tickBackdropHeight = getTickBackdropHeight(opts);\n    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n    var plFont = helpers$1.options._parseFont(pointLabelOpts);\n\n    ctx.save();\n    ctx.font = plFont.string;\n    ctx.textBaseline = 'middle';\n\n    for (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {\n      // Extra pixels out for some label spacing\n      var extra = i === 0 ? tickBackdropHeight / 2 : 0;\n      var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here\n\n      var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\n      ctx.fillStyle = pointLabelFontColor;\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers$1.toDegrees(angleRadians);\n      ctx.textAlign = getTextAlignForAngle(angle);\n      adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n      fillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);\n    }\n\n    ctx.restore();\n  }\n\n  function drawRadiusLine(scale, gridLineOpts, radius, index) {\n    var ctx = scale.ctx;\n    var circular = gridLineOpts.circular;\n    var valueCount = scale.chart.data.labels.length;\n    var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\n    var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\n    var pointPosition;\n\n    if (!circular && !valueCount || !lineColor || !lineWidth) {\n      return;\n    }\n\n    ctx.save();\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n\n    if (ctx.setLineDash) {\n      ctx.setLineDash(gridLineOpts.borderDash || []);\n      ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\n    }\n\n    ctx.beginPath();\n\n    if (circular) {\n      // Draw circular arcs between the points\n      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n    } else {\n      // Draw straight lines connecting each index\n      pointPosition = scale.getPointPosition(0, radius);\n      ctx.moveTo(pointPosition.x, pointPosition.y);\n\n      for (var i = 1; i < valueCount; i++) {\n        pointPosition = scale.getPointPosition(i, radius);\n        ctx.lineTo(pointPosition.x, pointPosition.y);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function numberOrZero(param) {\n    return helpers$1.isNumber(param) ? param : 0;\n  }\n\n  var scale_radialLinear = scale_linearbase.extend({\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      me.width = me.maxWidth;\n      me.height = me.maxHeight;\n      me.paddingTop = getTickBackdropHeight(me.options) / 2;\n      me.xCenter = Math.floor(me.width / 2);\n      me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n      me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var min = Number.POSITIVE_INFINITY;\n      var max = Number.NEGATIVE_INFINITY;\n      helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {\n        if (chart.isDatasetVisible(datasetIndex)) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          helpers$1.each(dataset.data, function (rawValue, index) {\n            var value = +me.getRightValue(rawValue);\n\n            if (isNaN(value) || meta.data[index].hidden) {\n              return;\n            }\n\n            min = Math.min(value, min);\n            max = Math.max(value, max);\n          });\n        }\n      });\n      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      me.handleTickRangeOptions();\n    },\n    // Returns the maximum number of ticks based on the scale dimension\n    _computeTickLimit: function () {\n      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels\n\n      me.pointLabels = me.chart.data.labels.map(function () {\n        var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);\n        return label || label === 0 ? label : '';\n      });\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n\n      if (opts.display && opts.pointLabels.display) {\n        fitWithPointLabels(me);\n      } else {\n        me.setCenterPoint(0, 0, 0, 0);\n      }\n    },\n\n    /**\r\n     * Set radius reductions and determine new radius and center point\r\n     * @private\r\n     */\n    setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {\n      var me = this;\n      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n      var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n      radiusReductionLeft = numberOrZero(radiusReductionLeft);\n      radiusReductionRight = numberOrZero(radiusReductionRight);\n      radiusReductionTop = numberOrZero(radiusReductionTop);\n      radiusReductionBottom = numberOrZero(radiusReductionBottom);\n      me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n    },\n    setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {\n      var me = this;\n      var maxRight = me.width - rightMovement - me.drawingArea;\n      var maxLeft = leftMovement + me.drawingArea;\n      var maxTop = topMovement + me.drawingArea;\n      var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;\n      me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);\n      me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);\n    },\n    getIndexAngle: function (index) {\n      var chart = this.chart;\n      var angleMultiplier = 360 / chart.data.labels.length;\n      var options = chart.options || {};\n      var startAngle = options.startAngle || 0; // Start from the top instead of right, so remove a quarter of the circle\n\n      var angle = (index * angleMultiplier + startAngle) % 360;\n      return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;\n    },\n    getDistanceFromCenterForValue: function (value) {\n      var me = this;\n\n      if (helpers$1.isNullOrUndef(value)) {\n        return NaN;\n      } // Take into account half font size + the yPadding of the top value\n\n\n      var scalingFactor = me.drawingArea / (me.max - me.min);\n\n      if (me.options.ticks.reverse) {\n        return (me.max - value) * scalingFactor;\n      }\n\n      return (value - me.min) * scalingFactor;\n    },\n    getPointPosition: function (index, distanceFromCenter) {\n      var me = this;\n      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n      return {\n        x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\n        y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\n      };\n    },\n    getPointPositionForValue: function (index, value) {\n      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    },\n    getBasePosition: function (index) {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _drawGrid: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var opts = me.options;\n      var gridLineOpts = opts.gridLines;\n      var angleLineOpts = opts.angleLines;\n      var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\n      var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);\n      var i, offset, position;\n\n      if (opts.pointLabels.display) {\n        drawPointLabels(me);\n      }\n\n      if (gridLineOpts.display) {\n        helpers$1.each(me.ticks, function (label, index) {\n          if (index !== 0) {\n            offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n            drawRadiusLine(me, gridLineOpts, offset, index);\n          }\n        });\n      }\n\n      if (angleLineOpts.display && lineWidth && lineColor) {\n        ctx.save();\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = lineColor;\n\n        if (ctx.setLineDash) {\n          ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));\n          ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);\n        }\n\n        for (i = me.chart.data.labels.length - 1; i >= 0; i--) {\n          offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\n          position = me.getPointPosition(i, offset);\n          ctx.beginPath();\n          ctx.moveTo(me.xCenter, me.yCenter);\n          ctx.lineTo(position.x, position.y);\n          ctx.stroke();\n        }\n\n        ctx.restore();\n      }\n    },\n\n    /**\r\n     * @private\r\n     */\n    _drawLabels: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n\n      if (!tickOpts.display) {\n        return;\n      }\n\n      var startAngle = me.getIndexAngle(0);\n\n      var tickFont = helpers$1.options._parseFont(tickOpts);\n\n      var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);\n      var offset, width;\n      ctx.save();\n      ctx.font = tickFont.string;\n      ctx.translate(me.xCenter, me.yCenter);\n      ctx.rotate(startAngle);\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      helpers$1.each(me.ticks, function (label, index) {\n        if (index === 0 && !tickOpts.reverse) {\n          return;\n        }\n\n        offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n        if (tickOpts.showLabelBackdrop) {\n          width = ctx.measureText(label).width;\n          ctx.fillStyle = tickOpts.backdropColor;\n          ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);\n        }\n\n        ctx.fillStyle = tickFontColor;\n        ctx.fillText(label, 0, -offset);\n      });\n      ctx.restore();\n    },\n\n    /**\r\n     * @private\r\n     */\n    _drawTitle: helpers$1.noop\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$3 = defaultConfig$3;\n  scale_radialLinear._defaults = _defaults$3;\n  var deprecated$1 = helpers$1._deprecated;\n  var resolve$5 = helpers$1.options.resolve;\n  var valueOrDefault$d = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.\n\n  var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\n  var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var INTERVALS = {\n    millisecond: {\n      common: true,\n      size: 1,\n      steps: 1000\n    },\n    second: {\n      common: true,\n      size: 1000,\n      steps: 60\n    },\n    minute: {\n      common: true,\n      size: 60000,\n      steps: 60\n    },\n    hour: {\n      common: true,\n      size: 3600000,\n      steps: 24\n    },\n    day: {\n      common: true,\n      size: 86400000,\n      steps: 30\n    },\n    week: {\n      common: false,\n      size: 604800000,\n      steps: 4\n    },\n    month: {\n      common: true,\n      size: 2.628e9,\n      steps: 12\n    },\n    quarter: {\n      common: false,\n      size: 7.884e9,\n      steps: 4\n    },\n    year: {\n      common: true,\n      size: 3.154e10\n    }\n  };\n  var UNITS = Object.keys(INTERVALS);\n\n  function sorter(a, b) {\n    return a - b;\n  }\n\n  function arrayUnique(items) {\n    var hash = {};\n    var out = [];\n    var i, ilen, item;\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n\n      if (!hash[item]) {\n        hash[item] = true;\n        out.push(item);\n      }\n    }\n\n    return out;\n  }\n\n  function getMin(options) {\n    return helpers$1.valueOrDefault(options.time.min, options.ticks.min);\n  }\n\n  function getMax(options) {\n    return helpers$1.valueOrDefault(options.time.max, options.ticks.max);\n  }\n  /**\r\n   * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\r\n   * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\r\n   * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\r\n   * extremity (left + width or top + height). Note that it would be more optimized to directly\r\n   * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\r\n   * to create the lookup table. The table ALWAYS contains at least two items: min and max.\r\n   *\r\n   * @param {number[]} timestamps - timestamps sorted from lowest to highest.\r\n   * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min\r\n   * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\r\n   * If 'series', timestamps will be positioned at the same distance from each other. In this\r\n   * case, only timestamps that break the time linearity are registered, meaning that in the\r\n   * best case, all timestamps are linear, the table contains only min and max.\r\n   */\n\n\n  function buildLookupTable(timestamps, min, max, distribution) {\n    if (distribution === 'linear' || !timestamps.length) {\n      return [{\n        time: min,\n        pos: 0\n      }, {\n        time: max,\n        pos: 1\n      }];\n    }\n\n    var table = [];\n    var items = [min];\n    var i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n\n      if (curr > min && curr < max) {\n        items.push(curr);\n      }\n    }\n\n    items.push(max);\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i]; // only add points that breaks the scale linearity\n\n      if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n        table.push({\n          time: curr,\n          pos: i / (ilen - 1)\n        });\n      }\n    }\n\n    return table;\n  } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\n\n\n  function lookup(table, key, value) {\n    var lo = 0;\n    var hi = table.length - 1;\n    var mid, i0, i1;\n\n    while (lo >= 0 && lo <= hi) {\n      mid = lo + hi >> 1;\n      i0 = table[mid - 1] || null;\n      i1 = table[mid];\n\n      if (!i0) {\n        // given value is outside table (before first item)\n        return {\n          lo: null,\n          hi: i1\n        };\n      } else if (i1[key] < value) {\n        lo = mid + 1;\n      } else if (i0[key] > value) {\n        hi = mid - 1;\n      } else {\n        return {\n          lo: i0,\n          hi: i1\n        };\n      }\n    } // given value is outside table (after last item)\n\n\n    return {\n      lo: i1,\n      hi: null\n    };\n  }\n  /**\r\n   * Linearly interpolates the given source `value` using the table items `skey` values and\r\n   * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n   * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n   * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n   */\n\n\n  function interpolate$1(table, skey, sval, tkey) {\n    var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\n    var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n    var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n    var span = next[skey] - prev[skey];\n    var ratio = span ? (sval - prev[skey]) / span : 0;\n    var offset = (next[tkey] - prev[tkey]) * ratio;\n    return prev[tkey] + offset;\n  }\n\n  function toTimestamp(scale, input) {\n    var adapter = scale._adapter;\n    var options = scale.options.time;\n    var parser = options.parser;\n    var format = parser || options.format;\n    var value = input;\n\n    if (typeof parser === 'function') {\n      value = parser(value);\n    } // Only parse if its not a timestamp already\n\n\n    if (!helpers$1.isFinite(value)) {\n      value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);\n    }\n\n    if (value !== null) {\n      return +value;\n    } // Labels are in an incompatible format and no `parser` has been provided.\n    // The user might still use the deprecated `format` option for parsing.\n\n\n    if (!parser && typeof format === 'function') {\n      value = format(input); // `format` could return something else than a timestamp, if so, parse it\n\n      if (!helpers$1.isFinite(value)) {\n        value = adapter.parse(value);\n      }\n    }\n\n    return value;\n  }\n\n  function parse(scale, input) {\n    if (helpers$1.isNullOrUndef(input)) {\n      return null;\n    }\n\n    var options = scale.options.time;\n    var value = toTimestamp(scale, scale.getRightValue(input));\n\n    if (value === null) {\n      return value;\n    }\n\n    if (options.round) {\n      value = +scale._adapter.startOf(value, options.round);\n    }\n\n    return value;\n  }\n  /**\r\n   * Figures out what unit results in an appropriate number of auto-generated ticks\r\n   */\n\n\n  function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    var ilen = UNITS.length;\n    var i, interval, factor;\n\n    for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n      interval = INTERVALS[UNITS[i]];\n      factor = interval.steps ? interval.steps : MAX_INTEGER;\n\n      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n        return UNITS[i];\n      }\n    }\n\n    return UNITS[ilen - 1];\n  }\n  /**\r\n   * Figures out what unit to format a set of ticks with\r\n   */\n\n\n  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    var i, unit;\n\n    for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n      unit = UNITS[i];\n\n      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n        return unit;\n      }\n    }\n\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n  }\n\n  function determineMajorUnit(unit) {\n    for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n      if (INTERVALS[UNITS[i]].common) {\n        return UNITS[i];\n      }\n    }\n  }\n  /**\r\n   * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n   * `minor` unit using the given scale time `options`.\r\n   * Important: this method can return ticks outside the min and max range, it's the\r\n   * responsibility of the calling code to clamp values if needed.\r\n   */\n\n\n  function generate(scale, min, max, capacity) {\n    var adapter = scale._adapter;\n    var options = scale.options;\n    var timeOpts = options.time;\n    var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);\n    var weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    var first = min;\n    var ticks = [];\n    var time; // For 'week' unit, handle the first day of week option\n\n    if (weekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    } // Align first ticks on unit\n\n\n    first = +adapter.startOf(first, weekday ? 'day' : minor); // Prevent browser from freezing in case user options request millions of milliseconds\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor;\n    }\n\n    for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {\n      ticks.push(time);\n    }\n\n    if (time === max || options.bounds === 'ticks') {\n      ticks.push(time);\n    }\n\n    return ticks;\n  }\n  /**\r\n   * Returns the start and end offsets from edges in the form of {start, end}\r\n   * where each value is a relative width to the scale and ranges between 0 and 1.\r\n   * They add extra margins on the both sides by scaling down the original scale.\r\n   * Offsets are added when the `offset` option is true.\r\n   */\n\n\n  function computeOffsets(table, ticks, min, max, options) {\n    var start = 0;\n    var end = 0;\n    var first, last;\n\n    if (options.offset && ticks.length) {\n      first = interpolate$1(table, 'time', ticks[0], 'pos');\n\n      if (ticks.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;\n      }\n\n      last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');\n\n      if (ticks.length === 1) {\n        end = last;\n      } else {\n        end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;\n      }\n    }\n\n    return {\n      start: start,\n      end: end,\n      factor: 1 / (start + 1 + end)\n    };\n  }\n\n  function setMajorTicks(scale, ticks, map, majorUnit) {\n    var adapter = scale._adapter;\n    var first = +adapter.startOf(ticks[0].value, majorUnit);\n    var last = ticks[ticks.length - 1].value;\n    var major, index;\n\n    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n      index = map[major];\n\n      if (index >= 0) {\n        ticks[index].major = true;\n      }\n    }\n\n    return ticks;\n  }\n\n  function ticksFromTimestamps(scale, values, majorUnit) {\n    var ticks = [];\n    var map = {};\n    var ilen = values.length;\n    var i, value;\n\n    for (i = 0; i < ilen; ++i) {\n      value = values[i];\n      map[value] = i;\n      ticks.push({\n        value: value,\n        major: false\n      });\n    } // We set the major ticks separately from the above loop because calling startOf for every tick\n    // is expensive when there is a large number of ticks\n\n\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n  }\n\n  var defaultConfig$4 = {\n    position: 'bottom',\n\n    /**\r\n     * Data distribution along the scale:\r\n     * - 'linear': data are spread according to their time (distances can vary),\r\n     * - 'series': data are spread at the same distance from each other.\r\n     * @see https://github.com/chartjs/Chart.js/pull/4507\r\n     * @since 2.7.0\r\n     */\n    distribution: 'linear',\n\n    /**\r\n     * Scale boundary strategy (bypassed by min/max time options)\r\n     * - `data`: make sure data are fully visible, ticks outside are removed\r\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\r\n     * @see https://github.com/chartjs/Chart.js/pull/4556\r\n     * @since 2.7.0\r\n     */\n    bounds: 'data',\n    adapters: {},\n    time: {\n      parser: false,\n      // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n      unit: false,\n      // false == automatic or override with week, month, year, etc.\n      round: false,\n      // none, or override with week, month, year, etc.\n      displayFormat: false,\n      // DEPRECATED\n      isoWeekday: false,\n      // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      autoSkip: false,\n\n      /**\r\n       * Ticks generation input values:\r\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\r\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\r\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\r\n       * @see https://github.com/chartjs/Chart.js/pull/4507\r\n       * @since 2.7.0\r\n       */\n      source: 'auto',\n      major: {\n        enabled: false\n      }\n    }\n  };\n  var scale_time = core_scale.extend({\n    initialize: function () {\n      this.mergeTicksOptions();\n      core_scale.prototype.initialize.call(this);\n    },\n    update: function () {\n      var me = this;\n      var options = me.options;\n      var time = options.time || (options.time = {});\n      var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update\n\n      deprecated$1('time scale', time.format, 'time.format', 'time.parser');\n      deprecated$1('time scale', time.min, 'time.min', 'ticks.min');\n      deprecated$1('time scale', time.max, 'time.max', 'ticks.max'); // Backward compatibility: before introducing adapter, `displayFormats` was\n      // supposed to contain *all* unit/string pairs but this can't be resolved\n      // when loading the scale (adapters are loaded afterward), so let's populate\n      // missing formats on update\n\n      helpers$1.mergeIf(time.displayFormats, adapter.formats());\n      return core_scale.prototype.update.apply(me, arguments);\n    },\n\n    /**\r\n     * Allows data to be referenced via 't' attribute\r\n     */\n    getRightValue: function (rawValue) {\n      if (rawValue && rawValue.t !== undefined) {\n        rawValue = rawValue.t;\n      }\n\n      return core_scale.prototype.getRightValue.call(this, rawValue);\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var adapter = me._adapter;\n      var options = me.options;\n      var unit = options.time.unit || 'day';\n      var min = MAX_INTEGER;\n      var max = MIN_INTEGER;\n      var timestamps = [];\n      var datasets = [];\n      var labels = [];\n      var i, j, ilen, jlen, data, timestamp, labelsAdded;\n\n      var dataLabels = me._getLabels();\n\n      for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\n        labels.push(parse(me, dataLabels[i]));\n      }\n\n      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          data = chart.data.datasets[i].data; // Let's consider that all data have the same format.\n\n          if (helpers$1.isObject(data[0])) {\n            datasets[i] = [];\n\n            for (j = 0, jlen = data.length; j < jlen; ++j) {\n              timestamp = parse(me, data[j]);\n              timestamps.push(timestamp);\n              datasets[i][j] = timestamp;\n            }\n          } else {\n            datasets[i] = labels.slice(0);\n\n            if (!labelsAdded) {\n              timestamps = timestamps.concat(labels);\n              labelsAdded = true;\n            }\n          }\n        } else {\n          datasets[i] = [];\n        }\n      }\n\n      if (labels.length) {\n        min = Math.min(min, labels[0]);\n        max = Math.max(max, labels[labels.length - 1]);\n      }\n\n      if (timestamps.length) {\n        timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);\n        min = Math.min(min, timestamps[0]);\n        max = Math.max(max, timestamps[timestamps.length - 1]);\n      }\n\n      min = parse(me, getMin(options)) || min;\n      max = parse(me, getMax(options)) || max; // In case there is no valid min/max, set limits based on unit time option\n\n      min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;\n      max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)\n\n      me.min = Math.min(min, max);\n      me.max = Math.max(min + 1, max); // PRIVATE\n\n      me._table = [];\n      me._timestamps = {\n        data: timestamps,\n        datasets: datasets,\n        labels: labels\n      };\n    },\n    buildTicks: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      var options = me.options;\n      var tickOpts = options.ticks;\n      var timeOpts = options.time;\n      var timestamps = me._timestamps;\n      var ticks = [];\n      var capacity = me.getLabelCapacity(min);\n      var source = tickOpts.source;\n      var distribution = options.distribution;\n      var i, ilen, timestamp;\n\n      if (source === 'data' || source === 'auto' && distribution === 'series') {\n        timestamps = timestamps.data;\n      } else if (source === 'labels') {\n        timestamps = timestamps.labels;\n      } else {\n        timestamps = generate(me, min, max, capacity);\n      }\n\n      if (options.bounds === 'ticks' && timestamps.length) {\n        min = timestamps[0];\n        max = timestamps[timestamps.length - 1];\n      } // Enforce limits with user min/max options\n\n\n      min = parse(me, getMin(options)) || min;\n      max = parse(me, getMax(options)) || max; // Remove ticks outside the min/max range\n\n      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n        timestamp = timestamps[i];\n\n        if (timestamp >= min && timestamp <= max) {\n          ticks.push(timestamp);\n        }\n      }\n\n      me.min = min;\n      me.max = max; // PRIVATE\n      // determineUnitForFormatting relies on the number of ticks so we don't use it when\n      // autoSkip is enabled because we don't yet know what the final number of ticks will be\n\n      me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\n      me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined : determineMajorUnit(me._unit);\n      me._table = buildLookupTable(me._timestamps.data, min, max, distribution);\n      me._offsets = computeOffsets(me._table, ticks, min, max, options);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n      }\n\n      return ticksFromTimestamps(me, ticks, me._majorUnit);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var adapter = me._adapter;\n      var data = me.chart.data;\n      var timeOpts = me.options.time;\n      var label = data.labels && index < data.labels.length ? data.labels[index] : '';\n      var value = data.datasets[datasetIndex].data[index];\n\n      if (helpers$1.isObject(value)) {\n        label = me.getRightValue(value);\n      }\n\n      if (timeOpts.tooltipFormat) {\n        return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);\n      }\n\n      if (typeof label === 'string') {\n        return label;\n      }\n\n      return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\n    },\n\n    /**\r\n     * Function to format an individual tick mark\r\n     * @private\r\n     */\n    tickFormatFunction: function (time, index, ticks, format) {\n      var me = this;\n      var adapter = me._adapter;\n      var options = me.options;\n      var formats = options.time.displayFormats;\n      var minorFormat = formats[me._unit];\n      var majorUnit = me._majorUnit;\n      var majorFormat = formats[majorUnit];\n      var tick = ticks[index];\n      var tickOpts = options.ticks;\n      var major = majorUnit && majorFormat && tick && tick.major;\n      var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n      var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;\n      var formatter = resolve$5([nestedTickOpts.callback, nestedTickOpts.userCallback, tickOpts.callback, tickOpts.userCallback]);\n      return formatter ? formatter(label, index, ticks) : label;\n    },\n    convertTicksToLabels: function (ticks) {\n      var labels = [];\n      var i, ilen;\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));\n      }\n\n      return labels;\n    },\n\n    /**\r\n     * @private\r\n     */\n    getPixelForOffset: function (time) {\n      var me = this;\n      var offsets = me._offsets;\n      var pos = interpolate$1(me._table, 'time', time, 'pos');\n      return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    },\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var time = null;\n\n      if (index !== undefined && datasetIndex !== undefined) {\n        time = me._timestamps.datasets[datasetIndex][index];\n      }\n\n      if (time === null) {\n        time = parse(me, value);\n      }\n\n      if (time !== null) {\n        return me.getPixelForOffset(time);\n      }\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.getTicks();\n      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var offsets = me._offsets;\n      var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n      var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly\n\n      return me._adapter._create(time);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getLabelSize: function (label) {\n      var me = this;\n      var ticksOpts = me.options.ticks;\n      var tickLabelWidth = me.ctx.measureText(label).width;\n      var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n      var cosRotation = Math.cos(angle);\n      var sinRotation = Math.sin(angle);\n      var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);\n      return {\n        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n      };\n    },\n\n    /**\r\n     * Crude approximation of what the label width might be\r\n     * @private\r\n     */\n    getLabelWidth: function (label) {\n      return this._getLabelSize(label).w;\n    },\n\n    /**\r\n     * @private\r\n     */\n    getLabelCapacity: function (exampleTime) {\n      var me = this;\n      var timeOpts = me.options.time;\n      var displayFormats = timeOpts.displayFormats; // pick the longest format (milliseconds) for guestimation\n\n      var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n      var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\n\n      var size = me._getLabelSize(exampleLabel);\n\n      var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);\n\n      if (me.options.offset) {\n        capacity--;\n      }\n\n      return capacity > 0 ? capacity : 1;\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$4 = defaultConfig$4;\n  scale_time._defaults = _defaults$4;\n  var scales = {\n    category: scale_category,\n    linear: scale_linear,\n    logarithmic: scale_logarithmic,\n    radialLinear: scale_radialLinear,\n    time: scale_time\n  };\n  var FORMATS = {\n    datetime: 'MMM D, YYYY, h:mm:ss a',\n    millisecond: 'h:mm:ss.SSS a',\n    second: 'h:mm:ss a',\n    minute: 'h:mm a',\n    hour: 'hA',\n    day: 'MMM D',\n    week: 'll',\n    month: 'MMM YYYY',\n    quarter: '[Q]Q - YYYY',\n    year: 'YYYY'\n  };\n\n  core_adapters._date.override(typeof moment === 'function' ? {\n    _id: 'moment',\n    // DEBUG ONLY\n    formats: function () {\n      return FORMATS;\n    },\n    parse: function (value, format) {\n      if (typeof value === 'string' && typeof format === 'string') {\n        value = moment(value, format);\n      } else if (!(value instanceof moment)) {\n        value = moment(value);\n      }\n\n      return value.isValid() ? value.valueOf() : null;\n    },\n    format: function (time, format) {\n      return moment(time).format(format);\n    },\n    add: function (time, amount, unit) {\n      return moment(time).add(amount, unit).valueOf();\n    },\n    diff: function (max, min, unit) {\n      return moment(max).diff(moment(min), unit);\n    },\n    startOf: function (time, unit, weekday) {\n      time = moment(time);\n\n      if (unit === 'isoWeek') {\n        return time.isoWeekday(weekday).valueOf();\n      }\n\n      return time.startOf(unit).valueOf();\n    },\n    endOf: function (time, unit) {\n      return moment(time).endOf(unit).valueOf();\n    },\n    // DEPRECATIONS\n\n    /**\r\n     * Provided for backward compatibility with scale.getValueForPixel().\r\n     * @deprecated since version 2.8.0\r\n     * @todo remove at version 3\r\n     * @private\r\n     */\n    _create: function (time) {\n      return moment(time);\n    }\n  } : {});\n\n  core_defaults._set('global', {\n    plugins: {\n      filler: {\n        propagate: true\n      }\n    }\n  });\n\n  var mappers = {\n    dataset: function (source) {\n      var index = source.fill;\n      var chart = source.chart;\n      var meta = chart.getDatasetMeta(index);\n      var visible = meta && chart.isDatasetVisible(index);\n      var points = visible && meta.dataset._children || [];\n      var length = points.length || 0;\n      return !length ? null : function (point, i) {\n        return i < length && points[i]._view || null;\n      };\n    },\n    boundary: function (source) {\n      var boundary = source.boundary;\n      var x = boundary ? boundary.x : null;\n      var y = boundary ? boundary.y : null;\n\n      if (helpers$1.isArray(boundary)) {\n        return function (point, i) {\n          return boundary[i];\n        };\n      }\n\n      return function (point) {\n        return {\n          x: x === null ? point.x : x,\n          y: y === null ? point.y : y\n        };\n      };\n    }\n  }; // @todo if (fill[0] === '#')\n\n  function decodeFill(el, index, count) {\n    var model = el._model || {};\n    var fill = model.fill;\n    var target;\n\n    if (fill === undefined) {\n      fill = !!model.backgroundColor;\n    }\n\n    if (fill === false || fill === null) {\n      return false;\n    }\n\n    if (fill === true) {\n      return 'origin';\n    }\n\n    target = parseFloat(fill, 10);\n\n    if (isFinite(target) && Math.floor(target) === target) {\n      if (fill[0] === '-' || fill[0] === '+') {\n        target = index + target;\n      }\n\n      if (target === index || target < 0 || target >= count) {\n        return false;\n      }\n\n      return target;\n    }\n\n    switch (fill) {\n      // compatibility\n      case 'bottom':\n        return 'start';\n\n      case 'top':\n        return 'end';\n\n      case 'zero':\n        return 'origin';\n      // supported boundaries\n\n      case 'origin':\n      case 'start':\n      case 'end':\n        return fill;\n      // invalid fill values\n\n      default:\n        return false;\n    }\n  }\n\n  function computeLinearBoundary(source) {\n    var model = source.el._model || {};\n    var scale = source.el._scale || {};\n    var fill = source.fill;\n    var target = null;\n    var horizontal;\n\n    if (isFinite(fill)) {\n      return null;\n    } // Backward compatibility: until v3, we still need to support boundary values set on\n    // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n    // controllers might still use it (e.g. the Smith chart).\n\n\n    if (fill === 'start') {\n      target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n    } else if (fill === 'end') {\n      target = model.scaleTop === undefined ? scale.top : model.scaleTop;\n    } else if (model.scaleZero !== undefined) {\n      target = model.scaleZero;\n    } else if (scale.getBasePixel) {\n      target = scale.getBasePixel();\n    }\n\n    if (target !== undefined && target !== null) {\n      if (target.x !== undefined && target.y !== undefined) {\n        return target;\n      }\n\n      if (helpers$1.isFinite(target)) {\n        horizontal = scale.isHorizontal();\n        return {\n          x: horizontal ? target : null,\n          y: horizontal ? null : target\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function computeCircularBoundary(source) {\n    var scale = source.el._scale;\n    var options = scale.options;\n    var length = scale.chart.data.labels.length;\n    var fill = source.fill;\n    var target = [];\n    var start, end, center, i, point;\n\n    if (!length) {\n      return null;\n    }\n\n    start = options.ticks.reverse ? scale.max : scale.min;\n    end = options.ticks.reverse ? scale.min : scale.max;\n    center = scale.getPointPositionForValue(0, start);\n\n    for (i = 0; i < length; ++i) {\n      point = fill === 'start' || fill === 'end' ? scale.getPointPositionForValue(i, fill === 'start' ? start : end) : scale.getBasePosition(i);\n\n      if (options.gridLines.circular) {\n        point.cx = center.x;\n        point.cy = center.y;\n        point.angle = scale.getIndexAngle(i) - Math.PI / 2;\n      }\n\n      target.push(point);\n    }\n\n    return target;\n  }\n\n  function computeBoundary(source) {\n    var scale = source.el._scale || {};\n\n    if (scale.getPointPositionForValue) {\n      return computeCircularBoundary(source);\n    }\n\n    return computeLinearBoundary(source);\n  }\n\n  function resolveTarget(sources, index, propagate) {\n    var source = sources[index];\n    var fill = source.fill;\n    var visited = [index];\n    var target;\n\n    if (!propagate) {\n      return fill;\n    }\n\n    while (fill !== false && visited.indexOf(fill) === -1) {\n      if (!isFinite(fill)) {\n        return fill;\n      }\n\n      target = sources[fill];\n\n      if (!target) {\n        return false;\n      }\n\n      if (target.visible) {\n        return fill;\n      }\n\n      visited.push(fill);\n      fill = target.fill;\n    }\n\n    return false;\n  }\n\n  function createMapper(source) {\n    var fill = source.fill;\n    var type = 'dataset';\n\n    if (fill === false) {\n      return null;\n    }\n\n    if (!isFinite(fill)) {\n      type = 'boundary';\n    }\n\n    return mappers[type](source);\n  }\n\n  function isDrawable(point) {\n    return point && !point.skip;\n  }\n\n  function drawArea(ctx, curve0, curve1, len0, len1) {\n    var i, cx, cy, r;\n\n    if (!len0 || !len1) {\n      return;\n    } // building first area curve (normal)\n\n\n    ctx.moveTo(curve0[0].x, curve0[0].y);\n\n    for (i = 1; i < len0; ++i) {\n      helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n    }\n\n    if (curve1[0].angle !== undefined) {\n      cx = curve1[0].cx;\n      cy = curve1[0].cy;\n      r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));\n\n      for (i = len1 - 1; i > 0; --i) {\n        ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);\n      }\n\n      return;\n    } // joining the two area curves\n\n\n    ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)\n\n    for (i = len1 - 1; i > 0; --i) {\n      helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n    }\n  }\n\n  function doFill(ctx, points, mapper, view, color, loop) {\n    var count = points.length;\n    var span = view.spanGaps;\n    var curve0 = [];\n    var curve1 = [];\n    var len0 = 0;\n    var len1 = 0;\n    var i, ilen, index, p0, p1, d0, d1, loopOffset;\n    ctx.beginPath();\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i % count;\n      p0 = points[index]._view;\n      p1 = mapper(p0, index, view);\n      d0 = isDrawable(p0);\n      d1 = isDrawable(p1);\n\n      if (loop && loopOffset === undefined && d0) {\n        loopOffset = i + 1;\n        ilen = count + loopOffset;\n      }\n\n      if (d0 && d1) {\n        len0 = curve0.push(p0);\n        len1 = curve1.push(p1);\n      } else if (len0 && len1) {\n        if (!span) {\n          drawArea(ctx, curve0, curve1, len0, len1);\n          len0 = len1 = 0;\n          curve0 = [];\n          curve1 = [];\n        } else {\n          if (d0) {\n            curve0.push(p0);\n          }\n\n          if (d1) {\n            curve1.push(p1);\n          }\n        }\n      }\n    }\n\n    drawArea(ctx, curve0, curve1, len0, len1);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n  }\n\n  var plugin_filler = {\n    id: 'filler',\n    afterDatasetsUpdate: function (chart, options) {\n      var count = (chart.data.datasets || []).length;\n      var propagate = options.propagate;\n      var sources = [];\n      var meta, i, el, source;\n\n      for (i = 0; i < count; ++i) {\n        meta = chart.getDatasetMeta(i);\n        el = meta.dataset;\n        source = null;\n\n        if (el && el._model && el instanceof elements.Line) {\n          source = {\n            visible: chart.isDatasetVisible(i),\n            fill: decodeFill(el, i, count),\n            chart: chart,\n            el: el\n          };\n        }\n\n        meta.$filler = source;\n        sources.push(source);\n      }\n\n      for (i = 0; i < count; ++i) {\n        source = sources[i];\n\n        if (!source) {\n          continue;\n        }\n\n        source.fill = resolveTarget(sources, i, propagate);\n        source.boundary = computeBoundary(source);\n        source.mapper = createMapper(source);\n      }\n    },\n    beforeDatasetsDraw: function (chart) {\n      var metasets = chart._getSortedVisibleDatasetMetas();\n\n      var ctx = chart.ctx;\n      var meta, i, el, view, points, mapper, color;\n\n      for (i = metasets.length - 1; i >= 0; --i) {\n        meta = metasets[i].$filler;\n\n        if (!meta || !meta.visible) {\n          continue;\n        }\n\n        el = meta.el;\n        view = el._view;\n        points = el._children || [];\n        mapper = meta.mapper;\n        color = view.backgroundColor || core_defaults.global.defaultColor;\n\n        if (mapper && color && points.length) {\n          helpers$1.canvas.clipArea(ctx, chart.chartArea);\n          doFill(ctx, points, mapper, view, color, el._loop);\n          helpers$1.canvas.unclipArea(ctx);\n        }\n      }\n    }\n  };\n  var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;\n  var noop$1 = helpers$1.noop;\n  var valueOrDefault$e = helpers$1.valueOrDefault;\n\n  core_defaults._set('global', {\n    legend: {\n      display: true,\n      position: 'top',\n      align: 'center',\n      fullWidth: true,\n      reverse: false,\n      weight: 1000,\n      // a callback that will handle\n      onClick: function (e, legendItem) {\n        var index = legendItem.datasetIndex;\n        var ci = this.chart;\n        var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment\n\n        meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart\n\n        ci.update();\n      },\n      onHover: null,\n      onLeave: null,\n      labels: {\n        boxWidth: 40,\n        padding: 10,\n        // Generates labels shown in the legend\n        // Valid properties to return:\n        // text : text to display\n        // fillStyle : fill of coloured box\n        // strokeStyle: stroke of coloured box\n        // hidden : if this legend item refers to a hidden item\n        // lineCap : cap style for line\n        // lineDash\n        // lineDashOffset :\n        // lineJoin :\n        // lineWidth :\n        generateLabels: function (chart) {\n          var datasets = chart.data.datasets;\n          var options = chart.options.legend || {};\n          var usePointStyle = options.labels && options.labels.usePointStyle;\n          return chart._getSortedDatasetMetas().map(function (meta) {\n            var style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n            return {\n              text: datasets[meta.index].label,\n              fillStyle: style.backgroundColor,\n              hidden: !chart.isDatasetVisible(meta.index),\n              lineCap: style.borderCapStyle,\n              lineDash: style.borderDash,\n              lineDashOffset: style.borderDashOffset,\n              lineJoin: style.borderJoinStyle,\n              lineWidth: style.borderWidth,\n              strokeStyle: style.borderColor,\n              pointStyle: style.pointStyle,\n              rotation: style.rotation,\n              // Below is extra data used for toggling the datasets\n              datasetIndex: meta.index\n            };\n          }, this);\n        }\n      }\n    },\n    legendCallback: function (chart) {\n      var list = document.createElement('ul');\n      var datasets = chart.data.datasets;\n      var i, ilen, listItem, listItemSpan;\n      list.setAttribute('class', chart.id + '-legend');\n\n      for (i = 0, ilen = datasets.length; i < ilen; i++) {\n        listItem = list.appendChild(document.createElement('li'));\n        listItemSpan = listItem.appendChild(document.createElement('span'));\n        listItemSpan.style.backgroundColor = datasets[i].backgroundColor;\n\n        if (datasets[i].label) {\n          listItem.appendChild(document.createTextNode(datasets[i].label));\n        }\n      }\n\n      return list.outerHTML;\n    }\n  });\n  /**\r\n   * Helper function to get the box width based on the usePointStyle option\r\n   * @param {object} labelopts - the label options on the legend\r\n   * @param {number} fontSize - the label font size\r\n   * @return {number} width of the color box area\r\n   */\n\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;\n  }\n  /**\r\n   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\r\n   */\n\n\n  var Legend = core_element.extend({\n    initialize: function (config) {\n      var me = this;\n      helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)\n\n      me.legendHitBoxes = [];\n      /**\r\n      \t * @private\r\n      \t */\n\n      me._hoveredItem = null; // Are we in doughnut mode which has a different data type\n\n      me.doughnutMode = false;\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    // Any function defined here is inherited by all legend types.\n    // Any function can be extended by the legend type\n    beforeUpdate: noop$1,\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop$1,\n    //\n    beforeSetDimensions: noop$1,\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop$1,\n    //\n    beforeBuildLabels: noop$1,\n    buildLabels: function () {\n      var me = this;\n      var labelOpts = me.options.labels || {};\n      var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n      if (labelOpts.filter) {\n        legendItems = legendItems.filter(function (item) {\n          return labelOpts.filter(item, me.chart.data);\n        });\n      }\n\n      if (me.options.reverse) {\n        legendItems.reverse();\n      }\n\n      me.legendItems = legendItems;\n    },\n    afterBuildLabels: noop$1,\n    //\n    beforeFit: noop$1,\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var display = opts.display;\n      var ctx = me.ctx;\n\n      var labelFont = helpers$1.options._parseFont(labelOpts);\n\n      var fontSize = labelFont.size; // Reset hit boxes\n\n      var hitboxes = me.legendHitBoxes = [];\n      var minSize = me.minSize;\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth; // fill all the width\n\n        minSize.height = display ? 10 : 0;\n      } else {\n        minSize.width = display ? 10 : 0;\n        minSize.height = me.maxHeight; // fill all the height\n      } // Increase sizes here\n\n\n      if (!display) {\n        me.width = minSize.width = me.height = minSize.height = 0;\n        return;\n      }\n\n      ctx.font = labelFont.string;\n\n      if (isHorizontal) {\n        // Labels\n        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n        var lineWidths = me.lineWidths = [0];\n        var totalHeight = 0;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        helpers$1.each(me.legendItems, function (legendItem, i) {\n          var boxWidth = getBoxWidth(labelOpts, fontSize);\n          var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n          if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\n            totalHeight += fontSize + labelOpts.padding;\n            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n          } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: width,\n            height: fontSize\n          };\n          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n        });\n        minSize.height += totalHeight;\n      } else {\n        var vPadding = labelOpts.padding;\n        var columnWidths = me.columnWidths = [];\n        var columnHeights = me.columnHeights = [];\n        var totalWidth = labelOpts.padding;\n        var currentColWidth = 0;\n        var currentColHeight = 0;\n        helpers$1.each(me.legendItems, function (legendItem, i) {\n          var boxWidth = getBoxWidth(labelOpts, fontSize);\n          var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column\n\n          if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {\n            totalWidth += currentColWidth + labelOpts.padding;\n            columnWidths.push(currentColWidth); // previous column width\n\n            columnHeights.push(currentColHeight);\n            currentColWidth = 0;\n            currentColHeight = 0;\n          } // Get max width\n\n\n          currentColWidth = Math.max(currentColWidth, itemWidth);\n          currentColHeight += fontSize + vPadding; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: itemWidth,\n            height: fontSize\n          };\n        });\n        totalWidth += currentColWidth;\n        columnWidths.push(currentColWidth);\n        columnHeights.push(currentColHeight);\n        minSize.width += totalWidth;\n      }\n\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n    afterFit: noop$1,\n    // Shared Methods\n    isHorizontal: function () {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    // Actually draw the legend on the canvas\n    draw: function () {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var globalDefaults = core_defaults.global;\n      var defaultColor = globalDefaults.defaultColor;\n      var lineDefault = globalDefaults.elements.line;\n      var legendHeight = me.height;\n      var columnHeights = me.columnHeights;\n      var legendWidth = me.width;\n      var lineWidths = me.lineWidths;\n\n      if (!opts.display) {\n        return;\n      }\n\n      var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);\n      var ctx = me.ctx;\n      var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);\n\n      var labelFont = helpers$1.options._parseFont(labelOpts);\n\n      var fontSize = labelFont.size;\n      var cursor; // Canvas setup\n\n      ctx.textAlign = rtlHelper.textAlign('left');\n      ctx.textBaseline = 'middle';\n      ctx.lineWidth = 0.5;\n      ctx.strokeStyle = fontColor; // for strikethrough effect\n\n      ctx.fillStyle = fontColor; // render in correct colour\n\n      ctx.font = labelFont.string;\n      var boxWidth = getBoxWidth(labelOpts, fontSize);\n      var hitboxes = me.legendHitBoxes; // current position\n\n      var drawLegendBox = function (x, y, legendItem) {\n        if (isNaN(boxWidth) || boxWidth <= 0) {\n          return;\n        } // Set the ctx for the box\n\n\n        ctx.save();\n        var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);\n        ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);\n        ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);\n        ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n        ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);\n\n        if (ctx.setLineDash) {\n          // IE 9 and 10 do not support line dash\n          ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));\n        }\n\n        if (labelOpts && labelOpts.usePointStyle) {\n          // Recalculate x and y for drawPoint() because its expecting\n          // x and y to be center of figure (instead of top left)\n          var radius = boxWidth * Math.SQRT2 / 2;\n          var centerX = rtlHelper.xPlus(x, boxWidth / 2);\n          var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol\n\n          helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);\n        } else {\n          // Draw box as legend symbol\n          ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);\n\n          if (lineWidth !== 0) {\n            ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);\n          }\n        }\n\n        ctx.restore();\n      };\n\n      var fillText = function (x, y, legendItem, textWidth) {\n        var halfFontSize = fontSize / 2;\n        var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);\n        var yMiddle = y + halfFontSize;\n        ctx.fillText(legendItem.text, xLeft, yMiddle);\n\n        if (legendItem.hidden) {\n          // Strikethrough the text if hidden\n          ctx.beginPath();\n          ctx.lineWidth = 2;\n          ctx.moveTo(xLeft, yMiddle);\n          ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);\n          ctx.stroke();\n        }\n      };\n\n      var alignmentOffset = function (dimension, blockSize) {\n        switch (opts.align) {\n          case 'start':\n            return labelOpts.padding;\n\n          case 'end':\n            return dimension - blockSize;\n\n          default:\n            // center\n            return (dimension - blockSize + labelOpts.padding) / 2;\n        }\n      }; // Horizontal\n\n\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        cursor = {\n          x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n          y: me.top + labelOpts.padding,\n          line: 0\n        };\n      } else {\n        cursor = {\n          x: me.left + labelOpts.padding,\n          y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\n          line: 0\n        };\n      }\n\n      helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);\n      var itemHeight = fontSize + labelOpts.padding;\n      helpers$1.each(me.legendItems, function (legendItem, i) {\n        var textWidth = ctx.measureText(legendItem.text).width;\n        var width = boxWidth + fontSize / 2 + textWidth;\n        var x = cursor.x;\n        var y = cursor.y;\n        rtlHelper.setWidth(me.minSize.width); // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\n        // instead of me.right and me.bottom because me.width and me.height\n        // may have been changed since me.minSize was calculated\n\n        if (isHorizontal) {\n          if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\n            y = cursor.y += itemHeight;\n            cursor.line++;\n            x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n          }\n        } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\n          x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n          cursor.line++;\n          y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\n        }\n\n        var realX = rtlHelper.x(x);\n        drawLegendBox(realX, y, legendItem);\n        hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);\n        hitboxes[i].top = y; // Fill the actual label\n\n        fillText(realX, y, legendItem, textWidth);\n\n        if (isHorizontal) {\n          cursor.x += width + labelOpts.padding;\n        } else {\n          cursor.y += itemHeight;\n        }\n      });\n      helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);\n    },\n\n    /**\r\n     * @private\r\n     */\n    _getLegendItemAt: function (x, y) {\n      var me = this;\n      var i, hitBox, lh;\n\n      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n        // See if we are touching one of the dataset boxes\n        lh = me.legendHitBoxes;\n\n        for (i = 0; i < lh.length; ++i) {\n          hitBox = lh[i];\n\n          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n            // Touching an element\n            return me.legendItems[i];\n          }\n        }\n      }\n\n      return null;\n    },\n\n    /**\r\n     * Handle an event\r\n     * @private\r\n     * @param {IEvent} event - The event to handle\r\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var opts = me.options;\n      var type = e.type === 'mouseup' ? 'click' : e.type;\n      var hoveredItem;\n\n      if (type === 'mousemove') {\n        if (!opts.onHover && !opts.onLeave) {\n          return;\n        }\n      } else if (type === 'click') {\n        if (!opts.onClick) {\n          return;\n        }\n      } else {\n        return;\n      } // Chart event already has relative position in it\n\n\n      hoveredItem = me._getLegendItemAt(e.x, e.y);\n\n      if (type === 'click') {\n        if (hoveredItem && opts.onClick) {\n          // use e.native for backwards compatibility\n          opts.onClick.call(me, e.native, hoveredItem);\n        }\n      } else {\n        if (opts.onLeave && hoveredItem !== me._hoveredItem) {\n          if (me._hoveredItem) {\n            opts.onLeave.call(me, e.native, me._hoveredItem);\n          }\n\n          me._hoveredItem = hoveredItem;\n        }\n\n        if (opts.onHover && hoveredItem) {\n          // use e.native for backwards compatibility\n          opts.onHover.call(me, e.native, hoveredItem);\n        }\n      }\n    }\n  });\n\n  function createNewLegendAndAttach(chart, legendOpts) {\n    var legend = new Legend({\n      ctx: chart.ctx,\n      options: legendOpts,\n      chart: chart\n    });\n    core_layouts.configure(chart, legend, legendOpts);\n    core_layouts.addBox(chart, legend);\n    chart.legend = legend;\n  }\n\n  var plugin_legend = {\n    id: 'legend',\n\n    /**\r\n     * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\r\n     * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\r\n     * the plugin, which one will be re-exposed in the chart.js file.\r\n     * https://github.com/chartjs/Chart.js/pull/2640\r\n     * @private\r\n     */\n    _element: Legend,\n    beforeInit: function (chart) {\n      var legendOpts = chart.options.legend;\n\n      if (legendOpts) {\n        createNewLegendAndAttach(chart, legendOpts);\n      }\n    },\n    beforeUpdate: function (chart) {\n      var legendOpts = chart.options.legend;\n      var legend = chart.legend;\n\n      if (legendOpts) {\n        helpers$1.mergeIf(legendOpts, core_defaults.global.legend);\n\n        if (legend) {\n          core_layouts.configure(chart, legend, legendOpts);\n          legend.options = legendOpts;\n        } else {\n          createNewLegendAndAttach(chart, legendOpts);\n        }\n      } else if (legend) {\n        core_layouts.removeBox(chart, legend);\n        delete chart.legend;\n      }\n    },\n    afterEvent: function (chart, e) {\n      var legend = chart.legend;\n\n      if (legend) {\n        legend.handleEvent(e);\n      }\n    }\n  };\n  var noop$2 = helpers$1.noop;\n\n  core_defaults._set('global', {\n    title: {\n      display: false,\n      fontStyle: 'bold',\n      fullWidth: true,\n      padding: 10,\n      position: 'top',\n      text: '',\n      weight: 2000 // by default greater than legend (1000) to be above\n\n    }\n  });\n  /**\r\n   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\r\n   */\n\n\n  var Title = core_element.extend({\n    initialize: function (config) {\n      var me = this;\n      helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)\n\n      me.legendHitBoxes = [];\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    beforeUpdate: noop$2,\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop$2,\n    //\n    beforeSetDimensions: noop$2,\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop$2,\n    //\n    beforeBuildLabels: noop$2,\n    buildLabels: noop$2,\n    afterBuildLabels: noop$2,\n    //\n    beforeFit: noop$2,\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n      var minSize = me.minSize = {};\n      var isHorizontal = me.isHorizontal();\n      var lineCount, textSize;\n\n      if (!opts.display) {\n        me.width = minSize.width = me.height = minSize.height = 0;\n        return;\n      }\n\n      lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;\n      textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;\n      me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;\n      me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;\n    },\n    afterFit: noop$2,\n    // Shared Methods\n    isHorizontal: function () {\n      var pos = this.options.position;\n      return pos === 'top' || pos === 'bottom';\n    },\n    // Actually draw the title block on the canvas\n    draw: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var opts = me.options;\n\n      if (!opts.display) {\n        return;\n      }\n\n      var fontOpts = helpers$1.options._parseFont(opts);\n\n      var lineHeight = fontOpts.lineHeight;\n      var offset = lineHeight / 2 + opts.padding;\n      var rotation = 0;\n      var top = me.top;\n      var left = me.left;\n      var bottom = me.bottom;\n      var right = me.right;\n      var maxWidth, titleX, titleY;\n      ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour\n\n      ctx.font = fontOpts.string; // Horizontal\n\n      if (me.isHorizontal()) {\n        titleX = left + (right - left) / 2; // midpoint of the width\n\n        titleY = top + offset;\n        maxWidth = right - left;\n      } else {\n        titleX = opts.position === 'left' ? left + offset : right - offset;\n        titleY = top + (bottom - top) / 2;\n        maxWidth = bottom - top;\n        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n      }\n\n      ctx.save();\n      ctx.translate(titleX, titleY);\n      ctx.rotate(rotation);\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      var text = opts.text;\n\n      if (helpers$1.isArray(text)) {\n        var y = 0;\n\n        for (var i = 0; i < text.length; ++i) {\n          ctx.fillText(text[i], 0, y, maxWidth);\n          y += lineHeight;\n        }\n      } else {\n        ctx.fillText(text, 0, 0, maxWidth);\n      }\n\n      ctx.restore();\n    }\n  });\n\n  function createNewTitleBlockAndAttach(chart, titleOpts) {\n    var title = new Title({\n      ctx: chart.ctx,\n      options: titleOpts,\n      chart: chart\n    });\n    core_layouts.configure(chart, title, titleOpts);\n    core_layouts.addBox(chart, title);\n    chart.titleBlock = title;\n  }\n\n  var plugin_title = {\n    id: 'title',\n\n    /**\r\n     * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\r\n     * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\r\n     * the plugin, which one will be re-exposed in the chart.js file.\r\n     * https://github.com/chartjs/Chart.js/pull/2640\r\n     * @private\r\n     */\n    _element: Title,\n    beforeInit: function (chart) {\n      var titleOpts = chart.options.title;\n\n      if (titleOpts) {\n        createNewTitleBlockAndAttach(chart, titleOpts);\n      }\n    },\n    beforeUpdate: function (chart) {\n      var titleOpts = chart.options.title;\n      var titleBlock = chart.titleBlock;\n\n      if (titleOpts) {\n        helpers$1.mergeIf(titleOpts, core_defaults.global.title);\n\n        if (titleBlock) {\n          core_layouts.configure(chart, titleBlock, titleOpts);\n          titleBlock.options = titleOpts;\n        } else {\n          createNewTitleBlockAndAttach(chart, titleOpts);\n        }\n      } else if (titleBlock) {\n        core_layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n      }\n    }\n  };\n  var plugins = {};\n  var filler = plugin_filler;\n  var legend = plugin_legend;\n  var title = plugin_title;\n  plugins.filler = filler;\n  plugins.legend = legend;\n  plugins.title = title;\n  /**\r\n   * @namespace Chart\r\n   */\n\n  core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\n\n  core_helpers();\n  core_controller._adapters = core_adapters;\n  core_controller.Animation = core_animation;\n  core_controller.animationService = core_animations;\n  core_controller.controllers = controllers;\n  core_controller.DatasetController = core_datasetController;\n  core_controller.defaults = core_defaults;\n  core_controller.Element = core_element;\n  core_controller.elements = elements;\n  core_controller.Interaction = core_interaction;\n  core_controller.layouts = core_layouts;\n  core_controller.platform = platform;\n  core_controller.plugins = core_plugins;\n  core_controller.Scale = core_scale;\n  core_controller.scaleService = core_scaleService;\n  core_controller.Ticks = core_ticks;\n  core_controller.Tooltip = core_tooltip; // Register built-in scales\n\n  core_controller.helpers.each(scales, function (scale, type) {\n    core_controller.scaleService.registerScaleType(type, scale, scale._defaults);\n  }); // Load to register built-in adapters (as side effects)\n  // Loading built-in plugins\n\n  for (var k in plugins) {\n    if (plugins.hasOwnProperty(k)) {\n      core_controller.plugins.register(plugins[k]);\n    }\n  }\n\n  core_controller.platform.initialize();\n  var src = core_controller;\n\n  if (typeof window !== 'undefined') {\n    window.Chart = core_controller;\n  } // DEPRECATIONS\n\n  /**\r\n   * Provided for backward compatibility, not available anymore\r\n   * @namespace Chart.Chart\r\n   * @deprecated since version 2.8.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n\n  core_controller.Chart = core_controller;\n  /**\r\n   * Provided for backward compatibility, not available anymore\r\n   * @namespace Chart.Legend\r\n   * @deprecated since version 2.1.5\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.Legend = plugins.legend._element;\n  /**\r\n   * Provided for backward compatibility, not available anymore\r\n   * @namespace Chart.Title\r\n   * @deprecated since version 2.1.5\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.Title = plugins.title._element;\n  /**\r\n   * Provided for backward compatibility, use Chart.plugins instead\r\n   * @namespace Chart.pluginService\r\n   * @deprecated since version 2.1.5\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.pluginService = core_controller.plugins;\n  /**\r\n   * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\r\n   * effect, instead simply create/register plugins via plain JavaScript objects.\r\n   * @interface Chart.PluginBase\r\n   * @deprecated since version 2.5.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.PluginBase = core_controller.Element.extend({});\n  /**\r\n   * Provided for backward compatibility, use Chart.helpers.canvas instead.\r\n   * @namespace Chart.canvasHelpers\r\n   * @deprecated since version 2.6.0\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.canvasHelpers = core_controller.helpers.canvas;\n  /**\r\n   * Provided for backward compatibility, use Chart.layouts instead.\r\n   * @namespace Chart.layoutService\r\n   * @deprecated since version 2.7.3\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.layoutService = core_controller.layouts;\n  /**\r\n   * Provided for backward compatibility, not available anymore.\r\n   * @namespace Chart.LinearScaleBase\r\n   * @deprecated since version 2.8\r\n   * @todo remove at version 3\r\n   * @private\r\n   */\n\n  core_controller.LinearScaleBase = scale_linearbase;\n  /**\r\n   * Provided for backward compatibility, instead we should create a new Chart\r\n   * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\r\n   * @deprecated since version 2.8.0\r\n   * @todo remove at version 3\r\n   */\n\n  core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {\n    core_controller[klass] = function (ctx, cfg) {\n      return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {\n        type: klass.charAt(0).toLowerCase() + klass.slice(1)\n      }));\n    };\n  });\n  return src;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcz8zMGVmIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImUiLCJtb21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIiwibiIsImNvbG9yTmFtZSIsImNvbnZlcnNpb25zIiwicmV2ZXJzZUtleXdvcmRzIiwia2V5IiwiY29udmVydCIsInJnYiIsImNoYW5uZWxzIiwibGFiZWxzIiwiaHNsIiwiaHN2IiwiaHdiIiwiY215ayIsInh5eiIsImxhYiIsImxjaCIsImhleCIsImtleXdvcmQiLCJhbnNpMTYiLCJhbnNpMjU2IiwiaGNnIiwiYXBwbGUiLCJncmF5IiwibW9kZWwiLCJFcnJvciIsImxlbmd0aCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJyIiwiZyIsImIiLCJtaW4iLCJNYXRoIiwibWF4IiwiZGVsdGEiLCJoIiwicyIsImwiLCJyZGlmIiwiZ2RpZiIsImJkaWYiLCJ2IiwiZGlmZiIsImRpZmZjIiwiYyIsInciLCJtIiwieSIsImsiLCJjb21wYXJhdGl2ZURpc3RhbmNlIiwieCIsInBvdyIsInJldmVyc2VkIiwiY3VycmVudENsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiY3VycmVudENsb3Nlc3RLZXl3b3JkIiwiZGlzdGFuY2UiLCJ6IiwiYSIsInQxIiwidDIiLCJ0MyIsInZhbCIsImkiLCJzbWluIiwibG1pbiIsInN2IiwiaGkiLCJmbG9vciIsImYiLCJwIiwicSIsInQiLCJ2bWluIiwic2wiLCJ3aCIsImJsIiwicmF0aW8iLCJ5MiIsIngyIiwiejIiLCJociIsImF0YW4yIiwiUEkiLCJzcXJ0IiwiY29zIiwic2luIiwiYXJncyIsImFyZ3VtZW50cyIsInJvdW5kIiwiYW5zaSIsImNvbG9yIiwibXVsdCIsInJlbSIsImludGVnZXIiLCJzdHJpbmciLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwic3Vic3RyaW5nIiwibWF0Y2giLCJjb2xvclN0cmluZyIsInNwbGl0IiwibWFwIiwiY2hhciIsImpvaW4iLCJwYXJzZUludCIsImNocm9tYSIsImdyYXlzY2FsZSIsImh1ZSIsInB1cmUiLCJtZyIsImNvbnZlcnNpb25zXzEiLCJjb252ZXJzaW9uc18yIiwiY29udmVyc2lvbnNfMyIsImNvbnZlcnNpb25zXzQiLCJjb252ZXJzaW9uc181IiwiY29udmVyc2lvbnNfNiIsImNvbnZlcnNpb25zXzciLCJjb252ZXJzaW9uc184IiwiY29udmVyc2lvbnNfOSIsImNvbnZlcnNpb25zXzEwIiwiY29udmVyc2lvbnNfMTEiLCJjb252ZXJzaW9uc18xMiIsImNvbnZlcnNpb25zXzEzIiwiY29udmVyc2lvbnNfMTQiLCJjb252ZXJzaW9uc18xNSIsImJ1aWxkR3JhcGgiLCJncmFwaCIsIm1vZGVscyIsImtleXMiLCJsZW4iLCJwYXJlbnQiLCJkZXJpdmVCRlMiLCJmcm9tTW9kZWwiLCJxdWV1ZSIsImN1cnJlbnQiLCJwb3AiLCJhZGphY2VudHMiLCJhZGphY2VudCIsIm5vZGUiLCJ1bnNoaWZ0IiwibGluayIsImZyb20iLCJ0byIsIndyYXBDb252ZXJzaW9uIiwidG9Nb2RlbCIsInBhdGgiLCJjdXIiLCJjb252ZXJzaW9uIiwicm91dGUiLCJ3cmFwUmF3Iiwid3JhcHBlZEZuIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJ3cmFwUm91bmRlZCIsInJlc3VsdCIsImZvckVhY2giLCJyb3V0ZXMiLCJyb3V0ZU1vZGVscyIsInJhdyIsImNvbG9yQ29udmVydCIsImNvbG9yTmFtZSQxIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwiYWJiciIsInJnYmEiLCJwZXIiLCJoZXhBbHBoYSIsInBhcnNlRmxvYXQiLCJzY2FsZSIsImFscGhhIiwiaXNOYU4iLCJoc2xhIiwidmFscyIsImhleERvdWJsZSIsInJldmVyc2VOYW1lcyIsIm51bSIsInN0ciIsIm5hbWUiLCJDb2xvciIsIm9iaiIsInZhbGlkIiwidmFsdWVzIiwic2V0VmFsdWVzIiwicmVkIiwibGlnaHRuZXNzIiwid2hpdGVuZXNzIiwiY3lhbiIsImlzVmFsaWQiLCJzZXRTcGFjZSIsInJnYkFycmF5IiwiaHNsQXJyYXkiLCJoc3ZBcnJheSIsImh3YkFycmF5IiwiY29uY2F0IiwiY215a0FycmF5IiwicmdiYUFycmF5IiwiaHNsYUFycmF5Iiwic2V0Q2hhbm5lbCIsImdyZWVuIiwiYmx1ZSIsInNhdHVyYXRpb24iLCJzYXR1cmF0aW9udiIsImJsYWNrbmVzcyIsIm1hZ2VudGEiLCJ5ZWxsb3ciLCJibGFjayIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJjaGFuIiwiY29udHJhc3QiLCJjb2xvcjIiLCJsdW0xIiwibHVtMiIsImxldmVsIiwiY29udHJhc3RSYXRpbyIsImRhcmsiLCJ5aXEiLCJsaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJzYXR1cmF0ZSIsImRlc2F0dXJhdGUiLCJ3aGl0ZW4iLCJibGFja2VuIiwiZ3JleXNjYWxlIiwiY2xlYXJlciIsIm9wYXF1ZXIiLCJyb3RhdGUiLCJkZWdyZWVzIiwibWl4IiwibWl4aW5Db2xvciIsIndlaWdodCIsImNvbG9yMSIsIncxIiwidzIiLCJ0b0pTT04iLCJjbG9uZSIsInNvdXJjZSIsInRhcmdldCIsInR5cGUiLCJwcm9wIiwiY29uc29sZSIsImVycm9yIiwic3BhY2VzIiwibWF4ZXMiLCJnZXRWYWx1ZXMiLCJzcGFjZSIsImNoYXJBdCIsImNoYW5zIiwiY2FwcGVkIiwic25hbWUiLCJpbmRleCIsInN2YWx1ZXMiLCJ3aW5kb3ciLCJjaGFydGpzQ29sb3IiLCJpc1ZhbGlkS2V5IiwiaW5kZXhPZiIsImhlbHBlcnMiLCJub29wIiwidWlkIiwiaWQiLCJpc051bGxPclVuZGVmIiwiaXNBcnJheSIsInN1YnN0ciIsImlzT2JqZWN0IiwiaXNGaW5pdGUiLCJOdW1iZXIiLCJ2YWx1ZU9yRGVmYXVsdCIsImRlZmF1bHRWYWx1ZSIsInZhbHVlQXRJbmRleE9yRGVmYXVsdCIsImNhbGxiYWNrIiwidGhpc0FyZyIsImFwcGx5IiwiZWFjaCIsImxvb3BhYmxlIiwicmV2ZXJzZSIsImFycmF5RXF1YWxzIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwiY3JlYXRlIiwia2xlbiIsIl9tZXJnZXIiLCJvcHRpb25zIiwidHZhbCIsInN2YWwiLCJtZXJnZSIsIl9tZXJnZXJJZiIsIm1lcmdlSWYiLCJzb3VyY2VzIiwibWVyZ2VyIiwiZXh0ZW5kIiwiYXNzaWduIiwiZHN0Iiwic3JjIiwiaW5oZXJpdHMiLCJleHRlbnNpb25zIiwibWUiLCJDaGFydEVsZW1lbnQiLCJjb25zdHJ1Y3RvciIsIlN1cnJvZ2F0ZSIsIl9fc3VwZXJfXyIsIl9kZXByZWNhdGVkIiwic2NvcGUiLCJwcmV2aW91cyIsIndhcm4iLCJoZWxwZXJzX2NvcmUiLCJjYWxsQ2FsbGJhY2siLCJhcnJheSIsIml0ZW0iLCJmcm9tSW5kZXgiLCJnZXRWYWx1ZU9yRGVmYXVsdCIsImdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCIsImVmZmVjdHMiLCJsaW5lYXIiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwiZWFzZU91dENpcmMiLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluRWxhc3RpYyIsImFzaW4iLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsImVhc2VJbk91dEJvdW5jZSIsImhlbHBlcnNfZWFzaW5nIiwiZWFzaW5nRWZmZWN0cyIsIlJBRF9QRVJfREVHIiwiRE9VQkxFX1BJIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwiZXhwb3J0cyQxIiwiY2xlYXIiLCJjaGFydCIsImN0eCIsImNsZWFyUmVjdCIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmRlZFJlY3QiLCJyYWRpdXMiLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJtb3ZlVG8iLCJhcmMiLCJjbG9zZVBhdGgiLCJyZWN0IiwiZHJhd1BvaW50Iiwic3R5bGUiLCJyb3RhdGlvbiIsInhPZmZzZXQiLCJ5T2Zmc2V0Iiwic2l6ZSIsImNvcm5lclJhZGl1cyIsInJhZCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJkcmF3SW1hZ2UiLCJyZXN0b3JlIiwiYmVnaW5QYXRoIiwibGluZVRvIiwiU1FSVDFfMiIsImZpbGwiLCJzdHJva2UiLCJfaXNQb2ludEluQXJlYSIsInBvaW50IiwiYXJlYSIsImVwc2lsb24iLCJjbGlwQXJlYSIsImNsaXAiLCJ1bmNsaXBBcmVhIiwiZmxpcCIsInN0ZXBwZWQiLCJzdGVwcGVkTGluZSIsIm1pZHBvaW50IiwidGVuc2lvbiIsImJlemllckN1cnZlVG8iLCJjb250cm9sUG9pbnRQcmV2aW91c1giLCJjb250cm9sUG9pbnROZXh0WCIsImNvbnRyb2xQb2ludFByZXZpb3VzWSIsImNvbnRyb2xQb2ludE5leHRZIiwiaGVscGVyc19jYW52YXMiLCJkcmF3Um91bmRlZFJlY3RhbmdsZSIsImRlZmF1bHRzIiwiX3NldCIsImRlZmF1bHRDb2xvciIsImRlZmF1bHRGb250Q29sb3IiLCJkZWZhdWx0Rm9udEZhbWlseSIsImRlZmF1bHRGb250U2l6ZSIsImRlZmF1bHRGb250U3R5bGUiLCJkZWZhdWx0TGluZUhlaWdodCIsInNob3dMaW5lcyIsImNvcmVfZGVmYXVsdHMiLCJ0b0ZvbnRTdHJpbmciLCJmb250IiwiZmFtaWx5IiwiaGVscGVyc19vcHRpb25zIiwidG9MaW5lSGVpZ2h0IiwibWF0Y2hlcyIsInRvUGFkZGluZyIsIl9wYXJzZUZvbnQiLCJnbG9iYWxEZWZhdWx0cyIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImxpbmVIZWlnaHQiLCJmb250U3R5bGUiLCJyZXNvbHZlIiwiaW5wdXRzIiwiY29udGV4dCIsImluZm8iLCJjYWNoZWFibGUiLCJleHBvcnRzJDIiLCJfZmFjdG9yaXplIiwicHVzaCIsInNvcnQiLCJsb2cxMCIsImV4cG9uZW50IiwibG9nIiwiTE9HMTBFIiwicG93ZXJPZjEwIiwiaXNQb3dlck9mMTAiLCJoZWxwZXJzX21hdGgiLCJnZXRSdGxBZGFwdGVyIiwicmVjdFgiLCJzZXRXaWR0aCIsInRleHRBbGlnbiIsImFsaWduIiwieFBsdXMiLCJsZWZ0Rm9yTHRyIiwiaXRlbVdpZHRoIiwiZ2V0THRyQWRhcHRlciIsIl9pdGVtV2lkdGgiLCJnZXRBZGFwdGVyIiwicnRsIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwib3JpZ2luYWwiLCJjYW52YXMiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0UHJvcGVydHlQcmlvcml0eSIsInNldFByb3BlcnR5IiwicHJldlRleHREaXJlY3Rpb24iLCJyZXN0b3JlVGV4dERpcmVjdGlvbiIsImhlbHBlcnNfcnRsIiwiaGVscGVycyQxIiwiZWFzaW5nIiwibWF0aCIsImludGVycG9sYXRlIiwic3RhcnQiLCJ2aWV3IiwiZWFzZSIsImFjdHVhbCIsIm9yaWdpbiIsImMwIiwiYzEiLCJFbGVtZW50IiwiY29uZmlndXJhdGlvbiIsImluaXRpYWxpemUiLCJfdHlwZSIsImhpZGRlbiIsInBpdm90IiwiX3ZpZXciLCJfbW9kZWwiLCJfc3RhcnQiLCJ0cmFuc2l0aW9uIiwidG9vbHRpcFBvc2l0aW9uIiwiaGFzVmFsdWUiLCJpc051bWJlciIsImNvcmVfZWxlbWVudCIsImV4cG9ydHMkMyIsImN1cnJlbnRTdGVwIiwibnVtU3RlcHMiLCJyZW5kZXIiLCJvbkFuaW1hdGlvblByb2dyZXNzIiwib25BbmltYXRpb25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9uIiwiZ2V0Iiwic2V0IiwiYW5pbWF0aW9uIiwiZHVyYXRpb24iLCJvblByb2dyZXNzIiwib25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJyZXF1ZXN0IiwiYWRkQW5pbWF0aW9uIiwibGF6eSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJhbmltYXRpbmciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb24iLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJyZXF1ZXN0QW5pbUZyYW1lIiwic3RhcnREaWdlc3QiLCJhZHZhbmNlIiwibmV4dFN0ZXAiLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsImxpc3RlbmVycyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJtZXRob2QiLCJiYXNlIiwicmVzIiwib2JqZWN0IiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInN0dWIiLCJEYXRhc2V0Q29udHJvbGxlciIsImRhdGFzZXRJbmRleCIsImRhdGFzZXRFbGVtZW50VHlwZSIsImRhdGFFbGVtZW50VHlwZSIsIl9kYXRhc2V0RWxlbWVudE9wdGlvbnMiLCJfZGF0YUVsZW1lbnRPcHRpb25zIiwibGlua1NjYWxlcyIsImFkZEVsZW1lbnRzIiwiZ2V0TWV0YSIsInVwZGF0ZUluZGV4IiwibWV0YSIsInNjYWxlcyIsImRhdGFzZXQiLCJnZXREYXRhc2V0Iiwic2NhbGVzT3B0cyIsInhBeGlzSUQiLCJ4QXhlcyIsInlBeGlzSUQiLCJ5QXhlcyIsImRhdGEiLCJkYXRhc2V0cyIsImdldERhdGFzZXRNZXRhIiwiZ2V0U2NhbGVGb3JJZCIsInNjYWxlSUQiLCJfZ2V0VmFsdWVTY2FsZUlkIiwiX2dldEluZGV4U2NhbGVJZCIsIl9nZXRWYWx1ZVNjYWxlIiwiX2dldEluZGV4U2NhbGUiLCJyZXNldCIsIl91cGRhdGUiLCJkZXN0cm95IiwiX2RhdGEiLCJjcmVhdGVNZXRhRGF0YXNldCIsIl9jaGFydCIsIl9kYXRhc2V0SW5kZXgiLCJjcmVhdGVNZXRhRGF0YSIsIl9pbmRleCIsIm1ldGFEYXRhIiwiYWRkRWxlbWVudEFuZFJlc2V0IiwiZWxlbWVudCIsInVwZGF0ZUVsZW1lbnQiLCJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCJpc0V4dGVuc2libGUiLCJyZXN5bmNFbGVtZW50cyIsIl9jb25maWd1cmUiLCJfY29uZmlnIiwiX2NhY2hlZERhdGFPcHRzIiwidXBkYXRlIiwiZWFzaW5nVmFsdWUiLCJlbGVtZW50cyIsImRyYXciLCJnZXRTdHlsZSIsIl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zIiwiX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImhvdmVyIiwiZGF0YXNldE9wdHMiLCJjdXN0b20iLCJlbGVtZW50T3B0aW9ucyIsInJlYWRLZXkiLCJjYWNoZWQiLCJkYXRhSW5kZXgiLCJmcmVlemUiLCJyZW1vdmVIb3ZlclN0eWxlIiwiJHByZXZpb3VzU3R5bGUiLCJzZXRIb3ZlclN0eWxlIiwiZ2V0SG92ZXJDb2xvciIsImJvcmRlcldpZHRoIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJCb3JkZXJXaWR0aCIsIl9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSIsIl9zZXREYXRhc2V0SG92ZXJTdHlsZSIsInByZXYiLCJob3Zlck9wdGlvbnMiLCJudW1NZXRhIiwibnVtRGF0YSIsImluc2VydEVsZW1lbnRzIiwiY291bnQiLCJvbkRhdGFQdXNoIiwib25EYXRhUG9wIiwib25EYXRhU2hpZnQiLCJzaGlmdCIsIm9uRGF0YVNwbGljZSIsIm9uRGF0YVVuc2hpZnQiLCJjb3JlX2RhdGFzZXRDb250cm9sbGVyIiwiVEFVIiwiYm9yZGVyQWxpZ24iLCJjbGlwQXJjIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsIm91dGVyUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJkcmF3RnVsbENpcmNsZUJvcmRlcnMiLCJ2bSIsImlubmVyIiwiZnVsbENpcmNsZXMiLCJkcmF3Qm9yZGVyIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJlbGVtZW50X2FyYyIsImluTGFiZWxSYW5nZSIsIm1vdXNlWCIsImhvdmVyUmFkaXVzIiwiaW5SYW5nZSIsImNoYXJ0WCIsImNoYXJ0WSIsInBvaW50UmVsYXRpdmVQb3NpdGlvbiIsImdldEFuZ2xlRnJvbVBvaW50IiwiYW5nbGUiLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiZ2V0Q2VudGVyUG9pbnQiLCJoYWxmQW5nbGUiLCJoYWxmUmFkaXVzIiwiZ2V0QXJlYSIsImNlbnRyZUFuZ2xlIiwicmFuZ2VGcm9tQ2VudHJlIiwiY2lyY3VtZmVyZW5jZSIsImZpbGxTdHlsZSIsInN0cm9rZVN0eWxlIiwidmFsdWVPckRlZmF1bHQkMSIsImxpbmUiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwiY2FwQmV6aWVyUG9pbnRzIiwiZWxlbWVudF9saW5lIiwic3BhbkdhcHMiLCJwb2ludHMiLCJfY2hpbGRyZW4iLCJnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMiLCJsYXN0RHJhd25JbmRleCIsIl9sb29wIiwiY3VycmVudFZNIiwicHJldmlvdXNJdGVtIiwic2tpcCIsImxpbmVDYXAiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwidmFsdWVPckRlZmF1bHQkMiIsImRlZmF1bHRDb2xvciQxIiwicG9pbnRTdHlsZSIsImhpdFJhZGl1cyIsInhSYW5nZSIsImFicyIsInlSYW5nZSIsIm1vdXNlWSIsImVsZW1lbnRfcG9pbnQiLCJpblhSYW5nZSIsImluWVJhbmdlIiwicGFkZGluZyIsImNoYXJ0QXJlYSIsImRlZmF1bHRDb2xvciQyIiwicmVjdGFuZ2xlIiwiYm9yZGVyU2tpcHBlZCIsImlzVmVydGljYWwiLCJnZXRCYXJCb3VuZHMiLCJ4MSIsInkxIiwiaGFsZiIsInN3YXAiLCJvcmlnIiwidjIiLCJwYXJzZUJvcmRlclNraXBwZWQiLCJlZGdlIiwiaG9yaXpvbnRhbCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsImJvdW5kaW5nUmVjdHMiLCJib3VuZHMiLCJib3JkZXIiLCJvdXRlciIsInNraXBYIiwic2tpcFkiLCJlbGVtZW50X3JlY3RhbmdsZSIsInJlY3RzIiwiZmlsbFJlY3QiLCJBcmMiLCJMaW5lIiwiUG9pbnQiLCJSZWN0YW5nbGUiLCJkZXByZWNhdGVkIiwidmFsdWVPckRlZmF1bHQkMyIsIm1vZGUiLCJvZmZzZXQiLCJncmlkTGluZXMiLCJvZmZzZXRHcmlkTGluZXMiLCJiYXIiLCJjYXRlZ29yeVBlcmNlbnRhZ2UiLCJiYXJQZXJjZW50YWdlIiwiY29tcHV0ZU1pblNhbXBsZVNpemUiLCJwaXhlbHMiLCJfbGVuZ3RoIiwiY3VyciIsImdldFRpY2tzIiwiZ2V0UGl4ZWxGb3JUaWNrIiwiY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzIiwicnVsZXIiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJzdGFja0NvdW50IiwiY2h1bmsiLCJjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzIiwibmV4dCIsInBlcmNlbnQiLCJlbmQiLCJjb250cm9sbGVyX2JhciIsInNjYWxlT3B0cyIsInN0YWNrIiwibWluQmFyTGVuZ3RoIiwibWF4QmFyVGhpY2tuZXNzIiwiX3J1bGVyIiwiZ2V0UnVsZXIiLCJfeFNjYWxlIiwiX3lTY2FsZSIsImRhdGFzZXRMYWJlbCIsImxhYmVsIiwiX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeSIsInZzY2FsZSIsImdldEJhc2VQaXhlbCIsImlzSG9yaXpvbnRhbCIsInZwaXhlbHMiLCJjYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsImlwaXhlbHMiLCJjYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImhlYWQiLCJjZW50ZXIiLCJfZ2V0U3RhY2tzIiwibGFzdCIsIm1ldGFzZXRzIiwiX2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzIiwic3RhY2tlZCIsInN0YWNrcyIsImdldFN0YWNrQ291bnQiLCJnZXRTdGFja0luZGV4IiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsIl9zdGFydFBpeGVsIiwiX2VuZFBpeGVsIiwiX3BhcnNlVmFsdWUiLCJpbWV0YSIsIml2YWx1ZSIsInN0YWNrTGVuZ3RoIiwicmFuZ2UiLCJzdGFja0luZGV4IiwiaW5kZXhPcHRzIiwidmFsdWVPcHRzIiwidmFsdWVPckRlZmF1bHQkNCIsInJlc29sdmUkMSIsInBvc2l0aW9uIiwidG9vbHRpcHMiLCJjYWxsYmFja3MiLCJ0aXRsZSIsImRhdGFQb2ludCIsInhMYWJlbCIsInlMYWJlbCIsImNvbnRyb2xsZXJfYnViYmxlIiwieFNjYWxlIiwieVNjYWxlIiwiZHNJbmRleCIsImdldFBpeGVsRm9yRGVjaW1hbCIsIk5hTiIsIl9vcHRpb25zIiwidmFsdWVPckRlZmF1bHQkNSIsIlBJJDEiLCJET1VCTEVfUEkkMSIsIkhBTEZfUEkkMSIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJsZWdlbmRDYWxsYmFjayIsImxpc3QiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJsaXN0SXRlbSIsImxpc3RJdGVtU3BhbiIsInNldEF0dHJpYnV0ZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJvdXRlckhUTUwiLCJsZWdlbmQiLCJnZW5lcmF0ZUxhYmVscyIsImNvbnRyb2xsZXIiLCJ0ZXh0Iiwib25DbGljayIsImxlZ2VuZEl0ZW0iLCJjdXRvdXRQZXJjZW50YWdlIiwidG9vbHRpcEl0ZW0iLCJkYXRhTGFiZWwiLCJjb250cm9sbGVyX2RvdWdobnV0IiwiZ2V0UmluZ0luZGV4IiwicmluZ0luZGV4IiwiaiIsImlzRGF0YXNldFZpc2libGUiLCJvcHRzIiwicmF0aW9YIiwicmF0aW9ZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJhcmNzIiwiY3V0b3V0IiwiY2hhcnRXZWlnaHQiLCJfZ2V0UmluZ1dlaWdodCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0Iiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJjb250YWluczAiLCJjb250YWluczkwIiwiY29udGFpbnMxODAiLCJjb250YWluczI3MCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRNYXhCb3JkZXJXaWR0aCIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwidG90YWwiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImhvdmVyV2lkdGgiLCJyaW5nV2VpZ2h0T2Zmc2V0IiwiZGF0YVNldEluZGV4IiwiYXhpcyIsImhvcml6b250YWxCYXIiLCJjb250cm9sbGVyX2hvcml6b250YWxCYXIiLCJ2YWx1ZU9yRGVmYXVsdCQ2IiwicmVzb2x2ZSQyIiwiaXNQb2ludEluQXJlYSIsInNjYWxlQ2xpcCIsImhhbGZCb3JkZXJXaWR0aCIsInRpY2tPcHRzIiwidGlja3MiLCJkZWZhdWx0Q2xpcCIsInRvQ2xpcCIsImNvbnRyb2xsZXJfbGluZSIsImNvbmZpZyIsInNob3dMaW5lIiwiX3Nob3dMaW5lIiwibGluZVRlbnNpb24iLCJfc2NhbGUiLCJ1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwibGluZU1vZGVsIiwiY2FsY3VsYXRlUG9pbnRZIiwibGluZU9wdGlvbnMiLCJzdW1Qb3MiLCJzdW1OZWciLCJkcyIsImRzTWV0YSIsInN0YWNrZWRSaWdodFZhbHVlIiwicmlnaHRWYWx1ZSIsImdldFJpZ2h0VmFsdWUiLCJfZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsImNvbnRyb2xQb2ludHMiLCJmaWx0ZXIiLCJwdCIsImNhcENvbnRyb2xQb2ludCIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic3BsaW5lQ3VydmUiLCJuZXh0SXRlbSIsInJlc29sdmUkMyIsImFuZ2xlTGluZXMiLCJkaXNwbGF5IiwiY2lyY3VsYXIiLCJwb2ludExhYmVscyIsImJlZ2luQXRaZXJvIiwiY29udHJvbGxlcl9wb2xhckFyZWEiLCJzdGFydHMiLCJfc3RhcnRzIiwiYW5nbGVzIiwiX2FuZ2xlcyIsIl91cGRhdGVSYWRpdXMiLCJjb3VudFZpc2libGVFbGVtZW50cyIsIl9jb21wdXRlQW5nbGUiLCJtaW5TaXplIiwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsInhDZW50ZXIiLCJ5Q2VudGVyIiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsInJlc2V0UmFkaXVzIiwiZG91Z2hudXQiLCJjb250cm9sbGVyX3BpZSIsInZhbHVlT3JEZWZhdWx0JDciLCJjb250cm9sbGVyX3JhZGFyIiwicG9pbnRQb3NpdGlvbiIsImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsInNjYXR0ZXIiLCJjb250cm9sbGVyX3NjYXR0ZXIiLCJjb250cm9sbGVycyIsImJ1YmJsZSIsInBvbGFyQXJlYSIsInBpZSIsInJhZGFyIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsIm5hdGl2ZSIsInBhcnNlVmlzaWJsZUl0ZW1zIiwiaGFuZGxlciIsIm1ldGFkYXRhIiwiamxlbiIsImdldEludGVyc2VjdEl0ZW1zIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiaW50ZXJzZWN0IiwiZGlzdGFuY2VNZXRyaWMiLCJtaW5EaXN0YW5jZSIsIlBPU0lUSVZFX0lORklOSVRZIiwibmVhcmVzdEl0ZW1zIiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJwdDEiLCJwdDIiLCJkZWx0YVgiLCJkZWx0YVkiLCJpbmRleE1vZGUiLCJpdGVtcyIsImNvcmVfaW50ZXJhY3Rpb24iLCJtb2RlcyIsInNpbmdsZSIsIm5lYXJlc3QiLCJpbnRlcnNlY3RzSXRlbSIsImZpbHRlckJ5UG9zaXRpb24iLCJ3aGVyZSIsInBvcyIsInNvcnRCeVdlaWdodCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJib3giLCJzZXRMYXlvdXREaW1zIiwibGF5b3V0cyIsInBhcmFtcyIsImxheW91dCIsImZ1bGxXaWR0aCIsImF2YWlsYWJsZVdpZHRoIiwidkJveE1heFdpZHRoIiwiaEJveE1heEhlaWdodCIsImJ1aWxkTGF5b3V0Qm94ZXMiLCJsZWZ0QW5kVG9wIiwicmlnaHRBbmRCb3R0b20iLCJ2ZXJ0aWNhbCIsImdldENvbWJpbmVkTWF4IiwibWF4UGFkZGluZyIsInVwZGF0ZURpbXMiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImdldFBhZGRpbmciLCJib3hQYWRkaW5nIiwib3V0ZXJXaWR0aCIsIm91dGVySGVpZ2h0Iiwic2l6ZXMiLCJoYW5kbGVNYXhQYWRkaW5nIiwidXBkYXRlUG9zIiwiY2hhbmdlIiwiZ2V0TWFyZ2lucyIsIm1hcmdpbkZvclBvc2l0aW9ucyIsInBvc2l0aW9ucyIsIm1hcmdpbiIsImZpdEJveGVzIiwicmVmaXRCb3hlcyIsInJlZml0IiwiY2hhbmdlZCIsInBsYWNlQm94ZXMiLCJ1c2VyUGFkZGluZyIsImNvcmVfbGF5b3V0cyIsImFkZEJveCIsIl9sYXllcnMiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwiY29uZmlndXJlIiwicHJvcHMiLCJsYXlvdXRPcHRpb25zIiwiYXZhaWxhYmxlSGVpZ2h0IiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsInBsYXRmb3JtX2Jhc2ljIiwiYWNxdWlyZUNvbnRleHQiLCJnZXRDb250ZXh0IiwicGxhdGZvcm1fZG9tIiwicGxhdGZvcm1fZG9tJDEiLCJfX3Byb3RvX18iLCJzdHlsZXNoZWV0IiwiRVhQQU5ET19LRVkiLCJDU1NfUFJFRklYIiwiQ1NTX1NJWkVfTU9OSVRPUiIsIkNTU19SRU5ERVJfTU9OSVRPUiIsIkNTU19SRU5ERVJfQU5JTUFUSU9OIiwiQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJyZWFkVXNlZFNpemUiLCJwcm9wZXJ0eSIsImluaXRDYW52YXMiLCJyZW5kZXJIZWlnaHQiLCJnZXRBdHRyaWJ1dGUiLCJyZW5kZXJXaWR0aCIsImluaXRpYWwiLCJkaXNwbGF5V2lkdGgiLCJhc3BlY3RSYXRpbyIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVFdmVudCIsIm5hdGl2ZUV2ZW50IiwiZnJvbU5hdGl2ZUV2ZW50IiwiZXZlbnQiLCJ0aHJvdHRsZWQiLCJ0aWNraW5nIiwiY3JlYXRlRGl2IiwiY2xzIiwiZWwiLCJjbGFzc05hbWUiLCJjcmVhdGVSZXNpemVyIiwibWF4U2l6ZSIsInJlc2l6ZXIiLCJleHBhbmQiLCJzaHJpbmsiLCJfcmVzZXQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib25TY3JvbGwiLCJiaW5kIiwid2F0Y2hGb3JSZW5kZXIiLCJleHBhbmRvIiwicHJveHkiLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJyZWZsb3ciLCJvZmZzZXRQYXJlbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJ1bndhdGNoRm9yUmVuZGVyIiwicmVtb3ZlIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJjb250YWluZXIiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwicGFyZW50Tm9kZSIsImNsaWVudFdpZHRoIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsInJlbW92ZVJlc2l6ZUxpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJpbmplY3RDU1MiLCJyb290Tm9kZSIsImNzcyIsImNvbnRhaW5zU3R5bGVzIiwicGxhdGZvcm1fZG9tJDIiLCJkaXNhYmxlQ1NTSW5qZWN0aW9uIiwiX2VuYWJsZWQiLCJfZW5zdXJlTG9hZGVkIiwicm9vdCIsImdldFJvb3ROb2RlIiwidGFyZ2V0Tm9kZSIsImhvc3QiLCJnZXRFbGVtZW50QnlJZCIsInJlbGVhc2VDb250ZXh0IiwicmVtb3ZlQXR0cmlidXRlIiwicHJveGllcyIsImFkZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJpbXBsZW1lbnRhdGlvbiIsInBsYXRmb3JtIiwicGx1Z2lucyIsImNvcmVfcGx1Z2lucyIsIl9wbHVnaW5zIiwiX2NhY2hlSWQiLCJyZWdpc3RlciIsInBsdWdpbiIsInVucmVnaXN0ZXIiLCJpZHgiLCJnZXRBbGwiLCJub3RpZnkiLCJob29rIiwiZGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwiY2FjaGUiLCIkcGx1Z2lucyIsIl9pbnZhbGlkYXRlIiwiY29yZV9zY2FsZVNlcnZpY2UiLCJjb25zdHJ1Y3RvcnMiLCJyZWdpc3RlclNjYWxlVHlwZSIsInNjYWxlQ29uc3RydWN0b3IiLCJzY2FsZURlZmF1bHRzIiwiZ2V0U2NhbGVDb25zdHJ1Y3RvciIsImdldFNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiYWRkU2NhbGVzVG9MYXlvdXQiLCJ2YWx1ZU9yRGVmYXVsdCQ4IiwiZ2V0UnRsSGVscGVyIiwiZW5hYmxlZCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwiYWN0aXZlRWxlbWVudCIsImxhYmVsVGV4dENvbG9yIiwiYWZ0ZXJMYWJlbCIsImFmdGVyQm9keSIsImJlZm9yZUZvb3RlciIsImZvb3RlciIsImFmdGVyRm9vdGVyIiwicG9zaXRpb25lcnMiLCJhdmVyYWdlIiwiZXZlbnRQb3NpdGlvbiIsIm5lYXJlc3RFbGVtZW50IiwiZCIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInRwIiwicHVzaE9yQ29uY2F0IiwidG9QdXNoIiwic3BsaXROZXdsaW5lcyIsIlN0cmluZyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJnZXRMYWJlbEZvckluZGV4IiwiZ2V0QmFzZU1vZGVsIiwidG9vbHRpcE9wdHMiLCJ4QWxpZ24iLCJ5QWxpZ24iLCJ0ZXh0RGlyZWN0aW9uIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsIm9wYWNpdHkiLCJsZWdlbmRDb2xvckJhY2tncm91bmQiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJib2R5IiwiY29tYmluZWRCb2R5TGVuZ3RoIiwicmVkdWNlIiwiYm9keUl0ZW0iLCJiZWZvcmUiLCJsaW5lcyIsImFmdGVyIiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJtZWFzdXJlVGV4dCIsImZvbnRTdHJpbmciLCJkZXRlcm1pbmVBbGlnbm1lbnQiLCJsZiIsInJmIiwib2xmIiwib3JmIiwieWYiLCJtaWRYIiwibWlkWSIsImdldEJhY2tncm91bmRQb2ludCIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJleHBvcnRzJDQiLCJfbGFzdEFjdGl2ZSIsImdldFRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJleGlzdGluZ01vZGVsIiwiYWN0aXZlIiwiX2FjdGl2ZSIsImJhY2tncm91bmRQb2ludCIsInRvb2x0aXBTaXplIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFRleHRDb2xvcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInRtcCIsImRyYXdUaXRsZSIsInJ0bEhlbHBlciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZHJhd0JvZHkiLCJkcmF3Q29sb3JCb3hlcyIsInhMaW5lUGFkZGluZyIsImNvbG9yWCIsImZpbGxMaW5lT2ZUZXh0IiwidGV4dENvbG9yIiwiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCJydGxDb2xvclgiLCJzdHJva2VSZWN0IiwiZHJhd0Zvb3RlciIsImRyYXdCYWNrZ3JvdW5kIiwicXVhZHJhdGljQ3VydmVUbyIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJoYW5kbGVFdmVudCIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJwb3NpdGlvbmVyc18xIiwiY29yZV90b29sdGlwIiwidmFsdWVPckRlZmF1bHQkOSIsImV2ZW50cyIsIm9uSG92ZXIiLCJhbmltYXRpb25EdXJhdGlvbiIsInJlc3BvbnNpdmUiLCJyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb24iLCJtZXJnZVNjYWxlQ29uZmlnIiwic2xlbiIsIm1lcmdlQ29uZmlnIiwiaW5pdENvbmZpZyIsInVwZGF0ZUNvbmZpZyIsIm5ld09wdGlvbnMiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsIm5leHRBdmFpbGFibGVTY2FsZUlkIiwiYXhlc09wdHMiLCJwcmVmaXgiLCJoYXNJZCIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29tcGFyZTJMZXZlbCIsImwxIiwibDIiLCJDaGFydCIsImNvbnN0cnVjdCIsIl9idWZmZXJlZFJlbmRlciIsImluc3RhbmNlcyIsInJldGluYVNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJpbmRFdmVudHMiLCJyZXNpemUiLCJpbml0VG9vbFRpcCIsInN0b3AiLCJzaWxlbnQiLCJnZXRNYXhpbXVtV2lkdGgiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwic2NhbGVzT3B0aW9ucyIsInNjYWxlT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsInVwZGF0ZWQiLCJkdHlwZSIsImRwb3NpdGlvbiIsImlzRGVmYXVsdCIsInNjYWxlVHlwZSIsInNjYWxlQ2xhc3MiLCJtZXJnZVRpY2tzT3B0aW9ucyIsImhhc1VwZGF0ZWQiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsImRlc3Ryb3lEYXRhc2V0TWV0YSIsIm9yZGVyIiwiQ29udHJvbGxlckNsYXNzIiwicmVzZXRFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwibGFzdEFjdGl2ZSIsIl9idWZmZXJlZFJlcXVlc3QiLCJfaWR4IiwidXBkYXRlRGF0YXNldCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25PYmplY3QiLCJlYXNpbmdGdW5jdGlvbiIsInN0ZXBEZWNpbWFsIiwibGF5ZXJzIiwiZHJhd0RhdGFzZXRzIiwiX2RyYXdUb29sdGlwIiwiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsImZpbHRlclZpc2libGUiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdFhBeGlzIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsIl9jaGFydEluc3RhbmNlIiwiX2xpc3RlbmVycyIsImV2ZW50SGFuZGxlciIsInVwZGF0ZUhvdmVyU3R5bGUiLCJidWZmZXJlZFJlcXVlc3QiLCJjb3JlX2NvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwidHlwZXMiLCJjb25maWdNZXJnZSIsInNjYWxlTWVyZ2UiLCJjb3JlX2hlbHBlcnMiLCJjb2xsZWN0aW9uIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImZpbmROZXh0V2hlcmUiLCJhcnJheVRvU2VhcmNoIiwic3RhcnRJbmRleCIsImN1cnJlbnRJdGVtIiwiZmluZFByZXZpb3VzV2hlcmUiLCJhbG1vc3RFcXVhbHMiLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJORUdBVElWRV9JTkZJTklUWSIsInNpZ24iLCJ0b1JhZGlhbnMiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiX2RlY2ltYWxQbGFjZXMiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFsaWFzUGl4ZWwiLCJwaXhlbFdpZHRoIiwiX2FsaWduUGl4ZWwiLCJwaXhlbCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwiaGFsZldpZHRoIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsImQwMSIsImQxMiIsInMwMSIsInMxMiIsImZhIiwiZmIiLCJFUFNJTE9OIiwicG9pbnRzV2l0aFRhbmdlbnRzIiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJwb2ludEJlZm9yZSIsInBvaW50Q3VycmVudCIsInBvaW50QWZ0ZXIiLCJzbG9wZURlbHRhWCIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJsb29wIiwibmljZU51bSIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImV2dCIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhcnNlTWF4U3R5bGUiLCJzdHlsZVZhbHVlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiaXNDb25zdHJhaW5lZFZhbHVlIiwiZ2V0Q29uc3RyYWludERpbWVuc2lvbiIsImRvbU5vZGUiLCJtYXhTdHlsZSIsInBlcmNlbnRhZ2VQcm9wZXJ0eSIsImRlZmF1bHRWaWV3IiwiX2dldFBhcmVudE5vZGUiLCJjb25zdHJhaW5lZE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiY29uc3RyYWluZWRDb250YWluZXIiLCJoYXNDTm9kZSIsImhhc0NDb250YWluZXIiLCJpbmZpbml0eSIsImdldENvbnN0cmFpbnRXaWR0aCIsImdldENvbnN0cmFpbnRIZWlnaHQiLCJfY2FsY3VsYXRlUGFkZGluZyIsInBhcmVudERpbWVuc2lvbiIsImN3IiwiY2xpZW50SGVpZ2h0IiwiY2giLCJjdXJyZW50U3R5bGUiLCJmb3JjZVJhdGlvIiwicGl4ZWxSYXRpbyIsInBpeGVsU2l6ZSIsImxvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImdjIiwiZ2FyYmFnZUNvbGxlY3QiLCJsb25nZXN0IiwidGhpbmciLCJuZXN0ZWRUaGluZyIsImdjTGVuIiwidGV4dFdpZHRoIiwibnVtYmVyT2ZMYWJlbExpbmVzIiwibnVtYmVyT2ZMaW5lcyIsIkNhbnZhc0dyYWRpZW50IiwiY29sb3JWYWx1ZSIsIkNhbnZhc1BhdHRlcm4iLCJhYnN0cmFjdCIsIkRhdGVBZGFwdGVyIiwiZm9ybWF0cyIsInBhcnNlIiwiZm9ybWF0Iiwic3RhcnRPZiIsImVuZE9mIiwiX2NyZWF0ZSIsIm92ZXJyaWRlIiwibWVtYmVycyIsIl9kYXRlIiwiY29yZV9hZGFwdGVycyIsImNvcmVfdGlja3MiLCJmb3JtYXR0ZXJzIiwidGlja1ZhbHVlIiwibG9nRGVsdGEiLCJ0aWNrU3RyaW5nIiwibWF4VGljayIsImxvZ1RpY2siLCJudW1FeHBvbmVudGlhbCIsInRvRXhwb25lbnRpYWwiLCJudW1EZWNpbWFsIiwidG9GaXhlZCIsImxvZ2FyaXRobWljIiwicmVtYWluIiwidmFsdWVPckRlZmF1bHQkYSIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tNYXJrTGVuZ3RoIiwiemVyb0xpbmVXaWR0aCIsInplcm9MaW5lQ29sb3IiLCJ6ZXJvTGluZUJvcmRlckRhc2giLCJ6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJtaW5Sb3RhdGlvbiIsIm1heFJvdGF0aW9uIiwibWlycm9yIiwiYXV0b1NraXAiLCJhdXRvU2tpcFBhZGRpbmciLCJsYWJlbE9mZnNldCIsIm1pbm9yIiwibWFqb3IiLCJzYW1wbGUiLCJhcnIiLCJudW1JdGVtcyIsImluY3JlbWVudCIsImdldFBpeGVsRm9yR3JpZExpbmUiLCJ2YWxpZEluZGV4IiwibGluZVZhbHVlIiwiY2FjaGVzIiwiY29tcHV0ZUxhYmVsU2l6ZXMiLCJ0aWNrRm9udHMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwib2Zmc2V0cyIsIndpZGVzdExhYmVsU2l6ZSIsImhpZ2hlc3RMYWJlbFNpemUiLCJ0aWNrRm9udCIsIm5lc3RlZExhYmVsIiwid2lkZXN0IiwiaGlnaGVzdCIsInZhbHVlQXQiLCJmaXJzdCIsImdldFRpY2tNYXJrTGVuZ3RoIiwiZ2V0U2NhbGVMYWJlbEhlaWdodCIsInBhcnNlRm9udE9wdGlvbnMiLCJuZXN0ZWRPcHRzIiwiZm9udENvbG9yIiwicGFyc2VUaWNrRm9udE9wdGlvbnMiLCJub25Ta2lwcGVkIiwidGlja3NUb0ZpbHRlciIsImdldEV2ZW5TcGFjaW5nIiwiY2FsY3VsYXRlU3BhY2luZyIsIm1ham9ySW5kaWNlcyIsImF4aXNMZW5ndGgiLCJ0aWNrc0xpbWl0IiwiZXZlbk1ham9yU3BhY2luZyIsInNwYWNpbmciLCJmYWN0b3JzIiwiZmFjdG9yIiwiZ2V0TWFqb3JJbmRpY2VzIiwic2tpcE1ham9ycyIsInRpY2siLCJjZWlsIiwibWFqb3JTdGFydCIsIm1ham9yRW5kIiwiU2NhbGUiLCJ6ZXJvTGluZUluZGV4IiwiX3RpY2tzIiwiX2dldExhYmVscyIsInhMYWJlbHMiLCJ5TGFiZWxzIiwiYmVmb3JlVXBkYXRlIiwibWFyZ2lucyIsInNhbXBsZVNpemUiLCJzYW1wbGluZ0VuYWJsZWQiLCJfbGFiZWxTaXplcyIsIl9tYXhMYWJlbExpbmVzIiwibG9uZ2VzdExhYmVsV2lkdGgiLCJsb25nZXN0VGV4dENhY2hlIiwiX2dyaWRMaW5lSXRlbXMiLCJfbGFiZWxJdGVtcyIsImJlZm9yZVNldERpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwiYWZ0ZXJTZXREaW1lbnNpb25zIiwiYmVmb3JlRGF0YUxpbWl0cyIsImRldGVybWluZURhdGFMaW1pdHMiLCJhZnRlckRhdGFMaW1pdHMiLCJiZWZvcmVCdWlsZFRpY2tzIiwiYnVpbGRUaWNrcyIsImFmdGVyQnVpbGRUaWNrcyIsIl9jb252ZXJ0VGlja3NUb0xhYmVscyIsImJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJfdGlja3NUb0RyYXciLCJfYXV0b1NraXAiLCJhZnRlclVwZGF0ZSIsInJldmVyc2VQaXhlbHMiLCJzdGFydFBpeGVsIiwiZW5kUGl4ZWwiLCJfcmV2ZXJzZVBpeGVscyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImNvbnZlcnRUaWNrc1RvTGFiZWxzIiwidXNlckNhbGxiYWNrIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJudW1UaWNrcyIsImxhYmVsUm90YXRpb24iLCJsYWJlbFNpemVzIiwibWF4TGFiZWxXaWR0aCIsIm1heExhYmVsSGVpZ2h0IiwidGlja1dpZHRoIiwibWF4TGFiZWxEaWFnb25hbCIsIl9pc1Zpc2libGUiLCJfZ2V0TGFiZWxTaXplcyIsInNjYWxlTGFiZWxPcHRzIiwiZ3JpZExpbmVPcHRzIiwiaXNCb3R0b20iLCJmaXJzdExhYmVsU2l6ZSIsImxhc3RMYWJlbFNpemUiLCJsaW5lU3BhY2UiLCJ0aWNrUGFkZGluZyIsImlzUm90YXRlZCIsImFuZ2xlUmFkaWFucyIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJsYWJlbEhlaWdodCIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImxhYmVsV2lkdGgiLCJoYW5kbGVNYXJnaW5zIiwiaXNGdWxsV2lkdGgiLCJyYXdWYWx1ZSIsIl9nZXRTY2FsZUxhYmVsIiwiZ2V0VmFsdWVGb3JQaXhlbCIsImRlY2ltYWwiLCJnZXREZWNpbWFsRm9yUGl4ZWwiLCJnZXRCYXNlVmFsdWUiLCJtYXhUaWNrc0xpbWl0IiwiX3RpY2tTaXplIiwibnVtTWFqb3JJbmRpY2VzIiwiYXZnTWFqb3JTcGFjaW5nIiwib3B0aW9uVGlja3MiLCJyb3QiLCJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCJ0aWNrc0xlbmd0aCIsInRsIiwiYXhpc1dpZHRoIiwiYXhpc0hhbGZXaWR0aCIsImFsaWduUGl4ZWwiLCJhbGlnbkJvcmRlclZhbHVlIiwiYm9yZGVyVmFsdWUiLCJhbGlnbmVkTGluZVZhbHVlIiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwibGluZUNvbG9yIiwiX2NvbXB1dGVMYWJlbEl0ZW1zIiwiaXNNaXJyb3JlZCIsImZvbnRzIiwibGluZUNvdW50IiwidGV4dE9mZnNldCIsIl9kcmF3R3JpZCIsImZpcnN0TGluZVdpZHRoIiwibGFzdExpbmVXaWR0aCIsIl9kcmF3TGFiZWxzIiwiX2RyYXdUaXRsZSIsInNjYWxlTGFiZWxGb250Q29sb3IiLCJzY2FsZUxhYmVsRm9udCIsInNjYWxlTGFiZWxQYWRkaW5nIiwiaGFsZkxpbmVIZWlnaHQiLCJzY2FsZUxhYmVsWCIsInNjYWxlTGFiZWxZIiwiaXNMZWZ0IiwidHoiLCJneiIsIl9kcmF3IiwiY29yZV9zY2FsZSIsImlzTnVsbE9yVW5kZWYkMSIsImRlZmF1bHRDb25maWciLCJzY2FsZV9jYXRlZ29yeSIsInRpY2tzT3B0cyIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJfc3RhcnRWYWx1ZSIsIl92YWx1ZVJhbmdlIiwidmFsdWVDYXRlZ29yeSIsIl9kZWZhdWx0cyIsImlzTnVsbE9yVW5kZWYkMiIsImdlbmVyYXRlVGlja3MiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwic3RlcFNpemUiLCJ1bml0IiwibWF4TnVtU3BhY2VzIiwibWF4VGlja3MiLCJwcmVjaXNpb24iLCJybWluIiwicm1heCIsIm5pY2VNaW4iLCJuaWNlTWF4IiwibnVtU3BhY2VzIiwic2NhbGVfbGluZWFyYmFzZSIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsImdldFRpY2tMaW1pdCIsIl9jb21wdXRlVGlja0xpbWl0IiwiaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzIiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJmaXhlZFN0ZXBTaXplIiwidGlja3NBc051bWJlcnMiLCJfZW5kVmFsdWUiLCJkZWZhdWx0Q29uZmlnJDEiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiZ2V0T3JDcmVhdGVTdGFjayIsIm5lZyIsInN0YWNrRGF0YSIsInJlbGF0aXZlUG9pbnRzIiwidXBkYXRlTWluTWF4Iiwic2NhbGVfbGluZWFyIiwiaGFzU3RhY2tzIiwic3RhY2tWYWx1ZXMiLCJfZGVmYXVsdHMkMSIsInZhbHVlT3JEZWZhdWx0JGIiLCJnZW5lcmF0ZVRpY2tzJDEiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJleHAiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsImRlZmF1bHRDb25maWckMiIsIm5vbk5lZ2F0aXZlT3JEZWZhdWx0Iiwic2NhbGVfbG9nYXJpdGhtaWMiLCJJRE1hdGNoZXMiLCJ2YWx1ZXNQZXJTdGFjayIsInZhbHVlc0ZvclR5cGUiLCJtaW5WYWwiLCJtYXhWYWwiLCJ0aWNrVmFsdWVzIiwiX2dldEZpcnN0VGlja1ZhbHVlIiwiX3ZhbHVlT2Zmc2V0IiwiX2RlZmF1bHRzJDIiLCJ2YWx1ZU9yRGVmYXVsdCRjIiwidmFsdWVBdEluZGV4T3JEZWZhdWx0JDEiLCJyZXNvbHZlJDQiLCJkZWZhdWx0Q29uZmlnJDMiLCJhbmltYXRlIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nWSIsImJhY2tkcm9wUGFkZGluZ1giLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInRleHRTaXplIiwiX3BvaW50TGFiZWxTaXplcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJnZXRJbmRleEFuZ2xlIiwiaExpbWl0cyIsInZMaW1pdHMiLCJzZXRSZWR1Y3Rpb25zIiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJwb2ludExhYmVsT3B0cyIsInRpY2tCYWNrZHJvcEhlaWdodCIsIm91dGVyRGlzdGFuY2UiLCJleHRyYSIsInBvaW50TGFiZWxQb3NpdGlvbiIsInBvaW50TGFiZWxGb250Q29sb3IiLCJkcmF3UmFkaXVzTGluZSIsIm51bWJlck9yWmVybyIsInBhcmFtIiwic2NhbGVfcmFkaWFsTGluZWFyIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJ0aGlzQW5nbGUiLCJnZXRCYXNlUG9zaXRpb24iLCJhbmdsZUxpbmVPcHRzIiwidGlja0ZvbnRDb2xvciIsIl9kZWZhdWx0cyQzIiwiZGVwcmVjYXRlZCQxIiwicmVzb2x2ZSQ1IiwidmFsdWVPckRlZmF1bHQkZCIsIk1JTl9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiTUFYX1NBRkVfSU5URUdFUiIsIklOVEVSVkFMUyIsIm1pbGxpc2Vjb25kIiwiY29tbW9uIiwic3RlcHMiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5Iiwid2VlayIsIm1vbnRoIiwicXVhcnRlciIsInllYXIiLCJVTklUUyIsInNvcnRlciIsImFycmF5VW5pcXVlIiwiaGFzaCIsIm91dCIsImdldE1pbiIsInRpbWUiLCJnZXRNYXgiLCJidWlsZExvb2t1cFRhYmxlIiwidGltZXN0YW1wcyIsImRpc3RyaWJ1dGlvbiIsInRhYmxlIiwibG9va3VwIiwibG8iLCJtaWQiLCJpMCIsImkxIiwiaW50ZXJwb2xhdGUkMSIsInNrZXkiLCJ0a2V5Iiwic3BhbiIsInRvVGltZXN0YW1wIiwiaW5wdXQiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwibWluVW5pdCIsImNhcGFjaXR5IiwiaW50ZXJ2YWwiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsImdlbmVyYXRlIiwidGltZU9wdHMiLCJ1bml0U3RlcFNpemUiLCJ3ZWVrZGF5IiwiaXNvV2Vla2RheSIsImNvbXB1dGVPZmZzZXRzIiwic2V0TWFqb3JUaWNrcyIsIm1ham9yVW5pdCIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJkZWZhdWx0Q29uZmlnJDQiLCJhZGFwdGVycyIsImRpc3BsYXlGb3JtYXQiLCJkaXNwbGF5Rm9ybWF0cyIsInNjYWxlX3RpbWUiLCJkYXRlIiwidGltZXN0YW1wIiwibGFiZWxzQWRkZWQiLCJkYXRhTGFiZWxzIiwiX3RhYmxlIiwiX3RpbWVzdGFtcHMiLCJnZXRMYWJlbENhcGFjaXR5IiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJ0b29sdGlwRm9ybWF0IiwiZGF0ZXRpbWUiLCJ0aWNrRm9ybWF0RnVuY3Rpb24iLCJtaW5vckZvcm1hdCIsIm1ham9yRm9ybWF0IiwibmVzdGVkVGlja09wdHMiLCJmb3JtYXR0ZXIiLCJnZXRQaXhlbEZvck9mZnNldCIsIl9nZXRMYWJlbFNpemUiLCJ0aWNrTGFiZWxXaWR0aCIsInRpY2tGb250U2l6ZSIsImdldExhYmVsV2lkdGgiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCIsIl9kZWZhdWx0cyQ0IiwiY2F0ZWdvcnkiLCJyYWRpYWxMaW5lYXIiLCJGT1JNQVRTIiwiX2lkIiwidmFsdWVPZiIsImFtb3VudCIsImZpbGxlciIsInByb3BhZ2F0ZSIsIm1hcHBlcnMiLCJ2aXNpYmxlIiwiYm91bmRhcnkiLCJkZWNvZGVGaWxsIiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5Iiwic2NhbGVCb3R0b20iLCJzY2FsZVRvcCIsInNjYWxlWmVybyIsImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwiY3giLCJjeSIsImNvbXB1dGVCb3VuZGFyeSIsInJlc29sdmVUYXJnZXQiLCJ2aXNpdGVkIiwiY3JlYXRlTWFwcGVyIiwiaXNEcmF3YWJsZSIsImRyYXdBcmVhIiwiY3VydmUwIiwiY3VydmUxIiwibGVuMCIsImxlbjEiLCJkb0ZpbGwiLCJtYXBwZXIiLCJwMCIsInAxIiwiZDAiLCJkMSIsImxvb3BPZmZzZXQiLCJwbHVnaW5fZmlsbGVyIiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIiRmaWxsZXIiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJnZXRSdGxIZWxwZXIkMSIsIm5vb3AkMSIsInZhbHVlT3JEZWZhdWx0JGUiLCJjaSIsIm9uTGVhdmUiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJsaW5lRGFzaCIsImdldEJveFdpZHRoIiwibGFiZWxPcHRzIiwiTGVnZW5kIiwibGVnZW5kSGl0Qm94ZXMiLCJfaG92ZXJlZEl0ZW0iLCJkb3VnaG51dE1vZGUiLCJiZWZvcmVCdWlsZExhYmVscyIsImJ1aWxkTGFiZWxzIiwiYWZ0ZXJCdWlsZExhYmVscyIsImxlZ2VuZEl0ZW1zIiwibGFiZWxGb250IiwiaGl0Ym94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJ2UGFkZGluZyIsImNvbHVtbldpZHRocyIsImNvbHVtbkhlaWdodHMiLCJ0b3RhbFdpZHRoIiwiY3VycmVudENvbFdpZHRoIiwiY3VycmVudENvbEhlaWdodCIsImxpbmVEZWZhdWx0IiwibGVnZW5kSGVpZ2h0IiwibGVnZW5kV2lkdGgiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwiU1FSVDIiLCJoYWxmRm9udFNpemUiLCJ4TGVmdCIsInlNaWRkbGUiLCJhbGlnbm1lbnRPZmZzZXQiLCJkaW1lbnNpb24iLCJibG9ja1NpemUiLCJpdGVtSGVpZ2h0IiwicmVhbFgiLCJfZ2V0TGVnZW5kSXRlbUF0IiwiaGl0Qm94IiwibGgiLCJob3ZlcmVkSXRlbSIsImNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaCIsImxlZ2VuZE9wdHMiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJiZWZvcmVJbml0IiwiYWZ0ZXJFdmVudCIsIm5vb3AkMiIsIlRpdGxlIiwiZm9udE9wdHMiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoIiwidGl0bGVPcHRzIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIl9hZGFwdGVycyIsIkFuaW1hdGlvbiIsImFuaW1hdGlvblNlcnZpY2UiLCJJbnRlcmFjdGlvbiIsInNjYWxlU2VydmljZSIsIlRpY2tzIiwiVG9vbHRpcCIsInBsdWdpblNlcnZpY2UiLCJQbHVnaW5CYXNlIiwiY2FudmFzSGVscGVycyIsImxheW91dFNlcnZpY2UiLCJMaW5lYXJTY2FsZUJhc2UiLCJrbGFzcyIsImNmZyIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiQUFB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MnBELEdBQWQsRUFBbUI7QUFDM0MsYUFBTyxJQUFJbnBCLGVBQUosQ0FBb0J4Z0MsR0FBcEIsRUFBeUJ3Z0MsZUFBZSxDQUFDN21DLE9BQWhCLENBQXdCK0IsS0FBeEIsQ0FBOEJpdUQsR0FBRyxJQUFJLEVBQXJDLEVBQXlDO0FBQ3hFbHhELFlBQUksRUFBRWl4RCxLQUFLLENBQUN6d0QsTUFBTixDQUFhLENBQWIsRUFBZ0Iyd0QsV0FBaEIsS0FBZ0NGLEtBQUssQ0FBQ3YzRCxLQUFOLENBQVksQ0FBWjtBQURrQyxPQUF6QyxDQUF6QixDQUFQO0FBR0EsS0FKRDtBQUtBLEdBaEJGO0FBbUJBLFNBQU8rSixHQUFQO0FBRUMsQ0FyeWZBLENBQUQiLCJmaWxlIjoiMTY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2Mi45LjRcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMCBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVxdWlyZSddLCBmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSk7IH0pIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNoYXJ0ID0gZmFjdG9yeShnbG9iYWwubW9tZW50KSk7XG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxubW9tZW50ID0gbW9tZW50ICYmIG1vbWVudC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gbW9tZW50WydkZWZhdWx0J10gOiBtb21lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG5mdW5jdGlvbiBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIChuKSB7XG5cdHJldHVybiBuICYmIG5bJ2RlZmF1bHQnXSB8fCBuO1xufVxuXG52YXIgY29sb3JOYW1lID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxudmFyIGNvbnZlcnNpb25zID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG4vLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4vLyAgICAgICB2YWx1ZXMgdGhhdCBnaXZlIGNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cykuXG4vLyAgICAgICBkbyBub3QgdXNlIGJveCB2YWx1ZXMgdHlwZXMgKGkuZS4gTnVtYmVyKCksIFN0cmluZygpLCBldGMuKVxuXG52YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKHZhciBrZXkgaW4gY29sb3JOYW1lKSB7XG5cdGlmIChjb2xvck5hbWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdHJldmVyc2VLZXl3b3Jkc1tjb2xvck5hbWVba2V5XV0gPSBrZXk7XG5cdH1cbn1cblxudmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0cmdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3JnYid9LFxuXHRoc2w6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHNsJ30sXG5cdGhzdjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc3YnfSxcblx0aHdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2h3Yid9LFxuXHRjbXlrOiB7Y2hhbm5lbHM6IDQsIGxhYmVsczogJ2NteWsnfSxcblx0eHl6OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3h5eid9LFxuXHRsYWI6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGFiJ30sXG5cdGxjaDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsY2gnfSxcblx0aGV4OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydoZXgnXX0sXG5cdGtleXdvcmQ6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2tleXdvcmQnXX0sXG5cdGFuc2kxNjoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTE2J119LFxuXHRhbnNpMjU2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMjU2J119LFxuXHRoY2c6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ2gnLCAnYycsICdnJ119LFxuXHRhcHBsZToge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXX0sXG5cdGdyYXk6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2dyYXknXX1cbn07XG5cbi8vIGhpZGUgLmNoYW5uZWxzIGFuZCAubGFiZWxzIHByb3BlcnRpZXNcbmZvciAodmFyIG1vZGVsIGluIGNvbnZlcnQpIHtcblx0aWYgKGNvbnZlcnQuaGFzT3duUHJvcGVydHkobW9kZWwpKSB7XG5cdFx0aWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNoYW5uZWxzfSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBsYWJlbHN9KTtcblx0fVxufVxuXG5jb252ZXJ0LnJnYi5oc2wgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cdHZhciBoO1xuXHR2YXIgcztcblx0dmFyIGw7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRsID0gKG1pbiArIG1heCkgLyAyO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG5cdFx0cyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHR9XG5cblx0cmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmhzdiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHJkaWY7XG5cdHZhciBnZGlmO1xuXHR2YXIgYmRpZjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciB2ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgZGlmZmMgPSBmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAodiAtIGMpIC8gNiAvIGRpZmYgKyAxIC8gMjtcblx0fTtcblxuXHRpZiAoZGlmZiA9PT0gMCkge1xuXHRcdGggPSBzID0gMDtcblx0fSBlbHNlIHtcblx0XHRzID0gZGlmZiAvIHY7XG5cdFx0cmRpZiA9IGRpZmZjKHIpO1xuXHRcdGdkaWYgPSBkaWZmYyhnKTtcblx0XHRiZGlmID0gZGlmZmMoYik7XG5cblx0XHRpZiAociA9PT0gdikge1xuXHRcdFx0aCA9IGJkaWYgLSBnZGlmO1xuXHRcdH0gZWxzZSBpZiAoZyA9PT0gdikge1xuXHRcdFx0aCA9ICgxIC8gMykgKyByZGlmIC0gYmRpZjtcblx0XHR9IGVsc2UgaWYgKGIgPT09IHYpIHtcblx0XHRcdGggPSAoMiAvIDMpICsgZ2RpZiAtIHJkaWY7XG5cdFx0fVxuXHRcdGlmIChoIDwgMCkge1xuXHRcdFx0aCArPSAxO1xuXHRcdH0gZWxzZSBpZiAoaCA+IDEpIHtcblx0XHRcdGggLT0gMTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdGggKiAzNjAsXG5cdFx0cyAqIDEwMCxcblx0XHR2ICogMTAwXG5cdF07XG59O1xuXG5jb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdO1xuXHR2YXIgZyA9IHJnYlsxXTtcblx0dmFyIGIgPSByZ2JbMl07XG5cdHZhciBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG5cdHZhciB3ID0gMSAvIDI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKTtcblxuXHRiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cblx0cmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmNteWsgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBjO1xuXHR2YXIgbTtcblx0dmFyIHk7XG5cdHZhciBrO1xuXG5cdGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcblx0YyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcblxuXHRyZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufTtcblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9lbi5tLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UjU3F1YXJlZF9FdWNsaWRlYW5fZGlzdGFuY2VcbiAqICovXG5mdW5jdGlvbiBjb21wYXJhdGl2ZURpc3RhbmNlKHgsIHkpIHtcblx0cmV0dXJuIChcblx0XHRNYXRoLnBvdyh4WzBdIC0geVswXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMV0gLSB5WzFdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsyXSAtIHlbMl0sIDIpXG5cdCk7XG59XG5cbmNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuXHRpZiAocmV2ZXJzZWQpIHtcblx0XHRyZXR1cm4gcmV2ZXJzZWQ7XG5cdH1cblxuXHR2YXIgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHR2YXIgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG5cdGZvciAodmFyIGtleXdvcmQgaW4gY29sb3JOYW1lKSB7XG5cdFx0aWYgKGNvbG9yTmFtZS5oYXNPd25Qcm9wZXJ0eShrZXl3b3JkKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gY29sb3JOYW1lW2tleXdvcmRdO1xuXG5cdFx0XHQvLyBDb21wdXRlIGNvbXBhcmF0aXZlIGRpc3RhbmNlXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBjb21wYXJhdGl2ZURpc3RhbmNlKHJnYiwgdmFsdWUpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3Rcblx0XHRcdGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG59O1xuXG5jb252ZXJ0LmtleXdvcmQucmdiID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcblx0cmV0dXJuIGNvbG9yTmFtZVtrZXl3b3JkXTtcbn07XG5cbmNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcblx0ZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG5cdGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG5cdHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuXHR2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcblx0dmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cblx0cmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF0gLyAzNjA7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHQxO1xuXHR2YXIgdDI7XG5cdHZhciB0Mztcblx0dmFyIHJnYjtcblx0dmFyIHZhbDtcblxuXHRpZiAocyA9PT0gMCkge1xuXHRcdHZhbCA9IGwgKiAyNTU7XG5cdFx0cmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcblx0fVxuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0dDIgPSBsICogKDEgKyBzKTtcblx0fSBlbHNlIHtcblx0XHR0MiA9IGwgKyBzIC0gbCAqIHM7XG5cdH1cblxuXHR0MSA9IDIgKiBsIC0gdDI7XG5cblx0cmdiID0gWzAsIDAsIDBdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHQzID0gaCArIDEgLyAzICogLShpIC0gMSk7XG5cdFx0aWYgKHQzIDwgMCkge1xuXHRcdFx0dDMrKztcblx0XHR9XG5cdFx0aWYgKHQzID4gMSkge1xuXHRcdFx0dDMtLTtcblx0XHR9XG5cblx0XHRpZiAoNiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG5cdFx0fSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0Mjtcblx0XHR9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gdDE7XG5cdFx0fVxuXG5cdFx0cmdiW2ldID0gdmFsICogMjU1O1xuXHR9XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNvbnZlcnQuaHNsLmhzdiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF07XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHNtaW4gPSBzO1xuXHR2YXIgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuXHR2YXIgc3Y7XG5cdHZhciB2O1xuXG5cdGwgKj0gMjtcblx0cyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcblx0c21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG5cdHYgPSAobCArIHMpIC8gMjtcblx0c3YgPSBsID09PSAwID8gKDIgKiBzbWluKSAvIChsbWluICsgc21pbikgOiAoMiAqIHMpIC8gKGwgKyBzKTtcblxuXHRyZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LnJnYiA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF0gLyA2MDtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuXHR2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuXHR2YXIgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuXHR2YXIgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpO1xuXHR2YXIgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpO1xuXHR2ICo9IDI1NTtcblxuXHRzd2l0Y2ggKGhpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cmV0dXJuIFt2LCB0LCBwXTtcblx0XHRjYXNlIDE6XG5cdFx0XHRyZXR1cm4gW3EsIHYsIHBdO1xuXHRcdGNhc2UgMjpcblx0XHRcdHJldHVybiBbcCwgdiwgdF07XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cmV0dXJuIFtwLCBxLCB2XTtcblx0XHRjYXNlIDQ6XG5cdFx0XHRyZXR1cm4gW3QsIHAsIHZdO1xuXHRcdGNhc2UgNTpcblx0XHRcdHJldHVybiBbdiwgcCwgcV07XG5cdH1cbn07XG5cbmNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF07XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcblx0dmFyIGxtaW47XG5cdHZhciBzbDtcblx0dmFyIGw7XG5cblx0bCA9ICgyIC0gcykgKiB2O1xuXHRsbWluID0gKDIgLSBzKSAqIHZtaW47XG5cdHNsID0gcyAqIHZtaW47XG5cdHNsIC89IChsbWluIDw9IDEpID8gbG1pbiA6IDIgLSBsbWluO1xuXHRzbCA9IHNsIHx8IDA7XG5cdGwgLz0gMjtcblxuXHRyZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn07XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuY29udmVydC5od2IucmdiID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgaCA9IGh3YlswXSAvIDM2MDtcblx0dmFyIHdoID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYmwgPSBod2JbMl0gLyAxMDA7XG5cdHZhciByYXRpbyA9IHdoICsgYmw7XG5cdHZhciBpO1xuXHR2YXIgdjtcblx0dmFyIGY7XG5cdHZhciBuO1xuXG5cdC8vIHdoICsgYmwgY2FudCBiZSA+IDFcblx0aWYgKHJhdGlvID4gMSkge1xuXHRcdHdoIC89IHJhdGlvO1xuXHRcdGJsIC89IHJhdGlvO1xuXHR9XG5cblx0aSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuXHR2ID0gMSAtIGJsO1xuXHRmID0gNiAqIGggLSBpO1xuXG5cdGlmICgoaSAmIDB4MDEpICE9PSAwKSB7XG5cdFx0ZiA9IDEgLSBmO1xuXHR9XG5cblx0biA9IHdoICsgZiAqICh2IC0gd2gpOyAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cdHN3aXRjaCAoaSkge1xuXHRcdGRlZmF1bHQ6XG5cdFx0Y2FzZSA2OlxuXHRcdGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuXHRcdGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuXHR2YXIgYyA9IGNteWtbMF0gLyAxMDA7XG5cdHZhciBtID0gY215a1sxXSAvIDEwMDtcblx0dmFyIHkgPSBjbXlrWzJdIC8gMTAwO1xuXHR2YXIgayA9IGNteWtbM10gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuXHRnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG5cdGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoucmdiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXSAvIDEwMDtcblx0dmFyIHkgPSB4eXpbMV0gLyAxMDA7XG5cdHZhciB6ID0geHl6WzJdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcblx0ZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG5cdGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IHIgKiAxMi45MjtcblxuXHRnID0gZyA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBnICogMTIuOTI7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogYiAqIDEyLjkyO1xuXG5cdHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG5cdGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG5cdGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LmxhYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmxhYi54eXogPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciB4O1xuXHR2YXIgeTtcblx0dmFyIHo7XG5cblx0eSA9IChsICsgMTYpIC8gMTE2O1xuXHR4ID0gYSAvIDUwMCArIHk7XG5cdHogPSB5IC0gYiAvIDIwMDtcblxuXHR2YXIgeTIgPSBNYXRoLnBvdyh5LCAzKTtcblx0dmFyIHgyID0gTWF0aC5wb3coeCwgMyk7XG5cdHZhciB6MiA9IE1hdGgucG93KHosIDMpO1xuXHR5ID0geTIgPiAwLjAwODg1NiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eCA9IHgyID4gMC4wMDg4NTYgPyB4MiA6ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHogPSB6MiA+IDAuMDA4ODU2ID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXG5cdHggKj0gOTUuMDQ3O1xuXHR5ICo9IDEwMDtcblx0eiAqPSAxMDguODgzO1xuXG5cdHJldHVybiBbeCwgeSwgel07XG59O1xuXG5jb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciBocjtcblx0dmFyIGg7XG5cdHZhciBjO1xuXG5cdGhyID0gTWF0aC5hdGFuMihiLCBhKTtcblx0aCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXG5cdHJldHVybiBbbCwgYywgaF07XG59O1xuXG5jb252ZXJ0LmxjaC5sYWIgPSBmdW5jdGlvbiAobGNoKSB7XG5cdHZhciBsID0gbGNoWzBdO1xuXHR2YXIgYyA9IGxjaFsxXTtcblx0dmFyIGggPSBsY2hbMl07XG5cdHZhciBhO1xuXHR2YXIgYjtcblx0dmFyIGhyO1xuXG5cdGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuXHRhID0gYyAqIE1hdGguY29zKGhyKTtcblx0YiA9IGMgKiBNYXRoLnNpbihocik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cdHZhciB2YWx1ZSA9IDEgaW4gYXJndW1lbnRzID8gYXJndW1lbnRzWzFdIDogY29udmVydC5yZ2IuaHN2KGFyZ3MpWzJdOyAvLyBoc3YgLT4gYW5zaTE2IG9wdGltaXphdGlvblxuXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIDUwKTtcblxuXHRpZiAodmFsdWUgPT09IDApIHtcblx0XHRyZXR1cm4gMzA7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDMwXG5cdFx0KyAoKE1hdGgucm91bmQoYiAvIDI1NSkgPDwgMilcblx0XHR8IChNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEpXG5cdFx0fCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcblxuXHRpZiAodmFsdWUgPT09IDIpIHtcblx0XHRhbnNpICs9IDYwO1xuXHR9XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0Lmhzdi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBvcHRpbWl6YXRpb24gaGVyZTsgd2UgYWxyZWFkeSBrbm93IHRoZSB2YWx1ZSBhbmQgZG9uJ3QgbmVlZCB0byBnZXRcblx0Ly8gaXQgY29udmVydGVkIGZvciB1cy5cblx0cmV0dXJuIGNvbnZlcnQucmdiLmFuc2kxNihjb252ZXJ0Lmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cblx0Ly8gd2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcblx0XHRpZiAociA8IDgpIHtcblx0XHRcdHJldHVybiAxNjtcblx0XHR9XG5cblx0XHRpZiAociA+IDI0OCkge1xuXHRcdFx0cmV0dXJuIDIzMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgoKHIgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDE2XG5cdFx0KyAoMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSlcblx0XHQrICg2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkpXG5cdFx0KyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBjb2xvciA9IGFyZ3MgJSAxMDtcblxuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuXHRcdGlmIChhcmdzID4gNTApIHtcblx0XHRcdGNvbG9yICs9IDMuNTtcblx0XHR9XG5cblx0XHRjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcblxuXHRcdHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG5cdH1cblxuXHR2YXIgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG5cdHZhciByID0gKChjb2xvciAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBnID0gKCgoY29sb3IgPj4gMSkgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgYiA9ICgoKGNvbG9yID4+IDIpICYgMSkgKiBtdWx0KSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGFyZ3MgPj0gMjMyKSB7XG5cdFx0dmFyIGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG5cdFx0cmV0dXJuIFtjLCBjLCBjXTtcblx0fVxuXG5cdGFyZ3MgLT0gMTY7XG5cblx0dmFyIHJlbTtcblx0dmFyIHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuXHR2YXIgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG5cdHZhciBiID0gKHJlbSAlIDYpIC8gNSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGV4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNilcblx0XHQrICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDB4RkYpIDw8IDgpXG5cdFx0KyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDB4RkYpO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIG1hdGNoID0gYXJncy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuXHRpZiAoIW1hdGNoKSB7XG5cdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0fVxuXG5cdHZhciBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuXG5cdGlmIChtYXRjaFswXS5sZW5ndGggPT09IDMpIHtcblx0XHRjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcblx0XHRcdHJldHVybiBjaGFyICsgY2hhcjtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblx0dmFyIHIgPSAoaW50ZWdlciA+PiAxNikgJiAweEZGO1xuXHR2YXIgZyA9IChpbnRlZ2VyID4+IDgpICYgMHhGRjtcblx0dmFyIGIgPSBpbnRlZ2VyICYgMHhGRjtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuXHR2YXIgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuXHR2YXIgY2hyb21hID0gKG1heCAtIG1pbik7XG5cdHZhciBncmF5c2NhbGU7XG5cdHZhciBodWU7XG5cblx0aWYgKGNocm9tYSA8IDEpIHtcblx0XHRncmF5c2NhbGUgPSBtaW4gLyAoMSAtIGNocm9tYSk7XG5cdH0gZWxzZSB7XG5cdFx0Z3JheXNjYWxlID0gMDtcblx0fVxuXG5cdGlmIChjaHJvbWEgPD0gMCkge1xuXHRcdGh1ZSA9IDA7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSByKSB7XG5cdFx0aHVlID0gKChnIC0gYikgLyBjaHJvbWEpICUgNjtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IGcpIHtcblx0XHRodWUgPSAyICsgKGIgLSByKSAvIGNocm9tYTtcblx0fSBlbHNlIHtcblx0XHRodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYSArIDQ7XG5cdH1cblxuXHRodWUgLz0gNjtcblx0aHVlICU9IDE7XG5cblx0cmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgYyA9IDE7XG5cdHZhciBmID0gMDtcblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdGMgPSAyLjAgKiBzICogbDtcblx0fSBlbHNlIHtcblx0XHRjID0gMi4wICogcyAqICgxLjAgLSBsKTtcblx0fVxuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblxuXHR2YXIgYyA9IHMgKiB2O1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5yZ2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBoID0gaGNnWzBdIC8gMzYwO1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0aWYgKGMgPT09IDAuMCkge1xuXHRcdHJldHVybiBbZyAqIDI1NSwgZyAqIDI1NSwgZyAqIDI1NV07XG5cdH1cblxuXHR2YXIgcHVyZSA9IFswLCAwLCAwXTtcblx0dmFyIGhpID0gKGggJSAxKSAqIDY7XG5cdHZhciB2ID0gaGkgJSAxO1xuXHR2YXIgdyA9IDEgLSB2O1xuXHR2YXIgbWcgPSAwO1xuXG5cdHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IHY7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRwdXJlWzBdID0gdzsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSB2OyBicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IHc7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRwdXJlWzBdID0gdjsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gdztcblx0fVxuXG5cdG1nID0gKDEuMCAtIGMpICogZztcblxuXHRyZXR1cm4gW1xuXHRcdChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG5cdF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKHYgPiAwLjApIHtcblx0XHRmID0gYyAvIHY7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuXHR2YXIgcyA9IDA7XG5cblx0aWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuXHRcdHMgPSBjIC8gKDIgKiBsKTtcblx0fSBlbHNlXG5cdGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG5cdFx0cyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIHcgPSBod2JbMV0gLyAxMDA7XG5cdHZhciBiID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgdiA9IDEgLSBiO1xuXHR2YXIgYyA9IHYgLSB3O1xuXHR2YXIgZyA9IDA7XG5cblx0aWYgKGMgPCAxKSB7XG5cdFx0ZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtod2JbMF0sIGMgKiAxMDAsIGcgKiAxMDBdO1xufTtcblxuY29udmVydC5hcHBsZS5yZ2IgPSBmdW5jdGlvbiAoYXBwbGUpIHtcblx0cmV0dXJuIFsoYXBwbGVbMF0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsxXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzJdIC8gNjU1MzUpICogMjU1XTtcbn07XG5cbmNvbnZlcnQucmdiLmFwcGxlID0gZnVuY3Rpb24gKHJnYikge1xuXHRyZXR1cm4gWyhyZ2JbMF0gLyAyNTUpICogNjU1MzUsIChyZ2JbMV0gLyAyNTUpICogNjU1MzUsIChyZ2JbMl0gLyAyNTUpICogNjU1MzVdO1xufTtcblxuY29udmVydC5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHNsID0gY29udmVydC5ncmF5LmhzdiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbMCwgMCwgYXJnc1swXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDAsIDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbZ3JheVswXSwgMCwgMF07XG59O1xuXG5jb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0dmFyIHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAweEZGO1xuXHR2YXIgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG5cdHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbn07XG59KTtcbnZhciBjb252ZXJzaW9uc18xID0gY29udmVyc2lvbnMucmdiO1xudmFyIGNvbnZlcnNpb25zXzIgPSBjb252ZXJzaW9ucy5oc2w7XG52YXIgY29udmVyc2lvbnNfMyA9IGNvbnZlcnNpb25zLmhzdjtcbnZhciBjb252ZXJzaW9uc180ID0gY29udmVyc2lvbnMuaHdiO1xudmFyIGNvbnZlcnNpb25zXzUgPSBjb252ZXJzaW9ucy5jbXlrO1xudmFyIGNvbnZlcnNpb25zXzYgPSBjb252ZXJzaW9ucy54eXo7XG52YXIgY29udmVyc2lvbnNfNyA9IGNvbnZlcnNpb25zLmxhYjtcbnZhciBjb252ZXJzaW9uc184ID0gY29udmVyc2lvbnMubGNoO1xudmFyIGNvbnZlcnNpb25zXzkgPSBjb252ZXJzaW9ucy5oZXg7XG52YXIgY29udmVyc2lvbnNfMTAgPSBjb252ZXJzaW9ucy5rZXl3b3JkO1xudmFyIGNvbnZlcnNpb25zXzExID0gY29udmVyc2lvbnMuYW5zaTE2O1xudmFyIGNvbnZlcnNpb25zXzEyID0gY29udmVyc2lvbnMuYW5zaTI1NjtcbnZhciBjb252ZXJzaW9uc18xMyA9IGNvbnZlcnNpb25zLmhjZztcbnZhciBjb252ZXJzaW9uc18xNCA9IGNvbnZlcnNpb25zLmFwcGxlO1xudmFyIGNvbnZlcnNpb25zXzE1ID0gY29udmVyc2lvbnMuZ3JheTtcblxuLypcblx0dGhpcyBmdW5jdGlvbiByb3V0ZXMgYSBtb2RlbCB0byBhbGwgb3RoZXIgbW9kZWxzLlxuXG5cdGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcm91dGVkIGhhdmUgYSBwcm9wZXJ0eSBgLmNvbnZlcnNpb25gIGF0dGFjaGVkXG5cdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcblx0b2Ygc3RyaW5ncywgZWFjaCB3aXRoIHRoZSBzdGVwcyBpbiBiZXR3ZWVuIHRoZSAnZnJvbScgYW5kICd0bydcblx0Y29sb3IgbW9kZWxzIChpbmNsdXNpdmUpLlxuXG5cdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiovXG5cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG5cdHZhciBncmFwaCA9IHt9O1xuXHQvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdGdyYXBoW21vZGVsc1tpXV0gPSB7XG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG5cdFx0XHQvLyBtaWNyby1vcHQsIGJ1dCB0aGlzIGlzIHNpbXBsZS5cblx0XHRcdGRpc3RhbmNlOiAtMSxcblx0XHRcdHBhcmVudDogbnVsbFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNoXG5mdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGJ1aWxkR3JhcGgoKTtcblx0dmFyIHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIHVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdHZhciBjdXJyZW50ID0gcXVldWUucG9wKCk7XG5cdFx0dmFyIGFkamFjZW50cyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zW2N1cnJlbnRdKTtcblxuXHRcdGZvciAodmFyIGxlbiA9IGFkamFjZW50cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHZhciBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdHZhciBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuXG5cdFx0XHRpZiAobm9kZS5kaXN0YW5jZSA9PT0gLTEpIHtcblx0XHRcdFx0bm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcblx0XHRcdFx0bm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KGFkamFjZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbmZ1bmN0aW9uIGxpbmsoZnJvbSwgdG8pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0cmV0dXJuIHRvKGZyb20oYXJncykpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCkge1xuXHR2YXIgcGF0aCA9IFtncmFwaFt0b01vZGVsXS5wYXJlbnQsIHRvTW9kZWxdO1xuXHR2YXIgZm4gPSBjb252ZXJzaW9uc1tncmFwaFt0b01vZGVsXS5wYXJlbnRdW3RvTW9kZWxdO1xuXG5cdHZhciBjdXIgPSBncmFwaFt0b01vZGVsXS5wYXJlbnQ7XG5cdHdoaWxlIChncmFwaFtjdXJdLnBhcmVudCkge1xuXHRcdHBhdGgudW5zaGlmdChncmFwaFtjdXJdLnBhcmVudCk7XG5cdFx0Zm4gPSBsaW5rKGNvbnZlcnNpb25zW2dyYXBoW2N1cl0ucGFyZW50XVtjdXJdLCBmbik7XG5cdFx0Y3VyID0gZ3JhcGhbY3VyXS5wYXJlbnQ7XG5cdH1cblxuXHRmbi5jb252ZXJzaW9uID0gcGF0aDtcblx0cmV0dXJuIGZuO1xufVxuXG52YXIgcm91dGUgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuXHR2YXIgY29udmVyc2lvbiA9IHt9O1xuXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcblx0XHR2YXIgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuXG5cdFx0aWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHQvLyBubyBwb3NzaWJsZSBjb252ZXJzaW9uLCBvciB0aGlzIG5vZGUgaXMgdGhlIHNvdXJjZSBtb2RlbC5cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG5cdH1cblxuXHRyZXR1cm4gY29udmVyc2lvbjtcbn07XG5cbnZhciBjb252ZXJ0ID0ge307XG5cbnZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbihhcmdzKTtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbmZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG5cdHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoYXJncykge1xuXHRcdGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0ID0gZm4oYXJncyk7XG5cblx0XHQvLyB3ZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG5cdFx0Ly8gc2VlIG5vdGljZSBpbiBjb252ZXJzaW9ucy5qczsgZG9uJ3QgdXNlIGJveCB0eXBlc1xuXHRcdC8vIGluIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbm1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0Y29udmVydFtmcm9tTW9kZWxdID0ge307XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmNoYW5uZWxzfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0ubGFiZWxzfSk7XG5cblx0dmFyIHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG5cdHZhciByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG5cblx0cm91dGVNb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAodG9Nb2RlbCkge1xuXHRcdHZhciBmbiA9IHJvdXRlc1t0b01vZGVsXTtcblxuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG5cdH0pO1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG52YXIgY29sb3JOYW1lJDEgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cbnZhciBjb2xvclN0cmluZyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn07XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezMsNH0pJC9pLFxuICAgICAgIGhleCA9ICAvXiMoW2EtZkEtRjAtOV17Nn0oW2EtZkEtRjAtOV17Mn0pPykkL2ksXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAga2V5d29yZCA9IC8oXFx3KykvO1xuXG4gICB2YXIgcmdiID0gWzAsIDAsIDBdLFxuICAgICAgIGEgPSAxLFxuICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpLFxuICAgICAgIGhleEFscGhhID0gXCJcIjtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGhleEFscGhhID0gbWF0Y2hbM107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEgKyBoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzJdO1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZSQxW21hdGNoWzFdXTtcbiAgICAgIGlmICghcmdiKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JbaV0gPSBzY2FsZShyZ2JbaV0sIDAsIDI1NSk7XG4gICB9XG4gICBpZiAoIWEgJiYgYSAhPSAwKSB7XG4gICAgICBhID0gMTtcbiAgIH1cbiAgIGVsc2Uge1xuICAgICAgYSA9IHNjYWxlKGEsIDAsIDEpO1xuICAgfVxuICAgcmdiWzNdID0gYTtcbiAgIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGdldEhzbGEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHMgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBsID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHMsIGwsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRId2Ioc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgdywgYiwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldFJnYihzdHJpbmcpIHtcbiAgIHZhciByZ2JhID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgcmV0dXJuIHJnYmEgJiYgcmdiYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsKHN0cmluZykge1xuICB2YXIgaHNsYSA9IGdldEhzbGEoc3RyaW5nKTtcbiAgcmV0dXJuIGhzbGEgJiYgaHNsYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxwaGEoc3RyaW5nKSB7XG4gICB2YXIgdmFscyA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIGlmICh2YWxzKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRIc2xhKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEh3YihzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbn1cblxuLy8gZ2VuZXJhdG9yc1xuZnVuY3Rpb24gaGV4U3RyaW5nKHJnYmEsIGEpIHtcbiAgIHZhciBhID0gKGEgIT09IHVuZGVmaW5lZCAmJiByZ2JhLmxlbmd0aCA9PT0gMykgPyBhIDogcmdiYVszXTtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JhWzBdKSBcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiYVsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiYVsyXSlcbiAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgIChhID49IDAgJiYgYSA8IDEpXG4gICAgICAgICAgICAgICAgID8gaGV4RG91YmxlKE1hdGgucm91bmQoYSAqIDI1NSkpXG4gICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICApO1xufVxuXG5mdW5jdGlvbiByZ2JTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2IoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl0gKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKHJnYmFbM10gIT09IHVuZGVmaW5lZCA/IHJnYmFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl1cbiAgICAgICAgICAgKyBcIiwgXCIgKyBhbHBoYSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50U3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcblxuICAgcmV0dXJuIFwicmdiKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUsIFwiICsgKGFscGhhIHx8IHJnYmFbM10gfHwgMSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gaHNsU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChoc2xhWzNdICYmIGhzbGFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGhzbGFbM10gIT09IHVuZGVmaW5lZCA/IGhzbGFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbGEoXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlLCBcIlxuICAgICAgICAgICArIGFscGhhICsgXCIpXCI7XG59XG5cbi8vIGh3YiBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiByZ2IoYSkgJiBoc2woYSkgc2luY2UgdGhlcmUgaXMgbm8gYWxwaGEgc3BlY2lmaWMgc3ludGF4XG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXG5mdW5jdGlvbiBod2JTdHJpbmcoaHdiLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGh3YlszXSAhPT0gdW5kZWZpbmVkID8gaHdiWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJod2IoXCIgKyBod2JbMF0gKyBcIiwgXCIgKyBod2JbMV0gKyBcIiUsIFwiICsgaHdiWzJdICsgXCIlXCJcbiAgICAgICAgICAgKyAoYWxwaGEgIT09IHVuZGVmaW5lZCAmJiBhbHBoYSAhPT0gMSA/IFwiLCBcIiArIGFscGhhIDogXCJcIikgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24ga2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufVxuXG4vLyBoZWxwZXJzXG5mdW5jdGlvbiBzY2FsZShudW0sIG1pbiwgbWF4KSB7XG4gICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gXCIwXCIgKyBzdHIgOiBzdHI7XG59XG5cblxuLy9jcmVhdGUgYSBsaXN0IG9mIHJldmVyc2UgY29sb3IgbmFtZXNcbnZhciByZXZlcnNlTmFtZXMgPSB7fTtcbmZvciAodmFyIG5hbWUgaW4gY29sb3JOYW1lJDEpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWUkMVtuYW1lXV0gPSBuYW1lO1xufVxuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cblxudmFyIENvbG9yID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaik7XG5cdH1cblxuXHR0aGlzLnZhbGlkID0gZmFsc2U7XG5cdHRoaXMudmFsdWVzID0ge1xuXHRcdHJnYjogWzAsIDAsIDBdLFxuXHRcdGhzbDogWzAsIDAsIDBdLFxuXHRcdGhzdjogWzAsIDAsIDBdLFxuXHRcdGh3YjogWzAsIDAsIDBdLFxuXHRcdGNteWs6IFswLCAwLCAwLCAwXSxcblx0XHRhbHBoYTogMVxuXHR9O1xuXG5cdC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcblx0dmFyIHZhbHM7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHZhbHMgPSBjb2xvclN0cmluZy5nZXRSZ2JhKG9iaik7XG5cdFx0aWYgKHZhbHMpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRIc2xhKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRId2Iob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuXHRcdHZhbHMgPSBvYmo7XG5cdFx0aWYgKHZhbHMuciAhPT0gdW5kZWZpbmVkIHx8IHZhbHMucmVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMubCAhPT0gdW5kZWZpbmVkIHx8IHZhbHMubGlnaHRuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudiAhPT0gdW5kZWZpbmVkIHx8IHZhbHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzdicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy53ICE9PSB1bmRlZmluZWQgfHwgdmFscy53aGl0ZW5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5jICE9PSB1bmRlZmluZWQgfHwgdmFscy5jeWFuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdjbXlrJywgdmFscyk7XG5cdFx0fVxuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZDtcblx0fSxcblx0cmdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ3JnYicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc2wnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc3Y6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHN2JywgYXJndW1lbnRzKTtcblx0fSxcblx0aHdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2h3YicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGNteWs6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnY215aycsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0cmdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuXHR9LFxuXHRoc2xBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG5cdH0sXG5cdGhzdkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcblx0fSxcblx0aHdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlcy5od2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcy5od2I7XG5cdH0sXG5cdGNteWtBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuXHR9LFxuXHRyZ2JhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5yZ2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0aHNsYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMuaHNsLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIHZhbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMCwgdmFsKTtcblx0fSxcblx0Z3JlZW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMiwgdmFsKTtcblx0fSxcblx0aHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0dmFsICU9IDM2MDtcblx0XHRcdHZhbCA9IHZhbCA8IDAgPyAzNjAgKyB2YWwgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDAsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb246IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAxLCB2YWwpO1xuXHR9LFxuXHRsaWdodG5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAyLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9udjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDEsIHZhbCk7XG5cdH0sXG5cdHdoaXRlbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsYWNrbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDIsIHZhbCk7XG5cdH0sXG5cdHZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMiwgdmFsKTtcblx0fSxcblx0Y3lhbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAwLCB2YWwpO1xuXHR9LFxuXHRtYWdlbnRhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDEsIHZhbCk7XG5cdH0sXG5cdHllbGxvdzogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAyLCB2YWwpO1xuXHR9LFxuXHRibGFjazogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAzLCB2YWwpO1xuXHR9LFxuXG5cdGhleFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oZXhTdHJpbmcodGhpcy52YWx1ZXMucmdiKTtcblx0fSxcblx0cmdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cmdiYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JhU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnBlcmNlbnRTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbGFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsYVN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmh3YlN0cmluZyh0aGlzLnZhbHVlcy5od2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0a2V5d29yZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0cmV0dXJuIChyZ2JbMF0gPDwgMTYpIHwgKHJnYlsxXSA8PCA4KSB8IHJnYlsyXTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRhcmsoKTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IDI1NSAtIHRoaXMudmFsdWVzLnJnYltpXTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHJnYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gKz0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSAtPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gKz0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gLT0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsxXSArPSBod2JbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsyXSArPSBod2JbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRncmV5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCBbdmFsLCB2YWwsIHZhbF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhIC0gKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSArIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0dmFyIGh1ZSA9IChoc2xbMF0gKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRoc2xbMF0gPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdCAqL1xuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHR2YXIgY29sb3IxID0gdGhpcztcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvcjtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5yZ2IoXG5cdFx0XHRcdHcxICogY29sb3IxLnJlZCgpICsgdzIgKiBjb2xvcjIucmVkKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKClcblx0XHRcdClcblx0XHRcdC5hbHBoYShjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJnYigpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gTk9URShTQik6IHVzaW5nIG5vZGUtY2xvbmUgY3JlYXRlcyBhIGRlcGVuZGVuY3kgdG8gQnVmZmVyIHdoZW4gdXNpbmcgYnJvd3NlcmlmeSxcblx0XHQvLyBtYWtpbmcgdGhlIGZpbmFsIGJ1aWxkIHdheSB0byBiaWcgdG8gZW1iZWQgaW4gQ2hhcnQuanMuIFNvIGxldCdzIGRvIGl0IG1hbnVhbGx5LFxuXHRcdC8vIGFzc3VtaW5nIHRoYXQgdmFsdWVzIHRvIGNsb25lIGFyZSAxIGRpbWVuc2lvbiBhcnJheXMgY29udGFpbmluZyBvbmx5IG51bWJlcnMsXG5cdFx0Ly8gZXhjZXB0ICdhbHBoYScgd2hpY2ggaXMgYSBudW1iZXIuXG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb2xvcigpO1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLnZhbHVlcztcblx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0LnZhbHVlcztcblx0XHR2YXIgdmFsdWUsIHR5cGU7XG5cblx0XHRmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblx0XHRcdFx0dHlwZSA9ICh7fSkudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWUuc2xpY2UoMCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmV4cGVjdGVkIGNvbG9yIHZhbHVlOicsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zcGFjZXMgPSB7XG5cdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdGhzdjogWydodWUnLCAnc2F0dXJhdGlvbicsICd2YWx1ZSddLFxuXHRod2I6IFsnaHVlJywgJ3doaXRlbmVzcycsICdibGFja25lc3MnXSxcblx0Y215azogWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93JywgJ2JsYWNrJ11cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5tYXhlcyA9IHtcblx0cmdiOiBbMjU1LCAyNTUsIDI1NV0sXG5cdGhzbDogWzM2MCwgMTAwLCAxMDBdLFxuXHRoc3Y6IFszNjAsIDEwMCwgMTAwXSxcblx0aHdiOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGNteWs6IFsxMDAsIDEwMCwgMTAwLCAxMDBdXG59O1xuXG5Db2xvci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHZhbHMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFsc1tzcGFjZS5jaGFyQXQoaSldID0gdmFsdWVzW3NwYWNlXVtpXTtcblx0fVxuXG5cdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHR2YWxzLmEgPSB2YWx1ZXMuYWxwaGE7XG5cdH1cblxuXHQvLyB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMC40fVxuXHRyZXR1cm4gdmFscztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UsIHZhbHMpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXM7XG5cdHZhciBtYXhlcyA9IHRoaXMubWF4ZXM7XG5cdHZhciBhbHBoYSA9IDE7XG5cdHZhciBpO1xuXG5cdHRoaXMudmFsaWQgPSB0cnVlO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdGFscGhhID0gdmFscztcblx0fSBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuXHRcdC8vIFsxMCwgMTAsIDEwXVxuXHRcdHZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG5cdFx0YWxwaGEgPSB2YWxzW3NwYWNlLmxlbmd0aF07XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZS5jaGFyQXQoMCldICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cjogMTAsIGc6IDEwLCBiOiAxMH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlLmNoYXJBdChpKV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmE7XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3JlZDogMTAsIGdyZWVuOiAxMCwgYmx1ZTogMTB9XG5cdFx0dmFyIGNoYW5zID0gc3BhY2VzW3NwYWNlXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hbHBoYTtcblx0fVxuXG5cdHZhbHVlcy5hbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChhbHBoYSA9PT0gdW5kZWZpbmVkID8gdmFsdWVzLmFscGhhIDogYWxwaGEpKSk7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNhcHBlZDtcblxuXHQvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcblx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2FwcGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4ZXNbc3BhY2VdW2ldLCB2YWx1ZXNbc3BhY2VdW2ldKSk7XG5cdFx0dmFsdWVzW3NwYWNlXVtpXSA9IE1hdGgucm91bmQoY2FwcGVkKTtcblx0fVxuXG5cdC8vIGNvbnZlcnQgdG8gYWxsIHRoZSBvdGhlciBjb2xvciBzcGFjZXNcblx0Zm9yICh2YXIgc25hbWUgaW4gc3BhY2VzKSB7XG5cdFx0aWYgKHNuYW1lICE9PSBzcGFjZSkge1xuXHRcdFx0dmFsdWVzW3NuYW1lXSA9IGNvbG9yQ29udmVydFtzcGFjZV1bc25hbWVdKHZhbHVlc1tzcGFjZV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24gKHNwYWNlLCBhcmdzKSB7XG5cdHZhciB2YWxzID0gYXJnc1swXTtcblxuXHRpZiAodmFscyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmdiKClcblx0XHRyZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuXHR9XG5cblx0Ly8gY29sb3IucmdiKDEwLCAxMCwgMTApXG5cdGlmICh0eXBlb2YgdmFscyA9PT0gJ251bWJlcicpIHtcblx0XHR2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cdH1cblxuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFscyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoc3BhY2UsIGluZGV4LCB2YWwpIHtcblx0dmFyIHN2YWx1ZXMgPSB0aGlzLnZhbHVlc1tzcGFjZV07XG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJlZCgpXG5cdFx0cmV0dXJuIHN2YWx1ZXNbaW5kZXhdO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gc3ZhbHVlc1tpbmRleF0pIHtcblx0XHQvLyBjb2xvci5yZWQoY29sb3IucmVkKCkpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBjb2xvci5yZWQoMTAwKVxuXHRzdmFsdWVzW2luZGV4XSA9IHZhbDtcblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHN2YWx1ZXMpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5Db2xvciA9IENvbG9yO1xufVxuXG52YXIgY2hhcnRqc0NvbG9yID0gQ29sb3I7XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XHJcblx0cmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcclxuICovXHJcbnZhciBoZWxwZXJzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXHJcblx0ICovXHJcblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0dWlkOiAoZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgaWQgPSAwO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gaWQrKztcclxuXHRcdH07XHJcblx0fSgpKSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0aXNOdWxsT3JVbmRlZjogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxyXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHRpc0FycmF5OiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcblx0XHRpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdGlzT2JqZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRpc0Zpbml0ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUodmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cclxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICovXHJcblx0dmFsdWVPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB2YWx1ZSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiBhcnJheSBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWUgLSBUaGUgYXJyYXkgdG8gbG9va3VwIGZvciB2YWx1ZSBhdCBgaW5kZXhgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXHJcblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZVtpbmRleF1gIGlzIHVuZGVmaW5lZC5cclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKi9cclxuXHR2YWx1ZUF0SW5kZXhPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XHJcblx0XHRyZXR1cm4gaGVscGVycy52YWx1ZU9yRGVmYXVsdChoZWxwZXJzLmlzQXJyYXkodmFsdWUpID8gdmFsdWVbaW5kZXhdIDogdmFsdWUsIGRlZmF1bHRWYWx1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxyXG5cdCAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICovXHJcblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGlzQXJnKSB7XHJcblx0XHRpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxyXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXHJcblx0ICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cclxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cclxuXHQgKi9cclxuXHRlYWNoOiBmdW5jdGlvbihsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcclxuXHRcdHZhciBpLCBsZW4sIGtleXM7XHJcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xyXG5cdFx0XHRsZW4gPSBsb29wYWJsZS5sZW5ndGg7XHJcblx0XHRcdGlmIChyZXZlcnNlKSB7XHJcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChoZWxwZXJzLmlzT2JqZWN0KGxvb3BhYmxlKSkge1xyXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xyXG5cdFx0XHRsZW4gPSBrZXlzLmxlbmd0aDtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxyXG5cdCAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XHJcblx0XHR2YXIgaSwgaWxlbiwgdjAsIHYxO1xyXG5cclxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHYwID0gYTBbaV07XHJcblx0XHRcdHYxID0gYTFbaV07XHJcblxyXG5cdFx0XHRpZiAodjAgaW5zdGFuY2VvZiBBcnJheSAmJiB2MSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XHJcblx0XHRcdFx0Ly8gTk9URTogdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cclxuXHQgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKi9cclxuXHRjbG9uZTogZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcclxuXHRcdFx0cmV0dXJuIHNvdXJjZS5tYXAoaGVscGVycy5jbG9uZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShzb3VyY2UpO1xyXG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XHJcblx0XHRcdHZhciBrID0gMDtcclxuXHJcblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XHJcblx0XHRcdFx0dGFyZ2V0W2tleXNba11dID0gaGVscGVycy5jbG9uZShzb3VyY2Vba2V5c1trXV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGRlZmF1bHQgbWVyZ2VyIHdoZW4gQ2hhcnQuaGVscGVycy5tZXJnZSBpcyBjYWxsZWQgd2l0aG91dCBtZXJnZXIgb3B0aW9uLlxyXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xyXG5cdFx0XHQvLyBXZSB3YW50IHRvIGVuc3VyZSB3ZSBkbyBub3QgY29weSBwcm90b3R5cGVzIG92ZXJcclxuXHRcdFx0Ly8gYXMgdGhpcyBjYW4gcG9sbHV0ZSBnbG9iYWwgbmFtZXNwYWNlc1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcclxuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xyXG5cdFx0XHRoZWxwZXJzLm1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9tZXJnZXJJZjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xyXG5cdFx0aWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcclxuXHRcdFx0Ly8gV2Ugd2FudCB0byBlbnN1cmUgd2UgZG8gbm90IGNvcHkgcHJvdG90eXBlcyBvdmVyXHJcblx0XHRcdC8vIGFzIHRoaXMgY2FuIHBvbGx1dGUgZ2xvYmFsIG5hbWVzcGFjZXNcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV07XHJcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHR2YWwpICYmIGhlbHBlcnMuaXNPYmplY3Qoc3ZhbCkpIHtcclxuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xyXG5cdFx0fSBlbHNlIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXHJcblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXHJcblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XHJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXHJcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cclxuXHQgKi9cclxuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzb3VyY2VzID0gaGVscGVycy5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcclxuXHRcdHZhciBpbGVuID0gc291cmNlcy5sZW5ndGg7XHJcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XHJcblxyXG5cdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHRhcmdldCkpIHtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdG1lcmdlID0gb3B0aW9ucy5tZXJnZXIgfHwgaGVscGVycy5fbWVyZ2VyO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcclxuXHRcdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcblx0XHRcdGZvciAoayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xyXG5cdFx0XHRcdG1lcmdlKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXHJcblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXHJcblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXHJcblx0ICovXHJcblx0bWVyZ2VJZjogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzLm1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBoZWxwZXJzLl9tZXJnZXJJZn0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgb2JqZWN0cyBhcmUgbWVyZ2VkIGludG8uXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZzEgLSBPYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4gdGFyZ2V0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXHJcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cclxuXHQgKi9cclxuXHRleHRlbmQ6IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZSh0YXJnZXQsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwge1xyXG5cdFx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgZHN0LCBzcmMpIHtcclxuXHRcdFx0XHRkc3Rba2V5XSA9IHNyY1trZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXHJcblx0ICovXHJcblx0aW5oZXJpdHM6IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgQ2hhcnRFbGVtZW50ID0gKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkgPyBleHRlbnNpb25zLmNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBDaGFydEVsZW1lbnQ7XHJcblx0XHR9O1xyXG5cclxuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XHJcblx0XHRDaGFydEVsZW1lbnQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpO1xyXG5cdFx0Q2hhcnRFbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XHJcblxyXG5cdFx0aWYgKGV4dGVuc2lvbnMpIHtcclxuXHRcdFx0aGVscGVycy5leHRlbmQoQ2hhcnRFbGVtZW50LnByb3RvdHlwZSwgZXh0ZW5zaW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Q2hhcnRFbGVtZW50Ll9fc3VwZXJfXyA9IG1lLnByb3RvdHlwZTtcclxuXHRcdHJldHVybiBDaGFydEVsZW1lbnQ7XHJcblx0fSxcclxuXHJcblx0X2RlcHJlY2F0ZWQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcclxuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcclxuXHRcdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG52YXIgaGVscGVyc19jb3JlID0gaGVscGVycztcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYWxsYmFjayBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzLmNhbGxDYWxsYmFjayA9IGhlbHBlcnMuY2FsbGJhY2s7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBpbnN0ZWFkLlxyXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5pbmRleE9mXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xyXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZU9yRGVmYXVsdCBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQgaW5zdGVhZC5cclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxuLyoqXHJcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xyXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXHJcbiAqL1xyXG52YXIgZWZmZWN0cyA9IHtcclxuXHRsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0ICogdDtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIC10ICogKHQgLSAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0ICogdCAqIHQ7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIC0oKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKiB0ICogdCArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAtTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0U2luZTogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIE1hdGguc2luKHQgKiAoTWF0aC5QSSAvIDIpKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAodCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHRcdGlmICh0ID09PSAxKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICh0ID49IDEpIHtcclxuXHRcdFx0cmV0dXJuIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAodCA9IHQgLSAxKSAqIHQpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XHJcblx0XHR2YXIgcyA9IDEuNzAxNTg7XHJcblx0XHR2YXIgcCA9IDA7XHJcblx0XHR2YXIgYSA9IDE7XHJcblx0XHRpZiAodCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHRcdGlmICh0ID09PSAxKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFwKSB7XHJcblx0XHRcdHAgPSAwLjM7XHJcblx0XHR9XHJcblx0XHRpZiAoYSA8IDEpIHtcclxuXHRcdFx0YSA9IDE7XHJcblx0XHRcdHMgPSBwIC8gNDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0dmFyIHAgPSAwO1xyXG5cdFx0dmFyIGEgPSAxO1xyXG5cdFx0aWYgKHQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0XHRpZiAodCA9PT0gMSkge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdGlmICghcCkge1xyXG5cdFx0XHRwID0gMC4zO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEgPCAxKSB7XHJcblx0XHRcdGEgPSAxO1xyXG5cdFx0XHRzID0gcCAvIDQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHZhciBzID0gMS43MDE1ODtcclxuXHRcdHZhciBwID0gMDtcclxuXHRcdHZhciBhID0gMTtcclxuXHRcdGlmICh0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoIXApIHtcclxuXHRcdFx0cCA9IDAuNDU7XHJcblx0XHR9XHJcblx0XHRpZiAoYSA8IDEpIHtcclxuXHRcdFx0YSA9IDE7XHJcblx0XHRcdHMgPSBwIC8gNDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XHJcblx0XHR9XHJcblx0XHRpZiAodCA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xyXG5cdH0sXHJcblx0ZWFzZUluQmFjazogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHZhciBzID0gMS43MDE1ODtcclxuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAodCA8ICgxIC8gMi43NSkpIHtcclxuXHRcdFx0cmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHQgPCAoMiAvIDIuNzUpKSB7XHJcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzU7XHJcblx0XHR9XHJcblx0XHRpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xyXG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICh0IDwgMC41KSB7XHJcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGhlbHBlcnNfZWFzaW5nID0ge1xyXG5cdGVmZmVjdHM6IGVmZmVjdHNcclxufTtcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0cyBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5lYXNpbmdFZmZlY3RzXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVyc19jb3JlLmVhc2luZ0VmZmVjdHMgPSBlZmZlY3RzO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xyXG52YXIgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcclxudmFyIERPVUJMRV9QSSA9IFBJICogMjtcclxudmFyIEhBTEZfUEkgPSBQSSAvIDI7XHJcbnZhciBRVUFSVEVSX1BJID0gUEkgLyA0O1xyXG52YXIgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xyXG4gKi9cclxudmFyIGV4cG9ydHMkMSA9IHtcclxuXHQvKipcclxuXHQgKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gYGNoYXJ0YC5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGNhbnZhcy5cclxuXHQgKi9cclxuXHRjbGVhcjogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdGNoYXJ0LmN0eC5jbGVhclJlY3QoMCwgMCwgY2hhcnQud2lkdGgsIGNoYXJ0LmhlaWdodCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXHJcblx0ICogZ2l2ZW4gc2l6ZSAod2lkdGgsIGhlaWdodCkgYW5kIHRoZSBzYW1lIGByYWRpdXNgIGZvciBhbGwgY29ybmVycy5cclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVGhlIGNhbnZhcyAyRCBDb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlY3RhbmdsZSdzIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcm91bmRlZCBhbW91bnQgKGluIHBpeGVscykgZm9yIHRoZSBmb3VyIGNvcm5lcnMuXHJcblx0ICogQHRvZG8gaGFuZGxlIGByYWRpdXNgIGFzIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnQgYXJyYXkvb2JqZWN0P1xyXG5cdCAqL1xyXG5cdHJvdW5kZWRSZWN0OiBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xyXG5cdFx0aWYgKHJhZGl1cykge1xyXG5cdFx0XHR2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKTtcclxuXHRcdFx0dmFyIGxlZnQgPSB4ICsgcjtcclxuXHRcdFx0dmFyIHRvcCA9IHkgKyByO1xyXG5cdFx0XHR2YXIgcmlnaHQgPSB4ICsgd2lkdGggLSByO1xyXG5cdFx0XHR2YXIgYm90dG9tID0geSArIGhlaWdodCAtIHI7XHJcblxyXG5cdFx0XHRjdHgubW92ZVRvKHgsIHRvcCk7XHJcblx0XHRcdGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgLUhBTEZfUEkpO1xyXG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xyXG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIGJvdHRvbSwgciwgMCwgSEFMRl9QSSk7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIEhBTEZfUEksIFBJKTtcclxuXHRcdFx0fSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcclxuXHRcdFx0XHRjdHgubW92ZVRvKGxlZnQsIHkpO1xyXG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIEhBTEZfUEkpO1xyXG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBQSSArIEhBTEZfUEkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xyXG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIDApO1xyXG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBQSSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgUEkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRyYXdQb2ludDogZnVuY3Rpb24oY3R4LCBzdHlsZSwgcmFkaXVzLCB4LCB5LCByb3RhdGlvbikge1xyXG5cdFx0dmFyIHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcclxuXHRcdHZhciByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcclxuXHJcblx0XHRpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHR0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcclxuXHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG5cdFx0XHRcdGN0eC5yb3RhdGUocmFkKTtcclxuXHRcdFx0XHRjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdHN3aXRjaCAoc3R5bGUpIHtcclxuXHRcdC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgRE9VQkxFX1BJKTtcclxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3RyaWFuZ2xlJzpcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAncmVjdFJvdW5kZWQnOlxyXG5cdFx0XHQvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcclxuXHRcdFx0Ly8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcclxuXHRcdFx0Ly8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxyXG5cdFx0XHQvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxyXG5cdFx0XHQvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxyXG5cdFx0XHRjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcclxuXHRcdFx0c2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcclxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcclxuXHRcdFx0Y3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xyXG5cdFx0XHRjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xyXG5cdFx0XHRjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xyXG5cdFx0XHRjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdyZWN0JzpcclxuXHRcdFx0aWYgKCFyb3RhdGlvbikge1xyXG5cdFx0XHRcdHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XHJcblx0XHRcdFx0Y3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xyXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXHJcblx0XHRjYXNlICdyZWN0Um90JzpcclxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xyXG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdjcm9zc1JvdCc6XHJcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xyXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXHJcblx0XHRjYXNlICdjcm9zcyc6XHJcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3N0YXInOlxyXG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcclxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XHJcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2xpbmUnOlxyXG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2Rhc2gnOlxyXG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5maWxsKCk7XHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZWEgLSBUaGUgcmVjdGFuZ2xlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaXNQb2ludEluQXJlYTogZnVuY3Rpb24ocG9pbnQsIGFyZWEpIHtcclxuXHRcdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA+IGFyZWEubGVmdCAtIGVwc2lsb24gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBlcHNpbG9uICYmXHJcblx0XHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIGVwc2lsb24gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgZXBzaWxvbjtcclxuXHR9LFxyXG5cclxuXHRjbGlwQXJlYTogZnVuY3Rpb24oY3R4LCBhcmVhKSB7XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XHJcblx0XHRjdHguY2xpcCgpO1xyXG5cdH0sXHJcblxyXG5cdHVuY2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9LFxyXG5cclxuXHRsaW5lVG86IGZ1bmN0aW9uKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xyXG5cdFx0dmFyIHN0ZXBwZWQgPSB0YXJnZXQuc3RlcHBlZExpbmU7XHJcblx0XHRpZiAoc3RlcHBlZCkge1xyXG5cdFx0XHRpZiAoc3RlcHBlZCA9PT0gJ21pZGRsZScpIHtcclxuXHRcdFx0XHR2YXIgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcclxuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gdGFyZ2V0LnkgOiBwcmV2aW91cy55KTtcclxuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gcHJldmlvdXMueSA6IHRhcmdldC55KTtcclxuXHRcdFx0fSBlbHNlIGlmICgoc3RlcHBlZCA9PT0gJ2FmdGVyJyAmJiAhZmxpcCkgfHwgKHN0ZXBwZWQgIT09ICdhZnRlcicgJiYgZmxpcCkpIHtcclxuXHRcdFx0XHRjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRhcmdldC50ZW5zaW9uKSB7XHJcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKFxyXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNYIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFgsXHJcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1kgOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WSxcclxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WCA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1gsXHJcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFkgOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNZLFxyXG5cdFx0XHR0YXJnZXQueCxcclxuXHRcdFx0dGFyZ2V0LnkpO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX2NhbnZhcyA9IGV4cG9ydHMkMTtcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNsZWFyXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVyc19jb3JlLmNsZWFyID0gZXhwb3J0cyQxLmNsZWFyO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMucm91bmRlZFJlY3QgaW5zdGVhZC5cclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVyc19jb3JlLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGV4cG9ydHMkMS5yb3VuZGVkUmVjdC5hcHBseShleHBvcnRzJDEsIGFyZ3VtZW50cyk7XHJcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZXMpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzX2NvcmUubWVyZ2UodGhpc1tzY29wZV0gfHwgKHRoaXNbc2NvcGVdID0ge30pLCB2YWx1ZXMpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8odjMpOiByZW1vdmUgJ2dsb2JhbCcgZnJvbSBuYW1lc3BhY2UuICBhbGwgZGVmYXVsdCBhcmUgZ2xvYmFsIGFuZFxyXG4vLyB0aGVyZSdzIGluY29uc2lzdGVuY3kgYXJvdW5kIHdoaWNoIG9wdGlvbnMgYXJlIHVuZGVyICdnbG9iYWwnXHJcbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRkZWZhdWx0Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxyXG5cdGRlZmF1bHRGb250Q29sb3I6ICcjNjY2JyxcclxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxyXG5cdGRlZmF1bHRGb250U2l6ZTogMTIsXHJcblx0ZGVmYXVsdEZvbnRTdHlsZTogJ25vcm1hbCcsXHJcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcclxuXHRzaG93TGluZXM6IHRydWVcclxufSk7XHJcblxyXG52YXIgY29yZV9kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG52YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzX2NvcmUudmFsdWVPckRlZmF1bHQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBmb250IC0gQSBmb250IG9iamVjdC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XHJcblx0aWYgKCFmb250IHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaGVscGVyc19jb3JlLmlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcclxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcclxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcclxuXHRcdCsgZm9udC5mYW1pbHk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxyXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xyXG5cdFx0dmFyIG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xyXG5cdFx0aWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XHJcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XHJcblxyXG5cdFx0c3dpdGNoIChtYXRjaGVzWzNdKSB7XHJcblx0XHRjYXNlICdweCc6XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdGNhc2UgJyUnOlxyXG5cdFx0XHR2YWx1ZSAvPSAxMDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaXplICogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcclxuXHQgKiAgZWxzZSwgaWYgYW5kIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHZhciB0LCByLCBiLCBsO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzX2NvcmUuaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XHJcblx0XHRcdHIgPSArdmFsdWUucmlnaHQgfHwgMDtcclxuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcclxuXHRcdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dG9wOiB0LFxyXG5cdFx0XHRyaWdodDogcixcclxuXHRcdFx0Ym90dG9tOiBiLFxyXG5cdFx0XHRsZWZ0OiBsLFxyXG5cdFx0XHRoZWlnaHQ6IHQgKyBiLFxyXG5cdFx0XHR3aWR0aDogbCArIHJcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXHJcblx0ICogQHJldHVybiB7b2JqZWN0fSBUaGUgZm9udCBvYmplY3QuXHJcblx0ICogQHRvZG8gU3VwcG9ydCBmb250Liogb3B0aW9ucyBhbmQgcmVuYW1lZCB0byB0b0ZvbnQoKS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9wYXJzZUZvbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xyXG5cdFx0dmFyIHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xyXG5cdFx0dmFyIGZvbnQgPSB7XHJcblx0XHRcdGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRcdGxpbmVIZWlnaHQ6IGhlbHBlcnNfY29yZS5vcHRpb25zLnRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRMaW5lSGVpZ2h0KSwgc2l6ZSksXHJcblx0XHRcdHNpemU6IHNpemUsXHJcblx0XHRcdHN0eWxlOiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXHJcblx0XHRcdHdlaWdodDogbnVsbCxcclxuXHRcdFx0c3RyaW5nOiAnJ1xyXG5cdFx0fTtcclxuXHJcblx0XHRmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcclxuXHRcdHJldHVybiBmb250O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcclxuXHQgKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdIC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxyXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtpbmZvXSAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luZm8uY2FjaGVhYmxlXSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xyXG5cdFx0dmFyIGNhY2hlYWJsZSA9IHRydWU7XHJcblx0XHR2YXIgaSwgaWxlbiwgdmFsdWU7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dmFsdWUgPSBpbnB1dHNbaV07XHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xyXG5cdFx0XHRcdGNhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnNfY29yZS5pc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbaW5kZXhdO1xyXG5cdFx0XHRcdGNhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0aWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xyXG5cdFx0XHRcdFx0aW5mby5jYWNoZWFibGUgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG4vKipcclxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgZXhwb3J0cyQyID0ge1xyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZmFjdG9yaXplOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0dmFyIHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xyXG5cdFx0dmFyIGk7XHJcblxyXG5cdFx0Zm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsdWUgJSBpID09PSAwKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaSk7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2godmFsdWUgLyBpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXHJcblx0XHRcdHJlc3VsdC5wdXNoKHNxcnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0cmV0dXJuIGEgLSBiO1xyXG5cdFx0fSkucG9wKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0sXHJcblxyXG5cdGxvZzEwOiBNYXRoLmxvZzEwIHx8IGZ1bmN0aW9uKHgpIHtcclxuXHRcdHZhciBleHBvbmVudCA9IE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7IC8vIE1hdGguTE9HMTBFID0gMSAvIE1hdGguTE4xMC5cclxuXHRcdC8vIENoZWNrIGZvciB3aG9sZSBwb3dlcnMgb2YgMTAsXHJcblx0XHQvLyB3aGljaCBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3Igc2hvdWxkIGJlIGNvcnJlY3RlZC5cclxuXHRcdHZhciBwb3dlck9mMTAgPSBNYXRoLnJvdW5kKGV4cG9uZW50KTtcclxuXHRcdHZhciBpc1Bvd2VyT2YxMCA9IHggPT09IE1hdGgucG93KDEwLCBwb3dlck9mMTApO1xyXG5cclxuXHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX21hdGggPSBleHBvcnRzJDI7XHJcblxyXG4vLyBERVBSRUNBVElPTlNcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMubWF0aC5sb2cxMCBpbnN0ZWFkLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMubG9nMTBcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjkuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzX2NvcmUubG9nMTAgPSBleHBvcnRzJDIubG9nMTA7XG5cbnZhciBnZXRSdGxBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XHJcblx0XHR9LFxyXG5cdFx0c2V0V2lkdGg6IGZ1bmN0aW9uKHcpIHtcclxuXHRcdFx0d2lkdGggPSB3O1xyXG5cdFx0fSxcclxuXHRcdHRleHRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcclxuXHRcdFx0aWYgKGFsaWduID09PSAnY2VudGVyJykge1xyXG5cdFx0XHRcdHJldHVybiBhbGlnbjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xyXG5cdFx0fSxcclxuXHRcdHhQbHVzOiBmdW5jdGlvbih4LCB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4geCAtIHZhbHVlO1xyXG5cdFx0fSxcclxuXHRcdGxlZnRGb3JMdHI6IGZ1bmN0aW9uKHgsIGl0ZW1XaWR0aCkge1xyXG5cdFx0XHRyZXR1cm4geCAtIGl0ZW1XaWR0aDtcclxuXHRcdH0sXHJcblx0fTtcclxufTtcclxuXHJcbnZhciBnZXRMdHJBZGFwdGVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIHg7XHJcblx0XHR9LFxyXG5cdFx0c2V0V2lkdGg6IGZ1bmN0aW9uKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0fSxcclxuXHRcdHRleHRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcclxuXHRcdFx0cmV0dXJuIGFsaWduO1xyXG5cdFx0fSxcclxuXHRcdHhQbHVzOiBmdW5jdGlvbih4LCB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4geCArIHZhbHVlO1xyXG5cdFx0fSxcclxuXHRcdGxlZnRGb3JMdHI6IGZ1bmN0aW9uKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0XHRyZXR1cm4geDtcclxuXHRcdH0sXHJcblx0fTtcclxufTtcclxuXHJcbnZhciBnZXRBZGFwdGVyID0gZnVuY3Rpb24ocnRsLCByZWN0WCwgd2lkdGgpIHtcclxuXHRyZXR1cm4gcnRsID8gZ2V0UnRsQWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0THRyQWRhcHRlcigpO1xyXG59O1xyXG5cclxudmFyIG92ZXJyaWRlVGV4dERpcmVjdGlvbiA9IGZ1bmN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XHJcblx0dmFyIHN0eWxlLCBvcmlnaW5hbDtcclxuXHRpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XHJcblx0XHRzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XHJcblx0XHRvcmlnaW5hbCA9IFtcclxuXHRcdFx0c3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXHJcblx0XHRcdHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxyXG5cdFx0XTtcclxuXHJcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XHJcblx0XHRjdHgucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgcmVzdG9yZVRleHREaXJlY3Rpb24gPSBmdW5jdGlvbihjdHgpIHtcclxuXHR2YXIgb3JpZ2luYWwgPSBjdHgucHJldlRleHREaXJlY3Rpb247XHJcblx0aWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XHJcblx0XHRjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX3J0bCA9IHtcclxuXHRnZXRSdGxBZGFwdGVyOiBnZXRBZGFwdGVyLFxyXG5cdG92ZXJyaWRlVGV4dERpcmVjdGlvbjogb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLFxyXG5cdHJlc3RvcmVUZXh0RGlyZWN0aW9uOiByZXN0b3JlVGV4dERpcmVjdGlvbixcclxufTtcblxudmFyIGhlbHBlcnMkMSA9IGhlbHBlcnNfY29yZTtcclxudmFyIGVhc2luZyA9IGhlbHBlcnNfZWFzaW5nO1xyXG52YXIgY2FudmFzID0gaGVscGVyc19jYW52YXM7XHJcbnZhciBvcHRpb25zID0gaGVscGVyc19vcHRpb25zO1xyXG52YXIgbWF0aCA9IGhlbHBlcnNfbWF0aDtcclxudmFyIHJ0bCA9IGhlbHBlcnNfcnRsO1xuaGVscGVycyQxLmVhc2luZyA9IGVhc2luZztcbmhlbHBlcnMkMS5jYW52YXMgPSBjYW52YXM7XG5oZWxwZXJzJDEub3B0aW9ucyA9IG9wdGlvbnM7XG5oZWxwZXJzJDEubWF0aCA9IG1hdGg7XG5oZWxwZXJzJDEucnRsID0gcnRsO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcclxuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcclxuXHR2YXIgaSwgaWxlbiwga2V5LCBhY3R1YWwsIG9yaWdpbiwgdGFyZ2V0LCB0eXBlLCBjMCwgYzE7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0a2V5ID0ga2V5c1tpXTtcclxuXHJcblx0XHR0YXJnZXQgPSBtb2RlbFtrZXldO1xyXG5cclxuXHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xyXG5cdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXHJcblx0XHRpZiAoIXZpZXcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0YWN0dWFsID0gdmlld1trZXldO1xyXG5cclxuXHRcdGlmIChhY3R1YWwgPT09IHRhcmdldCB8fCBrZXlbMF0gPT09ICdfJykge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcclxuXHRcdH1cclxuXHJcblx0XHRvcmlnaW4gPSBzdGFydFtrZXldO1xyXG5cclxuXHRcdHR5cGUgPSB0eXBlb2YgdGFyZ2V0O1xyXG5cclxuXHRcdGlmICh0eXBlID09PSB0eXBlb2Ygb3JpZ2luKSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGMwID0gY2hhcnRqc0NvbG9yKG9yaWdpbik7XHJcblx0XHRcdFx0aWYgKGMwLnZhbGlkKSB7XHJcblx0XHRcdFx0XHRjMSA9IGNoYXJ0anNDb2xvcih0YXJnZXQpO1xyXG5cdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XHJcblx0XHRcdFx0XHRcdHZpZXdba2V5XSA9IGMxLm1peChjMCwgZWFzZSkucmdiU3RyaW5nKCk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNGaW5pdGUob3JpZ2luKSAmJiBoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xyXG5cdFx0XHRcdHZpZXdba2V5XSA9IG9yaWdpbiArICh0YXJnZXQgLSBvcmlnaW4pICogZWFzZTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xyXG5cdGhlbHBlcnMkMS5leHRlbmQodGhpcywgY29uZmlndXJhdGlvbik7XHJcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5oZWxwZXJzJDEuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XHJcblx0X3R5cGU6IHVuZGVmaW5lZCxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdHBpdm90OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRpZiAoIW1lLl92aWV3KSB7XHJcblx0XHRcdG1lLl92aWV3ID0gaGVscGVycyQxLmV4dGVuZCh7fSwgbWUuX21vZGVsKTtcclxuXHRcdH1cclxuXHRcdG1lLl9zdGFydCA9IHt9O1xyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2UpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWw7XHJcblx0XHR2YXIgc3RhcnQgPSBtZS5fc3RhcnQ7XHJcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xyXG5cclxuXHRcdC8vIE5vIGFuaW1hdGlvbiAtPiBObyBUcmFuc2l0aW9uXHJcblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcclxuXHRcdFx0bWUuX3ZpZXcgPSBoZWxwZXJzJDEuZXh0ZW5kKHt9LCBtb2RlbCk7XHJcblx0XHRcdG1lLl9zdGFydCA9IG51bGw7XHJcblx0XHRcdHJldHVybiBtZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXZpZXcpIHtcclxuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdGFydCkge1xyXG5cdFx0XHRzdGFydCA9IG1lLl9zdGFydCA9IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSk7XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB0aGlzLl9tb2RlbC54LFxyXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGhhc1ZhbHVlOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueCkgJiYgaGVscGVycyQxLmlzTnVtYmVyKHRoaXMuX21vZGVsLnkpO1xyXG5cdH1cclxufSk7XHJcblxyXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcclxuXHJcbnZhciBjb3JlX2VsZW1lbnQgPSBFbGVtZW50O1xuXG52YXIgZXhwb3J0cyQzID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxyXG5cdGN1cnJlbnRTdGVwOiAwLCAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RlcFxyXG5cdG51bVN0ZXBzOiA2MCwgLy8gZGVmYXVsdCBudW1iZXIgb2Ygc3RlcHNcclxuXHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cclxuXHRyZW5kZXI6IG51bGwsIC8vIHJlbmRlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhbmltYXRpb24gc2VydmljZVxyXG5cclxuXHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXHJcblx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcclxufSk7XHJcblxyXG52YXIgY29yZV9hbmltYXRpb24gPSBleHBvcnRzJDM7XHJcblxyXG4vLyBERVBSRUNBVElPTlNcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXHJcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNhbmltYXRpb25PYmplY3RcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQzLnByb3RvdHlwZSwgJ2FuaW1hdGlvbk9iamVjdCcsIHtcclxuXHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiNjaGFydCBpbnN0ZWFkXHJcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNjaGFydEluc3RhbmNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMkMy5wcm90b3R5cGUsICdjaGFydEluc3RhbmNlJywge1xyXG5cdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydDtcclxuXHR9LFxyXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHRoaXMuY2hhcnQgPSB2YWx1ZTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRhbmltYXRpb246IHtcclxuXHRcdGR1cmF0aW9uOiAxMDAwLFxyXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcclxuXHRcdG9uUHJvZ3Jlc3M6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0b25Db21wbGV0ZTogaGVscGVycyQxLm5vb3BcclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvcmVfYW5pbWF0aW9ucyA9IHtcclxuXHRhbmltYXRpb25zOiBbXSxcclxuXHRyZXF1ZXN0OiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCB0byBhbmltYXRlLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBsYXp5IC0gaWYgdHJ1ZSwgdGhlIGNoYXJ0IGlzIG5vdCBtYXJrZWQgYXMgYW5pbWF0aW5nIHRvIGVuYWJsZSBtb3JlIHJlc3BvbnNpdmUgaW50ZXJhY3Rpb25zXHJcblx0ICovXHJcblx0YWRkQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSkge1xyXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRhbmltYXRpb24uY2hhcnQgPSBjaGFydDtcclxuXHRcdGFuaW1hdGlvbi5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblxyXG5cdFx0aWYgKCFsYXp5KSB7XHJcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmIChhbmltYXRpb25zW2ldLmNoYXJ0ID09PSBjaGFydCkge1xyXG5cdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgcXVldWVkLCBtYW51YWxseSBraWNrc3RhcnQgYSBkaWdlc3QsIGZvciBsYWNrIG9mIGEgYmV0dGVyIHdvcmRcclxuXHRcdGlmIChhbmltYXRpb25zLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBpbmRleCA9IGhlbHBlcnMkMS5maW5kSW5kZXgodGhpcy5hbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGlmIChtZS5yZXF1ZXN0ID09PSBudWxsKSB7XHJcblx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxyXG5cdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xyXG5cdFx0XHQvLyBhbmQgJ21vdXNlb3V0JyBldmVudHMgd2lsbCB0cmlnZ2VyIG11bHRpcGxlIHJlbmRlcnMuXHJcblx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bWUucmVxdWVzdCA9IG51bGw7XHJcblx0XHRcdFx0bWUuc3RhcnREaWdlc3QoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzdGFydERpZ2VzdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdG1lLmFkdmFuY2UoKTtcclxuXHJcblx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cclxuXHRcdGlmIChtZS5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0bWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRhZHZhbmNlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xyXG5cdFx0dmFyIGFuaW1hdGlvbiwgY2hhcnQsIG51bVN0ZXBzLCBuZXh0U3RlcDtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHQvLyAxIGFuaW1hdGlvbiBwZXIgY2hhcnQsIHNvIHdlIGFyZSBsb29waW5nIGNoYXJ0cyBoZXJlXHJcblx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XHJcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XHJcblx0XHRcdGNoYXJ0ID0gYW5pbWF0aW9uLmNoYXJ0O1xyXG5cdFx0XHRudW1TdGVwcyA9IGFuaW1hdGlvbi5udW1TdGVwcztcclxuXHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGN1cnJlbnRTdGVwIHN0YXJ0cyBhdCAxXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MTA0XHJcblx0XHRcdG5leHRTdGVwID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGFuaW1hdGlvbi5zdGFydFRpbWUpIC8gYW5pbWF0aW9uLmR1cmF0aW9uICogbnVtU3RlcHMpICsgMTtcclxuXHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRTdGVwID0gTWF0aC5taW4obmV4dFN0ZXAsIG51bVN0ZXBzKTtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ucmVuZGVyLCBbY2hhcnQsIGFuaW1hdGlvbl0sIGNoYXJ0KTtcclxuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvblByb2dyZXNzLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xyXG5cclxuXHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBudW1TdGVwcykge1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcclxuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRhbmltYXRpb25zLnNwbGljZShpLCAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQrK2k7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XG5cbnZhciByZXNvbHZlID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcclxuXHJcbnZhciBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcclxuXHJcbi8qKlxyXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxyXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXHJcbiAqIGNhbGxlZCBvbiB0aGUgJ29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBvbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XHJcblx0aWYgKGFycmF5Ll9jaGFydGpzKSB7XHJcblx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcclxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxyXG5cdFx0dmFsdWU6IHtcclxuXHRcdFx0bGlzdGVuZXJzOiBbbGlzdGVuZXJdXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHR2YXIgbWV0aG9kID0gJ29uRGF0YScgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7XHJcblx0XHR2YXIgYmFzZSA9IGFycmF5W2tleV07XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcclxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHJcblx0XHRcdFx0aGVscGVycyQxLmVhY2goYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLCBmdW5jdGlvbihvYmplY3QpIHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0b2JqZWN0W21ldGhvZF0uYXBwbHkob2JqZWN0LCBhcmdzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXHJcbiAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xyXG5cdHZhciBzdHViID0gYXJyYXkuX2NoYXJ0anM7XHJcblx0aWYgKCFzdHViKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHR2YXIgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XHJcblx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG5cdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdH1cclxuXHJcblx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0ZGVsZXRlIGFycmF5W2tleV07XHJcblx0fSk7XHJcblxyXG5cdGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcclxufVxyXG5cclxuLy8gQmFzZSBjbGFzcyBmb3IgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgKGxpbmUsIGJhciwgZXRjKVxyXG52YXIgRGF0YXNldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XHJcblx0dGhpcy5pbml0aWFsaXplKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xyXG59O1xyXG5cclxuaGVscGVycyQxLmV4dGVuZChEYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcclxuXHJcblx0LyoqXHJcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lKS5cclxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxyXG5cdCAqL1xyXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXHJcblx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cclxuXHQgKi9cclxuXHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIERhdGFzZXQgZWxlbWVudCBvcHRpb24ga2V5cyB0byBiZSByZXNvbHZlZCBpbiBfcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucy5cclxuXHQgKiBBIGRlcml2ZWQgY29udHJvbGxlciBtYXkgb3ZlcnJpZGUgdGhpcyB0byByZXNvbHZlIGNvbnRyb2xsZXItc3BlY2lmaWMgb3B0aW9ucy5cclxuXHQgKiBUaGUga2V5cyBkZWZpbmVkIGhlcmUgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBsZWdlbmQgc3R5bGVzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFzZXRFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ2FwU3R5bGUnLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJEYXNoJyxcclxuXHRcdCdib3JkZXJEYXNoT2Zmc2V0JyxcclxuXHRcdCdib3JkZXJKb2luU3R5bGUnLFxyXG5cdFx0J2JvcmRlcldpZHRoJ1xyXG5cdF0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERhdGEgZWxlbWVudCBvcHRpb24ga2V5cyB0byBiZSByZXNvbHZlZCBpbiBfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucy5cclxuXHQgKiBBIGRlcml2ZWQgY29udHJvbGxlciBtYXkgb3ZlcnJpZGUgdGhpcyB0byByZXNvbHZlIGNvbnRyb2xsZXItc3BlY2lmaWMgb3B0aW9ucy5cclxuXHQgKiBUaGUga2V5cyBkZWZpbmVkIGhlcmUgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBsZWdlbmQgc3R5bGVzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlcldpZHRoJyxcclxuXHRcdCdwb2ludFN0eWxlJ1xyXG5cdF0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRtZS5jaGFydCA9IGNoYXJ0O1xyXG5cdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XHJcblx0XHRtZS5saW5rU2NhbGVzKCk7XHJcblx0XHRtZS5hZGRFbGVtZW50cygpO1xyXG5cdFx0bWUuX3R5cGUgPSBtZS5nZXRNZXRhKCkudHlwZTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XHJcblx0XHR0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xyXG5cdH0sXHJcblxyXG5cdGxpbmtTY2FsZXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgc2NhbGVzT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuc2NhbGVzO1xyXG5cclxuXHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnhBeGlzSUQgaW4gc2NhbGVzKSB8fCBkYXRhc2V0LnhBeGlzSUQpIHtcclxuXHRcdFx0bWV0YS54QXhpc0lEID0gZGF0YXNldC54QXhpc0lEIHx8IHNjYWxlc09wdHMueEF4ZXNbMF0uaWQ7XHJcblx0XHR9XHJcblx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS55QXhpc0lEIGluIHNjYWxlcykgfHwgZGF0YXNldC55QXhpc0lEKSB7XHJcblx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBzY2FsZXNPcHRzLnlBeGVzWzBdLmlkO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldERhdGFzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcclxuXHR9LFxyXG5cclxuXHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNjYWxlRm9ySWQ6IGZ1bmN0aW9uKHNjYWxlSUQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFZhbHVlU2NhbGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLl9nZXRWYWx1ZVNjYWxlSWQoKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldEluZGV4U2NhbGVJZCgpKTtcclxuXHR9LFxyXG5cclxuXHRyZXNldDogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl91cGRhdGUodHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuXHRcdGlmICh0aGlzLl9kYXRhKSB7XHJcblx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0eXBlID0gbWUuZGF0YXNldEVsZW1lbnRUeXBlO1xyXG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xyXG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxyXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhRWxlbWVudFR5cGU7XHJcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XHJcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXHJcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxyXG5cdFx0XHRfaW5kZXg6IGluZGV4XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRhZGRFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIG1ldGFEYXRhID0gbWV0YS5kYXRhO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XHJcblx0fSxcclxuXHJcblx0YWRkRWxlbWVudEFuZFJlc2V0OiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZU1ldGFEYXRhKGluZGV4KTtcclxuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcclxuXHRcdHRoaXMudXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XHJcblxyXG5cdFx0Ly8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW4gdGh1cyBzaW11bGF0ZVxyXG5cdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXHJcblx0XHQvLyB0aGUgaW50ZXJuYWwgbWV0YSBkYXRhIGFjY29yZGluZ2x5LlxyXG5cdFx0aWYgKG1lLl9kYXRhICE9PSBkYXRhKSB7XHJcblx0XHRcdGlmIChtZS5fZGF0YSkge1xyXG5cdFx0XHRcdC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXHJcblx0XHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyhtZS5fZGF0YSwgbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XHJcblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1lLl9kYXRhID0gZGF0YTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxyXG5cdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cclxuXHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbWVyZ2VkIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRtZS5fY29uZmlnID0gaGVscGVycyQxLm1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcclxuXHRcdFx0bWUuY2hhcnQub3B0aW9ucy5kYXRhc2V0c1ttZS5fdHlwZV0sXHJcblx0XHRcdG1lLmdldERhdGFzZXQoKSxcclxuXHRcdF0sIHtcclxuXHRcdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XHJcblx0XHRcdFx0aWYgKGtleSAhPT0gJ19tZXRhJyAmJiBrZXkgIT09ICdkYXRhJykge1xyXG5cdFx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdG1lLl9jb25maWd1cmUoKTtcclxuXHRcdG1lLl9jYWNoZWREYXRhT3B0cyA9IG51bGw7XHJcblx0XHRtZS51cGRhdGUocmVzZXQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xyXG5cdFx0XHRtZXRhLmRhdGFzZXQudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xyXG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxyXG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBkYXRhIGluZGV4XHJcblx0ICogQHJldHVybiB7SVN0eWxlSW50ZXJmYWNlfSBzdHlsZSBvYmplY3RcclxuXHQgKi9cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xyXG5cdFx0dmFyIHN0eWxlO1xyXG5cclxuXHRcdG1lLl9jb25maWd1cmUoKTtcclxuXHRcdGlmIChkYXRhc2V0ICYmIGluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c3R5bGUgPSBtZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhkYXRhc2V0IHx8IHt9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGluZGV4ID0gaW5kZXggfHwgMDtcclxuXHRcdFx0c3R5bGUgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhtZXRhLmRhdGFbaW5kZXhdIHx8IHt9LCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0eWxlLmZpbGwgPT09IGZhbHNlIHx8IHN0eWxlLmZpbGwgPT09IG51bGwpIHtcclxuXHRcdFx0c3R5bGUuYmFja2dyb3VuZENvbG9yID0gc3R5bGUuYm9yZGVyQ29sb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0eWxlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQsIGhvdmVyKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldE9wdHMgPSBtZS5fY29uZmlnO1xyXG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzW21lLmRhdGFzZXRFbGVtZW50VHlwZS5wcm90b3R5cGUuX3R5cGVdIHx8IHt9O1xyXG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gbWUuX2RhdGFzZXRFbGVtZW50T3B0aW9ucztcclxuXHRcdHZhciB2YWx1ZXMgPSB7fTtcclxuXHRcdHZhciBpLCBpbGVuLCBrZXksIHJlYWRLZXk7XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0XHRkYXRhc2V0OiBtZS5nZXREYXRhc2V0KCksXHJcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdGhvdmVyOiBob3ZlclxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudE9wdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGtleSA9IGVsZW1lbnRPcHRpb25zW2ldO1xyXG5cdFx0XHRyZWFkS2V5ID0gaG92ZXIgPyAnaG92ZXInICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpIDoga2V5O1xyXG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUoW1xyXG5cdFx0XHRcdGN1c3RvbVtyZWFkS2V5XSxcclxuXHRcdFx0XHRkYXRhc2V0T3B0c1tyZWFkS2V5XSxcclxuXHRcdFx0XHRvcHRpb25zW3JlYWRLZXldXHJcblx0XHRcdF0sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudCAmJiBlbGVtZW50LmN1c3RvbTtcclxuXHRcdHZhciBjYWNoZWQgPSBtZS5fY2FjaGVkRGF0YU9wdHM7XHJcblx0XHRpZiAoY2FjaGVkICYmICFjdXN0b20pIHtcclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHRcdH1cclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXRPcHRzID0gbWUuX2NvbmZpZztcclxuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50c1ttZS5kYXRhRWxlbWVudFR5cGUucHJvdG90eXBlLl90eXBlXSB8fCB7fTtcclxuXHRcdHZhciBlbGVtZW50T3B0aW9ucyA9IG1lLl9kYXRhRWxlbWVudE9wdGlvbnM7XHJcblx0XHR2YXIgdmFsdWVzID0ge307XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRkYXRhc2V0OiBtZS5nZXREYXRhc2V0KCksXHJcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gYHJlc29sdmVgIHNldHMgY2FjaGVhYmxlIHRvIGBmYWxzZWAgaWYgYW55IG9wdGlvbiBpcyBpbmRleGVkIG9yIHNjcmlwdGVkXHJcblx0XHR2YXIgaW5mbyA9IHtjYWNoZWFibGU6ICFjdXN0b219O1xyXG5cclxuXHRcdHZhciBrZXlzLCBpLCBpbGVuLCBrZXk7XHJcblxyXG5cdFx0Y3VzdG9tID0gY3VzdG9tIHx8IHt9O1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShlbGVtZW50T3B0aW9ucykpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRPcHRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGtleSA9IGVsZW1lbnRPcHRpb25zW2ldO1xyXG5cdFx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZShbXHJcblx0XHRcdFx0XHRjdXN0b21ba2V5XSxcclxuXHRcdFx0XHRcdGRhdGFzZXRPcHRzW2tleV0sXHJcblx0XHRcdFx0XHRvcHRpb25zW2tleV1cclxuXHRcdFx0XHRdLCBjb250ZXh0LCBpbmRleCwgaW5mbyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50T3B0aW9ucyk7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGtleSA9IGtleXNbaV07XHJcblx0XHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlKFtcclxuXHRcdFx0XHRcdGN1c3RvbVtrZXldLFxyXG5cdFx0XHRcdFx0ZGF0YXNldE9wdHNbZWxlbWVudE9wdGlvbnNba2V5XV0sXHJcblx0XHRcdFx0XHRkYXRhc2V0T3B0c1trZXldLFxyXG5cdFx0XHRcdFx0b3B0aW9uc1trZXldXHJcblx0XHRcdFx0XSwgY29udGV4dCwgaW5kZXgsIGluZm8pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGluZm8uY2FjaGVhYmxlKSB7XHJcblx0XHRcdG1lLl9jYWNoZWREYXRhT3B0cyA9IE9iamVjdC5mcmVlemUodmFsdWVzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdGhlbHBlcnMkMS5tZXJnZShlbGVtZW50Ll9tb2RlbCwgZWxlbWVudC4kcHJldmlvdXNTdHlsZSB8fCB7fSk7XHJcblx0XHRkZWxldGUgZWxlbWVudC4kcHJldmlvdXNTdHlsZTtcclxuXHR9LFxyXG5cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xyXG5cdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgbW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblxyXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoXHJcblx0XHR9O1xyXG5cclxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciwgZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlckNvbG9yLCBkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XHJcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlcldpZHRoLCBkYXRhc2V0LmhvdmVyQm9yZGVyV2lkdGgsIG1vZGVsLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpbmRleCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldE1ldGEoKS5kYXRhc2V0O1xyXG5cclxuXHRcdGlmIChlbGVtZW50KSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXREYXRhc2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0TWV0YSgpLmRhdGFzZXQ7XHJcblx0XHR2YXIgcHJldiA9IHt9O1xyXG5cdFx0dmFyIGksIGlsZW4sIGtleSwga2V5cywgaG92ZXJPcHRpb25zLCBtb2RlbDtcclxuXHJcblx0XHRpZiAoIWVsZW1lbnQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XHJcblx0XHRob3Zlck9wdGlvbnMgPSB0aGlzLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGVsZW1lbnQsIHRydWUpO1xyXG5cclxuXHRcdGtleXMgPSBPYmplY3Qua2V5cyhob3Zlck9wdGlvbnMpO1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGtleSA9IGtleXNbaV07XHJcblx0XHRcdHByZXZba2V5XSA9IG1vZGVsW2tleV07XHJcblx0XHRcdG1vZGVsW2tleV0gPSBob3Zlck9wdGlvbnNba2V5XTtcclxuXHRcdH1cclxuXHJcblx0XHRlbGVtZW50LiRwcmV2aW91c1N0eWxlID0gcHJldjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XHJcblx0XHR2YXIgbnVtTWV0YSA9IG1ldGEuZGF0YS5sZW5ndGg7XHJcblx0XHR2YXIgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xyXG5cclxuXHRcdGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xyXG5cdFx0XHRtZXRhLmRhdGEuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcclxuXHRcdH0gZWxzZSBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcclxuXHRcdFx0bWUuaW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5zZXJ0RWxlbWVudHM6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcblx0XHRcdHRoaXMuYWRkRWxlbWVudEFuZFJlc2V0KHN0YXJ0ICsgaSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvbkRhdGFQdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uRGF0YVBvcDogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnBvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25EYXRhU2hpZnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcclxuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XHJcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvbkRhdGFVbnNoaWZ0OiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcblx0fVxyXG59KTtcclxuXHJcbkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcclxuXHJcbnZhciBjb3JlX2RhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5cbnZhciBUQVUgPSBNYXRoLlBJICogMjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRhcmM6IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiAnI2ZmZicsXHJcblx0XHRcdGJvcmRlcldpZHRoOiAyLFxyXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGFyYykge1xyXG5cdHZhciBzdGFydEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGU7XHJcblx0dmFyIGVuZEFuZ2xlID0gYXJjLmVuZEFuZ2xlO1xyXG5cdHZhciBwaXhlbE1hcmdpbiA9IGFyYy5waXhlbE1hcmdpbjtcclxuXHR2YXIgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGFyYy5vdXRlclJhZGl1cztcclxuXHR2YXIgeCA9IGFyYy54O1xyXG5cdHZhciB5ID0gYXJjLnk7XHJcblxyXG5cdC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcclxuXHQvLyBFbmxhcmdlIHRoZSBjbGlwcGluZyBhcmMgYnkgMC4zMyBwaXhlbHMgdG8gZWxpbWluYXRlIGdsaXRjaGVzIGJldHdlZW4gYm9yZGVyc1xyXG5cdGN0eC5iZWdpblBhdGgoKTtcclxuXHRjdHguYXJjKHgsIHksIGFyYy5vdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcclxuXHRpZiAoYXJjLmlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcclxuXHRcdGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBhcmMuaW5uZXJSYWRpdXM7XHJcblx0XHRjdHguYXJjKHgsIHksIGFyYy5pbm5lclJhZGl1cyAtIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIE1hdGguUEkgLyAyLCBzdGFydEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xyXG5cdH1cclxuXHRjdHguY2xvc2VQYXRoKCk7XHJcblx0Y3R4LmNsaXAoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgdm0sIGFyYywgaW5uZXIpIHtcclxuXHR2YXIgZW5kQW5nbGUgPSBhcmMuZW5kQW5nbGU7XHJcblx0dmFyIGk7XHJcblxyXG5cdGlmIChpbm5lcikge1xyXG5cdFx0YXJjLmVuZEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUgKyBUQVU7XHJcblx0XHRjbGlwQXJjKGN0eCwgYXJjKTtcclxuXHRcdGFyYy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xyXG5cdFx0aWYgKGFyYy5lbmRBbmdsZSA9PT0gYXJjLnN0YXJ0QW5nbGUgJiYgYXJjLmZ1bGxDaXJjbGVzKSB7XHJcblx0XHRcdGFyYy5lbmRBbmdsZSArPSBUQVU7XHJcblx0XHRcdGFyYy5mdWxsQ2lyY2xlcy0tO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMuaW5uZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlICsgVEFVLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XHJcblx0Zm9yIChpID0gMDsgaSA8IGFyYy5mdWxsQ2lyY2xlczsgKytpKSB7XHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0fVxyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIHZtLm91dGVyUmFkaXVzLCBhcmMuc3RhcnRBbmdsZSwgYXJjLnN0YXJ0QW5nbGUgKyBUQVUpO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBhcmMuZnVsbENpcmNsZXM7ICsraSkge1xyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIHZtLCBhcmMpIHtcclxuXHR2YXIgaW5uZXIgPSB2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcclxuXHJcblx0aWYgKGlubmVyKSB7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGggKiAyO1xyXG5cdFx0Y3R4LmxpbmVKb2luID0gJ3JvdW5kJztcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xyXG5cdFx0Y3R4LmxpbmVKb2luID0gJ2JldmVsJztcclxuXHR9XHJcblxyXG5cdGlmIChhcmMuZnVsbENpcmNsZXMpIHtcclxuXHRcdGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIHZtLCBhcmMsIGlubmVyKTtcclxuXHR9XHJcblxyXG5cdGlmIChpbm5lcikge1xyXG5cdFx0Y2xpcEFyYyhjdHgsIGFyYyk7XHJcblx0fVxyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIHZtLm91dGVyUmFkaXVzLCBhcmMuc3RhcnRBbmdsZSwgYXJjLmVuZEFuZ2xlKTtcclxuXHRjdHguYXJjKGFyYy54LCBhcmMueSwgYXJjLmlubmVyUmFkaXVzLCBhcmMuZW5kQW5nbGUsIGFyYy5zdGFydEFuZ2xlLCB0cnVlKTtcclxuXHRjdHguY2xvc2VQYXRoKCk7XHJcblx0Y3R4LnN0cm9rZSgpO1xyXG59XHJcblxyXG52YXIgZWxlbWVudF9hcmMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHRfdHlwZTogJ2FyYycsXHJcblxyXG5cdGluTGFiZWxSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cclxuXHRcdGlmICh2bSkge1xyXG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRpblJhbmdlOiBmdW5jdGlvbihjaGFydFgsIGNoYXJ0WSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHJcblx0XHRpZiAodm0pIHtcclxuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XHJcblx0XHRcdHZhciBhbmdsZSA9IHBvaW50UmVsYXRpdmVQb3NpdGlvbi5hbmdsZTtcclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xyXG5cclxuXHRcdFx0Ly8gU2FuaXRpc2UgYW5nbGUgcmFuZ2VcclxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xyXG5cdFx0XHR2YXIgZW5kQW5nbGUgPSB2bS5lbmRBbmdsZTtcclxuXHRcdFx0d2hpbGUgKGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xyXG5cdFx0XHRcdGVuZEFuZ2xlICs9IFRBVTtcclxuXHRcdFx0fVxyXG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xyXG5cdFx0XHRcdGFuZ2xlIC09IFRBVTtcclxuXHRcdFx0fVxyXG5cdFx0XHR3aGlsZSAoYW5nbGUgPCBzdGFydEFuZ2xlKSB7XHJcblx0XHRcdFx0YW5nbGUgKz0gVEFVO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXHJcblx0XHRcdHZhciBiZXR3ZWVuQW5nbGVzID0gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpO1xyXG5cdFx0XHR2YXIgd2l0aGluUmFkaXVzID0gKGRpc3RhbmNlID49IHZtLmlubmVyUmFkaXVzICYmIGRpc3RhbmNlIDw9IHZtLm91dGVyUmFkaXVzKTtcclxuXHJcblx0XHRcdHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gKHZtLnN0YXJ0QW5nbGUgKyB2bS5lbmRBbmdsZSkgLyAyO1xyXG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogdm0ueCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxyXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIGNlbnRyZUFuZ2xlID0gdm0uc3RhcnRBbmdsZSArICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvIDIpO1xyXG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXHJcblx0XHRcdHk6IHZtLnkgKyAoTWF0aC5zaW4oY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIHBpeGVsTWFyZ2luID0gKHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xyXG5cdFx0dmFyIGFyYyA9IHtcclxuXHRcdFx0eDogdm0ueCxcclxuXHRcdFx0eTogdm0ueSxcclxuXHRcdFx0aW5uZXJSYWRpdXM6IHZtLmlubmVyUmFkaXVzLFxyXG5cdFx0XHRvdXRlclJhZGl1czogTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksXHJcblx0XHRcdHBpeGVsTWFyZ2luOiBwaXhlbE1hcmdpbixcclxuXHRcdFx0c3RhcnRBbmdsZTogdm0uc3RhcnRBbmdsZSxcclxuXHRcdFx0ZW5kQW5nbGU6IHZtLmVuZEFuZ2xlLFxyXG5cdFx0XHRmdWxsQ2lyY2xlczogTWF0aC5mbG9vcih2bS5jaXJjdW1mZXJlbmNlIC8gVEFVKVxyXG5cdFx0fTtcclxuXHRcdHZhciBpO1xyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblxyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcclxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xyXG5cclxuXHRcdGlmIChhcmMuZnVsbENpcmNsZXMpIHtcclxuXHRcdFx0YXJjLmVuZEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUgKyBUQVU7XHJcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5vdXRlclJhZGl1cywgYXJjLnN0YXJ0QW5nbGUsIGFyYy5lbmRBbmdsZSk7XHJcblx0XHRcdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMuaW5uZXJSYWRpdXMsIGFyYy5lbmRBbmdsZSwgYXJjLnN0YXJ0QW5nbGUsIHRydWUpO1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhcmMuZnVsbENpcmNsZXM7ICsraSkge1xyXG5cdFx0XHRcdGN0eC5maWxsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YXJjLmVuZEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUgKyB2bS5jaXJjdW1mZXJlbmNlICUgVEFVO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMub3V0ZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlLCBhcmMuZW5kQW5nbGUpO1xyXG5cdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5pbm5lclJhZGl1cywgYXJjLmVuZEFuZ2xlLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XHJcblx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRjdHguZmlsbCgpO1xyXG5cclxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xyXG5cdFx0XHRkcmF3Qm9yZGVyKGN0eCwgdm0sIGFyYyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbnZhciBkZWZhdWx0Q29sb3IgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRlbGVtZW50czoge1xyXG5cdFx0bGluZToge1xyXG5cdFx0XHR0ZW5zaW9uOiAwLjQsXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogMyxcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcclxuXHRcdFx0Ym9yZGVyRGFzaDogW10sXHJcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcclxuXHRcdFx0Ym9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxyXG5cdFx0XHRjYXBCZXppZXJQb2ludHM6IHRydWUsXHJcblx0XHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgZWxlbWVudF9saW5lID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0X3R5cGU6ICdsaW5lJyxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHZtID0gbWUuX3ZpZXc7XHJcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcclxuXHRcdHZhciBzcGFuR2FwcyA9IHZtLnNwYW5HYXBzO1xyXG5cdFx0dmFyIHBvaW50cyA9IG1lLl9jaGlsZHJlbi5zbGljZSgpOyAvLyBjbG9uZSBhcnJheVxyXG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblx0XHR2YXIgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcclxuXHRcdHZhciBsYXN0RHJhd25JbmRleCA9IC0xO1xyXG5cdFx0dmFyIGNsb3NlUGF0aCA9IG1lLl9sb29wO1xyXG5cdFx0dmFyIGluZGV4LCBwcmV2aW91cywgY3VycmVudFZNO1xyXG5cclxuXHRcdGlmICghcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1lLl9sb29wKSB7XHJcblx0XHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcclxuXHRcdFx0XHRwcmV2aW91cyA9IGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpbmRleCk7XHJcblx0XHRcdFx0Ly8gSWYgdGhlIGxpbmUgaGFzIGFuIG9wZW4gcGF0aCwgc2hpZnQgdGhlIHBvaW50IGFycmF5XHJcblx0XHRcdFx0aWYgKCFwb2ludHNbaW5kZXhdLl92aWV3LnNraXAgJiYgcHJldmlvdXMuX3ZpZXcuc2tpcCkge1xyXG5cdFx0XHRcdFx0cG9pbnRzID0gcG9pbnRzLnNsaWNlKGluZGV4KS5jb25jYXQocG9pbnRzLnNsaWNlKDAsIGluZGV4KSk7XHJcblx0XHRcdFx0XHRjbG9zZVBhdGggPSBzcGFuR2FwcztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBJZiB0aGUgbGluZSBoYXMgYSBjbG9zZSBwYXRoLCBhZGQgdGhlIGZpcnN0IHBvaW50IGFnYWluXHJcblx0XHRcdGlmIChjbG9zZVBhdGgpIHtcclxuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludHNbMF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHJcblx0XHQvLyBTdHJva2UgTGluZSBPcHRpb25zXHJcblx0XHRjdHgubGluZUNhcCA9IHZtLmJvcmRlckNhcFN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJDYXBTdHlsZTtcclxuXHJcblx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcclxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcclxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQpO1xyXG5cdFx0Y3R4LmxpbmVKb2luID0gdm0uYm9yZGVySm9pblN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJKb2luU3R5bGU7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJXaWR0aCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlcldpZHRoKTtcclxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcclxuXHJcblx0XHQvLyBTdHJva2UgTGluZVxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcclxuXHRcdGN1cnJlbnRWTSA9IHBvaW50c1swXS5fdmlldztcclxuXHRcdGlmICghY3VycmVudFZNLnNraXApIHtcclxuXHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xyXG5cdFx0XHRsYXN0RHJhd25JbmRleCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpbmRleCA9IDE7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xyXG5cdFx0XHRjdXJyZW50Vk0gPSBwb2ludHNbaW5kZXhdLl92aWV3O1xyXG5cdFx0XHRwcmV2aW91cyA9IGxhc3REcmF3bkluZGV4ID09PSAtMSA/IGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpbmRleCkgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xyXG5cclxuXHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xyXG5cdFx0XHRcdGlmICgobGFzdERyYXduSW5kZXggIT09IChpbmRleCAtIDEpICYmICFzcGFuR2FwcykgfHwgbGFzdERyYXduSW5kZXggPT09IC0xKSB7XHJcblx0XHRcdFx0XHQvLyBUaGVyZSB3YXMgYSBnYXAgYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IGFmdGVyIHRoZSBnYXBcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gTGluZSB0byBuZXh0IHBvaW50XHJcblx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIHByZXZpb3VzLl92aWV3LCBjdXJyZW50Vk0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsYXN0RHJhd25JbmRleCA9IGluZGV4O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNsb3NlUGF0aCkge1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbnZhciBkZWZhdWx0Q29sb3IkMSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRwb2ludDoge1xyXG5cdFx0XHRyYWRpdXM6IDMsXHJcblx0XHRcdHBvaW50U3R5bGU6ICdjaXJjbGUnLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQxLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDEsXHJcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxyXG5cdFx0XHQvLyBIb3ZlclxyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXHJcblx0XHRcdGhvdmVyUmFkaXVzOiA0LFxyXG5cdFx0XHRob3ZlckJvcmRlcldpZHRoOiAxXHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHhSYW5nZShtb3VzZVgpIHtcclxuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVggLSB2bS54KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xyXG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWSAtIHZtLnkpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xyXG59XHJcblxyXG52YXIgZWxlbWVudF9wb2ludCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cdF90eXBlOiAncG9pbnQnLFxyXG5cclxuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB2bSA/ICgoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSkgPCBNYXRoLnBvdyh2bS5oaXRSYWRpdXMgKyB2bS5yYWRpdXMsIDIpKSA6IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGluTGFiZWxSYW5nZTogeFJhbmdlLFxyXG5cdGluWFJhbmdlOiB4UmFuZ2UsXHJcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcclxuXHJcblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHZtLngsXHJcblx0XHRcdHk6IHZtLnlcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5QSSAqIE1hdGgucG93KHRoaXMuX3ZpZXcucmFkaXVzLCAyKTtcclxuXHR9LFxyXG5cclxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHZtLngsXHJcblx0XHRcdHk6IHZtLnksXHJcblx0XHRcdHBhZGRpbmc6IHZtLnJhZGl1cyArIHZtLmJvcmRlcldpZHRoXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgcG9pbnRTdHlsZSA9IHZtLnBvaW50U3R5bGU7XHJcblx0XHR2YXIgcm90YXRpb24gPSB2bS5yb3RhdGlvbjtcclxuXHRcdHZhciByYWRpdXMgPSB2bS5yYWRpdXM7XHJcblx0XHR2YXIgeCA9IHZtLng7XHJcblx0XHR2YXIgeSA9IHZtLnk7XHJcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcclxuXHRcdHZhciBkZWZhdWx0Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XHJcblxyXG5cdFx0aWYgKHZtLnNraXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENsaXBwaW5nIGZvciBQb2ludHMuXHJcblx0XHRpZiAoY2hhcnRBcmVhID09PSB1bmRlZmluZWQgfHwgaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYSh2bSwgY2hhcnRBcmVhKSkge1xyXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBkZWZhdWx0Q29sb3I7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQyKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5wb2ludC5ib3JkZXJXaWR0aCk7XHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIHBvaW50U3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XG5cbnZhciBkZWZhdWx0Q29sb3IkMiA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRyZWN0YW5nbGU6IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxyXG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnYm90dG9tJyxcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gaXNWZXJ0aWNhbCh2bSkge1xyXG5cdHJldHVybiB2bSAmJiB2bS53aWR0aCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cclxuICogQHBhcmFtIGJhciB7Q2hhcnQuRWxlbWVudC5SZWN0YW5nbGV9IHRoZSBiYXJcclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKHZtKSB7XHJcblx0dmFyIHgxLCB4MiwgeTEsIHkyLCBoYWxmO1xyXG5cclxuXHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcclxuXHRcdGhhbGYgPSB2bS53aWR0aCAvIDI7XHJcblx0XHR4MSA9IHZtLnggLSBoYWxmO1xyXG5cdFx0eDIgPSB2bS54ICsgaGFsZjtcclxuXHRcdHkxID0gTWF0aC5taW4odm0ueSwgdm0uYmFzZSk7XHJcblx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRoYWxmID0gdm0uaGVpZ2h0IC8gMjtcclxuXHRcdHgxID0gTWF0aC5taW4odm0ueCwgdm0uYmFzZSk7XHJcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xyXG5cdFx0eTEgPSB2bS55IC0gaGFsZjtcclxuXHRcdHkyID0gdm0ueSArIGhhbGY7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0bGVmdDogeDEsXHJcblx0XHR0b3A6IHkxLFxyXG5cdFx0cmlnaHQ6IHgyLFxyXG5cdFx0Ym90dG9tOiB5MlxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XHJcblx0cmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKSB7XHJcblx0dmFyIGVkZ2UgPSB2bS5ib3JkZXJTa2lwcGVkO1xyXG5cdHZhciByZXMgPSB7fTtcclxuXHJcblx0aWYgKCFlZGdlKSB7XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHJcblx0aWYgKHZtLmhvcml6b250YWwpIHtcclxuXHRcdGlmICh2bS5iYXNlID4gdm0ueCkge1xyXG5cdFx0XHRlZGdlID0gc3dhcChlZGdlLCAnbGVmdCcsICdyaWdodCcpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodm0uYmFzZSA8IHZtLnkpIHtcclxuXHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdib3R0b20nLCAndG9wJyk7XHJcblx0fVxyXG5cclxuXHRyZXNbZWRnZV0gPSB0cnVlO1xyXG5cdHJldHVybiByZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgodm0sIG1heFcsIG1heEgpIHtcclxuXHR2YXIgdmFsdWUgPSB2bS5ib3JkZXJXaWR0aDtcclxuXHR2YXIgc2tpcCA9IHBhcnNlQm9yZGVyU2tpcHBlZCh2bSk7XHJcblx0dmFyIHQsIHIsIGIsIGw7XHJcblxyXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xyXG5cdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xyXG5cdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcclxuXHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dDogc2tpcC50b3AgfHwgKHQgPCAwKSA/IDAgOiB0ID4gbWF4SCA/IG1heEggOiB0LFxyXG5cdFx0cjogc2tpcC5yaWdodCB8fCAociA8IDApID8gMCA6IHIgPiBtYXhXID8gbWF4VyA6IHIsXHJcblx0XHRiOiBza2lwLmJvdHRvbSB8fCAoYiA8IDApID8gMCA6IGIgPiBtYXhIID8gbWF4SCA6IGIsXHJcblx0XHRsOiBza2lwLmxlZnQgfHwgKGwgPCAwKSA/IDAgOiBsID4gbWF4VyA/IG1heFcgOiBsXHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyh2bSkge1xyXG5cdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModm0pO1xyXG5cdHZhciB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xyXG5cdHZhciBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcclxuXHR2YXIgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aCh2bSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdG91dGVyOiB7XHJcblx0XHRcdHg6IGJvdW5kcy5sZWZ0LFxyXG5cdFx0XHR5OiBib3VuZHMudG9wLFxyXG5cdFx0XHR3OiB3aWR0aCxcclxuXHRcdFx0aDogaGVpZ2h0XHJcblx0XHR9LFxyXG5cdFx0aW5uZXI6IHtcclxuXHRcdFx0eDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcclxuXHRcdFx0eTogYm91bmRzLnRvcCArIGJvcmRlci50LFxyXG5cdFx0XHR3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXHJcblx0XHRcdGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmJcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpblJhbmdlKHZtLCB4LCB5KSB7XHJcblx0dmFyIHNraXBYID0geCA9PT0gbnVsbDtcclxuXHR2YXIgc2tpcFkgPSB5ID09PSBudWxsO1xyXG5cdHZhciBib3VuZHMgPSAhdm0gfHwgKHNraXBYICYmIHNraXBZKSA/IGZhbHNlIDogZ2V0QmFyQm91bmRzKHZtKTtcclxuXHJcblx0cmV0dXJuIGJvdW5kc1xyXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXHJcblx0XHQmJiAoc2tpcFkgfHwgeSA+PSBib3VuZHMudG9wICYmIHkgPD0gYm91bmRzLmJvdHRvbSk7XHJcbn1cclxuXHJcbnZhciBlbGVtZW50X3JlY3RhbmdsZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cdF90eXBlOiAncmVjdGFuZ2xlJyxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciByZWN0cyA9IGJvdW5kaW5nUmVjdHModm0pO1xyXG5cdFx0dmFyIG91dGVyID0gcmVjdHMub3V0ZXI7XHJcblx0XHR2YXIgaW5uZXIgPSByZWN0cy5pbm5lcjtcclxuXHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0Y3R4LmZpbGxSZWN0KG91dGVyLngsIG91dGVyLnksIG91dGVyLncsIG91dGVyLmgpO1xyXG5cclxuXHRcdGlmIChvdXRlci53ID09PSBpbm5lci53ICYmIG91dGVyLmggPT09IGlubmVyLmgpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgucmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcclxuXHRcdGN0eC5jbGlwKCk7XHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XHJcblx0XHRjdHgucmVjdChpbm5lci54LCBpbm5lci55LCBpbm5lci53LCBpbm5lci5oKTtcclxuXHRcdGN0eC5maWxsKCdldmVub2RkJyk7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH0sXHJcblxyXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIHZtLmJhc2UgLSB2bS55O1xyXG5cdH0sXHJcblxyXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XHJcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG1vdXNlWSk7XHJcblx0fSxcclxuXHJcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiBpc1ZlcnRpY2FsKHZtKVxyXG5cdFx0XHQ/IGluUmFuZ2Uodm0sIG1vdXNlWCwgbnVsbClcclxuXHRcdFx0OiBpblJhbmdlKHZtLCBudWxsLCBtb3VzZVkpO1xyXG5cdH0sXHJcblxyXG5cdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcclxuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0aW5ZUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWSkge1xyXG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbnVsbCwgbW91c2VZKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIHgsIHk7XHJcblx0XHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcclxuXHRcdFx0eCA9IHZtLng7XHJcblx0XHRcdHkgPSAodm0ueSArIHZtLmJhc2UpIC8gMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcclxuXHRcdFx0eSA9IHZtLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt4OiB4LCB5OiB5fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblxyXG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXHJcblx0XHRcdD8gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSlcclxuXHRcdFx0OiB2bS5oZWlnaHQgKiBNYXRoLmFicyh2bS54IC0gdm0uYmFzZSk7XHJcblx0fSxcclxuXHJcblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB2bS54LFxyXG5cdFx0XHR5OiB2bS55XHJcblx0XHR9O1xyXG5cdH1cclxufSk7XG5cbnZhciBlbGVtZW50cyA9IHt9O1xyXG52YXIgQXJjID0gZWxlbWVudF9hcmM7XHJcbnZhciBMaW5lID0gZWxlbWVudF9saW5lO1xyXG52YXIgUG9pbnQgPSBlbGVtZW50X3BvaW50O1xyXG52YXIgUmVjdGFuZ2xlID0gZWxlbWVudF9yZWN0YW5nbGU7XG5lbGVtZW50cy5BcmMgPSBBcmM7XG5lbGVtZW50cy5MaW5lID0gTGluZTtcbmVsZW1lbnRzLlBvaW50ID0gUG9pbnQ7XG5lbGVtZW50cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5cbnZhciBkZXByZWNhdGVkID0gaGVscGVycyQxLl9kZXByZWNhdGVkO1xyXG52YXIgdmFsdWVPckRlZmF1bHQkMyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnYmFyJywge1xyXG5cdGhvdmVyOiB7XHJcblx0XHRtb2RlOiAnbGFiZWwnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcclxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxyXG5cdFx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fV0sXHJcblxyXG5cdFx0eUF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdsaW5lYXInXHJcblx0XHR9XVxyXG5cdH1cclxufSk7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRkYXRhc2V0czoge1xyXG5cdFx0YmFyOiB7XHJcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxyXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjlcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBcIm9wdGltYWxcIiBzYW1wbGUgc2l6ZSB0byBtYWludGFpbiBiYXJzIGVxdWFsbHkgc2l6ZWQgd2hpbGUgcHJldmVudGluZyBvdmVybGFwLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscykge1xyXG5cdHZhciBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xyXG5cdHZhciBwcmV2LCBjdXJyLCBpLCBpbGVuO1xyXG5cclxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0bWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhwaXhlbHNbaV0gLSBwaXhlbHNbaSAtIDFdKSk7XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUuZ2V0VGlja3MoKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XHJcblx0XHRtaW4gPSBpID4gMCA/IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpKSA6IG1pbjtcclxuXHRcdHByZXYgPSBjdXJyO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1pbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXHJcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXHJcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XHJcblx0dmFyIHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xyXG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XHJcblx0dmFyIGN1cnIgPSBydWxlci5waXhlbHNbaW5kZXhdO1xyXG5cdHZhciBtaW4gPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpXHJcblx0XHQ/IGNvbXB1dGVNaW5TYW1wbGVTaXplKHJ1bGVyLnNjYWxlLCBydWxlci5waXhlbHMpXHJcblx0XHQ6IC0xO1xyXG5cdHZhciBzaXplLCByYXRpbztcclxuXHJcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcclxuXHRcdHNpemUgPSBtaW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcclxuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBXaGVuIGJhciB0aGlja25lc3MgaXMgZW5mb3JjZWQsIGNhdGVnb3J5IGFuZCBiYXIgcGVyY2VudGFnZXMgYXJlIGlnbm9yZWQuXHJcblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcclxuXHRcdC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXHJcblx0XHRzaXplID0gdGhpY2tuZXNzICogY291bnQ7XHJcblx0XHRyYXRpbyA9IDE7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Y2h1bms6IHNpemUgLyBjb3VudCxcclxuXHRcdHJhdGlvOiByYXRpbyxcclxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhbiBcIm9wdGltYWxcIiBjYXRlZ29yeSB0aGF0IGdsb2JhbGx5IGFycmFuZ2VzIGJhcnMgc2lkZSBieSBzaWRlIChubyBnYXAgd2hlblxyXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcclxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xyXG5cdHZhciBwaXhlbHMgPSBydWxlci5waXhlbHM7XHJcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xyXG5cdHZhciBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xyXG5cdHZhciBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcclxuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xyXG5cdHZhciBzdGFydCwgc2l6ZTtcclxuXHJcblx0aWYgKHByZXYgPT09IG51bGwpIHtcclxuXHRcdC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcclxuXHRcdC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXHJcblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XHJcblx0fVxyXG5cclxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0Ly8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXHJcblx0XHRuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xyXG5cdH1cclxuXHJcblx0c3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcclxuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXHJcblx0XHRyYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxyXG5cdFx0c3RhcnQ6IHN0YXJ0XHJcblx0fTtcclxufVxyXG5cclxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xyXG5cclxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlJlY3RhbmdsZSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyU2tpcHBlZCcsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2JhclBlcmNlbnRhZ2UnLFxyXG5cdFx0J2JhclRoaWNrbmVzcycsXHJcblx0XHQnY2F0ZWdvcnlQZXJjZW50YWdlJyxcclxuXHRcdCdtYXhCYXJUaGlja25lc3MnLFxyXG5cdFx0J21pbkJhckxlbmd0aCdcclxuXHRdLFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSwgc2NhbGVPcHRzO1xyXG5cclxuXHRcdGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdG1ldGEuc3RhY2sgPSBtZS5nZXREYXRhc2V0KCkuc3RhY2s7XHJcblx0XHRtZXRhLmJhciA9IHRydWU7XHJcblxyXG5cdFx0c2NhbGVPcHRzID0gbWUuX2dldEluZGV4U2NhbGUoKS5vcHRpb25zO1xyXG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLmJhclBlcmNlbnRhZ2UsICdzY2FsZXMuW3gveV1BeGVzLmJhclBlcmNlbnRhZ2UnLCAnZGF0YXNldC5iYXJQZXJjZW50YWdlJyk7XHJcblx0XHRkZXByZWNhdGVkKCdiYXIgY2hhcnQnLCBzY2FsZU9wdHMuYmFyVGhpY2tuZXNzLCAnc2NhbGVzLlt4L3ldQXhlcy5iYXJUaGlja25lc3MnLCAnZGF0YXNldC5iYXJUaGlja25lc3MnKTtcclxuXHRcdGRlcHJlY2F0ZWQoJ2JhciBjaGFydCcsIHNjYWxlT3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UsICdzY2FsZXMuW3gveV1BeGVzLmNhdGVnb3J5UGVyY2VudGFnZScsICdkYXRhc2V0LmNhdGVnb3J5UGVyY2VudGFnZScpO1xyXG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0JywgbWUuX2dldFZhbHVlU2NhbGUoKS5vcHRpb25zLm1pbkJhckxlbmd0aCwgJ3NjYWxlcy5beC95XUF4ZXMubWluQmFyTGVuZ3RoJywgJ2RhdGFzZXQubWluQmFyTGVuZ3RoJyk7XHJcblx0XHRkZXByZWNhdGVkKCdiYXIgY2hhcnQnLCBzY2FsZU9wdHMubWF4QmFyVGhpY2tuZXNzLCAnc2NhbGVzLlt4L3ldQXhlcy5tYXhCYXJUaGlja25lc3MnLCAnZGF0YXNldC5tYXhCYXJUaGlja25lc3MnKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRtZS5fcnVsZXIgPSBtZS5nZXRSdWxlcigpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChyZWN0c1tpXSwgaSwgcmVzZXQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocmVjdGFuZ2xlLCBpbmRleCk7XHJcblxyXG5cdFx0cmVjdGFuZ2xlLl94U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XHJcblx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcclxuXHRcdHJlY3RhbmdsZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XHJcblx0XHRyZWN0YW5nbGUuX2luZGV4ID0gaW5kZXg7XHJcblx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogb3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcclxuXHRcdFx0ZGF0YXNldExhYmVsOiBkYXRhc2V0LmxhYmVsLFxyXG5cdFx0XHRsYWJlbDogbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShkYXRhc2V0LmRhdGFbaW5kZXhdKSkge1xyXG5cdFx0XHRyZWN0YW5nbGUuX21vZGVsLmJvcmRlclNraXBwZWQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJlY3RhbmdsZS5waXZvdCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3VwZGF0ZUVsZW1lbnRHZW9tZXRyeTogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xyXG5cdFx0dmFyIHZzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcclxuXHRcdHZhciBob3Jpem9udGFsID0gdnNjYWxlLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0dmFyIHJ1bGVyID0gbWUuX3J1bGVyIHx8IG1lLmdldFJ1bGVyKCk7XHJcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgb3B0aW9ucyk7XHJcblx0XHR2YXIgaXBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgcnVsZXIsIG9wdGlvbnMpO1xyXG5cclxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xyXG5cdFx0bW9kZWwuYmFzZSA9IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuYmFzZTtcclxuXHRcdG1vZGVsLnggPSBob3Jpem9udGFsID8gcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXI7XHJcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xyXG5cdFx0bW9kZWwuaGVpZ2h0ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IHVuZGVmaW5lZDtcclxuXHRcdG1vZGVsLndpZHRoID0gaG9yaXpvbnRhbCA/IHVuZGVmaW5lZCA6IGlwaXhlbHMuc2l6ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHN0YWNrIElEc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFN0YWNrczogZnVuY3Rpb24obGFzdCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XHJcblx0XHR2YXIgbWV0YXNldHMgPSBzY2FsZS5fZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMobWUuX3R5cGUpO1xyXG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XHJcblx0XHR2YXIgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcclxuXHRcdHZhciBzdGFja3MgPSBbXTtcclxuXHRcdHZhciBpLCBtZXRhO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHQvLyBzdGFja2VkICAgfCBtZXRhLnN0YWNrXHJcblx0XHRcdC8vICAgICAgICAgICB8IGZvdW5kIHwgbm90IGZvdW5kIHwgdW5kZWZpbmVkXHJcblx0XHRcdC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcclxuXHRcdFx0Ly8gdHJ1ZSAgICAgIHwgICAgICAgfCAgICAgeCAgICAgfFxyXG5cdFx0XHQvLyB1bmRlZmluZWQgfCAgICAgICB8ICAgICB4ICAgICB8ICAgICB4XHJcblx0XHRcdGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcclxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcclxuXHRcdFx0XHRzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0YWNrcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0U3RhY2tDb3VudDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKCkubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YXNldEluZGV4XSAtIFRoZSBkYXRhc2V0IGluZGV4XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFN0YWNrSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgbmFtZSkge1xyXG5cdFx0dmFyIHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgpO1xyXG5cdFx0dmFyIGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcclxuXHRcdFx0PyBzdGFja3MuaW5kZXhPZihuYW1lKVxyXG5cdFx0XHQ6IC0xOyAvLyBpbmRleE9mIHJldHVybnMgLTEgaWYgZWxlbWVudCBpcyBub3QgcHJlc2VudFxyXG5cclxuXHRcdHJldHVybiAoaW5kZXggPT09IC0xKVxyXG5cdFx0XHQ/IHN0YWNrcy5sZW5ndGggLSAxXHJcblx0XHRcdDogaW5kZXg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRSdWxlcjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldEluZGV4U2NhbGUoKTtcclxuXHRcdHZhciBwaXhlbHMgPSBbXTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS5nZXRNZXRhKCkuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBtZS5pbmRleCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHBpeGVsczogcGl4ZWxzLFxyXG5cdFx0XHRzdGFydDogc2NhbGUuX3N0YXJ0UGl4ZWwsXHJcblx0XHRcdGVuZDogc2NhbGUuX2VuZFBpeGVsLFxyXG5cdFx0XHRzdGFja0NvdW50OiBtZS5nZXRTdGFja0NvdW50KCksXHJcblx0XHRcdHNjYWxlOiBzY2FsZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQmFyVmFsdWVQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIG1ldGFzZXRzID0gc2NhbGUuX2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzKG1lLl90eXBlKTtcclxuXHRcdHZhciB2YWx1ZSA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdFx0dmFyIG1pbkJhckxlbmd0aCA9IG9wdGlvbnMubWluQmFyTGVuZ3RoO1xyXG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XHJcblx0XHR2YXIgc3RhY2sgPSBtZS5nZXRNZXRhKCkuc3RhY2s7XHJcblx0XHR2YXIgc3RhcnQgPSB2YWx1ZS5zdGFydCA9PT0gdW5kZWZpbmVkID8gMCA6IHZhbHVlLm1heCA+PSAwICYmIHZhbHVlLm1pbiA+PSAwID8gdmFsdWUubWluIDogdmFsdWUubWF4O1xyXG5cdFx0dmFyIGxlbmd0aCA9IHZhbHVlLnN0YXJ0ID09PSB1bmRlZmluZWQgPyB2YWx1ZS5lbmQgOiB2YWx1ZS5tYXggPj0gMCAmJiB2YWx1ZS5taW4gPj0gMCA/IHZhbHVlLm1heCAtIHZhbHVlLm1pbiA6IHZhbHVlLm1pbiAtIHZhbHVlLm1heDtcclxuXHRcdHZhciBpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xyXG5cdFx0dmFyIGksIGltZXRhLCBpdmFsdWUsIGJhc2UsIGhlYWQsIHNpemUsIHN0YWNrTGVuZ3RoO1xyXG5cclxuXHRcdGlmIChzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgc3RhY2sgIT09IHVuZGVmaW5lZCkpIHtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGltZXRhID0gbWV0YXNldHNbaV07XHJcblxyXG5cdFx0XHRcdGlmIChpbWV0YS5pbmRleCA9PT0gZGF0YXNldEluZGV4KSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpbWV0YS5zdGFjayA9PT0gc3RhY2spIHtcclxuXHRcdFx0XHRcdHN0YWNrTGVuZ3RoID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YXNldHNbaW1ldGEuaW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHRcdFx0XHRcdGl2YWx1ZSA9IHN0YWNrTGVuZ3RoLnN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFja0xlbmd0aC5lbmQgOiBzdGFja0xlbmd0aC5taW4gPj0gMCAmJiBzdGFja0xlbmd0aC5tYXggPj0gMCA/IHN0YWNrTGVuZ3RoLm1heCA6IHN0YWNrTGVuZ3RoLm1pbjtcclxuXHJcblx0XHRcdFx0XHRpZiAoKHZhbHVlLm1pbiA8IDAgJiYgaXZhbHVlIDwgMCkgfHwgKHZhbHVlLm1heCA+PSAwICYmIGl2YWx1ZSA+IDApKSB7XHJcblx0XHRcdFx0XHRcdHN0YXJ0ICs9IGl2YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCk7XHJcblx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XHJcblx0XHRzaXplID0gaGVhZCAtIGJhc2U7XHJcblxyXG5cdFx0aWYgKG1pbkJhckxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XHJcblx0XHRcdHNpemUgPSBtaW5CYXJMZW5ndGg7XHJcblx0XHRcdGlmIChsZW5ndGggPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IGxlbmd0aCA8IDAgJiYgaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdFx0aGVhZCA9IGJhc2UgLSBtaW5CYXJMZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aGVhZCA9IGJhc2UgKyBtaW5CYXJMZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzaXplOiBzaXplLFxyXG5cdFx0XHRiYXNlOiBiYXNlLFxyXG5cdFx0XHRoZWFkOiBoZWFkLFxyXG5cdFx0XHRjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4LCBydWxlciwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcclxuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcclxuXHRcdFx0OiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xyXG5cdFx0dmFyIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcclxuXHRcdHZhciBzaXplID0gTWF0aC5taW4oXHJcblx0XHRcdHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KSxcclxuXHRcdFx0cmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXHJcblx0XHRcdGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0c2l6ZTogc2l6ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGlsZW4gPSByZWN0cy5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dmFyIHZhbCA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFzZXQuZGF0YVtpXSk7XHJcblx0XHRcdGlmICghaXNOYU4odmFsLm1pbikgJiYgIWlzTmFOKHZhbC5tYXgpKSB7XHJcblx0XHRcdFx0cmVjdHNbaV0uZHJhdygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHZhbHVlcyA9IGhlbHBlcnMkMS5leHRlbmQoe30sIGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zLmFwcGx5KG1lLCBhcmd1bWVudHMpKTtcclxuXHRcdHZhciBpbmRleE9wdHMgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpLm9wdGlvbnM7XHJcblx0XHR2YXIgdmFsdWVPcHRzID0gbWUuX2dldFZhbHVlU2NhbGUoKS5vcHRpb25zO1xyXG5cclxuXHRcdHZhbHVlcy5iYXJQZXJjZW50YWdlID0gdmFsdWVPckRlZmF1bHQkMyhpbmRleE9wdHMuYmFyUGVyY2VudGFnZSwgdmFsdWVzLmJhclBlcmNlbnRhZ2UpO1xyXG5cdFx0dmFsdWVzLmJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0JDMoaW5kZXhPcHRzLmJhclRoaWNrbmVzcywgdmFsdWVzLmJhclRoaWNrbmVzcyk7XHJcblx0XHR2YWx1ZXMuY2F0ZWdvcnlQZXJjZW50YWdlID0gdmFsdWVPckRlZmF1bHQkMyhpbmRleE9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlLCB2YWx1ZXMuY2F0ZWdvcnlQZXJjZW50YWdlKTtcclxuXHRcdHZhbHVlcy5tYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdCQzKGluZGV4T3B0cy5tYXhCYXJUaGlja25lc3MsIHZhbHVlcy5tYXhCYXJUaGlja25lc3MpO1xyXG5cdFx0dmFsdWVzLm1pbkJhckxlbmd0aCA9IHZhbHVlT3JEZWZhdWx0JDModmFsdWVPcHRzLm1pbkJhckxlbmd0aCwgdmFsdWVzLm1pbkJhckxlbmd0aCk7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdidWJibGUnLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdzaW5nbGUnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIGJ1YmJsZSBzaG91bGQgcHJvYmFibHkgdXNlIGEgbGluZWFyIHNjYWxlIGJ5IGRlZmF1bHRcclxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nLFxyXG5cdFx0XHRpZDogJ3gtYXhpcy0wJyAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXHJcblx0XHR9XSxcclxuXHRcdHlBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcclxuXHRcdFx0cG9zaXRpb246ICdsZWZ0JyxcclxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcclxuXHRcdH1dXHJcblx0fSxcclxuXHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xyXG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcclxuXHRcdFx0XHR2YXIgZGF0YVBvaW50ID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0uZGF0YVtpdGVtLmluZGV4XTtcclxuXHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgY29udHJvbGxlcl9idWJibGUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlcldpZHRoJyxcclxuXHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXHJcblx0XHQnaG92ZXJSYWRpdXMnLFxyXG5cdFx0J2hpdFJhZGl1cycsXHJcblx0XHQncG9pbnRTdHlsZScsXHJcblx0XHQncm90YXRpb24nXHJcblx0XSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGE7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xyXG5cdFx0aGVscGVycyQxLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcclxuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XHJcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcclxuXHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XHJcblxyXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcclxuXHRcdHZhciB5ID0gcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShkYXRhLCBpbmRleCwgZHNJbmRleCk7XHJcblxyXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcclxuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XHJcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcclxuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xyXG5cdFx0cG9pbnQuX21vZGVsID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXHJcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcclxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXHJcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXHJcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5LFxyXG5cdFx0fTtcclxuXHJcblx0XHRwb2ludC5waXZvdCgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xyXG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblxyXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcclxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xyXG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGFbaW5kZXhdIHx8IHt9O1xyXG5cdFx0dmFyIHZhbHVlcyA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xyXG5cdFx0dmFyIGNvbnRleHQgPSB7XHJcblx0XHRcdGNoYXJ0OiBjaGFydCxcclxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcclxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcclxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBJbiBjYXNlIHZhbHVlcyB3ZXJlIGNhY2hlZCAoYW5kIHRodXMgZnJvemVuKSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdmFsdWVzXHJcblx0XHRpZiAobWUuX2NhY2hlZERhdGFPcHRzID09PSB2YWx1ZXMpIHtcclxuXHRcdFx0dmFsdWVzID0gaGVscGVycyQxLmV4dGVuZCh7fSwgdmFsdWVzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cclxuXHRcdHZhbHVlcy5yYWRpdXMgPSByZXNvbHZlJDEoW1xyXG5cdFx0XHRjdXN0b20ucmFkaXVzLFxyXG5cdFx0XHRkYXRhLnIsXHJcblx0XHRcdG1lLl9jb25maWcucmFkaXVzLFxyXG5cdFx0XHRjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LnJhZGl1c1xyXG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fVxyXG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG52YXIgUEkkMSA9IE1hdGguUEk7XHJcbnZhciBET1VCTEVfUEkkMSA9IFBJJDEgKiAyO1xyXG52YXIgSEFMRl9QSSQxID0gUEkkMSAvIDI7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2RvdWdobnV0Jywge1xyXG5cdGFuaW1hdGlvbjoge1xyXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XHJcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxyXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcclxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2VcclxuXHR9LFxyXG5cdGhvdmVyOiB7XHJcblx0XHRtb2RlOiAnc2luZ2xlJ1xyXG5cdH0sXHJcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHR2YXIgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XHJcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XHJcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xyXG5cdFx0dmFyIGksIGlsZW4sIGxpc3RJdGVtLCBsaXN0SXRlbVNwYW47XHJcblxyXG5cdFx0bGlzdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2hhcnQuaWQgKyAnLWxlZ2VuZCcpO1xyXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRsaXN0SXRlbSA9IGxpc3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XHJcblx0XHRcdFx0bGlzdEl0ZW1TcGFuID0gbGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKTtcclxuXHRcdFx0XHRsaXN0SXRlbVNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldO1xyXG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcclxuXHRcdFx0XHRcdGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsc1tpXSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaXN0Lm91dGVySFRNTDtcclxuXHR9LFxyXG5cdGxlZ2VuZDoge1xyXG5cdFx0bGFiZWxzOiB7XHJcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcclxuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XHJcblx0XHRcdFx0XHRcdHZhciBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXHJcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkYXRhLmRhdGFzZXRzWzBdLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcclxuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcclxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcclxuXHRcdFx0XHRpZiAobWV0YS5kYXRhW2luZGV4XSkge1xyXG5cdFx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXHJcblx0Y3V0b3V0UGVyY2VudGFnZTogNTAsXHJcblxyXG5cdC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXHJcblx0cm90YXRpb246IC1IQUxGX1BJJDEsXHJcblxyXG5cdC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cclxuXHRjaXJjdW1mZXJlbmNlOiBET1VCTEVfUEkkMSxcclxuXHJcblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcclxuXHRcdFx0XHR2YXIgZGF0YUxhYmVsID0gZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW0uaW5kZXhdO1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XHJcblxyXG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShkYXRhTGFiZWwpKSB7XHJcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXHJcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNsb25lIGJlY2F1c2Ugd2UgYXJlIGNoYW5naW5nIHRoZSB2YWx1ZVxyXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XHJcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGRhdGFMYWJlbCArPSB2YWx1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBkYXRhTGFiZWw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2xsZXJfZG91Z2hudXQgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblxyXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxyXG5cclxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2JvcmRlckFsaWduJyxcclxuXHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXHJcblx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXHJcblx0XSxcclxuXHJcblx0Ly8gR2V0IGluZGV4IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcclxuXHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIHJpbmdJbmRleCA9IDA7XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xyXG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGopKSB7XHJcblx0XHRcdFx0KytyaW5nSW5kZXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmluZ0luZGV4O1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgcmF0aW9YID0gMTtcclxuXHRcdHZhciByYXRpb1kgPSAxO1xyXG5cdFx0dmFyIG9mZnNldFggPSAwO1xyXG5cdFx0dmFyIG9mZnNldFkgPSAwO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgYXJjcyA9IG1ldGEuZGF0YTtcclxuXHRcdHZhciBjdXRvdXQgPSBvcHRzLmN1dG91dFBlcmNlbnRhZ2UgLyAxMDAgfHwgMDtcclxuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gb3B0cy5jaXJjdW1mZXJlbmNlO1xyXG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xyXG5cdFx0dmFyIG1heFdpZHRoLCBtYXhIZWlnaHQsIGksIGlsZW47XHJcblxyXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xyXG5cdFx0aWYgKGNpcmN1bWZlcmVuY2UgPCBET1VCTEVfUEkkMSkge1xyXG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb24gJSBET1VCTEVfUEkkMTtcclxuXHRcdFx0c3RhcnRBbmdsZSArPSBzdGFydEFuZ2xlID49IFBJJDEgPyAtRE9VQkxFX1BJJDEgOiBzdGFydEFuZ2xlIDwgLVBJJDEgPyBET1VCTEVfUEkkMSA6IDA7XHJcblx0XHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xyXG5cdFx0XHR2YXIgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XHJcblx0XHRcdHZhciBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcclxuXHRcdFx0dmFyIGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XHJcblx0XHRcdHZhciBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xyXG5cdFx0XHR2YXIgY29udGFpbnMwID0gKHN0YXJ0QW5nbGUgPD0gMCAmJiBlbmRBbmdsZSA+PSAwKSB8fCBlbmRBbmdsZSA+PSBET1VCTEVfUEkkMTtcclxuXHRcdFx0dmFyIGNvbnRhaW5zOTAgPSAoc3RhcnRBbmdsZSA8PSBIQUxGX1BJJDEgJiYgZW5kQW5nbGUgPj0gSEFMRl9QSSQxKSB8fCBlbmRBbmdsZSA+PSBET1VCTEVfUEkkMSArIEhBTEZfUEkkMTtcclxuXHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gc3RhcnRBbmdsZSA9PT0gLVBJJDEgfHwgZW5kQW5nbGUgPj0gUEkkMTtcclxuXHRcdFx0dmFyIGNvbnRhaW5zMjcwID0gKHN0YXJ0QW5nbGUgPD0gLUhBTEZfUEkkMSAmJiBlbmRBbmdsZSA+PSAtSEFMRl9QSSQxKSB8fCBlbmRBbmdsZSA+PSBQSSQxICsgSEFMRl9QSSQxO1xyXG5cdFx0XHR2YXIgbWluWCA9IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydFgsIHN0YXJ0WCAqIGN1dG91dCwgZW5kWCwgZW5kWCAqIGN1dG91dCk7XHJcblx0XHRcdHZhciBtaW5ZID0gY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0WSwgc3RhcnRZICogY3V0b3V0LCBlbmRZLCBlbmRZICogY3V0b3V0KTtcclxuXHRcdFx0dmFyIG1heFggPSBjb250YWluczAgPyAxIDogTWF0aC5tYXgoc3RhcnRYLCBzdGFydFggKiBjdXRvdXQsIGVuZFgsIGVuZFggKiBjdXRvdXQpO1xyXG5cdFx0XHR2YXIgbWF4WSA9IGNvbnRhaW5zOTAgPyAxIDogTWF0aC5tYXgoc3RhcnRZLCBzdGFydFkgKiBjdXRvdXQsIGVuZFksIGVuZFkgKiBjdXRvdXQpO1xyXG5cdFx0XHRyYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcclxuXHRcdFx0cmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XHJcblx0XHRcdG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XHJcblx0XHRcdG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRjaGFydC5ib3JkZXJXaWR0aCA9IG1lLmdldE1heEJvcmRlcldpZHRoKCk7XHJcblx0XHRtYXhXaWR0aCA9IChjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCAtIGNoYXJ0LmJvcmRlcldpZHRoKSAvIHJhdGlvWDtcclxuXHRcdG1heEhlaWdodCA9IChjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCAtIGNoYXJ0LmJvcmRlcldpZHRoKSAvIHJhdGlvWTtcclxuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcclxuXHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgoY2hhcnQub3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xyXG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gKG1lLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkgfHwgMSk7XHJcblx0XHRjaGFydC5vZmZzZXRYID0gb2Zmc2V0WCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xyXG5cdFx0Y2hhcnQub2Zmc2V0WSA9IG9mZnNldFkgKiBjaGFydC5vdXRlclJhZGl1cztcclxuXHJcblx0XHRtZXRhLnRvdGFsID0gbWUuY2FsY3VsYXRlVG90YWwoKTtcclxuXHJcblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuX2dldFJpbmdXZWlnaHRPZmZzZXQobWUuaW5kZXgpO1xyXG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xyXG5cdFx0dmFyIGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcclxuXHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XHJcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcclxuXHRcdHZhciBlbmRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyAwIDogYXJjLmhpZGRlbiA/IDAgOiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pICogKG9wdHMuY2lyY3VtZmVyZW5jZSAvIERPVUJMRV9QSSQxKTtcclxuXHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xyXG5cdFx0dmFyIG91dGVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUub3V0ZXJSYWRpdXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xyXG5cdFx0XHQvLyBVdGlsaXR5XHJcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxyXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxyXG5cclxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdFx0X21vZGVsOiB7XHJcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRib3JkZXJBbGlnbjogb3B0aW9ucy5ib3JkZXJBbGlnbixcclxuXHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcclxuXHRcdFx0XHR5OiBjZW50ZXJZICsgY2hhcnQub2Zmc2V0WSxcclxuXHRcdFx0XHRzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcclxuXHRcdFx0XHRjaXJjdW1mZXJlbmNlOiBjaXJjdW1mZXJlbmNlLFxyXG5cdFx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuXHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5sYWJlbCwgaW5kZXgsIGNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XSlcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcclxuXHJcblx0XHQvLyBTZXQgY29ycmVjdCBhbmdsZXMgaWYgbm90IHJlc2V0dGluZ1xyXG5cdFx0aWYgKCFyZXNldCB8fCAhYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XHJcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xyXG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcclxuXHRcdH1cclxuXHJcblx0XHRhcmMucGl2b3QoKTtcclxuXHR9LFxyXG5cclxuXHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcclxuXHRcdHZhciB0b3RhbCA9IDA7XHJcblx0XHR2YXIgdmFsdWU7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHR2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XHJcblx0XHRcdGlmICghaXNOYU4odmFsdWUpICYmICFlbGVtZW50LmhpZGRlbikge1xyXG5cdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0LyogaWYgKHRvdGFsID09PSAwKSB7XHJcblx0XHRcdHRvdGFsID0gTmFOO1xyXG5cdFx0fSovXHJcblxyXG5cdFx0cmV0dXJuIHRvdGFsO1xyXG5cdH0sXHJcblxyXG5cdGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2U6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcclxuXHRcdGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gRE9VQkxFX1BJJDEgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fSxcclxuXHJcblx0Ly8gZ2V0cyB0aGUgbWF4IGJvcmRlciBvciBob3ZlciB3aWR0aCB0byBwcm9wZXJseSBzY2FsZSBwaWUgY2hhcnRzXHJcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWF4ID0gMDtcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGksIGlsZW4sIG1ldGEsIGFyYywgY29udHJvbGxlciwgb3B0aW9ucywgYm9yZGVyV2lkdGgsIGhvdmVyV2lkdGg7XHJcblxyXG5cdFx0aWYgKCFhcmNzKSB7XHJcblx0XHRcdC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdFx0XHRhcmNzID0gbWV0YS5kYXRhO1xyXG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XHJcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWFyY3MpIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGFyYyA9IGFyY3NbaV07XHJcblx0XHRcdGlmIChjb250cm9sbGVyKSB7XHJcblx0XHRcdFx0Y29udHJvbGxlci5fY29uZmlndXJlKCk7XHJcblx0XHRcdFx0b3B0aW9ucyA9IGNvbnRyb2xsZXIuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoYXJjLCBpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zID0gYXJjLl9vcHRpb25zO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XHJcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xyXG5cdFx0XHRcdGhvdmVyV2lkdGggPSBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGg7XHJcblxyXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XHJcblx0XHRcdFx0bWF4ID0gaG92ZXJXaWR0aCA+IG1heCA/IGhvdmVyV2lkdGggOiBtYXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xyXG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcclxuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XHJcblx0XHRcdGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRyaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCQ1KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhU2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJpbGUgZGF0YSBzZXQgd2VpZ2h0cy4gIFRoaXMgdmFsdWUgY2FuIGJlIDAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2hvcml6b250YWxCYXInLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdpbmRleCcsXHJcblx0XHRheGlzOiAneSdcclxuXHR9LFxyXG5cclxuXHRzY2FsZXM6IHtcclxuXHRcdHhBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcclxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXHJcblx0XHR9XSxcclxuXHJcblx0XHR5QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcclxuXHRcdFx0cG9zaXRpb246ICdsZWZ0JyxcclxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxyXG5cdFx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fV1cclxuXHR9LFxyXG5cclxuXHRlbGVtZW50czoge1xyXG5cdFx0cmVjdGFuZ2xlOiB7XHJcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdsZWZ0J1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBzOiB7XHJcblx0XHRtb2RlOiAnaW5kZXgnLFxyXG5cdFx0YXhpczogJ3knXHJcblx0fVxyXG59KTtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGRhdGFzZXRzOiB7XHJcblx0XHRob3Jpem9udGFsQmFyOiB7XHJcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxyXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjlcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIHJlc29sdmUkMiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcbnZhciBpc1BvaW50SW5BcmVhID0gaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYTtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcclxuXHRzaG93TGluZXM6IHRydWUsXHJcblx0c3BhbkdhcHM6IGZhbHNlLFxyXG5cclxuXHRob3Zlcjoge1xyXG5cdFx0bW9kZTogJ2xhYmVsJ1xyXG5cdH0sXHJcblxyXG5cdHNjYWxlczoge1xyXG5cdFx0eEF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXHJcblx0XHRcdGlkOiAneC1heGlzLTAnXHJcblx0XHR9XSxcclxuXHRcdHlBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcclxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcclxuXHRcdH1dXHJcblx0fVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgaGFsZkJvcmRlcldpZHRoKSB7XHJcblx0dmFyIHRpY2tPcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy50aWNrcyB8fCB7fTtcclxuXHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XHJcblx0dmFyIG1pbiA9IHRpY2tPcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gaGFsZkJvcmRlcldpZHRoIDogMDtcclxuXHR2YXIgbWF4ID0gdGlja09wdHMubWF4ID09PSB1bmRlZmluZWQgPyBoYWxmQm9yZGVyV2lkdGggOiAwO1xyXG5cdHJldHVybiB7XHJcblx0XHRzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcclxuXHRcdGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBib3JkZXJXaWR0aCkge1xyXG5cdHZhciBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XHJcblx0dmFyIHggPSBzY2FsZUNsaXAoeFNjYWxlLCBoYWxmQm9yZGVyV2lkdGgpO1xyXG5cdHZhciB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgaGFsZkJvcmRlcldpZHRoKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHRvcDogeS5lbmQsXHJcblx0XHRyaWdodDogeC5lbmQsXHJcblx0XHRib3R0b206IHkuc3RhcnQsXHJcblx0XHRsZWZ0OiB4LnN0YXJ0XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XHJcblx0dmFyIHQsIHIsIGIsIGw7XHJcblxyXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XHJcblx0XHR0ID0gdmFsdWUudG9wO1xyXG5cdFx0ciA9IHZhbHVlLnJpZ2h0O1xyXG5cdFx0YiA9IHZhbHVlLmJvdHRvbTtcclxuXHRcdGwgPSB2YWx1ZS5sZWZ0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0ID0gciA9IGIgPSBsID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dG9wOiB0LFxyXG5cdFx0cmlnaHQ6IHIsXHJcblx0XHRib3R0b206IGIsXHJcblx0XHRsZWZ0OiBsXHJcblx0fTtcclxufVxyXG5cclxuXHJcbnZhciBjb250cm9sbGVyX2xpbmUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblxyXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YXNldEVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDYXBTdHlsZScsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlckRhc2gnLFxyXG5cdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxyXG5cdFx0J2JvcmRlckpvaW5TdHlsZScsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2N1YmljSW50ZXJwb2xhdGlvbk1vZGUnLFxyXG5cdFx0J2ZpbGwnXHJcblx0XSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiB7XHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXHJcblx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxyXG5cdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcclxuXHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcclxuXHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxyXG5cdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcclxuXHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcclxuXHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcclxuXHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcclxuXHRcdHZhciBzaG93TGluZSA9IG1lLl9zaG93TGluZSA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRtZS5feFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xyXG5cdFx0bWUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgTGluZVxyXG5cdFx0aWYgKHNob3dMaW5lKSB7XHJcblx0XHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcclxuXHRcdFx0aWYgKGNvbmZpZy50ZW5zaW9uICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcubGluZVRlbnNpb24gPSBjb25maWcudGVuc2lvbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXRpbGl0eVxyXG5cdFx0XHRsaW5lLl9zY2FsZSA9IG1lLl95U2NhbGU7XHJcblx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0XHQvLyBEYXRhXHJcblx0XHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xyXG5cdFx0XHQvLyBNb2RlbFxyXG5cdFx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGxpbmUpO1xyXG5cclxuXHRcdFx0bGluZS5waXZvdCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNob3dMaW5lICYmIGxpbmUuX21vZGVsLnRlbnNpb24gIT09IDApIHtcclxuXHRcdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcclxuXHRcdHZhciB4U2NhbGUgPSBtZS5feFNjYWxlO1xyXG5cdFx0dmFyIHlTY2FsZSA9IG1lLl95U2NhbGU7XHJcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcclxuXHRcdHZhciB4LCB5O1xyXG5cclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcclxuXHJcblx0XHR4ID0geFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlIDogTmFOLCBpbmRleCwgZGF0YXNldEluZGV4KTtcclxuXHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XHJcblxyXG5cdFx0Ly8gVXRpbGl0eVxyXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcclxuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XHJcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xyXG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XHJcblxyXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdHBvaW50Ll9tb2RlbCA9IHtcclxuXHRcdFx0eDogeCxcclxuXHRcdFx0eTogeSxcclxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXHJcblx0XHRcdC8vIEFwcGVhcmFuY2VcclxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcclxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxyXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ2KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxyXG5cdFx0XHRzdGVwcGVkTGluZTogbGluZU1vZGVsID8gbGluZU1vZGVsLnN0ZXBwZWRMaW5lIDogZmFsc2UsXHJcblx0XHRcdC8vIFRvb2x0aXBcclxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgbGluZU9wdGlvbnMgPSBvcHRpb25zLmVsZW1lbnRzLmxpbmU7XHJcblx0XHR2YXIgdmFsdWVzID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xyXG5cdFx0Ly8gdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0MzUjaXNzdWVjb21tZW50LTIxNjcxODE1OFxyXG5cdFx0Ly8gVGhpcyBvcHRpb24gZ2l2ZXMgbGluZXMgdGhlIGFiaWxpdHkgdG8gc3BhbiBnYXBzXHJcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ2KGNvbmZpZy5zcGFuR2Fwcywgb3B0aW9ucy5zcGFuR2Fwcyk7XHJcblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLmxpbmVUZW5zaW9uLCBsaW5lT3B0aW9ucy50ZW5zaW9uKTtcclxuXHRcdHZhbHVlcy5zdGVwcGVkTGluZSA9IHJlc29sdmUkMihbY3VzdG9tLnN0ZXBwZWRMaW5lLCBjb25maWcuc3RlcHBlZExpbmUsIGxpbmVPcHRpb25zLnN0ZXBwZWRdKTtcclxuXHRcdHZhbHVlcy5jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLmNsaXAsIGRlZmF1bHRDbGlwKG1lLl94U2NhbGUsIG1lLl95U2NhbGUsIHZhbHVlcy5ib3JkZXJXaWR0aCkpKTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdGNhbGN1bGF0ZVBvaW50WTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciB5U2NhbGUgPSBtZS5feVNjYWxlO1xyXG5cdFx0dmFyIHN1bVBvcyA9IDA7XHJcblx0XHR2YXIgc3VtTmVnID0gMDtcclxuXHRcdHZhciBpLCBkcywgZHNNZXRhLCBzdGFja2VkUmlnaHRWYWx1ZSwgcmlnaHRWYWx1ZSwgbWV0YXNldHMsIGlsZW47XHJcblxyXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcclxuXHRcdFx0cmlnaHRWYWx1ZSA9ICt5U2NhbGUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XHJcblx0XHRcdG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuXHRcdFx0aWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRkc01ldGEgPSBtZXRhc2V0c1tpXTtcclxuXHRcdFx0XHRpZiAoZHNNZXRhLmluZGV4ID09PSBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2RzTWV0YS5pbmRleF07XHJcblx0XHRcdFx0aWYgKGRzTWV0YS50eXBlID09PSAnbGluZScgJiYgZHNNZXRhLnlBeGlzSUQgPT09IHlTY2FsZS5pZCkge1xyXG5cdFx0XHRcdFx0c3RhY2tlZFJpZ2h0VmFsdWUgPSAreVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pO1xyXG5cdFx0XHRcdFx0aWYgKHN0YWNrZWRSaWdodFZhbHVlIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN1bVBvcyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJpZ2h0VmFsdWUgPCAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdW1Qb3MgKyByaWdodFZhbHVlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xyXG5cdFx0dmFyIGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xyXG5cdFx0dmFyIGksIGlsZW4sIG1vZGVsLCBjb250cm9sUG9pbnRzO1xyXG5cclxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXHJcblx0XHRpZiAobGluZU1vZGVsLnNwYW5HYXBzKSB7XHJcblx0XHRcdHBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XHJcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGluZU1vZGVsLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcclxuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xyXG5cdFx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXHJcblx0XHRcdFx0XHRoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaSkuX21vZGVsLFxyXG5cdFx0XHRcdFx0bW9kZWwsXHJcblx0XHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXHJcblx0XHRcdFx0XHRsaW5lTW9kZWwudGVuc2lvblxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xyXG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcclxuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xyXG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lLmNhcEJlemllclBvaW50cykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcclxuXHRcdFx0XHRpZiAoaXNQb2ludEluQXJlYShtb2RlbCwgYXJlYSkpIHtcclxuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZLCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0uX21vZGVsLCBhcmVhKSkge1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcclxuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XHJcblx0XHR2YXIgaSA9IDA7XHJcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblx0XHR2YXIgY2xpcDtcclxuXHJcblx0XHRpZiAobWUuX3Nob3dMaW5lKSB7XHJcblx0XHRcdGNsaXAgPSBtZXRhLmRhdGFzZXQuX21vZGVsLmNsaXA7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xyXG5cdFx0XHRcdGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxyXG5cdFx0XHRcdHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IGNhbnZhcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxyXG5cdFx0XHRcdHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXHJcblx0XHRcdFx0Ym90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyBjYW52YXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEcmF3IHRoZSBwb2ludHNcclxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xyXG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblxyXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcclxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xyXG5cdFx0bW9kZWwucmFkaXVzID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyUmFkaXVzLCBvcHRpb25zLnJhZGl1cyk7XHJcblx0fSxcclxufSk7XG5cbnZhciByZXNvbHZlJDMgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdwb2xhckFyZWEnLCB7XHJcblx0c2NhbGU6IHtcclxuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxyXG5cdFx0YW5nbGVMaW5lczoge1xyXG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRjaXJjdWxhcjogdHJ1ZVxyXG5cdFx0fSxcclxuXHRcdHBvaW50TGFiZWxzOiB7XHJcblx0XHRcdGRpc3BsYXk6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0dGlja3M6IHtcclxuXHRcdFx0YmVnaW5BdFplcm86IHRydWVcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnRcclxuXHRhbmltYXRpb246IHtcclxuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXHJcblx0XHRhbmltYXRlU2NhbGU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRzdGFydEFuZ2xlOiAtMC41ICogTWF0aC5QSSxcclxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XHJcblx0XHR2YXIgaSwgaWxlbiwgbGlzdEl0ZW0sIGxpc3RJdGVtU3BhbjtcclxuXHJcblx0XHRsaXN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjaGFydC5pZCArICctbGVnZW5kJyk7XHJcblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGxpc3RJdGVtID0gbGlzdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpKTtcclxuXHRcdFx0XHRsaXN0SXRlbVNwYW4gPSBsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xyXG5cdFx0XHRcdGxpc3RJdGVtU3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV07XHJcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xyXG5cdFx0XHRcdFx0bGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWxzW2ldKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Qub3V0ZXJIVE1MO1xyXG5cdH0sXHJcblx0bGVnZW5kOiB7XHJcblx0XHRsYWJlbHM6IHtcclxuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xyXG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcclxuXHRcdFx0XHRcdFx0dmFyIHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcclxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXHJcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRhdGEuZGF0YXNldHNbMF0uZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXHJcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gW107XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xyXG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xyXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcclxuXHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcclxuXHR0b29sdGlwczoge1xyXG5cdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XHJcblx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzW2l0ZW0uaW5kZXhdICsgJzogJyArIGl0ZW0ueUxhYmVsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBjb250cm9sbGVyX3BvbGFyQXJlYSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXHJcblxyXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kYXRhRWxlbWVudE9wdGlvbnM6IFtcclxuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJXaWR0aCcsXHJcblx0XHQnYm9yZGVyQWxpZ24nLFxyXG5cdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlcldpZHRoJyxcclxuXHRdLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGUuaWQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XHJcblx0XHR2YXIgc3RhcnRzID0gbWUuX3N0YXJ0cyA9IFtdO1xyXG5cdFx0dmFyIGFuZ2xlcyA9IG1lLl9hbmdsZXMgPSBbXTtcclxuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xyXG5cdFx0dmFyIGksIGlsZW4sIGFuZ2xlO1xyXG5cclxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcclxuXHJcblx0XHRtZXRhLmNvdW50ID0gbWUuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldC5kYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRzdGFydHNbaV0gPSBzdGFydDtcclxuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xyXG5cdFx0XHRhbmdsZXNbaV0gPSBhbmdsZTtcclxuXHRcdFx0c3RhcnQgKz0gYW5nbGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfdXBkYXRlUmFkaXVzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XHJcblxyXG5cdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XHJcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xyXG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xyXG5cclxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xyXG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xyXG5cdFx0dmFyIHNjYWxlID0gY2hhcnQuc2NhbGU7XHJcblx0XHR2YXIgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHM7XHJcblxyXG5cdFx0dmFyIGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xyXG5cdFx0dmFyIGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xyXG5cclxuXHRcdC8vIHZhciBuZWdIYWxmUEkgPSAtMC41ICogTWF0aC5QSTtcclxuXHRcdHZhciBkYXRhc2V0U3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcclxuXHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XHJcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG1lLl9zdGFydHNbaW5kZXhdO1xyXG5cdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChhcmMuaGlkZGVuID8gMCA6IG1lLl9hbmdsZXNbaW5kZXhdKTtcclxuXHJcblx0XHR2YXIgcmVzZXRSYWRpdXMgPSBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcclxuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XHJcblx0XHRcdC8vIFV0aWxpdHlcclxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdF9pbmRleDogaW5kZXgsXHJcblx0XHRcdF9zY2FsZTogc2NhbGUsXHJcblxyXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xyXG5cdFx0XHRfbW9kZWw6IHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxyXG5cdFx0XHRcdHg6IGNlbnRlclgsXHJcblx0XHRcdFx0eTogY2VudGVyWSxcclxuXHRcdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0XHRvdXRlclJhZGl1czogcmVzZXQgPyByZXNldFJhZGl1cyA6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogc3RhcnRBbmdsZSxcclxuXHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcclxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChsYWJlbHMsIGluZGV4LCBsYWJlbHNbaW5kZXhdKVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRhcmMucGl2b3QoKTtcclxuXHR9LFxyXG5cclxuXHRjb3VudFZpc2libGVFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcclxuXHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHRpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pICYmICFlbGVtZW50LmhpZGRlbikge1xyXG5cdFx0XHRcdGNvdW50Kys7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjb3VudDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICovXHJcblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XHJcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XHJcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xyXG5cdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuXHRcdGFyYy4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29tcHV0ZUFuZ2xlOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHJcblx0XHRpZiAoaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IG1lLmNoYXJ0LFxyXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxyXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiByZXNvbHZlJDMoW1xyXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYy5hbmdsZSxcclxuXHRcdFx0KDIgKiBNYXRoLlBJKSAvIGNvdW50XHJcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XHJcblx0fVxyXG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5kb3VnaG51dCkpO1xyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BpZScsIHtcclxuXHRjdXRvdXRQZXJjZW50YWdlOiAwXHJcbn0pO1xyXG5cclxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcclxudmFyIGNvbnRyb2xsZXJfcGllID0gY29udHJvbGxlcl9kb3VnaG51dDtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDcgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3JhZGFyJywge1xyXG5cdHNwYW5HYXBzOiBmYWxzZSxcclxuXHRzY2FsZToge1xyXG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcidcclxuXHR9LFxyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRsaW5lOiB7XHJcblx0XHRcdGZpbGw6ICdzdGFydCcsXHJcblx0XHRcdHRlbnNpb246IDAgLy8gbm8gYmV6aWVyIGluIHJhZGFyXHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xyXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcclxuXHJcblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFzZXRFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJDYXBTdHlsZScsXHJcblx0XHQnYm9yZGVyRGFzaCcsXHJcblx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXHJcblx0XHQnYm9yZGVySm9pblN0eWxlJyxcclxuXHRcdCdmaWxsJ1xyXG5cdF0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczoge1xyXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncG9pbnRCYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0Ym9yZGVyQ29sb3I6ICdwb2ludEJvcmRlckNvbG9yJyxcclxuXHRcdGJvcmRlcldpZHRoOiAncG9pbnRCb3JkZXJXaWR0aCcsXHJcblx0XHRoaXRSYWRpdXM6ICdwb2ludEhpdFJhZGl1cycsXHJcblx0XHRob3ZlckJhY2tncm91bmRDb2xvcjogJ3BvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0aG92ZXJCb3JkZXJDb2xvcjogJ3BvaW50SG92ZXJCb3JkZXJDb2xvcicsXHJcblx0XHRob3ZlckJvcmRlcldpZHRoOiAncG9pbnRIb3ZlckJvcmRlcldpZHRoJyxcclxuXHRcdGhvdmVyUmFkaXVzOiAncG9pbnRIb3ZlclJhZGl1cycsXHJcblx0XHRwb2ludFN0eWxlOiAncG9pbnRTdHlsZScsXHJcblx0XHRyYWRpdXM6ICdwb2ludFJhZGl1cycsXHJcblx0XHRyb3RhdGlvbjogJ3BvaW50Um90YXRpb24nXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZS5pZDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcclxuXHRcdHZhciBjb25maWcgPSBtZS5fY29uZmlnO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xyXG5cdFx0aWYgKGNvbmZpZy50ZW5zaW9uICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y29uZmlnLmxpbmVUZW5zaW9uID0gY29uZmlnLnRlbnNpb247XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXRpbGl0eVxyXG5cdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcclxuXHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0Ly8gRGF0YVxyXG5cdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XHJcblx0XHRsaW5lLl9sb29wID0gdHJ1ZTtcclxuXHRcdC8vIE1vZGVsXHJcblx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGxpbmUpO1xyXG5cclxuXHRcdGxpbmUucGl2b3QoKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgUG9pbnRzXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcclxuXHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcclxuXHJcblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcclxuXHRcdHZhciBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCBkYXRhc2V0LmRhdGFbaW5kZXhdKTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcclxuXHRcdHZhciBsaW5lTW9kZWwgPSBtZS5nZXRNZXRhKCkuZGF0YXNldC5fbW9kZWw7XHJcblx0XHR2YXIgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcclxuXHRcdHZhciB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xyXG5cclxuXHRcdC8vIFV0aWxpdHlcclxuXHRcdHBvaW50Ll9zY2FsZSA9IHNjYWxlO1xyXG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xyXG5cdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xyXG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XHJcblxyXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdHBvaW50Ll9tb2RlbCA9IHtcclxuXHRcdFx0eDogeCwgLy8gdmFsdWUgbm90IHVzZWQgaW4gZGF0YXNldCBzY2FsZSwgYnV0IHdlIHdhbnQgYSBjb25zaXN0ZW50IEFQSSBiZXR3ZWVuIHNjYWxlc1xyXG5cdFx0XHR5OiB5LFxyXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcclxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxyXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxyXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXHJcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDcoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXHJcblxyXG5cdFx0XHQvLyBUb29sdGlwXHJcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXNcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XHJcblx0XHR2YXIgdmFsdWVzID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0dmFsdWVzLnNwYW5HYXBzID0gdmFsdWVPckRlZmF1bHQkNyhjb25maWcuc3BhbkdhcHMsIG9wdGlvbnMuc3BhbkdhcHMpO1xyXG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ3KGNvbmZpZy5saW5lVGVuc2lvbiwgb3B0aW9ucy5lbGVtZW50cy5saW5lLnRlbnNpb24pO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgYXJlYSA9IG1lLmNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XHJcblxyXG5cdFx0Ly8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcclxuXHRcdGlmIChtZXRhLmRhdGFzZXQuX21vZGVsLnNwYW5HYXBzKSB7XHJcblx0XHRcdHBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XHJcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XHJcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXHJcblx0XHRcdFx0aGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcclxuXHRcdFx0XHRtb2RlbCxcclxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXHJcblx0XHRcdFx0bW9kZWwudGVuc2lvblxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Ly8gUHJldmVudCB0aGUgYmV6aWVyIGdvaW5nIG91dHNpZGUgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XHJcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC55LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNyhvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xyXG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3NjYXR0ZXInLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdzaW5nbGUnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcclxuXHRcdFx0dHlwZTogJ2xpbmVhcicsICAgIC8vIHNjYXR0ZXIgc2hvdWxkIG5vdCB1c2UgYSBjYXRlZ29yeSBheGlzXHJcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xyXG5cdFx0fV0sXHJcblx0XHR5QXhlczogW3tcclxuXHRcdFx0aWQ6ICd5LWF4aXMtMScsXHJcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxyXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnXHJcblx0XHR9XVxyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBzOiB7XHJcblx0XHRjYWxsYmFja3M6IHtcclxuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAnJzsgICAgIC8vIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3Igc2NhdHRlciBzaW5jZSBkYXRhIGFyZSBmb3JtYXR0ZWQgYXMgYSBwb2ludFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHRcdHJldHVybiAnKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcpJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRkYXRhc2V0czoge1xyXG5cdFx0c2NhdHRlcjoge1xyXG5cdFx0XHRzaG93TGluZTogZmFsc2VcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gU2NhdHRlciBjaGFydHMgdXNlIGxpbmUgY29udHJvbGxlcnNcclxudmFyIGNvbnRyb2xsZXJfc2NhdHRlciA9IGNvbnRyb2xsZXJfbGluZTtcblxuLy8gTk9URSBleHBvcnQgYSBtYXAgaW4gd2hpY2ggdGhlIGtleSByZXByZXNlbnRzIHRoZSBjb250cm9sbGVyIHR5cGUsIG5vdFxyXG4vLyB0aGUgY2xhc3MsIGFuZCBzbyBtdXN0IGJlIENhbWVsQ2FzZSBpbiBvcmRlciB0byBiZSBjb3JyZWN0bHkgcmV0cmlldmVkXHJcbi8vIGJ5IHRoZSBjb250cm9sbGVyIGluIGNvcmUuY29udHJvbGxlci5qcyAoYGNvbnRyb2xsZXJzW21ldGEudHlwZV1gKS5cclxuXHJcbnZhciBjb250cm9sbGVycyA9IHtcclxuXHRiYXI6IGNvbnRyb2xsZXJfYmFyLFxyXG5cdGJ1YmJsZTogY29udHJvbGxlcl9idWJibGUsXHJcblx0ZG91Z2hudXQ6IGNvbnRyb2xsZXJfZG91Z2hudXQsXHJcblx0aG9yaXpvbnRhbEJhcjogY29udHJvbGxlcl9ob3Jpem9udGFsQmFyLFxyXG5cdGxpbmU6IGNvbnRyb2xsZXJfbGluZSxcclxuXHRwb2xhckFyZWE6IGNvbnRyb2xsZXJfcG9sYXJBcmVhLFxyXG5cdHBpZTogY29udHJvbGxlcl9waWUsXHJcblx0cmFkYXI6IGNvbnRyb2xsZXJfcmFkYXIsXHJcblx0c2NhdHRlcjogY29udHJvbGxlcl9zY2F0dGVyXHJcbn07XG5cbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHJlbGF0aXZlIHBvc2l0aW9uIGZvciBhbiBldmVudFxyXG4gKiBAcGFyYW0ge0V2ZW50fElFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBmb3JcclxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnRcclxuICogQHJldHVybnMge29iamVjdH0gdGhlIGV2ZW50IHBvc2l0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XHJcblx0aWYgKGUubmF0aXZlKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiBlLngsXHJcblx0XHRcdHk6IGUueVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhdmVyc2UgYWxsIG9mIHRoZSB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xyXG5cdHZhciBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XHJcblx0dmFyIG1ldGFkYXRhLCBpLCBqLCBpbGVuLCBqbGVuLCBlbGVtZW50O1xyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRtZXRhZGF0YSA9IG1ldGFzZXRzW2ldLmRhdGE7XHJcblx0XHRmb3IgKGogPSAwLCBqbGVuID0gbWV0YWRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdGVsZW1lbnQgPSBtZXRhZGF0YVtqXTtcclxuXHRcdFx0aWYgKCFlbGVtZW50Ll92aWV3LnNraXApIHtcclxuXHRcdFx0XHRoYW5kbGVyKGVsZW1lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB7Q2hhcnRFbGVtZW50W119IGl0ZW1zIC0gZWxlbWVudHMgdG8gZmlsdGVyXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXHJcbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSB7XHJcblx0dmFyIGVsZW1lbnRzID0gW107XHJcblxyXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XHJcblx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxyXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cclxuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0YW5jZU1ldHJpYyAtIGZ1bmN0aW9uIHRvIHByb3ZpZGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzXHJcbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYykge1xyXG5cdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XHJcblxyXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KCk7XHJcblx0XHR2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcclxuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XHJcblx0XHRcdG5lYXJlc3RJdGVtcyA9IFtlbGVtZW50XTtcclxuXHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XHJcblx0XHRcdC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXHJcblx0XHRcdG5lYXJlc3RJdGVtcy5wdXNoKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxyXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcclxuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcclxuXHR2YXIgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XHJcblx0XHR2YXIgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcclxuXHRcdHZhciBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhNb2RlKGNoYXJ0LCBlLCBvcHRpb25zKSB7XHJcblx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXHJcblx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcclxuXHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcclxuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xyXG5cdHZhciBlbGVtZW50cyA9IFtdO1xyXG5cclxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH1cclxuXHJcblx0Y2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGEpIHtcclxuXHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2l0ZW1zWzBdLl9pbmRleF07XHJcblxyXG5cdFx0Ly8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxyXG5cdFx0aWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xyXG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gZWxlbWVudHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIElJbnRlcmFjdGlvbk9wdGlvbnNcclxuICovXHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb2ludFxyXG4gKiBAbmFtZSBJSW50ZXJmYWNlT3B0aW9ucyNib29sZWFuXHJcbiAqIEB0eXBlIEJvb2xlYW5cclxuICovXHJcblxyXG4vKipcclxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcclxuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxyXG4gKi9cclxudmFyIGNvcmVfaW50ZXJhY3Rpb24gPSB7XHJcblx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcclxuXHRtb2Rlczoge1xyXG5cdFx0c2luZ2xlOiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0dmFyIGVsZW1lbnRzID0gW107XHJcblxyXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudHM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBlbGVtZW50cy5zbGljZSgwLCAxKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMubGFiZWxcclxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjBcclxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdGxhYmVsOiBpbmRleE1vZGUsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcclxuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcclxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcclxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcclxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRpbmRleDogaW5kZXhNb2RlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcclxuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxyXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcclxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcclxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRkYXRhc2V0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XHJcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xyXG5cdFx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xyXG5cclxuXHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRpdGVtcyA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLl9kYXRhc2V0SW5kZXgpLmRhdGE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpdGVtcztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueC1heGlzXHJcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLiBVc2UgaW5kZXggbW9kZSBhbmQgaW50ZXJzZWN0ID09IHRydWVcclxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0XHRyZXR1cm4gaW5kZXhNb2RlKGNoYXJ0LCBlLCB7aW50ZXJzZWN0OiBmYWxzZX0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cclxuXHRcdCAqIG9mIHRoZSBldmVudFxyXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxyXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcblx0XHRcdHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XHJcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cclxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XHJcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHRuZWFyZXN0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XHJcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xyXG5cdFx0XHRyZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgb3B0aW9ucy5pbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XHJcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cclxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XHJcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHR4OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0dmFyIGl0ZW1zID0gW107XHJcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblhSYW5nZShwb3NpdGlvbi54KSkge1xyXG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcclxuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xyXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XHJcblx0XHRcdFx0aXRlbXMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaXRlbXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxyXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxyXG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2VcclxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcclxuXHRcdCAqL1xyXG5cdFx0eTogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcclxuXHJcblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5ZUmFuZ2UocG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXHJcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcclxuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xyXG5cdFx0XHRcdGl0ZW1zID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIGV4dGVuZCA9IGhlbHBlcnMkMS5leHRlbmQ7XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xyXG5cdHJldHVybiBoZWxwZXJzJDEud2hlcmUoYXJyYXksIGZ1bmN0aW9uKHYpIHtcclxuXHRcdHJldHVybiB2LnBvcyA9PT0gcG9zaXRpb247XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xyXG5cdHJldHVybiBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcclxuXHRcdHZhciB2MSA9IHJldmVyc2UgPyBhIDogYjtcclxuXHRcdHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XHJcblx0XHRcdHYwLmluZGV4IC0gdjEuaW5kZXggOlxyXG5cdFx0XHR2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xyXG5cdHZhciBsYXlvdXRCb3hlcyA9IFtdO1xyXG5cdHZhciBpLCBpbGVuLCBib3g7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0Ym94ID0gYm94ZXNbaV07XHJcblx0XHRsYXlvdXRCb3hlcy5wdXNoKHtcclxuXHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdGJveDogYm94LFxyXG5cdFx0XHRwb3M6IGJveC5wb3NpdGlvbixcclxuXHRcdFx0aG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxyXG5cdFx0XHR3ZWlnaHQ6IGJveC53ZWlnaHRcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRyZXR1cm4gbGF5b3V0Qm94ZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XHJcblx0dmFyIGksIGlsZW4sIGxheW91dDtcclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGxheW91dCA9IGxheW91dHNbaV07XHJcblx0XHQvLyBzdG9yZSB3aWR0aCB1c2VkIGluc3RlYWQgb2YgY2hhcnRBcmVhLncgaW4gZml0Qm94ZXNcclxuXHRcdGxheW91dC53aWR0aCA9IGxheW91dC5ob3Jpem9udGFsXHJcblx0XHRcdD8gbGF5b3V0LmJveC5mdWxsV2lkdGggJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoXHJcblx0XHRcdDogcGFyYW1zLnZCb3hNYXhXaWR0aDtcclxuXHRcdC8vIHN0b3JlIGhlaWdodCB1c2VkIGluc3RlYWQgb2YgY2hhcnRBcmVhLmggaW4gZml0Qm94ZXNcclxuXHRcdGxheW91dC5oZWlnaHQgPSBsYXlvdXQuaG9yaXpvbnRhbCAmJiBwYXJhbXMuaEJveE1heEhlaWdodDtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcclxuXHR2YXIgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xyXG5cdHZhciBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xyXG5cdHZhciByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XHJcblx0dmFyIHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xyXG5cdHZhciBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXHJcblx0XHRyaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGJvdHRvbSksXHJcblx0XHRjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcclxuXHRcdHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCksXHJcblx0XHRob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSlcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcclxuXHRyZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCkge1xyXG5cdHZhciBib3ggPSBsYXlvdXQuYm94O1xyXG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcblx0dmFyIG5ld1dpZHRoLCBuZXdIZWlnaHQ7XHJcblxyXG5cdGlmIChsYXlvdXQuc2l6ZSkge1xyXG5cdFx0Ly8gdGhpcyBsYXlvdXQgd2FzIGFscmVhZHkgY291bnRlZCBmb3IsIGxldHMgZmlyc3QgcmVkdWNlIG9sZCBzaXplXHJcblx0XHRjaGFydEFyZWFbbGF5b3V0LnBvc10gLT0gbGF5b3V0LnNpemU7XHJcblx0fVxyXG5cdGxheW91dC5zaXplID0gbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoO1xyXG5cdGNoYXJ0QXJlYVtsYXlvdXQucG9zXSArPSBsYXlvdXQuc2l6ZTtcclxuXHJcblx0aWYgKGJveC5nZXRQYWRkaW5nKSB7XHJcblx0XHR2YXIgYm94UGFkZGluZyA9IGJveC5nZXRQYWRkaW5nKCk7XHJcblx0XHRtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XHJcblx0XHRtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XHJcblx0XHRtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XHJcblx0XHRtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XHJcblx0fVxyXG5cclxuXHRuZXdXaWR0aCA9IHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpO1xyXG5cdG5ld0hlaWdodCA9IHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKTtcclxuXHJcblx0aWYgKG5ld1dpZHRoICE9PSBjaGFydEFyZWEudyB8fCBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oKSB7XHJcblx0XHRjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xyXG5cdFx0Y2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XHJcblxyXG5cdFx0Ly8gcmV0dXJuIHRydWUgaWYgY2hhcnQgYXJlYSBjaGFuZ2VkIGluIGxheW91dCdzIGRpcmVjdGlvblxyXG5cdFx0dmFyIHNpemVzID0gbGF5b3V0Lmhvcml6b250YWwgPyBbbmV3V2lkdGgsIGNoYXJ0QXJlYS53XSA6IFtuZXdIZWlnaHQsIGNoYXJ0QXJlYS5oXTtcclxuXHRcdHJldHVybiBzaXplc1swXSAhPT0gc2l6ZXNbMV0gJiYgKCFpc05hTihzaXplc1swXSkgfHwgIWlzTmFOKHNpemVzWzFdKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xyXG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcclxuXHRcdHZhciBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XHJcblx0XHRjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XHJcblx0XHRyZXR1cm4gY2hhbmdlO1xyXG5cdH1cclxuXHRjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xyXG5cdGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xyXG5cdHVwZGF0ZVBvcygncmlnaHQnKTtcclxuXHR1cGRhdGVQb3MoJ2JvdHRvbScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xyXG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcblxyXG5cdGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcclxuXHRcdHZhciBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcclxuXHRcdHBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvcykge1xyXG5cdFx0XHRtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gbWFyZ2luO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGhvcml6b250YWxcclxuXHRcdD8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxyXG5cdFx0OiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpIHtcclxuXHR2YXIgcmVmaXRCb3hlcyA9IFtdO1xyXG5cdHZhciBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGxheW91dCA9IGJveGVzW2ldO1xyXG5cdFx0Ym94ID0gbGF5b3V0LmJveDtcclxuXHJcblx0XHRib3gudXBkYXRlKFxyXG5cdFx0XHRsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXHJcblx0XHRcdGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXHJcblx0XHRcdGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcclxuXHRcdCk7XHJcblx0XHRpZiAodXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0KSkge1xyXG5cdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0aWYgKHJlZml0Qm94ZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXHJcblx0XHRcdFx0Ly8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxyXG5cdFx0XHRcdHJlZml0ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7IC8vIGZ1bGxXaWR0aCBib3hlcyBkb24ndCBuZWVkIHRvIGJlIHJlLWZpdHRlZCBpbiBhbnkgY2FzZVxyXG5cdFx0XHRyZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZWZpdCA/IGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zKSB8fCBjaGFuZ2VkIDogY2hhbmdlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpIHtcclxuXHR2YXIgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcclxuXHR2YXIgeCA9IGNoYXJ0QXJlYS54O1xyXG5cdHZhciB5ID0gY2hhcnRBcmVhLnk7XHJcblx0dmFyIGksIGlsZW4sIGxheW91dCwgYm94O1xyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRsYXlvdXQgPSBib3hlc1tpXTtcclxuXHRcdGJveCA9IGxheW91dC5ib3g7XHJcblx0XHRpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcclxuXHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gdXNlclBhZGRpbmcubGVmdCA6IGNoYXJ0QXJlYS5sZWZ0O1xyXG5cdFx0XHRib3gucmlnaHQgPSBib3guZnVsbFdpZHRoID8gcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCA6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnc7XHJcblx0XHRcdGJveC50b3AgPSB5O1xyXG5cdFx0XHRib3guYm90dG9tID0geSArIGJveC5oZWlnaHQ7XHJcblx0XHRcdGJveC53aWR0aCA9IGJveC5yaWdodCAtIGJveC5sZWZ0O1xyXG5cdFx0XHR5ID0gYm94LmJvdHRvbTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJveC5sZWZ0ID0geDtcclxuXHRcdFx0Ym94LnJpZ2h0ID0geCArIGJveC53aWR0aDtcclxuXHRcdFx0Ym94LnRvcCA9IGNoYXJ0QXJlYS50b3A7XHJcblx0XHRcdGJveC5ib3R0b20gPSBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmg7XHJcblx0XHRcdGJveC5oZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcclxuXHRcdFx0eCA9IGJveC5yaWdodDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNoYXJ0QXJlYS54ID0geDtcclxuXHRjaGFydEFyZWEueSA9IHk7XHJcbn1cclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGxheW91dDoge1xyXG5cdFx0cGFkZGluZzoge1xyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IDBcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgSUxheW91dEl0ZW1cclxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxyXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcclxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxXaWR0aCAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxyXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXHJcbiAqIEBwcm9wIHtmdW5jdGlvbn0gdXBkYXRlIC0gVGFrZXMgdHdvIHBhcmFtZXRlcnM6IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgc2l6ZSBvZiBpdGVtXHJcbiAqIEBwcm9wIHtmdW5jdGlvbn0gZ2V0UGFkZGluZyAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHJpZ2h0IC0gUmlnaHQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxyXG4gKi9cclxuXHJcbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxyXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcclxuLy8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxyXG52YXIgY29yZV9sYXlvdXRzID0ge1xyXG5cdGRlZmF1bHRzOiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cclxuXHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxyXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XHJcblx0ICovXHJcblx0YWRkQm94OiBmdW5jdGlvbihjaGFydCwgaXRlbSkge1xyXG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xyXG5cdFx0XHRjaGFydC5ib3hlcyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluaXRpYWxpemUgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblx0XHRpdGVtLmZ1bGxXaWR0aCA9IGl0ZW0uZnVsbFdpZHRoIHx8IGZhbHNlO1xyXG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XHJcblx0XHRpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XHJcblx0XHRpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBbe1xyXG5cdFx0XHRcdHo6IDAsXHJcblx0XHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpdGVtLmRyYXcuYXBwbHkoaXRlbSwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1dO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBhIGxheW91dEl0ZW0gZnJvbSBhIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxyXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XHJcblx0ICovXHJcblx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xyXG5cdFx0dmFyIGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XHJcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxyXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXHJcblx0ICovXHJcblx0Y29uZmlndXJlOiBmdW5jdGlvbihjaGFydCwgaXRlbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHByb3BzID0gWydmdWxsV2lkdGgnLCAncG9zaXRpb24nLCAnd2VpZ2h0J107XHJcblx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdHZhciBwcm9wO1xyXG5cclxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHByb3AgPSBwcm9wc1tpXTtcclxuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuXHRcdFx0XHRpdGVtW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXHJcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXHJcblx0ICovXHJcblx0dXBkYXRlOiBmdW5jdGlvbihjaGFydCwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0aWYgKCFjaGFydCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxheW91dE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxheW91dCB8fCB7fTtcclxuXHRcdHZhciBwYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKGxheW91dE9wdGlvbnMucGFkZGluZyk7XHJcblxyXG5cdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBwYWRkaW5nLndpZHRoO1xyXG5cdFx0dmFyIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xyXG5cdFx0dmFyIGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XHJcblx0XHR2YXIgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xyXG5cdFx0dmFyIGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XHJcblxyXG5cdFx0Ly8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxyXG5cdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXHJcblx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxyXG5cdFx0Ly8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXHJcblx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcclxuXHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxyXG5cdFx0Ly8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcblx0XHQvL1xyXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcblx0XHQvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcclxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XHJcblx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcclxuXHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XHJcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcclxuXHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XHJcblx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcclxuXHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxyXG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XHJcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcclxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XHJcblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xyXG5cdFx0XHRvdXRlcldpZHRoOiB3aWR0aCxcclxuXHRcdFx0b3V0ZXJIZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0cGFkZGluZzogcGFkZGluZyxcclxuXHRcdFx0YXZhaWxhYmxlV2lkdGg6IGF2YWlsYWJsZVdpZHRoLFxyXG5cdFx0XHR2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoLFxyXG5cdFx0XHRoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXHJcblx0XHR9KTtcclxuXHRcdHZhciBjaGFydEFyZWEgPSBleHRlbmQoe1xyXG5cdFx0XHRtYXhQYWRkaW5nOiBleHRlbmQoe30sIHBhZGRpbmcpLFxyXG5cdFx0XHR3OiBhdmFpbGFibGVXaWR0aCxcclxuXHRcdFx0aDogYXZhaWxhYmxlSGVpZ2h0LFxyXG5cdFx0XHR4OiBwYWRkaW5nLmxlZnQsXHJcblx0XHRcdHk6IHBhZGRpbmcudG9wXHJcblx0XHR9LCBwYWRkaW5nKTtcclxuXHJcblx0XHRzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XHJcblxyXG5cdFx0Ly8gRmlyc3QgZml0IHZlcnRpY2FsIGJveGVzXHJcblx0XHRmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblxyXG5cdFx0Ly8gVGhlbiBmaXQgaG9yaXpvbnRhbCBib3hlc1xyXG5cdFx0aWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpKSB7XHJcblx0XHRcdC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xyXG5cdFx0XHRmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xyXG5cclxuXHRcdC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcclxuXHRcdHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMpO1xyXG5cclxuXHRcdC8vIE1vdmUgdG8gb3Bwb3NpdGUgc2lkZSBvZiBjaGFydFxyXG5cdFx0Y2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XHJcblx0XHRjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcclxuXHJcblx0XHRwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblxyXG5cdFx0Y2hhcnQuY2hhcnRBcmVhID0ge1xyXG5cdFx0XHRsZWZ0OiBjaGFydEFyZWEubGVmdCxcclxuXHRcdFx0dG9wOiBjaGFydEFyZWEudG9wLFxyXG5cdFx0XHRyaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcclxuXHRcdFx0Ym90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmhcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXHJcblx0XHRoZWxwZXJzJDEuZWFjaChib3hlcy5jaGFydEFyZWEsIGZ1bmN0aW9uKGxheW91dCkge1xyXG5cdFx0XHR2YXIgYm94ID0gbGF5b3V0LmJveDtcclxuXHRcdFx0ZXh0ZW5kKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcclxuXHRcdFx0Ym94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xuXG4vKipcclxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XHJcbiAqL1xyXG5cclxudmFyIHBsYXRmb3JtX2Jhc2ljID0ge1xyXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xyXG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcclxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xyXG5cdH1cclxufTtcblxudmFyIHBsYXRmb3JtX2RvbSA9IFwiLypcXHJcXG4gKiBET00gZWxlbWVudCByZW5kZXJpbmcgZGV0ZWN0aW9uXFxyXFxuICogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXFxyXFxuICovXFxyXFxuQGtleWZyYW1lcyBjaGFydGpzLXJlbmRlci1hbmltYXRpb24ge1xcclxcblxcdGZyb20geyBvcGFjaXR5OiAwLjk5OyB9XFxyXFxuXFx0dG8geyBvcGFjaXR5OiAxOyB9XFxyXFxufVxcclxcblxcclxcbi5jaGFydGpzLXJlbmRlci1tb25pdG9yIHtcXHJcXG5cXHRhbmltYXRpb246IGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAwLjAwMXM7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuICogRE9NIGVsZW1lbnQgcmVzaXppbmcgZGV0ZWN0aW9uXFxyXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcXHJcXG4gKi9cXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3IsXFxyXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCxcXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0Ym90dG9tOiAwO1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdHotaW5kZXg6IC0xO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kID4gZGl2IHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0d2lkdGg6IDEwMDAwMDBweDtcXHJcXG5cXHRoZWlnaHQ6IDEwMDAwMDBweDtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayA+IGRpdiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHdpZHRoOiAyMDAlO1xcclxcblxcdGhlaWdodDogMjAwJTtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG59XFxyXFxuXCI7XG5cbnZhciBwbGF0Zm9ybV9kb20kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbidkZWZhdWx0JzogcGxhdGZvcm1fZG9tXG59KTtcblxudmFyIHN0eWxlc2hlZXQgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKHBsYXRmb3JtX2RvbSQxKTtcblxudmFyIEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcclxudmFyIENTU19QUkVGSVggPSAnY2hhcnRqcy0nO1xyXG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcclxudmFyIENTU19SRU5ERVJfTU9OSVRPUiA9IENTU19QUkVGSVggKyAncmVuZGVyLW1vbml0b3InO1xyXG52YXIgQ1NTX1JFTkRFUl9BTklNQVRJT04gPSBDU1NfUFJFRklYICsgJ3JlbmRlci1hbmltYXRpb24nO1xyXG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcclxuXHJcbi8qKlxyXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXHJcbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXHJcbiAqL1xyXG52YXIgRVZFTlRfVFlQRVMgPSB7XHJcblx0dG91Y2hzdGFydDogJ21vdXNlZG93bicsXHJcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcclxuXHR0b3VjaGVuZDogJ21vdXNldXAnLFxyXG5cdHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxyXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcclxuXHRwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXHJcblx0cG9pbnRlcnVwOiAnbW91c2V1cCcsXHJcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxyXG5cdHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXHJcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXHJcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcclxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcclxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xyXG5cdHZhciB2YWx1ZSA9IGhlbHBlcnMkMS5nZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XHJcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcclxuXHRyZXR1cm4gbWF0Y2hlcyA/IE51bWJlcihtYXRjaGVzWzFdKSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgc3R5bGUgYW5kIHJlbmRlciBzaXplIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjYW52YXMgZGlzcGxheSBzaXplLFxyXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXHJcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcclxuXHR2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XHJcblxyXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcclxuXHQvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxyXG5cdHZhciByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcclxuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xyXG5cclxuXHQvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxyXG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XHJcblx0XHRpbml0aWFsOiB7XHJcblx0XHRcdGhlaWdodDogcmVuZGVySGVpZ2h0LFxyXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXHJcblx0XHRcdHN0eWxlOiB7XHJcblx0XHRcdFx0ZGlzcGxheTogc3R5bGUuZGlzcGxheSxcclxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcclxuXHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGhcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcclxuXHQvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcclxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xyXG5cclxuXHRpZiAocmVuZGVyV2lkdGggPT09IG51bGwgfHwgcmVuZGVyV2lkdGggPT09ICcnKSB7XHJcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XHJcblx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XHJcblx0XHRpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcclxuXHRcdFx0Ly8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxyXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cclxuXHRcdFx0Ly8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoY29uZmlnLm9wdGlvbnMuYXNwZWN0UmF0aW8gfHwgMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcclxuXHRcdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBjYW52YXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzdXBwb3J0cyA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3VwcG9ydHMgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgb3B0aW9ucyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHM7XHJcbn0oKSk7XHJcblxyXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XHJcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCB4LCB5LCBuYXRpdmVFdmVudCkge1xyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxyXG5cdFx0eDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXHJcblx0XHR5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XHJcblx0dmFyIHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xyXG5cdHZhciBwb3MgPSBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xyXG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xyXG5cdHZhciB0aWNraW5nID0gZmFsc2U7XHJcblx0dmFyIGFyZ3MgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xyXG5cclxuXHRcdGlmICghdGlja2luZykge1xyXG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcclxuXHRcdFx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRpY2tpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNscyB8fCAnJztcclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZXIoaGFuZGxlcikge1xyXG5cdHZhciBtYXhTaXplID0gMTAwMDAwMDtcclxuXHJcblx0Ly8gTk9URShTQikgRG9uJ3QgdXNlIGlubmVySFRNTCBiZWNhdXNlIGl0IGNvdWxkIGJlIGNvbnNpZGVyZWQgdW5zYWZlLlxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81OTAyXHJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XHJcblx0dmFyIGV4cGFuZCA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SICsgJy1leHBhbmQnKTtcclxuXHR2YXIgc2hyaW5rID0gY3JlYXRlRGl2KENTU19TSVpFX01PTklUT1IgKyAnLXNocmluaycpO1xyXG5cclxuXHRleHBhbmQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCkpO1xyXG5cdHNocmluay5hcHBlbmRDaGlsZChjcmVhdGVEaXYoKSk7XHJcblxyXG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoZXhwYW5kKTtcclxuXHRyZXNpemVyLmFwcGVuZENoaWxkKHNocmluayk7XHJcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdGV4cGFuZC5zY3JvbGxMZWZ0ID0gbWF4U2l6ZTtcclxuXHRcdGV4cGFuZC5zY3JvbGxUb3AgPSBtYXhTaXplO1xyXG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xyXG5cdFx0c2hyaW5rLnNjcm9sbFRvcCA9IG1heFNpemU7XHJcblx0fTtcclxuXHJcblx0dmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXNpemVyLl9yZXNldCgpO1xyXG5cdFx0aGFuZGxlcigpO1xyXG5cdH07XHJcblxyXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xyXG5cdGFkZExpc3RlbmVyKHNocmluaywgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoc2hyaW5rLCAnc2hyaW5rJykpO1xyXG5cclxuXHRyZXR1cm4gcmVzaXplcjtcclxufVxyXG5cclxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoRm9yUmVuZGVyKG5vZGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcclxuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0aWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gQ1NTX1JFTkRFUl9BTklNQVRJT04pIHtcclxuXHRcdFx0aGFuZGxlcigpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcclxuXHR9KTtcclxuXHJcblx0Ly8gIzQ3Mzc6IENocm9tZSBtaWdodCBza2lwIHRoZSBDU1MgYW5pbWF0aW9uIHdoZW4gdGhlIENTU19SRU5ERVJfTU9OSVRPUiBjbGFzc1xyXG5cdC8vIGlzIHJlbW92ZWQgdGhlbiBhZGRlZCBiYWNrIGltbWVkaWF0ZWx5IChzYW1lIGFuaW1hdGlvbiBmcmFtZT8pLiBBY2Nlc3NpbmcgdGhlXHJcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXHJcblx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhI2JveC1tZXRyaWNzXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ3MzdcclxuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XHJcblxyXG5cdG5vZGUuY2xhc3NMaXN0LmFkZChDU1NfUkVOREVSX01PTklUT1IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bndhdGNoRm9yUmVuZGVyKG5vZGUpIHtcclxuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xyXG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHk7XHJcblxyXG5cdGlmIChwcm94eSkge1xyXG5cdFx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHRyZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRkZWxldGUgZXhwYW5kby5yZW5kZXJQcm94eTtcclxuXHR9XHJcblxyXG5cdG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDU1NfUkVOREVSX01PTklUT1IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRSZXNpemVMaXN0ZW5lcihub2RlLCBsaXN0ZW5lciwgY2hhcnQpIHtcclxuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcclxuXHJcblx0Ly8gTGV0J3Mga2VlcCB0cmFjayBvZiB0aGlzIGFkZGVkIHJlc2l6ZXIgYW5kIHRodXMgYXZvaWQgRE9NIHF1ZXJ5IHdoZW4gcmVtb3ZpbmcgaXQuXHJcblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcclxuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcclxuXHRcdFx0dmFyIGNvbnRhaW5lciA9IGNoYXJ0Lm9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBub2RlLnBhcmVudE5vZGU7XHJcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcclxuXHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XHJcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgdyAmJiBjaGFydC5jYW52YXMpIHtcclxuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxyXG5cdFx0XHRcdC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cclxuXHRcdFx0XHQvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXHJcblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXHJcblx0XHRcdFx0Ly8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXHJcblx0XHRcdFx0Ly8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xyXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcclxuXHRcdFx0XHRsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pKTtcclxuXHJcblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXHJcblx0Ly8gc3VyZSB0aGF0IGBub2RlYCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NIGJlZm9yZSBpbmplY3RpbmcgdGhlIHJlc2l6ZXIgZWxlbWVudC5cclxuXHR3YXRjaEZvclJlbmRlcihub2RlLCBmdW5jdGlvbigpIHtcclxuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcclxuXHRcdFx0dmFyIGNvbnRhaW5lciA9IG5vZGUucGFyZW50Tm9kZTtcclxuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIgIT09IHJlc2l6ZXIucGFyZW50Tm9kZSkge1xyXG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cclxuXHRcdFx0cmVzaXplci5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xyXG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XHJcblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXI7XHJcblxyXG5cdGRlbGV0ZSBleHBhbmRvLnJlc2l6ZXI7XHJcblx0dW53YXRjaEZvclJlbmRlcihub2RlKTtcclxuXHJcblx0aWYgKHJlc2l6ZXIgJiYgcmVzaXplci5wYXJlbnROb2RlKSB7XHJcblx0XHRyZXNpemVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVzaXplcik7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogSW5qZWN0cyBDU1Mgc3R5bGVzIGlubGluZSBpZiB0aGUgc3R5bGVzIGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxyXG4gKiBAcGFyYW0ge0hUTUxEb2N1bWVudHxTaGFkb3dSb290fSByb290Tm9kZSAtIHRoZSBub2RlIHRvIGNvbnRhaW4gdGhlIDxzdHlsZT4uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgLSB0aGUgQ1NTIHRvIGJlIGluamVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5qZWN0Q1NTKHJvb3ROb2RlLCBjc3MpIHtcclxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxyXG5cdHZhciBleHBhbmRvID0gcm9vdE5vZGVbRVhQQU5ET19LRVldIHx8IChyb290Tm9kZVtFWFBBTkRPX0tFWV0gPSB7fSk7XHJcblx0aWYgKCFleHBhbmRvLmNvbnRhaW5zU3R5bGVzKSB7XHJcblx0XHRleHBhbmRvLmNvbnRhaW5zU3R5bGVzID0gdHJ1ZTtcclxuXHRcdGNzcyA9ICcvKiBDaGFydC5qcyAqL1xcbicgKyBjc3M7XHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XHJcblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHRcdHJvb3ROb2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcclxuXHQvKipcclxuXHQgKiBXaGVuIGB0cnVlYCwgcHJldmVudHMgdGhlIGF1dG9tYXRpYyBpbmplY3Rpb24gb2YgdGhlIHN0eWxlc2hlZXQgcmVxdWlyZWQgdG9cclxuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xyXG5cdCAqIHN3aXRjaCBoYXMgYmVlbiBhZGRlZCB0byBhbGxvdyBleHRlcm5hbCBzdHlsZXNoZWV0IChgZGlzdC9DaGFydCgubWluKT8uanNgKVxyXG5cdCAqIHRvIGJlIG1hbnVhbGx5IGltcG9ydGVkIHRvIG1ha2UgdGhpcyBsaWJyYXJ5IGNvbXBhdGlibGUgd2l0aCBhbnkgQ1NQLlxyXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxyXG5cdCAqL1xyXG5cdGRpc2FibGVDU1NJbmplY3Rpb246IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIHByb3BlcnR5IGhvbGRzIHdoZXRoZXIgdGhpcyBwbGF0Zm9ybSBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyByZXNvdXJjZXMgdGhhdCBkZXBlbmQgb24gcGxhdGZvcm0gb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgQ2FudmFzIGVsZW1lbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZW5zdXJlTG9hZGVkOiBmdW5jdGlvbihjYW52YXMpIHtcclxuXHRcdGlmICghdGhpcy5kaXNhYmxlQ1NTSW5qZWN0aW9uKSB7XHJcblx0XHRcdC8vIElmIHRoZSBjYW52YXMgaXMgaW4gYSBzaGFkb3cgRE9NLCB0aGVuIHRoZSBzdHlsZXMgbXVzdCBhbHNvIGJlIGluc2VydGVkXHJcblx0XHRcdC8vIGludG8gdGhlIHNhbWUgc2hhZG93IERPTS5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU3NjNcclxuXHRcdFx0dmFyIHJvb3QgPSBjYW52YXMuZ2V0Um9vdE5vZGUgPyBjYW52YXMuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xyXG5cdFx0XHR2YXIgdGFyZ2V0Tm9kZSA9IHJvb3QuaG9zdCA/IHJvb3QgOiBkb2N1bWVudC5oZWFkO1xyXG5cdFx0XHRpbmplY3RDU1ModGFyZ2V0Tm9kZSwgc3R5bGVzaGVldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xyXG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XHJcblx0XHR9IGVsc2UgaWYgKGl0ZW0ubGVuZ3RoKSB7XHJcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxyXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xyXG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcclxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcclxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xyXG5cdFx0dmFyIGNvbnRleHQgPSBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0Ly8gYGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBmYWlscyB3aGVuIHRoZSBpdGVtIGlzXHJcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXHJcblx0XHQvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xyXG5cdFx0Ly8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgaXRlbSBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGl0ZW0gYXMgYGNhbnZhc2AuXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTUyXHJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xyXG5cdFx0XHQvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBpdCBwb3NzaWJsZSB0b1xyXG5cdFx0XHQvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cclxuXHRcdFx0dGhpcy5fZW5zdXJlTG9hZGVkKGl0ZW0pO1xyXG5cdFx0XHRpbml0Q2FudmFzKGl0ZW0sIGNvbmZpZyk7XHJcblx0XHRcdHJldHVybiBjb250ZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdHJlbGVhc2VDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XHJcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XHJcblx0XHRpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xyXG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcclxuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHZhbHVlKSkge1xyXG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuXHRcdFx0Y2FudmFzLnN0eWxlW2tleV0gPSB2YWx1ZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxyXG5cdFx0Ly8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XHJcblx0XHQvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxyXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xyXG5cclxuXHRcdGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xyXG5cdH0sXHJcblxyXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xyXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xyXG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxyXG5cdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMsIGxpc3RlbmVyLCBjaGFydCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCAobGlzdGVuZXJbRVhQQU5ET19LRVldID0ge30pO1xyXG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwgKGV4cGFuZG8ucHJveGllcyA9IHt9KTtcclxuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0YWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XHJcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGNhbnZhcyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCB7fTtcclxuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IHt9O1xyXG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdO1xyXG5cdFx0aWYgKCFwcm94eSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmVtb3ZlTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGluc3RlYWQuXHJcbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFkZEV2ZW50XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLmFkZEV2ZW50ID0gYWRkTGlzdGVuZXI7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyIGluc3RlYWQuXHJcbiAqIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLnJlbW92ZUV2ZW50XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLnJlbW92ZUV2ZW50ID0gcmVtb3ZlTGlzdGVuZXI7XG5cbi8vIEBUT0RPIE1ha2UgcG9zc2libGUgdG8gc2VsZWN0IGFub3RoZXIgcGxhdGZvcm0gYXQgYnVpbGQgdGltZS5cclxudmFyIGltcGxlbWVudGF0aW9uID0gcGxhdGZvcm1fZG9tJDIuX2VuYWJsZWQgPyBwbGF0Zm9ybV9kb20kMiA6IHBsYXRmb3JtX2Jhc2ljO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGxhdGZvcm1cclxuICogQHNlZSBodHRwczovL2NoYXJ0anMuZ2l0Ym9va3MuaW8vcHJvcG9zYWxzL2NvbnRlbnQvUGxhdGZvcm0uaHRtbFxyXG4gKiBAc2luY2UgMi40LjBcclxuICovXHJcbnZhciBwbGF0Zm9ybSA9IGhlbHBlcnMkMS5leHRlbmQoe1xyXG5cdC8qKlxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcclxuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cclxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgbmF0aXZlIGl0ZW0gZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmQgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxyXG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXHJcblx0ICovXHJcblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXHJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xyXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cclxuXHQgKi9cclxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byByZW1vdmVcclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxyXG5cdCAqL1xyXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cclxuXHJcbn0sIGltcGxlbWVudGF0aW9uKTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0cGx1Z2luczoge31cclxufSk7XHJcblxyXG4vKipcclxuICogVGhlIHBsdWdpbiBzZXJ2aWNlIHNpbmdsZXRvblxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcclxuICogQHNpbmNlIDIuMS4wXHJcbiAqL1xyXG52YXIgY29yZV9wbHVnaW5zID0ge1xyXG5cdC8qKlxyXG5cdCAqIEdsb2JhbGx5IHJlZ2lzdGVyZWQgcGx1Z2lucy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9wbHVnaW5zOiBbXSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpZGVudGlmaWVyIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSB0aGUgZGVzY3JpcHRvcnMgY2FjaGUgYXR0YWNoZWQgdG8gZWFjaCBjaGFydFxyXG5cdCAqIHdoZW4gYSBnbG9iYWwgcGx1Z2luIGlzIHJlZ2lzdGVyZWQgb3IgdW5yZWdpc3RlcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBjYWNoZSBJRCBpc1xyXG5cdCAqIGluY3JlbWVudGVkIGFuZCBkZXNjcmlwdG9ycyBhcmUgcmVnZW5lcmF0ZWQgZHVyaW5nIGZvbGxvd2luZyBBUEkgY2FsbHMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY2FjaGVJZDogMCxcclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC5cclxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cclxuXHQgKi9cclxuXHRyZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xyXG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcclxuXHRcdFx0aWYgKHAuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xyXG5cdFx0XHRcdHAucHVzaChwbHVnaW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLl9jYWNoZUlkKys7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBvbmx5IGlmIHJlZ2lzdGVyZWQuXHJcblx0ICogQHBhcmFtIHtJUGx1Z2luW118SVBsdWdpbn0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXHJcblx0ICovXHJcblx0dW5yZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xyXG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcclxuXHRcdFx0dmFyIGlkeCA9IHAuaW5kZXhPZihwbHVnaW4pO1xyXG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xyXG5cdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuX2NhY2hlSWQrKztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cclxuXHQgKiBAc2luY2UgMi4xLjVcclxuXHQgKi9cclxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl9wbHVnaW5zID0gW107XHJcblx0XHR0aGlzLl9jYWNoZUlkKys7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZ2lzdGVyZWQgcGx1Z2lucz9cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBzaW5jZSAyLjEuNVxyXG5cdCAqL1xyXG5cdGNvdW50OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbiBpbnN0YW5jZXMuXHJcblx0ICogQHJldHVybnMge0lQbHVnaW5bXX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXHJcblx0ICogQHNpbmNlIDIuMS41XHJcblx0ICovXHJcblx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBmb3IgYGNoYXJ0YCBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXHJcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxyXG5cdCAqL1xyXG5cdG5vdGlmeTogZnVuY3Rpb24oY2hhcnQsIGhvb2ssIGFyZ3MpIHtcclxuXHRcdHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xyXG5cdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgZGVzY3JpcHRvciwgcGx1Z2luLCBwYXJhbXMsIG1ldGhvZDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcclxuXHRcdFx0cGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XHJcblx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRwYXJhbXMgPSBbY2hhcnRdLmNvbmNhdChhcmdzIHx8IFtdKTtcclxuXHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xyXG5cdFx0XHRcdGlmIChtZXRob2QuYXBwbHkocGx1Z2luLCBwYXJhbXMpID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgZGVzY3JpcHRvcnMgb2YgZW5hYmxlZCBwbHVnaW5zIGZvciB0aGUgZ2l2ZW4gY2hhcnQuXHJcblx0ICogQHJldHVybnMge29iamVjdFtdfSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGNhY2hlID0gY2hhcnQuJHBsdWdpbnMgfHwgKGNoYXJ0LiRwbHVnaW5zID0ge30pO1xyXG5cdFx0aWYgKGNhY2hlLmlkID09PSB0aGlzLl9jYWNoZUlkKSB7XHJcblx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGx1Z2lucyA9IFtdO1xyXG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gW107XHJcblx0XHR2YXIgY29uZmlnID0gKGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZykgfHwge307XHJcblx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9wbHVnaW5zLmNvbmNhdChjb25maWcucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcclxuXHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xyXG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGlkID0gcGx1Z2luLmlkO1xyXG5cdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xyXG5cdFx0XHRpZiAob3B0cyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRzID09PSB0cnVlKSB7XHJcblx0XHRcdFx0b3B0cyA9IGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG5cdFx0XHRkZXNjcmlwdG9ycy5wdXNoKHtcclxuXHRcdFx0XHRwbHVnaW46IHBsdWdpbixcclxuXHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y2FjaGUuZGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycztcclxuXHRcdGNhY2hlLmlkID0gdGhpcy5fY2FjaGVJZDtcclxuXHRcdHJldHVybiBkZXNjcmlwdG9ycztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbnZhbGlkYXRlcyBjYWNoZSBmb3IgdGhlIGdpdmVuIGNoYXJ0OiBkZXNjcmlwdG9ycyBob2xkIGEgcmVmZXJlbmNlIG9uIHBsdWdpbiBvcHRpb24sXHJcblx0ICogYnV0IGluIHNvbWUgY2FzZXMsIHRoaXMgcmVmZXJlbmNlIGNhbiBiZSBjaGFuZ2VkIGJ5IHRoZSB1c2VyIHdoZW4gdXBkYXRpbmcgb3B0aW9ucy5cclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaW52YWxpZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdGRlbGV0ZSBjaGFydC4kcGx1Z2lucztcclxuXHR9XHJcbn07XG5cbnZhciBjb3JlX3NjYWxlU2VydmljZSA9IHtcclxuXHQvLyBTY2FsZSByZWdpc3RyYXRpb24gb2JqZWN0LiBFeHRlbnNpb25zIGNhbiByZWdpc3RlciBuZXcgc2NhbGUgdHlwZXMgKHN1Y2ggYXMgbG9nIG9yIERCIHNjYWxlcykgYW5kIHRoZW5cclxuXHQvLyB1c2UgdGhlIG5ldyBjaGFydCBvcHRpb25zIHRvIGdyYWIgdGhlIGNvcnJlY3Qgc2NhbGVcclxuXHRjb25zdHJ1Y3RvcnM6IHt9LFxyXG5cdC8vIFVzZSBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBzbyB0aGF0IHdlIGNhbiBtb3ZlIHRvIGFuIEVTNiBtYXAgd2hlbiB3ZSBubyBsb25nZXIgbmVlZCB0byBzdXBwb3J0XHJcblx0Ly8gb2xkIGJyb3dzZXJzXHJcblxyXG5cdC8vIFNjYWxlIGNvbmZpZyBkZWZhdWx0c1xyXG5cdGRlZmF1bHRzOiB7fSxcclxuXHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3Rvciwgc2NhbGVEZWZhdWx0cykge1xyXG5cdFx0dGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gPSBzY2FsZUNvbnN0cnVjdG9yO1xyXG5cdFx0dGhpcy5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5jbG9uZShzY2FsZURlZmF1bHRzKTtcclxuXHR9LFxyXG5cdGdldFNjYWxlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IHRoaXMuY29uc3RydWN0b3JzW3R5cGVdIDogdW5kZWZpbmVkO1xyXG5cdH0sXHJcblx0Z2V0U2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0Ly8gUmV0dXJuIHRoZSBzY2FsZSBkZWZhdWx0cyBtZXJnZWQgd2l0aCB0aGUgZ2xvYmFsIHNldHRpbmdzIHNvIHRoYXQgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IG9uZXNcclxuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycyQxLm1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtjb3JlX2RlZmF1bHRzLnNjYWxlLCB0aGlzLmRlZmF1bHRzW3R5cGVdXSkgOiB7fTtcclxuXHR9LFxyXG5cdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGlmIChtZS5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xyXG5cdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdC8vIEFkZHMgZWFjaCBzY2FsZSB0byB0aGUgY2hhcnQuYm94ZXMgYXJyYXkgdG8gYmUgc2l6ZWQgYWNjb3JkaW5nbHlcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcclxuXHRcdFx0Ly8gU2V0IElMYXlvdXRJdGVtIHBhcmFtZXRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdHNjYWxlLmZ1bGxXaWR0aCA9IHNjYWxlLm9wdGlvbnMuZnVsbFdpZHRoO1xyXG5cdFx0XHRzY2FsZS5wb3NpdGlvbiA9IHNjYWxlLm9wdGlvbnMucG9zaXRpb247XHJcblx0XHRcdHNjYWxlLndlaWdodCA9IHNjYWxlLm9wdGlvbnMud2VpZ2h0O1xyXG5cdFx0XHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBzY2FsZSk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ4ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG52YXIgZ2V0UnRsSGVscGVyID0gaGVscGVycyQxLnJ0bC5nZXRSdGxBZGFwdGVyO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRjdXN0b206IG51bGwsXHJcblx0XHRtb2RlOiAnbmVhcmVzdCcsXHJcblx0XHRwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxyXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxyXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcclxuXHRcdHRpdGxlRm9udFN0eWxlOiAnYm9sZCcsXHJcblx0XHR0aXRsZVNwYWNpbmc6IDIsXHJcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogNixcclxuXHRcdHRpdGxlRm9udENvbG9yOiAnI2ZmZicsXHJcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXHJcblx0XHRib2R5U3BhY2luZzogMixcclxuXHRcdGJvZHlGb250Q29sb3I6ICcjZmZmJyxcclxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxyXG5cdFx0Zm9vdGVyRm9udFN0eWxlOiAnYm9sZCcsXHJcblx0XHRmb290ZXJTcGFjaW5nOiAyLFxyXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiAnI2ZmZicsXHJcblx0XHRmb290ZXJBbGlnbjogJ2xlZnQnLFxyXG5cdFx0eVBhZGRpbmc6IDYsXHJcblx0XHR4UGFkZGluZzogNixcclxuXHRcdGNhcmV0UGFkZGluZzogMixcclxuXHRcdGNhcmV0U2l6ZTogNSxcclxuXHRcdGNvcm5lclJhZGl1czogNixcclxuXHRcdG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxyXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcclxuXHRcdGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXHJcblx0XHRib3JkZXJXaWR0aDogMCxcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcclxuXHRcdFx0YmVmb3JlVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XHJcblx0XHRcdFx0dmFyIHRpdGxlID0gJyc7XHJcblx0XHRcdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xyXG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XHJcblxyXG5cdFx0XHRcdGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XHJcblx0XHRcdFx0XHRpZiAoaXRlbS5sYWJlbCkge1xyXG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ubGFiZWw7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0ueExhYmVsKSB7XHJcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uaW5kZXggPCBsYWJlbENvdW50KSB7XHJcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxyXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0XHRcdGJlZm9yZUxhYmVsOiBoZWxwZXJzJDEubm9vcCxcclxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XHJcblx0XHRcdFx0dmFyIGxhYmVsID0gZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xyXG5cclxuXHRcdFx0XHRpZiAobGFiZWwpIHtcclxuXHRcdFx0XHRcdGxhYmVsICs9ICc6ICc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodG9vbHRpcEl0ZW0udmFsdWUpKSB7XHJcblx0XHRcdFx0XHRsYWJlbCArPSB0b29sdGlwSXRlbS52YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0ueUxhYmVsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsQ29sb3I6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBjaGFydCkge1xyXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IG1ldGEuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XHJcblx0XHRcdFx0dmFyIHZpZXcgPSBhY3RpdmVFbGVtZW50Ll92aWV3O1xyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogdmlldy5ib3JkZXJDb2xvcixcclxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogdmlldy5iYWNrZ3JvdW5kQ29sb3JcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYWJlbFRleHRDb2xvcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYm9keUZvbnRDb2xvcjtcclxuXHRcdFx0fSxcclxuXHRcdFx0YWZ0ZXJMYWJlbDogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcclxuXHRcdFx0YWZ0ZXJCb2R5OiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxyXG5cdFx0XHRiZWZvcmVGb290ZXI6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHRhZnRlckZvb3RlcjogaGVscGVycyQxLm5vb3BcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIHBvc2l0aW9uZXJzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXHJcblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMuYXZlcmFnZVxyXG5cdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnRFbGVtZW50W119IHRoZSBlbGVtZW50cyBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXBcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIHBvc2l0aW9uXHJcblx0ICovXHJcblx0YXZlcmFnZTogZnVuY3Rpb24oZWxlbWVudHMpIHtcclxuXHRcdGlmICghZWxlbWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cdFx0dmFyIHggPSAwO1xyXG5cdFx0dmFyIHkgPSAwO1xyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcclxuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHR2YXIgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XHJcblx0XHRcdFx0eCArPSBwb3MueDtcclxuXHRcdFx0XHR5ICs9IHBvcy55O1xyXG5cdFx0XHRcdCsrY291bnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB4IC8gY291bnQsXHJcblx0XHRcdHk6IHkgLyBjb3VudFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cclxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5uZWFyZXN0XHJcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydC5FbGVtZW50W119IHRoZSB0b29sdGlwIGVsZW1lbnRzXHJcblx0ICogQHBhcmFtIGV2ZW50UG9zaXRpb24ge29iamVjdH0gdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBpbiBjYW52YXMgY29vcmRpbmF0ZXNcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBwb3NpdGlvblxyXG5cdCAqL1xyXG5cdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XHJcblx0XHR2YXIgeCA9IGV2ZW50UG9zaXRpb24ueDtcclxuXHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xyXG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cdFx0dmFyIGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHRcdFx0dmFyIGVsID0gZWxlbWVudHNbaV07XHJcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XHJcblx0XHRcdFx0dmFyIGQgPSBoZWxwZXJzJDEuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XHJcblxyXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdGFuY2UpIHtcclxuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gZDtcclxuXHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5lYXJlc3RFbGVtZW50KSB7XHJcblx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xyXG5cdFx0XHR4ID0gdHAueDtcclxuXHRcdFx0eSA9IHRwLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogeCxcclxuXHRcdFx0eTogeVxyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XHJcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcclxuXHRpZiAodG9QdXNoKSB7XHJcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodG9QdXNoKSkge1xyXG5cdFx0XHQvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcclxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJhc2UucHVzaCh0b1B1c2gpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGJhc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSB2YWx1ZSBpZiBuZXdsaW5lIHByZXNlbnQgLSBSZXR1cm5lZCBmcm9tIFN0cmluZyBzcGxpdCgpIG1ldGhvZFxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XHJcblx0aWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XHJcblx0XHRyZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcclxuXHR9XHJcblx0cmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBQcml2YXRlIGhlbHBlciB0byBjcmVhdGUgYSB0b29sdGlwIGl0ZW0gbW9kZWxcclxuICogQHBhcmFtIGVsZW1lbnQgLSB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XHJcblx0dmFyIHhTY2FsZSA9IGVsZW1lbnQuX3hTY2FsZTtcclxuXHR2YXIgeVNjYWxlID0gZWxlbWVudC5feVNjYWxlIHx8IGVsZW1lbnQuX3NjYWxlOyAvLyBoYW5kbGUgcmFkYXIgfHwgcG9sYXJBcmVhIGNoYXJ0c1xyXG5cdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xyXG5cdHZhciBkYXRhc2V0SW5kZXggPSBlbGVtZW50Ll9kYXRhc2V0SW5kZXg7XHJcblx0dmFyIGNvbnRyb2xsZXIgPSBlbGVtZW50Ll9jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XHJcblx0dmFyIGluZGV4U2NhbGUgPSBjb250cm9sbGVyLl9nZXRJbmRleFNjYWxlKCk7XHJcblx0dmFyIHZhbHVlU2NhbGUgPSBjb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlKCk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHR5TGFiZWw6IHlTY2FsZSA/IHlTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHRsYWJlbDogaW5kZXhTY2FsZSA/ICcnICsgaW5kZXhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHR2YWx1ZTogdmFsdWVTY2FsZSA/ICcnICsgdmFsdWVTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXHJcblx0XHRpbmRleDogaW5kZXgsXHJcblx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcclxuXHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXHJcblx0XHR5OiBlbGVtZW50Ll9tb2RlbC55XHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgdGhlIHJlc2V0IG1vZGVsIGZvciB0aGUgdG9vbHRpcFxyXG4gKiBAcGFyYW0gdG9vbHRpcE9wdHMge29iamVjdH0gdGhlIHRvb2x0aXAgb3B0aW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmFzZU1vZGVsKHRvb2x0aXBPcHRzKSB7XHJcblx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBQb3NpdGlvbmluZ1xyXG5cdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxyXG5cdFx0eVBhZGRpbmc6IHRvb2x0aXBPcHRzLnlQYWRkaW5nLFxyXG5cdFx0eEFsaWduOiB0b29sdGlwT3B0cy54QWxpZ24sXHJcblx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcclxuXHJcblx0XHQvLyBEcmF3aW5nIGRpcmVjdGlvbiBhbmQgdGV4dCBkaXJlY3Rpb25cclxuXHRcdHJ0bDogdG9vbHRpcE9wdHMucnRsLFxyXG5cdFx0dGV4dERpcmVjdGlvbjogdG9vbHRpcE9wdHMudGV4dERpcmVjdGlvbixcclxuXHJcblx0XHQvLyBCb2R5XHJcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxyXG5cdFx0X2JvZHlGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLmJvZHlGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRfYm9keUZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5ib2R5Rm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcclxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcclxuXHRcdGJvZHlGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5ib2R5Rm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXHJcblx0XHRib2R5U3BhY2luZzogdG9vbHRpcE9wdHMuYm9keVNwYWNpbmcsXHJcblxyXG5cdFx0Ly8gVGl0bGVcclxuXHRcdHRpdGxlRm9udENvbG9yOiB0b29sdGlwT3B0cy50aXRsZUZvbnRDb2xvcixcclxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRfdGl0bGVGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMudGl0bGVGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxyXG5cdFx0dGl0bGVGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy50aXRsZUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxyXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXHJcblx0XHR0aXRsZVNwYWNpbmc6IHRvb2x0aXBPcHRzLnRpdGxlU3BhY2luZyxcclxuXHRcdHRpdGxlTWFyZ2luQm90dG9tOiB0b29sdGlwT3B0cy50aXRsZU1hcmdpbkJvdHRvbSxcclxuXHJcblx0XHQvLyBGb290ZXJcclxuXHRcdGZvb3RlckZvbnRDb2xvcjogdG9vbHRpcE9wdHMuZm9vdGVyRm9udENvbG9yLFxyXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxyXG5cdFx0X2Zvb3RlckZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5mb290ZXJGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxyXG5cdFx0Zm9vdGVyRm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuZm9vdGVyRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXHJcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxyXG5cdFx0Zm9vdGVyU3BhY2luZzogdG9vbHRpcE9wdHMuZm9vdGVyU3BhY2luZyxcclxuXHRcdGZvb3Rlck1hcmdpblRvcDogdG9vbHRpcE9wdHMuZm9vdGVyTWFyZ2luVG9wLFxyXG5cclxuXHRcdC8vIEFwcGVhcmFuY2VcclxuXHRcdGNhcmV0U2l6ZTogdG9vbHRpcE9wdHMuY2FyZXRTaXplLFxyXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBPcHRzLmJhY2tncm91bmRDb2xvcixcclxuXHRcdG9wYWNpdHk6IDAsXHJcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcclxuXHRcdGRpc3BsYXlDb2xvcnM6IHRvb2x0aXBPcHRzLmRpc3BsYXlDb2xvcnMsXHJcblx0XHRib3JkZXJDb2xvcjogdG9vbHRpcE9wdHMuYm9yZGVyQ29sb3IsXHJcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBtb2RlbCkge1xyXG5cdHZhciBjdHggPSB0b29sdGlwLl9jaGFydC5jdHg7XHJcblxyXG5cdHZhciBoZWlnaHQgPSBtb2RlbC55UGFkZGluZyAqIDI7IC8vIFRvb2x0aXAgUGFkZGluZ1xyXG5cdHZhciB3aWR0aCA9IDA7XHJcblxyXG5cdC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxyXG5cdHZhciBib2R5ID0gbW9kZWwuYm9keTtcclxuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XHJcblx0XHRyZXR1cm4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoO1xyXG5cdH0sIDApO1xyXG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XHJcblxyXG5cdHZhciB0aXRsZUxpbmVDb3VudCA9IG1vZGVsLnRpdGxlLmxlbmd0aDtcclxuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcclxuXHR2YXIgdGl0bGVGb250U2l6ZSA9IG1vZGVsLnRpdGxlRm9udFNpemU7XHJcblx0dmFyIGJvZHlGb250U2l6ZSA9IG1vZGVsLmJvZHlGb250U2l6ZTtcclxuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcclxuXHJcblx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250U2l6ZTsgLy8gVGl0bGUgTGluZXNcclxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xyXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/IG1vZGVsLnRpdGxlTWFyZ2luQm90dG9tIDogMDsgLy8gVGl0bGUncyBib3R0b20gTWFyZ2luXHJcblx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCAqIGJvZHlGb250U2l6ZTsgLy8gQm9keSBMaW5lc1xyXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXHJcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IG1vZGVsLmZvb3Rlck1hcmdpblRvcCA6IDA7IC8vIEZvb3RlciBNYXJnaW5cclxuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ICogKGZvb3RlckZvbnRTaXplKTsgLy8gRm9vdGVyIExpbmVzXHJcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXHJcblxyXG5cdC8vIFRpdGxlIHdpZHRoXHJcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XHJcblx0dmFyIG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XHJcblx0fTtcclxuXHJcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCBtb2RlbC5fdGl0bGVGb250U3R5bGUsIG1vZGVsLl90aXRsZUZvbnRGYW1pbHkpO1xyXG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xyXG5cclxuXHQvLyBCb2R5IHdpZHRoXHJcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xyXG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmJlZm9yZUJvZHkuY29uY2F0KG1vZGVsLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XHJcblxyXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxyXG5cdHdpZHRoUGFkZGluZyA9IG1vZGVsLmRpc3BsYXlDb2xvcnMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xyXG5cdGhlbHBlcnMkMS5lYWNoKGJvZHksIGZ1bmN0aW9uKGJvZHlJdGVtKSB7XHJcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XHJcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBSZXNldCBiYWNrIHRvIDBcclxuXHR3aWR0aFBhZGRpbmcgPSAwO1xyXG5cclxuXHQvLyBGb290ZXIgd2lkdGhcclxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XHJcblx0aGVscGVycyQxLmVhY2gobW9kZWwuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xyXG5cclxuXHQvLyBBZGQgcGFkZGluZ1xyXG5cdHdpZHRoICs9IDIgKiBtb2RlbC54UGFkZGluZztcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHdpZHRoOiB3aWR0aCxcclxuXHRcdGhlaWdodDogaGVpZ2h0XHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcclxuICovXHJcbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XHJcblx0dmFyIG1vZGVsID0gdG9vbHRpcC5fbW9kZWw7XHJcblx0dmFyIGNoYXJ0ID0gdG9vbHRpcC5fY2hhcnQ7XHJcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcclxuXHR2YXIgeEFsaWduID0gJ2NlbnRlcic7XHJcblx0dmFyIHlBbGlnbiA9ICdjZW50ZXInO1xyXG5cclxuXHRpZiAobW9kZWwueSA8IHNpemUuaGVpZ2h0KSB7XHJcblx0XHR5QWxpZ24gPSAndG9wJztcclxuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XHJcblx0XHR5QWxpZ24gPSAnYm90dG9tJztcclxuXHR9XHJcblxyXG5cdHZhciBsZiwgcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgbGVmdCwgcmlnaHQgYWxpZ25tZW50XHJcblx0dmFyIG9sZiwgb3JmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGlmIGxlZnQvcmlnaHQgYWxpZ25tZW50IGNhdXNlcyB0b29sdGlwIHRvIGdvIG91dHNpZGUgY2hhcnRcclxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXHJcblx0dmFyIG1pZFggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcclxuXHR2YXIgbWlkWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xyXG5cclxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xyXG5cdFx0bGYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XHJcblx0XHR9O1xyXG5cdFx0cmYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4geCA8PSAoc2l6ZS53aWR0aCAvIDIpO1xyXG5cdFx0fTtcclxuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4geCA+PSAoY2hhcnQud2lkdGggLSAoc2l6ZS53aWR0aCAvIDIpKTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRvbGYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcclxuXHR9O1xyXG5cdG9yZiA9IGZ1bmN0aW9uKHgpIHtcclxuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XHJcblx0fTtcclxuXHR5ZiA9IGZ1bmN0aW9uKHkpIHtcclxuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xyXG5cdH07XHJcblxyXG5cdGlmIChsZihtb2RlbC54KSkge1xyXG5cdFx0eEFsaWduID0gJ2xlZnQnO1xyXG5cclxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xyXG5cdFx0aWYgKG9sZihtb2RlbC54KSkge1xyXG5cdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChyZihtb2RlbC54KSkge1xyXG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcclxuXHJcblx0XHQvLyBJcyB0b29sdGlwIHRvbyB3aWRlIGFuZCBnb2VzIG91dHNpZGUgbGVmdCBlZGdlIG9mIGNhbnZhcz9cclxuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcclxuXHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XHJcblx0XHRcdHlBbGlnbiA9IHlmKG1vZGVsLnkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xyXG5cdHJldHVybiB7XHJcblx0XHR4QWxpZ246IG9wdHMueEFsaWduID8gb3B0cy54QWxpZ24gOiB4QWxpZ24sXHJcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludCh2bSwgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xyXG5cdC8vIEJhY2tncm91bmQgUG9zaXRpb25cclxuXHR2YXIgeCA9IHZtLng7XHJcblx0dmFyIHkgPSB2bS55O1xyXG5cclxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xyXG5cdHZhciBjYXJldFBhZGRpbmcgPSB2bS5jYXJldFBhZGRpbmc7XHJcblx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcclxuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcclxuXHR2YXIgeUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcclxuXHR2YXIgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XHJcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XHJcblxyXG5cdGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdHggLT0gc2l6ZS53aWR0aDtcclxuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuXHRcdHggLT0gKHNpemUud2lkdGggLyAyKTtcclxuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XHJcblx0XHRcdHggPSBjaGFydC53aWR0aCAtIHNpemUud2lkdGg7XHJcblx0XHR9XHJcblx0XHRpZiAoeCA8IDApIHtcclxuXHRcdFx0eCA9IDA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoeUFsaWduID09PSAndG9wJykge1xyXG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcclxuXHR9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcclxuXHRcdHkgLT0gc2l6ZS5oZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0eSAtPSAoc2l6ZS5oZWlnaHQgLyAyKTtcclxuXHR9XHJcblxyXG5cdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XHJcblx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcclxuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcclxuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XHJcblx0XHRcdHggLT0gcGFkZGluZ0FuZFNpemU7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0eCAtPSByYWRpdXNBbmRQYWRkaW5nO1xyXG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XHJcblx0XHR4ICs9IHJhZGl1c0FuZFBhZGRpbmc7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogeCxcclxuXHRcdHk6IHlcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh2bSwgYWxpZ24pIHtcclxuXHRyZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXHJcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcclxuXHRcdDogYWxpZ24gPT09ICdyaWdodCdcclxuXHRcdFx0PyB2bS54ICsgdm0ud2lkdGggLSB2bS54UGFkZGluZ1xyXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcclxuICovXHJcbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XHJcblx0cmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xyXG59XHJcblxyXG52YXIgZXhwb3J0cyQ0ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhc3RBY3RpdmUgPSBbXTtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIHRpdGxlXHJcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcclxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcclxuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcclxuXHJcblx0XHR2YXIgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHR2YXIgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IFtdO1xyXG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcclxuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XHJcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxyXG5cdGdldEJvZHk6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XHJcblx0XHR2YXIgYm9keUl0ZW1zID0gW107XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xyXG5cdFx0XHR2YXIgYm9keUl0ZW0gPSB7XHJcblx0XHRcdFx0YmVmb3JlOiBbXSxcclxuXHRcdFx0XHRsaW5lczogW10sXHJcblx0XHRcdFx0YWZ0ZXI6IFtdXHJcblx0XHRcdH07XHJcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmJlZm9yZUxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSkpO1xyXG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGNhbGxiYWNrcy5sYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xyXG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XHJcblxyXG5cdFx0XHRib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYm9keUl0ZW1zO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcclxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxyXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNhbGxiYWNrcyA9IG1lLl9vcHRpb25zLmNhbGxiYWNrcztcclxuXHJcblx0XHR2YXIgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdHZhciBmb290ZXIgPSBjYWxsYmFja3MuZm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IFtdO1xyXG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XHJcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcclxuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhbmdlZCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XHJcblxyXG5cdFx0Ly8gTmVlZCB0byByZWdlbmVyYXRlIHRoZSBtb2RlbCBiZWNhdXNlIGl0cyBmYXN0ZXIgdGhhbiB1c2luZyBleHRlbmQgYW5kIGl0IGlzIG5lY2Vzc2FyeSBkdWUgdG8gdGhlIG9wdGltaXphdGlvbiBpbiBDaGFydC5FbGVtZW50LnRyYW5zaXRpb25cclxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcclxuXHRcdC8vIHdoaWNoIGJyZWFrcyBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdHZhciBleGlzdGluZ01vZGVsID0gbWUuX21vZGVsO1xyXG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xyXG5cdFx0dmFyIGFjdGl2ZSA9IG1lLl9hY3RpdmU7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcclxuXHJcblx0XHQvLyBJbiB0aGUgY2FzZSB3aGVyZSBhY3RpdmUubGVuZ3RoID09PSAwIHdlIG5lZWQgdG8ga2VlcCB0aGVzZSBhdCBleGlzdGluZyB2YWx1ZXMgZm9yIGdvb2QgYW5pbWF0aW9uc1xyXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcclxuXHRcdFx0eEFsaWduOiBleGlzdGluZ01vZGVsLnhBbGlnbixcclxuXHRcdFx0eUFsaWduOiBleGlzdGluZ01vZGVsLnlBbGlnblxyXG5cdFx0fTtcclxuXHRcdHZhciBiYWNrZ3JvdW5kUG9pbnQgPSB7XHJcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwueCxcclxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XHJcblx0XHR9O1xyXG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xyXG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcclxuXHRcdFx0aGVpZ2h0OiBleGlzdGluZ01vZGVsLmhlaWdodFxyXG5cdFx0fTtcclxuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XHJcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwuY2FyZXRYLFxyXG5cdFx0XHR5OiBleGlzdGluZ01vZGVsLmNhcmV0WVxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChhY3RpdmUubGVuZ3RoKSB7XHJcblx0XHRcdG1vZGVsLm9wYWNpdHkgPSAxO1xyXG5cclxuXHRcdFx0dmFyIGxhYmVsQ29sb3JzID0gW107XHJcblx0XHRcdHZhciBsYWJlbFRleHRDb2xvcnMgPSBbXTtcclxuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XHJcblxyXG5cdFx0XHR2YXIgdG9vbHRpcEl0ZW1zID0gW107XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cdFx0XHRcdHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKGFjdGl2ZVtpXSkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xyXG5cdFx0XHRpZiAob3B0cy5maWx0ZXIpIHtcclxuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcclxuXHRcdFx0XHRcdHJldHVybiBvcHRzLmZpbHRlcihhLCBkYXRhKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXHJcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XHJcblx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9wdHMuaXRlbVNvcnQoYSwgYiwgZGF0YSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcclxuXHRcdFx0XHRsYWJlbENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsQ29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xyXG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cclxuXHRcdFx0Ly8gQnVpbGQgdGhlIFRleHQgTGluZXNcclxuXHRcdFx0bW9kZWwudGl0bGUgPSBtZS5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5ib2R5ID0gbWUuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5hZnRlckJvZHkgPSBtZS5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcclxuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XHJcblxyXG5cdFx0XHQvLyBJbml0aWFsIHBvc2l0aW9uaW5nIGFuZCBjb2xvcnNcclxuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xyXG5cdFx0XHRtb2RlbC55ID0gdG9vbHRpcFBvc2l0aW9uLnk7XHJcblx0XHRcdG1vZGVsLmNhcmV0UGFkZGluZyA9IG9wdHMuY2FyZXRQYWRkaW5nO1xyXG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xyXG5cdFx0XHRtb2RlbC5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XHJcblxyXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xyXG5cdFx0XHRtb2RlbC5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xyXG5cclxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXHJcblx0XHRcdHRvb2x0aXBTaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgbW9kZWwpO1xyXG5cdFx0XHRhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcywgdG9vbHRpcFNpemUpO1xyXG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxyXG5cdFx0XHRiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQobW9kZWwsIHRvb2x0aXBTaXplLCBhbGlnbm1lbnQsIG1lLl9jaGFydCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xyXG5cdFx0bW9kZWwueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcclxuXHRcdG1vZGVsLnggPSBiYWNrZ3JvdW5kUG9pbnQueDtcclxuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcclxuXHRcdG1vZGVsLndpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XHJcblx0XHRtb2RlbC5oZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XHJcblxyXG5cdFx0Ly8gUG9pbnQgd2hlcmUgdGhlIGNhcmV0IG9uIHRoZSB0b29sdGlwIHBvaW50cyB0b1xyXG5cdFx0bW9kZWwuY2FyZXRYID0gdG9vbHRpcFBvc2l0aW9uLng7XHJcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcclxuXHJcblx0XHRtZS5fbW9kZWwgPSBtb2RlbDtcclxuXHJcblx0XHRpZiAoY2hhbmdlZCAmJiBvcHRzLmN1c3RvbSkge1xyXG5cdFx0XHRvcHRzLmN1c3RvbS5jYWxsKG1lLCBtb2RlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdGRyYXdDYXJldDogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplKSB7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pO1xyXG5cclxuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XHJcblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xyXG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcclxuXHR9LFxyXG5cdGdldENhcmV0UG9zaXRpb246IGZ1bmN0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pIHtcclxuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xyXG5cdFx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcclxuXHRcdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XHJcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xyXG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcclxuXHRcdHZhciBwdFggPSB0b29sdGlwUG9pbnQueDtcclxuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcclxuXHRcdHZhciB3aWR0aCA9IHNpemUud2lkdGg7XHJcblx0XHR2YXIgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuXHRcdFx0eTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcclxuXHRcdFx0XHR4MSA9IHB0WDtcclxuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHgzID0geDE7XHJcblxyXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XHJcblx0XHRcdFx0eTMgPSB5MiAtIGNhcmV0U2l6ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xyXG5cdFx0XHRcdHgyID0geDEgKyBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MTtcclxuXHJcblx0XHRcdFx0eTEgPSB5MiAtIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR5MyA9IHkyICsgY2FyZXRTaXplO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcclxuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xyXG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcclxuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdFx0XHR4MiA9IHB0WCArIHdpZHRoIC0gY29ybmVyUmFkaXVzIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR4MiA9IHZtLmNhcmV0WDtcclxuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcclxuXHRcdFx0XHR5MSA9IHB0WTtcclxuXHRcdFx0XHR5MiA9IHkxIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHkzID0geTE7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0eTEgPSBwdFkgKyBoZWlnaHQ7XHJcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR5MyA9IHkxO1xyXG5cdFx0XHRcdC8vIGludmVydCBkcmF3aW5nIG9yZGVyXHJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xyXG5cdFx0XHRcdHgzID0geDE7XHJcblx0XHRcdFx0eDEgPSB0bXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB7eDE6IHgxLCB4MjogeDIsIHgzOiB4MywgeTE6IHkxLCB5MjogeTIsIHkzOiB5M307XHJcblx0fSxcclxuXHJcblx0ZHJhd1RpdGxlOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xyXG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XHJcblx0XHR2YXIgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xyXG5cdFx0dmFyIHRpdGxlRm9udFNpemUsIHRpdGxlU3BhY2luZywgaTtcclxuXHJcblx0XHRpZiAobGVuZ3RoKSB7XHJcblx0XHRcdHZhciBydGxIZWxwZXIgPSBnZXRSdGxIZWxwZXIodm0ucnRsLCB2bS54LCB2bS53aWR0aCk7XHJcblxyXG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl90aXRsZUFsaWduKTtcclxuXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKHZtLl90aXRsZUFsaWduKTtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdFx0dGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XHJcblx0XHRcdHRpdGxlU3BhY2luZyA9IHZtLnRpdGxlU3BhY2luZztcclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS50aXRsZUZvbnRDb2xvcjtcclxuXHRcdFx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCB2bS5fdGl0bGVGb250U3R5bGUsIHZtLl90aXRsZUZvbnRGYW1pbHkpO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udFNpemUgLyAyKTtcclxuXHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXHJcblxyXG5cdFx0XHRcdGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRwdC55ICs9IHZtLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xyXG5cdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcclxuXHRcdHZhciBib2R5U3BhY2luZyA9IHZtLmJvZHlTcGFjaW5nO1xyXG5cdFx0dmFyIGJvZHlBbGlnbiA9IHZtLl9ib2R5QWxpZ247XHJcblx0XHR2YXIgYm9keSA9IHZtLmJvZHk7XHJcblx0XHR2YXIgZHJhd0NvbG9yQm94ZXMgPSB2bS5kaXNwbGF5Q29sb3JzO1xyXG5cdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XHJcblx0XHR2YXIgY29sb3JYID0gZHJhd0NvbG9yQm94ZXMgPyBnZXRBbGlnbmVkWCh2bSwgJ2xlZnQnKSA6IDA7XHJcblxyXG5cdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlcih2bS5ydGwsIHZtLngsIHZtLndpZHRoKTtcclxuXHJcblx0XHR2YXIgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XHJcblx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlGb250U2l6ZSAvIDIpO1xyXG5cdFx0XHRwdC55ICs9IGJvZHlGb250U2l6ZSArIGJvZHlTcGFjaW5nO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgYm9keUl0ZW0sIHRleHRDb2xvciwgbGFiZWxDb2xvcnMsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xyXG5cdFx0dmFyIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xyXG5cclxuXHRcdGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XHJcblxyXG5cdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbik7XHJcblxyXG5cdFx0Ly8gQmVmb3JlIGJvZHkgbGluZXNcclxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib2R5Rm9udENvbG9yO1xyXG5cdFx0aGVscGVycyQxLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xyXG5cclxuXHRcdHhMaW5lUGFkZGluZyA9IGRyYXdDb2xvckJveGVzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXHJcblx0XHRcdD8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib2R5Rm9udFNpemUgLyAyICsgMSkgOiAoYm9keUZvbnRTaXplICsgMilcclxuXHRcdFx0OiAwO1xyXG5cclxuXHRcdC8vIERyYXcgYm9keSBsaW5lcyBub3dcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRib2R5SXRlbSA9IGJvZHlbaV07XHJcblx0XHRcdHRleHRDb2xvciA9IHZtLmxhYmVsVGV4dENvbG9yc1tpXTtcclxuXHRcdFx0bGFiZWxDb2xvcnMgPSB2bS5sYWJlbENvbG9yc1tpXTtcclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xyXG5cclxuXHRcdFx0bGluZXMgPSBib2R5SXRlbS5saW5lcztcclxuXHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xyXG5cdFx0XHRcdC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXHJcblx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XHJcblx0XHRcdFx0XHR2YXIgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcclxuXHJcblx0XHRcdFx0XHQvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmxlZ2VuZENvbG9yQmFja2dyb3VuZDtcclxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJvZHlGb250U2l6ZSksIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcclxuXHJcblx0XHRcdFx0XHQvLyBCb3JkZXJcclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xyXG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJvZHlGb250U2l6ZSksIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcclxuXHJcblx0XHRcdFx0XHQvLyBJbm5lciBzcXVhcmVcclxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QocnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJvZHlGb250U2l6ZSAtIDIpLCBwdC55ICsgMSwgYm9keUZvbnRTaXplIC0gMiwgYm9keUZvbnRTaXplIC0gMik7XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IGJhY2sgdG8gMCBmb3IgYWZ0ZXIgYm9keVxyXG5cdFx0eExpbmVQYWRkaW5nID0gMDtcclxuXHJcblx0XHQvLyBBZnRlciBib2R5IGxpbmVzXHJcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcclxuXHRcdHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xyXG5cdH0sXHJcblxyXG5cdGRyYXdGb290ZXI6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XHJcblx0XHR2YXIgZm9vdGVyID0gdm0uZm9vdGVyO1xyXG5cdFx0dmFyIGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XHJcblx0XHR2YXIgZm9vdGVyRm9udFNpemUsIGk7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCkge1xyXG5cdFx0XHR2YXIgcnRsSGVscGVyID0gZ2V0UnRsSGVscGVyKHZtLnJ0bCwgdm0ueCwgdm0ud2lkdGgpO1xyXG5cclxuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xyXG5cdFx0XHRwdC55ICs9IHZtLmZvb3Rlck1hcmdpblRvcDtcclxuXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKHZtLl9mb290ZXJBbGlnbik7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcblx0XHRcdGZvb3RlckZvbnRTaXplID0gdm0uZm9vdGVyRm9udFNpemU7XHJcblxyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0uZm9vdGVyRm9udENvbG9yO1xyXG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnRTaXplIC8gMik7XHJcblx0XHRcdFx0cHQueSArPSBmb290ZXJGb250U2l6ZSArIHZtLmZvb3RlclNwYWNpbmc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKSB7XHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XHJcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xyXG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcclxuXHRcdHZhciB4ID0gcHQueDtcclxuXHRcdHZhciB5ID0gcHQueTtcclxuXHRcdHZhciB3aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xyXG5cdFx0dmFyIGhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcclxuXHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XHJcblxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcclxuXHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XHJcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XHJcblx0XHR9XHJcblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XHJcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XHJcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcclxuXHRcdH1cclxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcclxuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcclxuXHRcdGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XHJcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XHJcblx0XHR9XHJcblx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xyXG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XHJcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xyXG5cdFx0fVxyXG5cdFx0Y3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcclxuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xyXG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cclxuXHRcdGN0eC5maWxsKCk7XHJcblxyXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoID4gMCkge1xyXG5cdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHJcblx0XHRpZiAodm0ub3BhY2l0eSA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xyXG5cdFx0XHR3aWR0aDogdm0ud2lkdGgsXHJcblx0XHRcdGhlaWdodDogdm0uaGVpZ2h0XHJcblx0XHR9O1xyXG5cdFx0dmFyIHB0ID0ge1xyXG5cdFx0XHR4OiB2bS54LFxyXG5cdFx0XHR5OiB2bS55XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcclxuXHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XHJcblxyXG5cdFx0Ly8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxyXG5cdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcclxuXHJcblx0XHRpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcclxuXHRcdFx0dGhpcy5kcmF3QmFja2dyb3VuZChwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpO1xyXG5cclxuXHRcdFx0Ly8gRHJhdyBUaXRsZSwgQm9keSwgYW5kIEZvb3RlclxyXG5cdFx0XHRwdC55ICs9IHZtLnlQYWRkaW5nO1xyXG5cclxuXHRcdFx0aGVscGVycyQxLnJ0bC5vdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCB2bS50ZXh0RGlyZWN0aW9uKTtcclxuXHJcblx0XHRcdC8vIFRpdGxlc1xyXG5cdFx0XHR0aGlzLmRyYXdUaXRsZShwdCwgdm0sIGN0eCk7XHJcblxyXG5cdFx0XHQvLyBCb2R5XHJcblx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgpO1xyXG5cclxuXHRcdFx0Ly8gRm9vdGVyXHJcblx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCk7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEucnRsLnJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgdm0udGV4dERpcmVjdGlvbik7XHJcblxyXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZSBhbiBldmVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcclxuXHQgKi9cclxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX29wdGlvbnM7XHJcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuXHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2xhc3RBY3RpdmUgfHwgW107XHJcblxyXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXHJcblx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XHJcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLl9hY3RpdmUgPSBtZS5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMpO1xyXG5cdFx0XHRpZiAob3B0aW9ucy5yZXZlcnNlKSB7XHJcblx0XHRcdFx0bWUuX2FjdGl2ZS5yZXZlcnNlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcclxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLl9hY3RpdmUsIG1lLl9sYXN0QWN0aXZlKTtcclxuXHJcblx0XHQvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcclxuXHRcdGlmIChjaGFuZ2VkKSB7XHJcblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5jdXN0b20pIHtcclxuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcclxuXHRcdFx0XHRcdHg6IGUueCxcclxuXHRcdFx0XHRcdHk6IGUueVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdG1lLnVwZGF0ZSh0cnVlKTtcclxuXHRcdFx0XHRtZS5waXZvdCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcclxuICovXHJcbnZhciBwb3NpdGlvbmVyc18xID0gcG9zaXRpb25lcnM7XHJcblxyXG52YXIgY29yZV90b29sdGlwID0gZXhwb3J0cyQ0O1xuY29yZV90b29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnNfMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDkgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRlbGVtZW50czoge30sXHJcblx0ZXZlbnRzOiBbXHJcblx0XHQnbW91c2Vtb3ZlJyxcclxuXHRcdCdtb3VzZW91dCcsXHJcblx0XHQnY2xpY2snLFxyXG5cdFx0J3RvdWNoc3RhcnQnLFxyXG5cdFx0J3RvdWNobW92ZSdcclxuXHRdLFxyXG5cdGhvdmVyOiB7XHJcblx0XHRvbkhvdmVyOiBudWxsLFxyXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxyXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxyXG5cdFx0YW5pbWF0aW9uRHVyYXRpb246IDQwMFxyXG5cdH0sXHJcblx0b25DbGljazogbnVsbCxcclxuXHRtYWludGFpbkFzcGVjdFJhdGlvOiB0cnVlLFxyXG5cdHJlc3BvbnNpdmU6IHRydWUsXHJcblx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGBzY2FsZXNgIG9wdGlvblxyXG4gKiBieSBpbmNvcnBvcmF0aW5nIHNjYWxlIGRlZmF1bHRzIGluIGB4QXhlc2AgYW5kIGB5QXhlc2AgYXJyYXkgaXRlbXMsIHRoZW5cclxuICogcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwge1xyXG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XHJcblx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XHJcblx0XHRcdFx0dmFyIHNsZW4gPSBzb3VyY2Vba2V5XS5sZW5ndGg7XHJcblx0XHRcdFx0dmFyIGksIHR5cGUsIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRhcmdldFtrZXldKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNsZW47ICsraSkge1xyXG5cdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcclxuXHRcdFx0XHRcdHR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ5KHNjYWxlLnR5cGUsIGtleSA9PT0gJ3hBeGVzJyA/ICdjYXRlZ29yeScgOiAnbGluZWFyJyk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldLnB1c2goe30pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICghdGFyZ2V0W2tleV1baV0udHlwZSB8fCAoc2NhbGUudHlwZSAmJiBzY2FsZS50eXBlICE9PSB0YXJnZXRba2V5XVtpXS50eXBlKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBuZXcvdW50eXBlZCBzY2FsZSBvciB0eXBlIGNoYW5nZWQ6IGxldCdzIGFwcGx5IHRoZSBuZXcgZGVmYXVsdHNcclxuXHRcdFx0XHRcdFx0Ly8gdGhlbiBtZXJnZSBzb3VyY2Ugc2NhbGUgdG8gY29ycmVjdGx5IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdHMuXHJcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHModHlwZSksIHNjYWxlXSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcclxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBzY2FsZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgYXMgdGhlIHJvb3Qgb3B0aW9ucyBieSBoYW5kbGluZ1xyXG4gKiBkZWZhdWx0IHNjYWxlIG9wdGlvbnMgZm9yIHRoZSBgc2NhbGVzYCBhbmQgYHNjYWxlYCBwcm9wZXJ0aWVzLCB0aGVuIHJldHVybnNcclxuICogYSBkZWVwIGNvcHkgb2YgdGhlIHJlc3VsdCwgdGh1cyBkb2Vzbid0IGFsdGVyIGlucHV0cy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xyXG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XHJcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuXHRcdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cdFx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xyXG5cclxuXHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcclxuXHRcdFx0XHQvLyBzY2FsZSBjb25maWcgbWVyZ2luZyBpcyBjb21wbGV4LiBBZGQgb3VyIG93biBmdW5jdGlvbiBoZXJlIGZvciB0aGF0XHJcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBtZXJnZVNjYWxlQ29uZmlnKHR2YWwsIHN2YWwpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xyXG5cdFx0XHRcdC8vIHVzZWQgaW4gcG9sYXIgYXJlYSAmIHJhZGFyIGNoYXJ0cyBzaW5jZSB0aGVyZSBpcyBvbmx5IG9uZSBzY2FsZVxyXG5cdFx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycyQxLm1lcmdlKHR2YWwsIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHN2YWwudHlwZSksIHN2YWxdKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xyXG5cdGNvbmZpZyA9IGNvbmZpZyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuXHQvLyBEbyBOT1QgdXNlIG1lcmdlQ29uZmlnIGZvciB0aGUgZGF0YSBvYmplY3QgYmVjYXVzZSB0aGlzIG1ldGhvZCBtZXJnZXMgYXJyYXlzXHJcblx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxyXG5cdHZhciBkYXRhID0gY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcclxuXHRkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcclxuXHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xyXG5cclxuXHRjb25maWcub3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxyXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXHJcblx0XHRjb3JlX2RlZmF1bHRzW2NvbmZpZy50eXBlXSxcclxuXHRcdGNvbmZpZy5vcHRpb25zIHx8IHt9KTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ29uZmlnKGNoYXJ0KSB7XHJcblx0dmFyIG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zO1xyXG5cclxuXHRoZWxwZXJzJDEuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XHJcblx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBzY2FsZSk7XHJcblx0fSk7XHJcblxyXG5cdG5ld09wdGlvbnMgPSBtZXJnZUNvbmZpZyhcclxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxyXG5cdFx0Y29yZV9kZWZhdWx0c1tjaGFydC5jb25maWcudHlwZV0sXHJcblx0XHRuZXdPcHRpb25zKTtcclxuXHJcblx0Y2hhcnQub3B0aW9ucyA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zID0gbmV3T3B0aW9ucztcclxuXHRjaGFydC5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XHJcblx0Y2hhcnQuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xyXG5cclxuXHQvLyBUb29sdGlwXHJcblx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XHJcblx0Y2hhcnQudG9vbHRpcC5pbml0aWFsaXplKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRBdmFpbGFibGVTY2FsZUlkKGF4ZXNPcHRzLCBwcmVmaXgsIGluZGV4KSB7XHJcblx0dmFyIGlkO1xyXG5cdHZhciBoYXNJZCA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0cmV0dXJuIG9iai5pZCA9PT0gaWQ7XHJcblx0fTtcclxuXHJcblx0ZG8ge1xyXG5cdFx0aWQgPSBwcmVmaXggKyBpbmRleCsrO1xyXG5cdH0gd2hpbGUgKGhlbHBlcnMkMS5maW5kSW5kZXgoYXhlc09wdHMsIGhhc0lkKSA+PSAwKTtcclxuXHJcblx0cmV0dXJuIGlkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xyXG5cdHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xyXG5cdHJldHVybiBmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYVtsMV0gPT09IGJbbDFdXHJcblx0XHRcdD8gYVtsMl0gLSBiW2wyXVxyXG5cdFx0XHQ6IGFbbDFdIC0gYltsMV07XHJcblx0fTtcclxufVxyXG5cclxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XHJcblx0dGhpcy5jb25zdHJ1Y3QoaXRlbSwgY29uZmlnKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmhlbHBlcnMkMS5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCAvKiogQGxlbmRzIENoYXJ0ICovIHtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IHBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGl0ZW0sIGNvbmZpZyk7XHJcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcclxuXHRcdHZhciBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcclxuXHRcdHZhciB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XHJcblxyXG5cdFx0bWUuaWQgPSBoZWxwZXJzJDEudWlkKCk7XHJcblx0XHRtZS5jdHggPSBjb250ZXh0O1xyXG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xyXG5cdFx0bWUuY29uZmlnID0gY29uZmlnO1xyXG5cdFx0bWUud2lkdGggPSB3aWR0aDtcclxuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdG1lLmFzcGVjdFJhdGlvID0gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xyXG5cdFx0bWUub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xyXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XHJcblx0XHRtZS5fbGF5ZXJzID0gW107XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcclxuXHRcdCAqIHRoZSBcImluc3RhbmNlXCIgc3RpbGwgbmVlZCB0byBiZSBkZWZpbmVkIHNpbmNlIGl0IG1pZ2h0IGJlIGNhbGxlZCBmcm9tIHBsdWdpbnMuXHJcblx0XHQgKiBAcHJvcCBDaGFydCNjaGFydFxyXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0bWUuY2hhcnQgPSBtZTtcclxuXHRcdG1lLmNvbnRyb2xsZXIgPSBtZTsgLy8gY2hhcnQuY2hhcnQuY29udHJvbGxlciAjaW5jZXB0aW9uXHJcblxyXG5cdFx0Ly8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxyXG5cdFx0Q2hhcnQuaW5zdGFuY2VzW21lLmlkXSA9IG1lO1xyXG5cclxuXHRcdC8vIERlZmluZSBhbGlhcyB0byB0aGUgY29uZmlnIGRhdGE6IGBjaGFydC5kYXRhID09PSBjaGFydC5jb25maWcuZGF0YWBcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2RhdGEnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1lLmNvbmZpZy5kYXRhO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdFx0bWUuY29uZmlnLmRhdGEgPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcclxuXHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXHJcblx0XHRcdC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XHJcblx0XHRcdC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcclxuXHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuaW5pdGlhbGl6ZSgpO1xyXG5cdFx0bWUudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUluaXQnKTtcclxuXHJcblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcblxyXG5cdFx0bWUuYmluZEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcclxuXHRcdFx0Ly8gSW5pdGlhbCByZXNpemUgYmVmb3JlIGNoYXJ0IGRyYXdzIChtdXN0IGJlIHNpbGVudCB0byBwcmVzZXJ2ZSBpbml0aWFsIGFuaW1hdGlvbnMpLlxyXG5cdFx0XHRtZS5yZXNpemUodHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuaW5pdFRvb2xUaXAoKTtcclxuXHJcblx0XHQvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckluaXQnKTtcclxuXHJcblx0XHRyZXR1cm4gbWU7XHJcblx0fSxcclxuXHJcblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGVhcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xyXG5cdFx0Ly8gU3RvcHMgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGxvb3Agb2NjdXJyaW5nXHJcblx0XHRjb3JlX2FuaW1hdGlvbnMuY2FuY2VsQW5pbWF0aW9uKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xyXG5cdFx0dmFyIGFzcGVjdFJhdGlvID0gKG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbykgfHwgbnVsbDtcclxuXHJcblx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XHJcblx0XHQvLyB0aGUgY2FudmFzIGRpc3BsYXkgc3R5bGUgdXNlcyB0aGUgc2FtZSBpbnRlZ2VyIHZhbHVlcyB0byBhdm9pZCBibHVycmluZyBlZmZlY3QuXHJcblxyXG5cdFx0Ly8gU2V0IHRvIDAgaW5zdGVhZCBvZiBjYW52YXMuc2l6ZSBiZWNhdXNlIHRoZSBzaXplIGRlZmF1bHRzIHRvIDMwMHgxNTAgaWYgdGhlIGVsZW1lbnQgaXMgY29sbGFwc2VkXHJcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGgoY2FudmFzKSkpO1xyXG5cdFx0dmFyIG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoYXNwZWN0UmF0aW8gPyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvIDogaGVscGVycyQxLmdldE1heGltdW1IZWlnaHQoY2FudmFzKSkpO1xyXG5cclxuXHRcdGlmIChtZS53aWR0aCA9PT0gbmV3V2lkdGggJiYgbWUuaGVpZ2h0ID09PSBuZXdIZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNhbnZhcy53aWR0aCA9IG1lLndpZHRoID0gbmV3V2lkdGg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xyXG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xyXG5cdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XHJcblxyXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xyXG5cclxuXHRcdGlmICghc2lsZW50KSB7XHJcblx0XHRcdC8vIE5vdGlmeSBhbnkgcGx1Z2lucyBhYm91dCB0aGUgcmVzaXplXHJcblx0XHRcdHZhciBuZXdTaXplID0ge3dpZHRoOiBuZXdXaWR0aCwgaGVpZ2h0OiBuZXdIZWlnaHR9O1xyXG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcclxuXHJcblx0XHRcdC8vIE5vdGlmeSBvZiByZXNpemVcclxuXHRcdFx0aWYgKG9wdGlvbnMub25SZXNpemUpIHtcclxuXHRcdFx0XHRvcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWUuc3RvcCgpO1xyXG5cdFx0XHRtZS51cGRhdGUoe1xyXG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvblxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRlbnN1cmVTY2FsZXNIYXZlSURzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcclxuXHRcdHZhciBzY2FsZU9wdGlvbnMgPSBvcHRpb25zLnNjYWxlO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcclxuXHRcdFx0aWYgKCF4QXhpc09wdGlvbnMuaWQpIHtcclxuXHRcdFx0XHR4QXhpc09wdGlvbnMuaWQgPSBuZXh0QXZhaWxhYmxlU2NhbGVJZChzY2FsZXNPcHRpb25zLnhBeGVzLCAneC1heGlzLScsIGluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy55QXhlcywgZnVuY3Rpb24oeUF4aXNPcHRpb25zLCBpbmRleCkge1xyXG5cdFx0XHRpZiAoIXlBeGlzT3B0aW9ucy5pZCkge1xyXG5cdFx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IG5leHRBdmFpbGFibGVTY2FsZUlkKHNjYWxlc09wdGlvbnMueUF4ZXMsICd5LWF4aXMtJywgaW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoc2NhbGVPcHRpb25zKSB7XHJcblx0XHRcdHNjYWxlT3B0aW9ucy5pZCA9IHNjYWxlT3B0aW9ucy5pZCB8fCAnc2NhbGUnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXHJcblx0ICovXHJcblx0YnVpbGRPclVwZGF0ZVNjYWxlczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyB8fCB7fTtcclxuXHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0dmFyIHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZShmdW5jdGlvbihvYmosIGlkKSB7XHJcblx0XHRcdG9ialtpZF0gPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zY2FsZXMpIHtcclxuXHRcdFx0aXRlbXMgPSBpdGVtcy5jb25jYXQoXHJcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHhBeGlzT3B0aW9ucywgZHR5cGU6ICdjYXRlZ29yeScsIGRwb3NpdGlvbjogJ2JvdHRvbSd9O1xyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB5QXhpc09wdGlvbnMsIGR0eXBlOiAnbGluZWFyJywgZHBvc2l0aW9uOiAnbGVmdCd9O1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcclxuXHRcdFx0aXRlbXMucHVzaCh7XHJcblx0XHRcdFx0b3B0aW9uczogb3B0aW9ucy5zY2FsZSxcclxuXHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXHJcblx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxyXG5cdFx0XHRcdGRwb3NpdGlvbjogJ2NoYXJ0QXJlYSdcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcclxuXHRcdFx0dmFyIGlkID0gc2NhbGVPcHRpb25zLmlkO1xyXG5cdFx0XHR2YXIgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQkOShzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XHJcblxyXG5cdFx0XHRpZiAocG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XHJcblx0XHRcdFx0c2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZWRbaWRdID0gdHJ1ZTtcclxuXHRcdFx0dmFyIHNjYWxlID0gbnVsbDtcclxuXHRcdFx0aWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xyXG5cdFx0XHRcdHNjYWxlID0gc2NhbGVzW2lkXTtcclxuXHRcdFx0XHRzY2FsZS5vcHRpb25zID0gc2NhbGVPcHRpb25zO1xyXG5cdFx0XHRcdHNjYWxlLmN0eCA9IG1lLmN0eDtcclxuXHRcdFx0XHRzY2FsZS5jaGFydCA9IG1lO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzY2FsZUNsYXNzID0gY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVDb25zdHJ1Y3RvcihzY2FsZVR5cGUpO1xyXG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcclxuXHRcdFx0XHRcdGlkOiBpZCxcclxuXHRcdFx0XHRcdHR5cGU6IHNjYWxlVHlwZSxcclxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcclxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxyXG5cdFx0XHRcdFx0Y2hhcnQ6IG1lXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0c2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzY2FsZS5tZXJnZVRpY2tzT3B0aW9ucygpO1xyXG5cclxuXHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXHJcblx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXHJcblx0XHRcdC8vIG1ha2UgdGhlIGxvZ2ljIGVhc2llciBhbmQgcmVtb3ZlIHNvbWUgdXNlbGVzcz8gY3VzdG9tIGNvZGUuXHJcblx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xyXG5cdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0Ly8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xyXG5cdFx0aGVscGVycyQxLmVhY2godXBkYXRlZCwgZnVuY3Rpb24oaGFzVXBkYXRlZCwgaWQpIHtcclxuXHRcdFx0aWYgKCFoYXNVcGRhdGVkKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHNjYWxlc1tpZF07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdG1lLnNjYWxlcyA9IHNjYWxlcztcclxuXHJcblx0XHRjb3JlX3NjYWxlU2VydmljZS5hZGRTY2FsZXNUb0xheW91dCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRidWlsZE9yVXBkYXRlQ29udHJvbGxlcnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IFtdO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gbWUuZGF0YS5kYXRhc2V0cztcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcclxuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0dmFyIHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgbWUuY29uZmlnLnR5cGU7XHJcblxyXG5cdFx0XHRpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xyXG5cdFx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0XHRtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcclxuXHRcdFx0bWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcclxuXHRcdFx0bWV0YS5pbmRleCA9IGk7XHJcblxyXG5cdFx0XHRpZiAobWV0YS5jb250cm9sbGVyKSB7XHJcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xyXG5cdFx0XHRcdG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIENvbnRyb2xsZXJDbGFzcyA9IGNvbnRyb2xsZXJzW21ldGEudHlwZV07XHJcblx0XHRcdFx0aWYgKENvbnRyb2xsZXJDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG1ldGEudHlwZSArICdcIiBpcyBub3QgYSBjaGFydCB0eXBlLicpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgaSk7XHJcblx0XHRcdFx0bmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0XHRtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcclxuXHRcdH0sIG1lKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdCdzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cclxuXHQqL1xyXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMucmVzZXRFbGVtZW50cygpO1xyXG5cdFx0dGhpcy50b29sdGlwLmluaXRpYWxpemUoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XHJcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdGNvbmZpZyA9IHtcclxuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxyXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHVwZGF0ZUNvbmZpZyhtZSk7XHJcblxyXG5cdFx0Ly8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XHJcblx0XHRjb3JlX3BsdWdpbnMuX2ludmFsaWRhdGUobWUpO1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVXBkYXRlJykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxyXG5cdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcclxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUudXBkYXRlTGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXHJcblx0XHRpZiAobWUub3B0aW9ucy5hbmltYXRpb24gJiYgbWUub3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24pIHtcclxuXHRcdFx0aGVscGVycyQxLmVhY2gobmV3Q29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcclxuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLnVwZGF0ZURhdGFzZXRzKCk7XHJcblxyXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxyXG5cdFx0Ly8gYWZ0ZXIgdXBkYXRlLlxyXG5cdFx0bWUudG9vbHRpcC5pbml0aWFsaXplKCk7XHJcblxyXG5cdFx0Ly8gTGFzdCBhY3RpdmUgY29udGFpbnMgaXRlbXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgaW4gdGhlIHRvb2x0aXAuXHJcblx0XHQvLyBXaGVuIHdlIHJlc2V0IHRoZSB0b29sdGlwLCB3ZSBuZWVkIHRvIGNsZWFyIGl0XHJcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XHJcblxyXG5cdFx0Ly8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XHJcblxyXG5cdFx0bWUuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcclxuXHJcblx0XHRpZiAobWUuX2J1ZmZlcmVkUmVuZGVyKSB7XHJcblx0XHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSB7XHJcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZy5kdXJhdGlvbixcclxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcsXHJcblx0XHRcdFx0bGF6eTogY29uZmlnLmxhenlcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLnJlbmRlcihjb25maWcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxyXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUxheW91dCcpID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9sYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG5cdFx0bWUuX2xheWVycyA9IFtdO1xyXG5cdFx0aGVscGVycyQxLmVhY2gobWUuYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xyXG5cdFx0XHQvLyBfY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxyXG5cdFx0XHQvLyBIZXJlIHRoZSBib3hlcyBhcmUgZnVsbHkgdXBkYXRlZCBhbmQgYXQgdGhlaXIgZmluYWwgcG9zaXRpb25zLlxyXG5cdFx0XHRpZiAoYm94Ll9jb25maWd1cmUpIHtcclxuXHRcdFx0XHRib3guX2NvbmZpZ3VyZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1lLl9sYXllcnMucHVzaC5hcHBseShtZS5fbGF5ZXJzLCBib3guX2xheWVycygpKTtcclxuXHRcdH0sIG1lKTtcclxuXHJcblx0XHRtZS5fbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0aXRlbS5faWR4ID0gaW5kZXg7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxyXG5cdFx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyU2NhbGVVcGRhdGVcclxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcclxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJMYXlvdXQnKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzVXBkYXRlJykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLnVwZGF0ZURhdGFzZXQoaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNVcGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVEYXRhc2V0OiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xyXG5cdFx0dmFyIGFyZ3MgPSB7XHJcblx0XHRcdG1ldGE6IG1ldGEsXHJcblx0XHRcdGluZGV4OiBpbmRleFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBbYXJnc10pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWV0YS5jb250cm9sbGVyLl91cGRhdGUoKTtcclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKTtcclxuXHR9LFxyXG5cclxuXHRyZW5kZXI6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRjb25maWcgPSB7XHJcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZyxcclxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IG1lLm9wdGlvbnMuYW5pbWF0aW9uO1xyXG5cdFx0dmFyIGR1cmF0aW9uID0gdmFsdWVPckRlZmF1bHQkOShjb25maWcuZHVyYXRpb24sIGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbik7XHJcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlUmVuZGVyJykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xyXG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJSZW5kZXInKTtcclxuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgbWUpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoYW5pbWF0aW9uT3B0aW9ucyAmJiBkdXJhdGlvbikge1xyXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcclxuXHRcdFx0XHRudW1TdGVwczogZHVyYXRpb24gLyAxNi42NiwgLy8gNjAgZnBzXHJcblx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nIHx8IGFuaW1hdGlvbk9wdGlvbnMuZWFzaW5nLFxyXG5cclxuXHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb25PYmplY3QpIHtcclxuXHRcdFx0XHRcdHZhciBlYXNpbmdGdW5jdGlvbiA9IGhlbHBlcnMkMS5lYXNpbmcuZWZmZWN0c1thbmltYXRpb25PYmplY3QuZWFzaW5nXTtcclxuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcclxuXHRcdFx0XHRcdHZhciBzdGVwRGVjaW1hbCA9IGN1cnJlbnRTdGVwIC8gYW5pbWF0aW9uT2JqZWN0Lm51bVN0ZXBzO1xyXG5cclxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcclxuXHRcdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29yZV9hbmltYXRpb25zLmFkZEFuaW1hdGlvbihtZSwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZS5kcmF3KCk7XHJcblxyXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM3ODFcclxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGksIGxheWVycztcclxuXHJcblx0XHRtZS5jbGVhcigpO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihlYXNpbmdWYWx1ZSkpIHtcclxuXHRcdFx0ZWFzaW5nVmFsdWUgPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xyXG5cclxuXHRcdGlmIChtZS53aWR0aCA8PSAwIHx8IG1lLmhlaWdodCA8PSAwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxyXG5cdFx0Ly8gY3VycmVudGx5IGJlIHBhcnQgb2YgbGF5ZXJzLiBJbnN0ZWFkLCB3ZSBkcmF3XHJcblx0XHQvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXHJcblx0XHRsYXllcnMgPSBtZS5fbGF5ZXJzO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XHJcblx0XHRcdGxheWVyc1tpXS5kcmF3KG1lLmNoYXJ0QXJlYSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuZHJhd0RhdGFzZXRzKGVhc2luZ1ZhbHVlKTtcclxuXHJcblx0XHQvLyBSZXN0IG9mIGxheWVyc1xyXG5cdFx0Zm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcobWUuY2hhcnRBcmVhKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5fZHJhd1Rvb2x0aXAoZWFzaW5nVmFsdWUpO1xyXG5cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRyYXcnLCBbZWFzaW5nVmFsdWVdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xyXG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtZS50b29sdGlwLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFNvcnRlZERhdGFzZXRNZXRhczogZnVuY3Rpb24oZmlsdGVyVmlzaWJsZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkYXRhc2V0cyA9IG1lLmRhdGEuZGF0YXNldHMgfHwgW107XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2gobWUuZ2V0RGF0YXNldE1ldGEoaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmVzdWx0LnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YXNldHMsIGk7XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1ldGFzZXRzID0gbWUuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuXHRcdGZvciAoaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0XHRcdG1lLmRyYXdEYXRhc2V0KG1ldGFzZXRzW2ldLCBlYXNpbmdWYWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZHJhd0RhdGFzZXQ6IGZ1bmN0aW9uKG1ldGEsIGVhc2luZ1ZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGFyZ3MgPSB7XHJcblx0XHRcdG1ldGE6IG1ldGEsXHJcblx0XHRcdGluZGV4OiBtZXRhLmluZGV4LFxyXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtZXRhLmNvbnRyb2xsZXIuZHJhdyhlYXNpbmdWYWx1ZSk7XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRvb2x0aXAgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZVRvb2x0aXBEcmF3YFxyXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlclRvb2x0aXBEcmF3YC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3VG9vbHRpcDogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XHJcblx0XHR2YXIgYXJncyA9IHtcclxuXHRcdFx0dG9vbHRpcDogdG9vbHRpcCxcclxuXHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVG9vbHRpcERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dG9vbHRpcC5kcmF3KCk7XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVG9vbHRpcERyYXcnLCBbYXJnc10pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgc2luZ2xlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBvblxyXG5cdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XHJcblx0ICovXHJcblx0Z2V0RWxlbWVudEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLmxhYmVsKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50c0F0WEF4aXM6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzWyd4LWF4aXMnXSh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZTogZnVuY3Rpb24oZSwgbW9kZSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG1ldGhvZCA9IGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XHJcblx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRyZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBbXTtcclxuXHR9LFxyXG5cclxuXHRnZXREYXRhc2V0QXRFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG5cdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XHJcblx0XHRcdGRhdGFzZXQuX21ldGEgPSB7fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdO1xyXG5cdFx0aWYgKCFtZXRhKSB7XHJcblx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcclxuXHRcdFx0XHR0eXBlOiBudWxsLFxyXG5cdFx0XHRcdGRhdGE6IFtdLFxyXG5cdFx0XHRcdGRhdGFzZXQ6IG51bGwsXHJcblx0XHRcdFx0Y29udHJvbGxlcjogbnVsbCxcclxuXHRcdFx0XHRoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XHJcblx0XHRcdFx0eEF4aXNJRDogbnVsbCxcclxuXHRcdFx0XHR5QXhpc0lEOiBudWxsLFxyXG5cdFx0XHRcdG9yZGVyOiBkYXRhc2V0Lm9yZGVyIHx8IDAsXHJcblx0XHRcdFx0aW5kZXg6IGRhdGFzZXRJbmRleFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtZXRhO1xyXG5cdH0sXHJcblxyXG5cdGdldFZpc2libGVEYXRhc2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRpZiAodGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvdW50O1xyXG5cdH0sXHJcblxyXG5cdGlzRGF0YXNldFZpc2libGU6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcblxyXG5cdFx0Ly8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxyXG5cdFx0Ly8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxyXG5cdFx0cmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIXRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmhpZGRlbjtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxlZ2VuZENhbGxiYWNrKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZGVzdHJveURhdGFzZXRNZXRhOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XHJcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhICYmIGRhdGFzZXQuX21ldGFbaWRdO1xyXG5cclxuXHRcdGlmIChtZXRhKSB7XHJcblx0XHRcdG1ldGEuY29udHJvbGxlci5kZXN0cm95KCk7XHJcblx0XHRcdGRlbGV0ZSBkYXRhc2V0Ll9tZXRhW2lkXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0bWUuc3RvcCgpO1xyXG5cclxuXHRcdC8vIGRhdGFzZXQgY29udHJvbGxlcnMgbmVlZCB0byBjbGVhbnVwIGFzc29jaWF0ZWQgZGF0YVxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY2FudmFzKSB7XHJcblx0XHRcdG1lLnVuYmluZEV2ZW50cygpO1xyXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKG1lKTtcclxuXHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcclxuXHRcdFx0bWUuY2FudmFzID0gbnVsbDtcclxuXHRcdFx0bWUuY3R4ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xyXG5cclxuXHRcdGRlbGV0ZSBDaGFydC5pbnN0YW5jZXNbbWUuaWRdO1xyXG5cdH0sXHJcblxyXG5cdHRvQmFzZTY0SW1hZ2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTC5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0bWUudG9vbHRpcCA9IG5ldyBjb3JlX3Rvb2x0aXAoe1xyXG5cdFx0XHRfY2hhcnQ6IG1lLFxyXG5cdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsIC8vIGRlcHJlY2F0ZWQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0X2RhdGE6IG1lLmRhdGEsXHJcblx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXHJcblx0XHR9LCBtZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRiaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycyA9IHt9O1xyXG5cdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdG1lLmV2ZW50SGFuZGxlci5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2gobWUub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xyXG5cdFx0XHRsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEVsZW1lbnRzIHVzZWQgdG8gZGV0ZWN0IHNpemUgY2hhbmdlIHNob3VsZCBub3QgYmUgaW5qZWN0ZWQgZm9yIG5vbiByZXNwb25zaXZlIGNoYXJ0cy5cclxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjIxMFxyXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG5cdFx0XHRsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdG1lLnJlc2l6ZSgpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcclxuXHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dW5iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgbWUuX2xpc3RlbmVycztcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcclxuXHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudHMsIG1vZGUsIGVuYWJsZWQpIHtcclxuXHRcdHZhciBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcclxuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG5cdFx0XHRpZiAoZWxlbWVudCkge1xyXG5cdFx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudC5fZGF0YXNldEluZGV4KS5jb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oZWxlbWVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XHJcblx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudHNbMF0uX2RhdGFzZXRJbmRleCkuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZXZlbnRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVmZmVyIGFueSB1cGRhdGUgY2FsbHMgc28gdGhhdCByZW5kZXJzIGRvIG5vdCBvY2N1clxyXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gdHJ1ZTtcclxuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xyXG5cclxuXHRcdHZhciBjaGFuZ2VkID0gbWUuaGFuZGxlRXZlbnQoZSk7XHJcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxyXG5cdFx0Ly8gdGhlIHRvb2x0aXAgc2hvdWxkIGJlIHRoZSBzb3VyY2Ugb2YgY2hhbmdlXHJcblx0XHQvLyBBbmltYXRpb24gY2hlY2sgd29ya2Fyb3VuZDpcclxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXHJcblx0XHRpZiAodG9vbHRpcCkge1xyXG5cdFx0XHRjaGFuZ2VkID0gdG9vbHRpcC5fc3RhcnRcclxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcclxuXHRcdFx0XHQ6IGNoYW5nZWQgfCB0b29sdGlwLmhhbmRsZUV2ZW50KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckV2ZW50JywgW2VdKTtcclxuXHJcblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcclxuXHRcdGlmIChidWZmZXJlZFJlcXVlc3QpIHtcclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhbiB1cGRhdGUgdGhhdCB3YXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGRvIGEgbm9ybWFsIHJlbmRlclxyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcclxuXHRcdH0gZWxzZSBpZiAoY2hhbmdlZCAmJiAhbWUuYW5pbWF0aW5nKSB7XHJcblx0XHRcdC8vIElmIGVudGVyaW5nLCBsZWF2aW5nLCBvciBjaGFuZ2luZyBlbGVtZW50cywgYW5pbWF0ZSB0aGUgY2hhbmdlIHZpYSBwaXZvdFxyXG5cdFx0XHRtZS5zdG9wKCk7XHJcblxyXG5cdFx0XHQvLyBXZSBvbmx5IG5lZWQgdG8gcmVuZGVyIGF0IHRoaXMgcG9pbnQuIFVwZGF0aW5nIHdpbGwgY2F1c2Ugc2NhbGVzIHRvIGJlXHJcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXHJcblx0XHRcdG1lLnJlbmRlcih7XHJcblx0XHRcdFx0ZHVyYXRpb246IG1lLm9wdGlvbnMuaG92ZXIuYW5pbWF0aW9uRHVyYXRpb24sXHJcblx0XHRcdFx0bGF6eTogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcclxuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiBtZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gaGFuZGxlXHJcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXHJcblx0ICovXHJcblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XHJcblx0XHR2YXIgaG92ZXJPcHRpb25zID0gb3B0aW9ucy5ob3ZlcjtcclxuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmxhc3RBY3RpdmUgfHwgW107XHJcblxyXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xyXG5cdFx0XHRtZS5hY3RpdmUgPSBbXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLmFjdGl2ZSA9IG1lLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW52b2tlIG9uSG92ZXIgaG9va1xyXG5cdFx0Ly8gTmVlZCB0byBjYWxsIHdpdGggbmF0aXZlIGV2ZW50IGhlcmUgdG8gbm90IGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XHJcblx0XHRcdFx0Ly8gVXNlIGUubmF0aXZlIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0b3B0aW9ucy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBtZS5hY3RpdmUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXHJcblx0XHRpZiAobWUubGFzdEFjdGl2ZS5sZW5ndGgpIHtcclxuXHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5sYXN0QWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1aWx0IGluIGhvdmVyIHN0eWxpbmdcclxuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XHJcblx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUuYWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuYWN0aXZlLCBtZS5sYXN0QWN0aXZlKTtcclxuXHJcblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcclxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5hY3RpdmU7XHJcblxyXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBOT1RFKFNCKSBXZSBhY3R1YWxseSBkb24ndCB1c2UgdGhpcyBjb250YWluZXIgYW55bW9yZSBidXQgd2UgbmVlZCB0byBrZWVwIGl0XHJcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxyXG4gKiB3b3VsZCBuZWVkIHRvIHdvcmsgb24gbXVsdGlwbGUgY2hhcnRzPyFcclxuICovXHJcbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xyXG5cclxudmFyIGNvcmVfY29udHJvbGxlciA9IENoYXJ0O1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydCBpbnN0ZWFkLlxyXG4gKiBAY2xhc3MgQ2hhcnQuQ29udHJvbGxlclxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DaGFydC5Db250cm9sbGVyID0gQ2hhcnQ7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cclxuICogQG5hbWVzcGFjZSBDaGFydFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DaGFydC50eXBlcyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jb25maWdNZXJnZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmhlbHBlcnMkMS5jb25maWdNZXJnZSA9IG1lcmdlQ29uZmlnO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5zY2FsZU1lcmdlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLnNjYWxlTWVyZ2UgPSBtZXJnZVNjYWxlQ29uZmlnO1xuXG52YXIgY29yZV9oZWxwZXJzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xyXG5cclxuXHRoZWxwZXJzJDEud2hlcmUgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBmaWx0ZXJDYWxsYmFjaykge1xyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcclxuXHRcdFx0cmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKGZpbHRlckNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XHJcblx0XHRcdFx0ZmlsdGVyZWQucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGZpbHRlcmVkO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggP1xyXG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xyXG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XHJcblx0XHR9IDpcclxuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcclxuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRpZiAoY2FsbGJhY2suY2FsbChzY29wZSwgYXJyYXlbaV0sIGksIGFycmF5KSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH07XHJcblx0aGVscGVycyQxLmZpbmROZXh0V2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xyXG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xyXG5cdFx0XHRzdGFydEluZGV4ID0gLTE7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBhcnJheVRvU2VhcmNoLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XHJcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5maW5kUHJldmlvdXNXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XHJcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xyXG5cdFx0XHRzdGFydEluZGV4ID0gYXJyYXlUb1NlYXJjaC5sZW5ndGg7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XHJcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcclxuXHRoZWxwZXJzJDEuaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7XHJcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHgsIHksIGVwc2lsb24pIHtcclxuXHRcdHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmFsbW9zdFdob2xlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xyXG5cdFx0dmFyIHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xyXG5cdFx0cmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xyXG5cdH07XHJcblx0aGVscGVycyQxLm1heCA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcclxuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgobWF4LCB2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG1heDtcclxuXHRcdH0sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEubWluID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWluLCB2YWx1ZSkge1xyXG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xyXG5cdFx0XHRcdHJldHVybiBNYXRoLm1pbihtaW4sIHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbWluO1xyXG5cdFx0fSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cclxuXHRcdGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIE1hdGguc2lnbih4KTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24oeCkge1xyXG5cdFx0XHR4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcclxuXHRcdFx0XHRyZXR1cm4geDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XHJcblx0XHR9O1xyXG5cdGhlbHBlcnMkMS50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XHJcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XHJcblx0XHRyZXR1cm4gcmFkaWFucyAqICgxODAgLyBNYXRoLlBJKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcclxuXHQgKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBBIG51bWJlci5cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGVscGVycyQxLl9kZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUoeCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGUgPSAxO1xyXG5cdFx0dmFyIHAgPSAwO1xyXG5cdFx0d2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xyXG5cdFx0XHRlICo9IDEwO1xyXG5cdFx0XHRwKys7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcDtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxyXG5cdGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCA9IGZ1bmN0aW9uKGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XHJcblx0XHR2YXIgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XHJcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XHJcblx0XHR2YXIgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xyXG5cclxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XHJcblxyXG5cdFx0aWYgKGFuZ2xlIDwgKC0wLjUgKiBNYXRoLlBJKSkge1xyXG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFuZ2xlOiBhbmdsZSxcclxuXHRcdFx0ZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxyXG5cdFx0fTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbihwdDEsIHB0Mikge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcblx0ICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWxpYXNQaXhlbFxyXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcblx0ICovXHJcblx0aGVscGVycyQxLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XHJcblx0XHRyZXR1cm4gKHBpeGVsV2lkdGggJSAyID09PSAwKSA/IDAgOiAwLjU7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYWxpZ25lZCBwaXhlbCB2YWx1ZSB0byBhdm9pZCBhbnRpLWFsaWFzaW5nIGJsdXJcclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhlbHBlcnMkMS5fYWxpZ25QaXhlbCA9IGZ1bmN0aW9uKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcclxuXHRcdHZhciBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XHJcblx0XHR2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xyXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcclxuXHR9O1xyXG5cclxuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xyXG5cdFx0Ly8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXHJcblx0XHQvLyBodHRwOi8vc2NhbGVkaW5ub3ZhdGlvbi5jb20vYW5hbHl0aWNzL3NwbGluZXMvYWJvdXRTcGxpbmVzLmh0bWxcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xyXG5cclxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcclxuXHRcdHZhciBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XHJcblx0XHR2YXIgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcclxuXHJcblx0XHR2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnQueCAtIHByZXZpb3VzLngsIDIpICsgTWF0aC5wb3coY3VycmVudC55IC0gcHJldmlvdXMueSwgMikpO1xyXG5cdFx0dmFyIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyhuZXh0LnggLSBjdXJyZW50LngsIDIpICsgTWF0aC5wb3cobmV4dC55IC0gY3VycmVudC55LCAyKSk7XHJcblxyXG5cdFx0dmFyIHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xyXG5cdFx0dmFyIHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xyXG5cclxuXHRcdC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcclxuXHRcdHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xyXG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XHJcblxyXG5cdFx0dmFyIGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXHJcblx0XHR2YXIgZmIgPSB0ICogczEyO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHByZXZpb3VzOiB7XHJcblx0XHRcdFx0eDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXHJcblx0XHRcdFx0eTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcclxuXHRcdFx0fSxcclxuXHRcdFx0bmV4dDoge1xyXG5cdFx0XHRcdHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxyXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fTtcclxuXHRoZWxwZXJzJDEuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xyXG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZU1vbm90b25lID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcclxuXHRcdC8vIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcclxuXHRcdC8vIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cclxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cclxuXHJcblx0XHR2YXIgcG9pbnRzV2l0aFRhbmdlbnRzID0gKHBvaW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0bW9kZWw6IHBvaW50Ll9tb2RlbCxcclxuXHRcdFx0XHRkZWx0YUs6IDAsXHJcblx0XHRcdFx0bUs6IDBcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxyXG5cdFx0dmFyIHBvaW50c0xlbiA9IHBvaW50c1dpdGhUYW5nZW50cy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcclxuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xyXG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XHJcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XHJcblx0XHRcdHBvaW50QWZ0ZXIgPSBpIDwgcG9pbnRzTGVuIC0gMSA/IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV0gOiBudWxsO1xyXG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0dmFyIHNsb3BlRGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KTtcclxuXHJcblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXHJcblx0XHRcdFx0cG9pbnRDdXJyZW50LmRlbHRhSyA9IHNsb3BlRGVsdGFYICE9PSAwID8gKHBvaW50QWZ0ZXIubW9kZWwueSAtIHBvaW50Q3VycmVudC5tb2RlbC55KSAvIHNsb3BlRGVsdGFYIDogMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFwb2ludEJlZm9yZSB8fCBwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEJlZm9yZS5kZWx0YUs7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zaWduKHBvaW50QmVmb3JlLmRlbHRhSykgIT09IHRoaXMuc2lnbihwb2ludEN1cnJlbnQuZGVsdGFLKSkge1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gKHBvaW50QmVmb3JlLmRlbHRhSyArIHBvaW50Q3VycmVudC5kZWx0YUspIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcclxuXHRcdHZhciBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xyXG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XHJcblx0XHRcdHBvaW50QWZ0ZXIgPSBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdO1xyXG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXAgfHwgcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEFmdGVyLm1LID0gMDtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxwaGFLID0gcG9pbnRDdXJyZW50Lm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdFx0c3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XHJcblx0XHRcdGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XHJcblx0XHRcdHBvaW50Q3VycmVudC5tSyA9IGFscGhhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xyXG5cdFx0XHRwb2ludEFmdGVyLm1LID0gYmV0YUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb21wdXRlIGNvbnRyb2wgcG9pbnRzXHJcblx0XHR2YXIgZGVsdGFYO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcclxuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcclxuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XHJcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xyXG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEN1cnJlbnQubW9kZWwueCAtIHBvaW50QmVmb3JlLm1vZGVsLngpIC8gMztcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggLSBkZWx0YVg7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBwb2ludEN1cnJlbnQubW9kZWwueCArIGRlbHRhWDtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBwb2ludEN1cnJlbnQubW9kZWwueSArIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0aGVscGVycyQxLm5leHRJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcclxuXHRcdGlmIChsb29wKSB7XHJcblx0XHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xyXG5cdFx0aWYgKGxvb3ApIHtcclxuXHRcdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XHJcblx0fTtcclxuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xyXG5cdGhlbHBlcnMkMS5uaWNlTnVtID0gZnVuY3Rpb24ocmFuZ2UsIHJvdW5kKSB7XHJcblx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChyYW5nZSkpO1xyXG5cdFx0dmFyIGZyYWN0aW9uID0gcmFuZ2UgLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xyXG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcclxuXHJcblx0XHRpZiAocm91bmQpIHtcclxuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XHJcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTtcclxuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDMpIHtcclxuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgNykge1xyXG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XHJcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XHJcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDIpIHtcclxuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcclxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gNSkge1xyXG5cdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5pY2VGcmFjdGlvbiAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XHJcblx0fTtcclxuXHQvLyBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbCAtIGh0dHBzOi8vd3d3LnBhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHRoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcclxuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0XHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxuXHRcdFx0fTtcclxuXHR9KCkpO1xyXG5cdC8vIC0tIERPTSBtZXRob2RzXHJcblx0aGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XHJcblx0XHR2YXIgbW91c2VYLCBtb3VzZVk7XHJcblx0XHR2YXIgZSA9IGV2dC5vcmlnaW5hbEV2ZW50IHx8IGV2dDtcclxuXHRcdHZhciBjYW52YXMgPSBldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xyXG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcclxuXHRcdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRtb3VzZVggPSB0b3VjaGVzWzBdLmNsaWVudFg7XHJcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XHJcblx0XHRcdG1vdXNlWSA9IGUuY2xpZW50WTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTY2FsZSBtb3VzZSBjb29yZGluYXRlcyBpbnRvIGNhbnZhcyBjb29yZGluYXRlc1xyXG5cdFx0Ly8gYnkgZm9sbG93aW5nIHRoZSBwYXR0ZXJuIGxhaWQgb3V0IGJ5ICdqZXJyeWonIGluIHRoZSBjb21tZW50cyBvZlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cclxuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctbGVmdCcpKTtcclxuXHRcdHZhciBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy10b3AnKSk7XHJcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcclxuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1ib3R0b20nKSk7XHJcblx0XHR2YXIgd2lkdGggPSBib3VuZGluZ1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xyXG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XHJcblxyXG5cdFx0Ly8gV2UgZGl2aWRlIGJ5IHRoZSBjdXJyZW50IGRldmljZSBwaXhlbCByYXRpbywgYmVjYXVzZSB0aGUgY2FudmFzIGlzIHNjYWxlZCB1cCBieSB0aGF0IGFtb3VudCBpbiBlYWNoIGRpcmVjdGlvbi4gSG93ZXZlclxyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcclxuXHRcdG1vdXNlWCA9IE1hdGgucm91bmQoKG1vdXNlWCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQpIC8gKHdpZHRoKSAqIGNhbnZhcy53aWR0aCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcclxuXHRcdG1vdXNlWSA9IE1hdGgucm91bmQoKG1vdXNlWSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wKSAvIChoZWlnaHQpICogY2FudmFzLmhlaWdodCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiBtb3VzZVgsXHJcblx0XHRcdHk6IG1vdXNlWVxyXG5cdFx0fTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcclxuXHRcdHZhciB2YWx1ZUluUGl4ZWxzO1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xyXG5cclxuXHRcdFx0aWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xyXG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxyXG5cdFx0XHRcdHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlSW5QaXhlbHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiB2YWx1ZSBjb250YWlucyBhbiBlZmZlY3RpdmUgY29uc3RyYWludC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGlzQ29uc3RyYWluZWRWYWx1ZSh2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG1heCB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGdpdmVuIERPTSBub2RlIGluIGEgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxlIGZhc2hpb25cclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21Ob2RlIC0gdGhlIG5vZGUgdG8gY2hlY2sgdGhlIGNvbnN0cmFpbnQgb25cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWF4U3R5bGUgLSB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAoJ21heC13aWR0aCcgLyAnbWF4LWhlaWdodCcpXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBlcmNlbnRhZ2VQcm9wZXJ0eSAtIHByb3BlcnR5IG9mIHBhcmVudCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aCBhcyBhIHBlcmNlbnRhZ2VcclxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5uYXRoYW5hZWxqb25lcy5jb20vYmxvZy8yMDEzL3JlYWRpbmctbWF4LXdpZHRoLWNyb3NzLWJyb3dzZXJ9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCBtYXhTdHlsZSwgcGVyY2VudGFnZVByb3BlcnR5KSB7XHJcblx0XHR2YXIgdmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cdFx0dmFyIHBhcmVudE5vZGUgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XHJcblx0XHR2YXIgY29uc3RyYWluZWROb2RlID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpW21heFN0eWxlXTtcclxuXHRcdHZhciBjb25zdHJhaW5lZENvbnRhaW5lciA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKVttYXhTdHlsZV07XHJcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcclxuXHRcdHZhciBoYXNDQ29udGFpbmVyID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkQ29udGFpbmVyKTtcclxuXHRcdHZhciBpbmZpbml0eSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcblx0XHRpZiAoaGFzQ05vZGUgfHwgaGFzQ0NvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oXHJcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxyXG5cdFx0XHRcdGhhc0NDb250YWluZXIgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkQ29udGFpbmVyLCBwYXJlbnROb2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAnbm9uZSc7XHJcblx0fVxyXG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XHJcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtd2lkdGgnLCAnY2xpZW50V2lkdGgnKTtcclxuXHR9O1xyXG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XHJcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQgPSBmdW5jdGlvbihkb21Ob2RlKSB7XHJcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcclxuXHR9O1xyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcbiBcdCAqL1xyXG5cdGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcGFkZGluZywgcGFyZW50RGltZW5zaW9uKSB7XHJcblx0XHRwYWRkaW5nID0gaGVscGVycyQxLmdldFN0eWxlKGNvbnRhaW5lciwgcGFkZGluZyk7XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmcuaW5kZXhPZignJScpID4gLTEgPyBwYXJlbnREaW1lbnNpb24gKiBwYXJzZUludChwYWRkaW5nLCAxMCkgLyAxMDAgOiBwYXJzZUludChwYWRkaW5nLCAxMCk7XHJcblx0fTtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHZhciBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XHJcblx0XHRpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcclxuXHRcdFx0cGFyZW50ID0gcGFyZW50Lmhvc3Q7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFyZW50O1xyXG5cdH07XHJcblx0aGVscGVycyQxLmdldE1heGltdW1XaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRXaWR0aDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XHJcblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JywgY2xpZW50V2lkdGgpO1xyXG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXJpZ2h0JywgY2xpZW50V2lkdGgpO1xyXG5cclxuXHRcdHZhciB3ID0gY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcclxuXHRcdHZhciBjdyA9IGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGgoZG9tTm9kZSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oY3cpID8gdyA6IE1hdGgubWluKHcsIGN3KTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudEhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcclxuXHRcdHZhciBwYWRkaW5nVG9wID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctdG9wJywgY2xpZW50SGVpZ2h0KTtcclxuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJywgY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHR2YXIgaCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xyXG5cdFx0dmFyIGNoID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oY2gpID8gaCA6IE1hdGgubWluKGgsIGNoKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xyXG5cdFx0cmV0dXJuIGVsLmN1cnJlbnRTdHlsZSA/XHJcblx0XHRcdGVsLmN1cnJlbnRTdHlsZVtwcm9wZXJ0eV0gOlxyXG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5yZXRpbmFTY2FsZSA9IGZ1bmN0aW9uKGNoYXJ0LCBmb3JjZVJhdGlvKSB7XHJcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XHJcblx0XHRpZiAocGl4ZWxSYXRpbyA9PT0gMSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XHJcblx0XHR2YXIgd2lkdGggPSBjaGFydC53aWR0aDtcclxuXHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcclxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcclxuXHRcdGNoYXJ0LmN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcclxuXHJcblx0XHQvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxyXG5cdFx0Ly8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cclxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxyXG5cdFx0aWYgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpIHtcclxuXHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdH1cclxuXHR9O1xyXG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXHJcblx0aGVscGVycyQxLmZvbnRTdHJpbmcgPSBmdW5jdGlvbihwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xyXG5cdFx0cmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5sb25nZXN0VGV4dCA9IGZ1bmN0aW9uKGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcclxuXHRcdGNhY2hlID0gY2FjaGUgfHwge307XHJcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xyXG5cdFx0dmFyIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcclxuXHJcblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xyXG5cdFx0XHRkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xyXG5cdFx0XHRnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XHJcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5mb250ID0gZm9udDtcclxuXHRcdHZhciBsb25nZXN0ID0gMDtcclxuXHRcdHZhciBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHR0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XHJcblxyXG5cdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcclxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycyQxLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XHJcblx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XHJcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxyXG5cdFx0XHRcdC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cclxuXHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XHJcblx0XHRcdFx0XHRuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xyXG5cdFx0XHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXHJcblx0XHRcdFx0XHRpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaGVscGVycyQxLmlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XHJcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XHJcblx0XHRpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xyXG5cdFx0XHRcdGRlbGV0ZSBkYXRhW2djW2ldXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxvbmdlc3Q7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEubWVhc3VyZVRleHQgPSBmdW5jdGlvbihjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcclxuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XHJcblx0XHRpZiAoIXRleHRXaWR0aCkge1xyXG5cdFx0XHR0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcclxuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcclxuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsb25nZXN0O1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICovXHJcblx0aGVscGVycyQxLm51bWJlck9mTGFiZWxMaW5lcyA9IGZ1bmN0aW9uKGFycmF5T2ZUaGluZ3MpIHtcclxuXHRcdHZhciBudW1iZXJPZkxpbmVzID0gMTtcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XHJcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcclxuXHRcdFx0XHRpZiAodGhpbmcubGVuZ3RoID4gbnVtYmVyT2ZMaW5lcykge1xyXG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIG51bWJlck9mTGluZXM7XHJcblx0fTtcclxuXHJcblx0aGVscGVycyQxLmNvbG9yID0gIWNoYXJ0anNDb2xvciA/XHJcblx0XHRmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0LyogZ2xvYmFsIENhbnZhc0dyYWRpZW50ICovXHJcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50KSB7XHJcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xyXG5cdFx0fTtcclxuXHJcblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XHJcblx0XHQvKiBnbG9iYWwgQ2FudmFzUGF0dGVybiAqL1xyXG5cdFx0cmV0dXJuIChjb2xvclZhbHVlIGluc3RhbmNlb2YgQ2FudmFzUGF0dGVybiB8fCBjb2xvclZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpID9cclxuXHRcdFx0Y29sb3JWYWx1ZSA6XHJcblx0XHRcdGhlbHBlcnMkMS5jb2xvcihjb2xvclZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLnJnYlN0cmluZygpO1xyXG5cdH07XHJcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xyXG5cdHRocm93IG5ldyBFcnJvcihcclxuXHRcdCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IGVpdGhlciBubyBhZGFwdGVyIGNhbiAnICtcclxuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXHJcblx0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxyXG4gKiBAdHlwZWRlZiB7KCdtaWxsaXNlY29uZCd8J3NlY29uZCd8J21pbnV0ZSd8J2hvdXInfCdkYXknfCd3ZWVrJ3wnbW9udGgnfCdxdWFydGVyJ3wneWVhcicpfVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXHJcbiAqIEBuYW1lIFVuaXRcclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxufVxyXG5cclxuaGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIC8qKiBAbGVuZHMgRGF0ZUFkYXB0ZXIgKi8ge1xyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxyXG5cdCAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXHJcblx0ICogQHJldHVybnMge3tzdHJpbmc6IHN0cmluZ319XHJcblx0ICovXHJcblx0Zm9ybWF0czogYWJzdHJhY3QsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cclxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcclxuXHQgKiBAcmV0dXJucyB7KG51bWJlcnxudWxsKX1cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHRwYXJzZTogYWJzdHJhY3QsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cclxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0Zm9ybWF0OiBhYnN0cmFjdCxcclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGBhbW91bnRgIG9mIGB1bml0YCB0byB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcclxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0YWRkOiBhYnN0cmFjdCxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGB1bml0YCBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lc3RhbXBzLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIHRoZSB0aW1lc3RhbXAgdG8gc3Vic3RyYWN0XHJcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXHJcblx0ICogQHJldHVybiB7bnVtYmVyfVxyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGRpZmY6IGFic3RyYWN0LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXHJcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcclxuXHQgKiBhbmQgNyBiZWluZyBTdW5kYXkgKG9ubHkgbmVlZGVkIGlmIHBhcmFtICp1bml0KiBpcyBgaXNvV2Vla2ApLlxyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdHN0YXJ0T2Y6IGFic3RyYWN0LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxyXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGVuZE9mOiBhYnN0cmFjdCxcclxuXHJcblx0Ly8gREVQUkVDQVRJT05TXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKCksXHJcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXHJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fVxyXG59KTtcclxuXHJcbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xyXG5cdGhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcclxufTtcclxuXHJcbnZhciBfZGF0ZSA9IERhdGVBZGFwdGVyO1xuXG52YXIgY29yZV9hZGFwdGVycyA9IHtcblx0X2RhdGU6IF9kYXRlXG59O1xuXG4vKipcclxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcclxuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xyXG4gKi9cclxudmFyIGNvcmVfdGlja3MgPSB7XHJcblx0LyoqXHJcblx0ICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXHJcblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXHJcblx0ICovXHJcblx0Zm9ybWF0dGVyczoge1xyXG5cdFx0LyoqXHJcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xyXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xyXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XHJcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XHJcblx0XHQgKi9cclxuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIGxpbmVhciBudW1lcmljIHRpY2tzXHJcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXHJcblx0XHQgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcclxuXHRcdCAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XHJcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcclxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXHJcblx0XHQgKi9cclxuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBsb3RzIG9mIHRpY2tzLCBkb24ndCB1c2UgdGhlIG9uZXNcclxuXHRcdFx0dmFyIGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdIC0gdGlja3NbMV0gOiB0aWNrc1sxXSAtIHRpY2tzWzBdO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxyXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEpID4gMSkge1xyXG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xyXG5cdFx0XHRcdFx0Ly8gbm90IGFuIGludGVnZXJcclxuXHRcdFx0XHRcdGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XHJcblx0XHRcdHZhciB0aWNrU3RyaW5nID0gJyc7XHJcblxyXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XHJcblx0XHRcdFx0dmFyIG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSk7XHJcblx0XHRcdFx0aWYgKG1heFRpY2sgPCAxZS00KSB7IC8vIGFsbCB0aWNrcyBhcmUgc21hbGwgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cclxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xyXG5cdFx0XHRcdFx0dmFyIG51bUV4cG9uZW50aWFsID0gTWF0aC5mbG9vcihsb2dUaWNrKSAtIE1hdGguZmxvb3IobG9nRGVsdGEpO1xyXG5cdFx0XHRcdFx0bnVtRXhwb25lbnRpYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1FeHBvbmVudGlhbCwgMjApLCAwKTtcclxuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChudW1FeHBvbmVudGlhbCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcclxuXHRcdFx0XHRcdG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1EZWNpbWFsLCAyMCksIDApOyAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xyXG5cdFx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0ZpeGVkKG51bURlY2ltYWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aWNrU3RyaW5nID0gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aWNrU3RyaW5nO1xyXG5cdFx0fSxcclxuXHJcblx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcclxuXHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbHVlKSkpKTtcclxuXHJcblx0XHRcdGlmICh0aWNrVmFsdWUgPT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gJzAnO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1IHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0aWNrcy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRpY2tWYWx1ZS50b0V4cG9uZW50aWFsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIGlzQXJyYXkgPSBoZWxwZXJzJDEuaXNBcnJheTtcclxudmFyIGlzTnVsbE9yVW5kZWYgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcclxudmFyIHZhbHVlT3JEZWZhdWx0JGEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcbnZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdzY2FsZScsIHtcclxuXHRkaXNwbGF5OiB0cnVlLFxyXG5cdHBvc2l0aW9uOiAnbGVmdCcsXHJcblx0b2Zmc2V0OiBmYWxzZSxcclxuXHJcblx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXHJcblx0Z3JpZExpbmVzOiB7XHJcblx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0Y29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxyXG5cdFx0bGluZVdpZHRoOiAxLFxyXG5cdFx0ZHJhd0JvcmRlcjogdHJ1ZSxcclxuXHRcdGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcclxuXHRcdGRyYXdUaWNrczogdHJ1ZSxcclxuXHRcdHRpY2tNYXJrTGVuZ3RoOiAxMCxcclxuXHRcdHplcm9MaW5lV2lkdGg6IDEsXHJcblx0XHR6ZXJvTGluZUNvbG9yOiAncmdiYSgwLDAsMCwwLjI1KScsXHJcblx0XHR6ZXJvTGluZUJvcmRlckRhc2g6IFtdLFxyXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiAwLjAsXHJcblx0XHRvZmZzZXRHcmlkTGluZXM6IGZhbHNlLFxyXG5cdFx0Ym9yZGVyRGFzaDogW10sXHJcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcclxuXHR9LFxyXG5cclxuXHQvLyBzY2FsZSBsYWJlbFxyXG5cdHNjYWxlTGFiZWw6IHtcclxuXHRcdC8vIGRpc3BsYXkgcHJvcGVydHlcclxuXHRcdGRpc3BsYXk6IGZhbHNlLFxyXG5cclxuXHRcdC8vIGFjdHVhbCBsYWJlbFxyXG5cdFx0bGFiZWxTdHJpbmc6ICcnLFxyXG5cclxuXHRcdC8vIHRvcC9ib3R0b20gcGFkZGluZ1xyXG5cdFx0cGFkZGluZzoge1xyXG5cdFx0XHR0b3A6IDQsXHJcblx0XHRcdGJvdHRvbTogNFxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIGxhYmVsIHNldHRpbmdzXHJcblx0dGlja3M6IHtcclxuXHRcdGJlZ2luQXRaZXJvOiBmYWxzZSxcclxuXHRcdG1pblJvdGF0aW9uOiAwLFxyXG5cdFx0bWF4Um90YXRpb246IDUwLFxyXG5cdFx0bWlycm9yOiBmYWxzZSxcclxuXHRcdHBhZGRpbmc6IDAsXHJcblx0XHRyZXZlcnNlOiBmYWxzZSxcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRhdXRvU2tpcDogdHJ1ZSxcclxuXHRcdGF1dG9Ta2lwUGFkZGluZzogMCxcclxuXHRcdGxhYmVsT2Zmc2V0OiAwLFxyXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcclxuXHRcdG1pbm9yOiB7fSxcclxuXHRcdG1ham9yOiB7fVxyXG5cdH1cclxufSk7XHJcblxyXG4vKiogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyICovXHJcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XHJcblx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdHZhciBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XHJcblx0dmFyIGkgPSAwO1xyXG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG5cclxuXHRmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcclxuXHRcdHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XHJcblx0fVxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcclxuXHR2YXIgbGVuZ3RoID0gc2NhbGUuZ2V0VGlja3MoKS5sZW5ndGg7XHJcblx0dmFyIHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XHJcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcclxuXHR2YXIgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcclxuXHR2YXIgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xyXG5cdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cclxuXHR2YXIgb2Zmc2V0O1xyXG5cclxuXHRpZiAob2Zmc2V0R3JpZExpbmVzKSB7XHJcblx0XHRpZiAobGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xyXG5cdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xyXG5cdFx0XHRvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xyXG5cdFx0fVxyXG5cdFx0bGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxyXG5cdFx0aWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGxpbmVWYWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcclxuXHRoZWxwZXJzJDEuZWFjaChjYWNoZXMsIGZ1bmN0aW9uKGNhY2hlKSB7XHJcblx0XHR2YXIgZ2MgPSBjYWNoZS5nYztcclxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XHJcblx0XHR2YXIgaTtcclxuXHRcdGlmIChnY0xlbiA+IGxlbmd0aCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xyXG5cdFx0XHRcdGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXHJcbiAqIGxhYmVscyB3aGVyZSBvZmZzZXQgaW5kaWNhdGVzIHRoZSBhbmNob3IgcG9pbnQgb2Zmc2V0IGZyb20gdGhlIHRvcCBpbiBwaXhlbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlTGFiZWxTaXplcyhjdHgsIHRpY2tGb250cywgdGlja3MsIGNhY2hlcykge1xyXG5cdHZhciBsZW5ndGggPSB0aWNrcy5sZW5ndGg7XHJcblx0dmFyIHdpZHRocyA9IFtdO1xyXG5cdHZhciBoZWlnaHRzID0gW107XHJcblx0dmFyIG9mZnNldHMgPSBbXTtcclxuXHR2YXIgd2lkZXN0TGFiZWxTaXplID0gMDtcclxuXHR2YXIgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XHJcblx0dmFyIGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsLCB3aWRlc3QsIGhpZ2hlc3Q7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG5cdFx0bGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcclxuXHRcdHRpY2tGb250ID0gdGlja3NbaV0ubWFqb3IgPyB0aWNrRm9udHMubWFqb3IgOiB0aWNrRm9udHMubWlub3I7XHJcblx0XHRjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XHJcblx0XHRjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XHJcblx0XHRsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcclxuXHRcdHdpZHRoID0gaGVpZ2h0ID0gMDtcclxuXHRcdC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xyXG5cdFx0XHR3aWR0aCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xyXG5cdFx0XHRoZWlnaHQgPSBsaW5lSGVpZ2h0O1xyXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xyXG5cdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxyXG5cdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdFx0bmVzdGVkTGFiZWwgPSBsYWJlbFtqXTtcclxuXHRcdFx0XHQvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxyXG5cdFx0XHRcdGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XHJcblx0XHRcdFx0XHR3aWR0aCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xyXG5cdFx0XHRcdFx0aGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR3aWR0aHMucHVzaCh3aWR0aCk7XHJcblx0XHRoZWlnaHRzLnB1c2goaGVpZ2h0KTtcclxuXHRcdG9mZnNldHMucHVzaChsaW5lSGVpZ2h0IC8gMik7XHJcblx0XHR3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcclxuXHRcdGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xyXG5cdH1cclxuXHRnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XHJcblxyXG5cdHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XHJcblx0aGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcclxuXHJcblx0ZnVuY3Rpb24gdmFsdWVBdChpZHgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHdpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwLFxyXG5cdFx0XHRvZmZzZXQ6IG9mZnNldHNbaWR4XSB8fCAwXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGZpcnN0OiB2YWx1ZUF0KDApLFxyXG5cdFx0bGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcclxuXHRcdHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxyXG5cdFx0aGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tNYXJrTGVuZ3RoIDogMDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2NhbGVMYWJlbEhlaWdodChvcHRpb25zKSB7XHJcblx0dmFyIGZvbnQsIHBhZGRpbmc7XHJcblxyXG5cdGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdGZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdGlvbnMpO1xyXG5cdHBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcclxuXHJcblx0cmV0dXJuIGZvbnQubGluZUhlaWdodCArIHBhZGRpbmcuaGVpZ2h0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG5lc3RlZE9wdHMpIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLmV4dGVuZChoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHtcclxuXHRcdGZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250RmFtaWx5LCBvcHRpb25zLmZvbnRGYW1pbHkpLFxyXG5cdFx0Zm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250U2l6ZSwgb3B0aW9ucy5mb250U2l6ZSksXHJcblx0XHRmb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250U3R5bGUsIG9wdGlvbnMuZm9udFN0eWxlKSxcclxuXHRcdGxpbmVIZWlnaHQ6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5saW5lSGVpZ2h0LCBvcHRpb25zLmxpbmVIZWlnaHQpXHJcblx0fSksIHtcclxuXHRcdGNvbG9yOiBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlKFtuZXN0ZWRPcHRzLmZvbnRDb2xvciwgb3B0aW9ucy5mb250Q29sb3IsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3JdKVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVRpY2tGb250T3B0aW9ucyhvcHRpb25zKSB7XHJcblx0dmFyIG1pbm9yID0gcGFyc2VGb250T3B0aW9ucyhvcHRpb25zLCBvcHRpb25zLm1pbm9yKTtcclxuXHR2YXIgbWFqb3IgPSBvcHRpb25zLm1ham9yLmVuYWJsZWQgPyBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG9wdGlvbnMubWFqb3IpIDogbWlub3I7XHJcblxyXG5cdHJldHVybiB7bWlub3I6IG1pbm9yLCBtYWpvcjogbWFqb3J9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub25Ta2lwcGVkKHRpY2tzVG9GaWx0ZXIpIHtcclxuXHR2YXIgZmlsdGVyZWQgPSBbXTtcclxuXHR2YXIgaXRlbSwgaW5kZXgsIGxlbjtcclxuXHRmb3IgKGluZGV4ID0gMCwgbGVuID0gdGlja3NUb0ZpbHRlci5sZW5ndGg7IGluZGV4IDwgbGVuOyArK2luZGV4KSB7XHJcblx0XHRpdGVtID0gdGlja3NUb0ZpbHRlcltpbmRleF07XHJcblx0XHRpZiAodHlwZW9mIGl0ZW0uX2luZGV4ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRmaWx0ZXJlZC5wdXNoKGl0ZW0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmlsdGVyZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xyXG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG5cdHZhciBpLCBkaWZmO1xyXG5cclxuXHRpZiAobGVuIDwgMikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Zm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XHJcblx0XHRpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkaWZmO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIGF4aXNMZW5ndGgsIHRpY2tzTGltaXQpIHtcclxuXHR2YXIgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XHJcblx0dmFyIHNwYWNpbmcgPSAodGlja3MubGVuZ3RoIC0gMSkgLyB0aWNrc0xpbWl0O1xyXG5cdHZhciBmYWN0b3JzLCBmYWN0b3IsIGksIGlsZW47XHJcblxyXG5cdC8vIElmIHRoZSBtYWpvciB0aWNrcyBhcmUgZXZlbmx5IHNwYWNlZCBhcGFydCwgcGxhY2UgdGhlIG1pbm9yIHRpY2tzXHJcblx0Ly8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xyXG5cdGlmICghZXZlbk1ham9yU3BhY2luZykge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xyXG5cdH1cclxuXHJcblx0ZmFjdG9ycyA9IGhlbHBlcnMkMS5tYXRoLl9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0ZmFjdG9yID0gZmFjdG9yc1tpXTtcclxuXHRcdGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XHJcblx0XHRcdHJldHVybiBmYWN0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XHJcblx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdHZhciBpLCBpbGVuO1xyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdGlmICh0aWNrc1tpXS5tYWpvcikge1xyXG5cdFx0XHRyZXN1bHQucHVzaChpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHR2YXIgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcclxuXHR2YXIgaSwgdGljaztcclxuXHJcblx0c3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdHRpY2sgPSB0aWNrc1tpXTtcclxuXHRcdGlmIChpID09PSBuZXh0KSB7XHJcblx0XHRcdHRpY2suX2luZGV4ID0gaTtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdFx0bmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGVsZXRlIHRpY2subGFiZWw7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xyXG5cdHZhciBzdGFydCA9IHZhbHVlT3JEZWZhdWx0JGEobWFqb3JTdGFydCwgMCk7XHJcblx0dmFyIGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0JGEobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHR2YXIgbGVuZ3RoLCBpLCB0aWNrLCBuZXh0O1xyXG5cclxuXHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xyXG5cdGlmIChtYWpvckVuZCkge1xyXG5cdFx0bGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xyXG5cdFx0c3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XHJcblx0fVxyXG5cclxuXHRuZXh0ID0gc3RhcnQ7XHJcblxyXG5cdHdoaWxlIChuZXh0IDwgMCkge1xyXG5cdFx0Y291bnQrKztcclxuXHRcdG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcclxuXHR9XHJcblxyXG5cdGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XHJcblx0XHR0aWNrID0gdGlja3NbaV07XHJcblx0XHRpZiAoaSA9PT0gbmV4dCkge1xyXG5cdFx0XHR0aWNrLl9pbmRleCA9IGk7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHRcdG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxudmFyIFNjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblxyXG5cdHplcm9MaW5lSW5kZXg6IDAsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxyXG5cdCAqIEBtZXRob2QgZ2V0UGFkZGluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge1BhZGRpbmd9IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xyXG5cdCAqL1xyXG5cdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXHJcblx0XHRcdHRvcDogbWUucGFkZGluZ1RvcCB8fCAwLFxyXG5cdFx0XHRyaWdodDogbWUucGFkZGluZ1JpZ2h0IHx8IDAsXHJcblx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0cyAoe2xhYmVsLCBtYWpvcn0pXHJcblx0ICogQHNpbmNlIDIuN1xyXG5cdCAqL1xyXG5cdGdldFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl90aWNrcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQqIEBwcml2YXRlXHJcblx0Ki9cclxuXHRfZ2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cclxuXHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXHJcblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxyXG5cclxuXHQvKipcclxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcblx0ICogQGZ1bmN0aW9uIENoYXJ0LlNjYWxlLm1lcmdlVGlja3NPcHRpb25zXHJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHQgKi9cclxuXHRtZXJnZVRpY2tzT3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHQvLyBub29wXHJcblx0fSxcclxuXHJcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIHRoZSBtYXggaGVpZ2h0IGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcclxuXHQgKiAgIFRoaXMgc3BhY2UgY29tZXMgZnJvbSB0d28gc291cmNlczpcclxuXHQgKiAgICAgLSBwYWRkaW5nIC0gc3BhY2UgdGhhdCdzIHJlcXVpcmVkIHRvIHNob3cgdGhlIGxhYmVscyBhdCB0aGUgZWRnZXMgb2YgdGhlIHNjYWxlXHJcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cclxuXHQgKi9cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xyXG5cdFx0dmFyIGksIGlsZW4sIGxhYmVscywgdGlja3MsIHNhbXBsaW5nRW5hYmxlZDtcclxuXHJcblx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxyXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXHJcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xyXG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG5cdFx0bWUubWFyZ2lucyA9IGhlbHBlcnMkMS5leHRlbmQoe1xyXG5cdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRyaWdodDogMCxcclxuXHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRib3R0b206IDBcclxuXHRcdH0sIG1hcmdpbnMpO1xyXG5cclxuXHRcdG1lLl90aWNrcyA9IG51bGw7XHJcblx0XHRtZS50aWNrcyA9IG51bGw7XHJcblx0XHRtZS5fbGFiZWxTaXplcyA9IG51bGw7XHJcblx0XHRtZS5fbWF4TGFiZWxMaW5lcyA9IDA7XHJcblx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IDA7XHJcblx0XHRtZS5sb25nZXN0VGV4dENhY2hlID0gbWUubG9uZ2VzdFRleHRDYWNoZSB8fCB7fTtcclxuXHRcdG1lLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcclxuXHRcdG1lLl9sYWJlbEl0ZW1zID0gbnVsbDtcclxuXHJcblx0XHQvLyBEaW1lbnNpb25zXHJcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuXHJcblx0XHQvLyBEYXRhIG1pbi9tYXhcclxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcclxuXHRcdG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcclxuXHRcdG1lLmFmdGVyRGF0YUxpbWl0cygpO1xyXG5cclxuXHRcdC8vIFRpY2tzIC0gYHRoaXMudGlja3NgIGlzIG5vdyBERVBSRUNBVEVEIVxyXG5cdFx0Ly8gSW50ZXJuYWwgdGlja3MgYXJlIG5vdyBzdG9yZWQgYXMgb2JqZWN0cyBpbiB0aGUgUFJJVkFURSBgdGhpcy5fdGlja3NgIG1lbWJlclxyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcclxuXHRcdC8vIGFyb3VuZCBmb3IgbG9uZyB0aW1lIGFuZCBub3QgbWFya2VkIGFzIHByaXZhdGUsIHdlIGNhbid0IGNoYW5nZSBpdHMgc3RydWN0dXJlXHJcblx0XHQvLyB3aXRob3V0IHVuZXhwZWN0ZWQgYnJlYWtpbmcgY2hhbmdlcy4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzY2FsZSB0aWNrcyxcclxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXHJcblxyXG5cdFx0bWUuYmVmb3JlQnVpbGRUaWNrcygpO1xyXG5cclxuXHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIGJ1dCBmb3IgQkFDS1dBUkQgQ09NUEFULFxyXG5cdFx0Ly8gd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IHNldCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kKS5cclxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xyXG5cclxuXHRcdC8vIEFsbG93IG1vZGlmaWNhdGlvbiBvZiB0aWNrcyBpbiBjYWxsYmFjay5cclxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcclxuXHJcblx0XHQvLyBFbnN1cmUgdGlja3MgY29udGFpbnMgdGlja3MgaW4gbmV3IHRpY2sgZm9ybWF0XHJcblx0XHRpZiAoKCF0aWNrcyB8fCAhdGlja3MubGVuZ3RoKSAmJiBtZS50aWNrcykge1xyXG5cdFx0XHR0aWNrcyA9IFtdO1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0dGlja3MucHVzaCh7XHJcblx0XHRcdFx0XHR2YWx1ZTogbWUudGlja3NbaV0sXHJcblx0XHRcdFx0XHRtYWpvcjogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl90aWNrcyA9IHRpY2tzO1xyXG5cclxuXHRcdC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXHJcblx0XHQvLyBXZSBnZW5lcmFsbHkgZG9uJ3QgbmVlZCB0byBjb21wdXRlIHRoZSBzaXplIG9mIGV2ZXJ5IHNpbmdsZSBsYWJlbCBmb3IgZGV0ZXJtaW5pbmcgc2NhbGUgc2l6ZVxyXG5cdFx0c2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aDtcclxuXHRcdGxhYmVscyA9IG1lLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpIDogdGlja3MpO1xyXG5cclxuXHRcdC8vIF9jb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGhlcmUsIG9uY2UgZnJvbSBjb3JlLmNvbnRyb2xsZXIudXBkYXRlTGF5b3V0LlxyXG5cdFx0Ly8gSGVyZSB3ZSBoYXZlbid0IGJlZW4gcG9zaXRpb25lZCB5ZXQsIGJ1dCBkaW1lbnNpb25zIGFyZSBjb3JyZWN0LlxyXG5cdFx0Ly8gVmFyaWFibGVzIHNldCBpbiBfY29uZmlndXJlIGFyZSBuZWVkZWQgZm9yIGNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgYW5kXHJcblx0XHQvLyBpdCdzIG9rIHRoYXQgY29vcmRpbmF0ZXMgYXJlIG5vdCBjb3JyZWN0IHRoZXJlLCBvbmx5IGRpbWVuc2lvbnMgbWF0dGVyLlxyXG5cdFx0bWUuX2NvbmZpZ3VyZSgpO1xyXG5cclxuXHRcdC8vIFRpY2sgUm90YXRpb25cclxuXHRcdG1lLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xyXG5cdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XHJcblx0XHRtZS5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xyXG5cclxuXHRcdG1lLmJlZm9yZUZpdCgpO1xyXG5cdFx0bWUuZml0KCk7XHJcblx0XHRtZS5hZnRlckZpdCgpO1xyXG5cclxuXHRcdC8vIEF1dG8tc2tpcFxyXG5cdFx0bWUuX3RpY2tzVG9EcmF3ID0gdGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpID8gbWUuX2F1dG9Ta2lwKHRpY2tzKSA6IHRpY2tzO1xyXG5cclxuXHRcdGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcclxuXHRcdFx0Ly8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xyXG5cdFx0XHRsYWJlbHMgPSBtZS5fY29udmVydFRpY2tzVG9MYWJlbHMobWUuX3RpY2tzVG9EcmF3KTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS50aWNrcyA9IGxhYmVsczsgICAvLyBCQUNLV0FSRCBDT01QQVRJQklMSVRZXHJcblxyXG5cdFx0Ly8gSU1QT1JUQU5UOiBhZnRlciB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcclxuXHJcblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIFRPRE8odjMpOiByZW1vdmUgbWluU2l6ZSBhcyBhIHB1YmxpYyBwcm9wZXJ0eSBhbmQgcmV0dXJuIHZhbHVlIGZyb20gYWxsIGxheW91dCBib3hlcy4gSXQgaXMgdW51c2VkXHJcblx0XHQvLyBtYWtlIG1heFdpZHRoIGFuZCBtYXhIZWlnaHQgcHJpdmF0ZVxyXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgcmV2ZXJzZVBpeGVscyA9IG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZTtcclxuXHRcdHZhciBzdGFydFBpeGVsLCBlbmRQaXhlbDtcclxuXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0c3RhcnRQaXhlbCA9IG1lLmxlZnQ7XHJcblx0XHRcdGVuZFBpeGVsID0gbWUucmlnaHQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdGFydFBpeGVsID0gbWUudG9wO1xyXG5cdFx0XHRlbmRQaXhlbCA9IG1lLmJvdHRvbTtcclxuXHRcdFx0Ly8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxyXG5cdFx0XHRyZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XHJcblx0XHR9XHJcblx0XHRtZS5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XHJcblx0XHRtZS5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcclxuXHRcdG1lLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcclxuXHRcdG1lLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XHJcblx0fSxcclxuXHJcblx0YWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcclxuXHR9LFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcclxuXHR9LFxyXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRcdG1lLmxlZnQgPSAwO1xyXG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLnRvcCA9IDA7XHJcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXNldCBwYWRkaW5nXHJcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcclxuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcclxuXHR9LFxyXG5cdGFmdGVyU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBEYXRhIGxpbWl0c1xyXG5cdGJlZm9yZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVEYXRhTGltaXRzLCBbdGhpc10pO1xyXG5cdH0sXHJcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogaGVscGVycyQxLm5vb3AsXHJcblx0YWZ0ZXJEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJEYXRhTGltaXRzLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblx0YmVmb3JlQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUJ1aWxkVGlja3MsIFt0aGlzXSk7XHJcblx0fSxcclxuXHRidWlsZFRpY2tzOiBoZWxwZXJzJDEubm9vcCxcclxuXHRhZnRlckJ1aWxkVGlja3M6IGZ1bmN0aW9uKHRpY2tzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gdGlja3MgaXMgZW1wdHkgZm9yIG9sZCBheGlzIGltcGxlbWVudGF0aW9ucyBoZXJlXHJcblx0XHRpZiAoaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuY2FsbGJhY2sobWUub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFttZSwgdGlja3NdKTtcclxuXHRcdH1cclxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcclxuXHRcdG1lLnRpY2tzID0gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIG1lLnRpY2tzXSkgfHwgbWUudGlja3M7XHJcblx0XHRyZXR1cm4gdGlja3M7XHJcblx0fSxcclxuXHJcblx0YmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIENvbnZlcnQgdGlja3MgdG8gc3RyaW5nc1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XHJcblx0fSxcclxuXHRhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcclxuXHR9LFxyXG5cdGNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBudW1UaWNrcyA9IG1lLmdldFRpY2tzKCkubGVuZ3RoO1xyXG5cdFx0dmFyIG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcclxuXHRcdHZhciBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xyXG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcclxuXHRcdHZhciBsYWJlbFNpemVzLCBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCwgbWF4V2lkdGgsIHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xyXG5cclxuXHRcdGlmICghbWUuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIW1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdG1lLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xyXG5cdFx0bWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xyXG5cdFx0bWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGFiZWxTaXplcy5oaWdoZXN0Lm9mZnNldDtcclxuXHJcblx0XHQvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXHJcblx0XHQvLyBsYWJlbCB3aWR0aCBhbmQgdGhlIG51bWJlciBvZiB0aWNrIGludGVydmFsc1xyXG5cdFx0bWF4V2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWUuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoKTtcclxuXHRcdHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gbWUubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XHJcblxyXG5cdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcclxuXHRcdGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xyXG5cdFx0XHR0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcclxuXHRcdFx0bWF4SGVpZ2h0ID0gbWUubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkTGluZXMpXHJcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0U2NhbGVMYWJlbEhlaWdodChvcHRpb25zLnNjYWxlTGFiZWwpO1xyXG5cdFx0XHRtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XHJcblx0XHRcdGxhYmVsUm90YXRpb24gPSBoZWxwZXJzJDEudG9EZWdyZWVzKE1hdGgubWluKFxyXG5cdFx0XHRcdE1hdGguYXNpbihNYXRoLm1pbigobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAxKSksXHJcblx0XHRcdFx0TWF0aC5hc2luKE1hdGgubWluKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIDEpKSAtIE1hdGguYXNpbihtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwpXHJcblx0XHRcdCkpO1xyXG5cdFx0XHRsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XHJcblx0fSxcclxuXHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcclxuXHR9LFxyXG5cdGZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gUmVzZXRcclxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcclxuXHRcdFx0d2lkdGg6IDAsXHJcblx0XHRcdGhlaWdodDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XHJcblx0XHR2YXIgc2NhbGVMYWJlbE9wdHMgPSBvcHRzLnNjYWxlTGFiZWw7XHJcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XHJcblx0XHR2YXIgZGlzcGxheSA9IG1lLl9pc1Zpc2libGUoKTtcclxuXHRcdHZhciBpc0JvdHRvbSA9IG9wdHMucG9zaXRpb24gPT09ICdib3R0b20nO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cclxuXHRcdC8vIFdpZHRoXHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDtcclxuXHRcdH0gZWxzZSBpZiAoZGlzcGxheSkge1xyXG5cdFx0XHRtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZExpbmVPcHRzKSArIGdldFNjYWxlTGFiZWxIZWlnaHQoc2NhbGVMYWJlbE9wdHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGhlaWdodFxyXG5cdFx0aWYgKCFpc0hvcml6b250YWwpIHtcclxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcclxuXHRcdH0gZWxzZSBpZiAoZGlzcGxheSkge1xyXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRMaW5lT3B0cykgKyBnZXRTY2FsZUxhYmVsSGVpZ2h0KHNjYWxlTGFiZWxPcHRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcclxuXHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIGRpc3BsYXkpIHtcclxuXHRcdFx0dmFyIHRpY2tGb250cyA9IHBhcnNlVGlja0ZvbnRPcHRpb25zKHRpY2tPcHRzKTtcclxuXHRcdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xyXG5cdFx0XHR2YXIgZmlyc3RMYWJlbFNpemUgPSBsYWJlbFNpemVzLmZpcnN0O1xyXG5cdFx0XHR2YXIgbGFzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMubGFzdDtcclxuXHRcdFx0dmFyIHdpZGVzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMud2lkZXN0O1xyXG5cdFx0XHR2YXIgaGlnaGVzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMuaGlnaGVzdDtcclxuXHRcdFx0dmFyIGxpbmVTcGFjZSA9IHRpY2tGb250cy5taW5vci5saW5lSGVpZ2h0ICogMC40O1xyXG5cdFx0XHR2YXIgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nO1xyXG5cclxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRcdC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cclxuXHRcdFx0XHR2YXIgaXNSb3RhdGVkID0gbWUubGFiZWxSb3RhdGlvbiAhPT0gMDtcclxuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcclxuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG5cdFx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XHJcblxyXG5cdFx0XHRcdHZhciBsYWJlbEhlaWdodCA9IHNpblJvdGF0aW9uICogd2lkZXN0TGFiZWxTaXplLndpZHRoXHJcblx0XHRcdFx0XHQrIGNvc1JvdGF0aW9uICogKGhpZ2hlc3RMYWJlbFNpemUuaGVpZ2h0IC0gKGlzUm90YXRlZCA/IGhpZ2hlc3RMYWJlbFNpemUub2Zmc2V0IDogMCkpXHJcblx0XHRcdFx0XHQrIChpc1JvdGF0ZWQgPyAwIDogbGluZVNwYWNlKTsgLy8gcGFkZGluZ1xyXG5cclxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKG1lLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcclxuXHJcblx0XHRcdFx0dmFyIG9mZnNldExlZnQgPSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSBtZS5sZWZ0O1xyXG5cdFx0XHRcdHZhciBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKG1lLmdldFRpY2tzKCkubGVuZ3RoIC0gMSk7XHJcblx0XHRcdFx0dmFyIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQ7XHJcblxyXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXHJcblx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XHJcblx0XHRcdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBpc0JvdHRvbSA/XHJcblx0XHRcdFx0XHRcdGNvc1JvdGF0aW9uICogZmlyc3RMYWJlbFNpemUud2lkdGggKyBzaW5Sb3RhdGlvbiAqIGZpcnN0TGFiZWxTaXplLm9mZnNldCA6XHJcblx0XHRcdFx0XHRcdHNpblJvdGF0aW9uICogKGZpcnN0TGFiZWxTaXplLmhlaWdodCAtIGZpcnN0TGFiZWxTaXplLm9mZnNldCk7XHJcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBpc0JvdHRvbSA/XHJcblx0XHRcdFx0XHRcdHNpblJvdGF0aW9uICogKGxhc3RMYWJlbFNpemUuaGVpZ2h0IC0gbGFzdExhYmVsU2l6ZS5vZmZzZXQpIDpcclxuXHRcdFx0XHRcdFx0Y29zUm90YXRpb24gKiBsYXN0TGFiZWxTaXplLndpZHRoICsgc2luUm90YXRpb24gKiBsYXN0TGFiZWxTaXplLm9mZnNldDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBmaXJzdExhYmVsU2l6ZS53aWR0aCAvIDI7XHJcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxTaXplLndpZHRoIC8gMjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXHJcblx0XHRcdFx0Ly8gYW5kIGFkZCAzIHB4IHRvIG1vdmUgYXdheSBmcm9tIGNhbnZhcyBlZGdlc1xyXG5cdFx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCkgKiBtZS53aWR0aCAvIChtZS53aWR0aCAtIG9mZnNldExlZnQpLCAwKSArIDM7XHJcblx0XHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0KSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKSArIDM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gQSB2ZXJ0aWNhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIHdpZHRoLiBMYWJlbHMgYXJlIHRoZVxyXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcclxuXHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOlxyXG5cdFx0XHRcdFx0Ly8gdXNlIGxpbmVTcGFjZSBmb3IgY29uc2lzdGVuY3kgd2l0aCBob3Jpem9udGFsIGF4aXNcclxuXHRcdFx0XHRcdC8vIHRpY2tQYWRkaW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgaG9yaXpvbnRhbFxyXG5cdFx0XHRcdFx0d2lkZXN0TGFiZWxTaXplLndpZHRoICsgdGlja1BhZGRpbmcgKyBsaW5lU3BhY2U7XHJcblxyXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGgpO1xyXG5cclxuXHRcdFx0XHRtZS5wYWRkaW5nVG9wID0gZmlyc3RMYWJlbFNpemUuaGVpZ2h0IC8gMjtcclxuXHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gbGFzdExhYmVsU2l6ZS5oZWlnaHQgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuaGFuZGxlTWFyZ2lucygpO1xyXG5cclxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0bWUud2lkdGggPSBtZS5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSBtZS5tYXJnaW5zLmxlZnQgLSBtZS5tYXJnaW5zLnJpZ2h0O1xyXG5cdFx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIG1lLm1hcmdpbnMudG9wIC0gbWUubWFyZ2lucy5ib3R0b207XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRpZiAobWUubWFyZ2lucykge1xyXG5cdFx0XHRtZS5tYXJnaW5zLmxlZnQgPSBNYXRoLm1heChtZS5wYWRkaW5nTGVmdCwgbWUubWFyZ2lucy5sZWZ0KTtcclxuXHRcdFx0bWUubWFyZ2lucy50b3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wLCBtZS5tYXJnaW5zLnRvcCk7XHJcblx0XHRcdG1lLm1hcmdpbnMucmlnaHQgPSBNYXRoLm1heChtZS5wYWRkaW5nUmlnaHQsIG1lLm1hcmdpbnMucmlnaHQpO1xyXG5cdFx0XHRtZS5tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KG1lLnBhZGRpbmdCb3R0b20sIG1lLm1hcmdpbnMuYm90dG9tKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZnRlckZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vIFNoYXJlZCBNZXRob2RzXHJcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0XHRyZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xyXG5cdH0sXHJcblx0aXNGdWxsV2lkdGg6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsV2lkdGg7XHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHZhbHVlLiBOYU4gYmFkIGlucHV0cywgSWYgdGhlIHZhbHVlIHR5cGUgaXMgb2JqZWN0IGdldCB0aGUgeCBvciB5IGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlIGhvcml6b250YWwgb3Igbm90XHJcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcclxuXHRcdC8vIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZmlyc3RcclxuXHRcdGlmIChpc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gTmFOO1xyXG5cdFx0fVxyXG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xyXG5cdFx0aWYgKCh0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInIHx8IHJhd1ZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUocmF3VmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBOYU47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcclxuXHRcdGlmIChyYXdWYWx1ZSkge1xyXG5cdFx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBWYWx1ZSBpcyBnb29kLCByZXR1cm4gaXRcclxuXHRcdHJldHVybiByYXdWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRfY29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKHRpY2tzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGxhYmVscywgaSwgaWxlbjtcclxuXHJcblx0XHRtZS50aWNrcyA9IHRpY2tzLm1hcChmdW5jdGlvbih0aWNrKSB7XHJcblx0XHRcdHJldHVybiB0aWNrLnZhbHVlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XHJcblxyXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxyXG5cdFx0Ly8gQ09NUEFULCB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgY2hhbmdlZCBieSBjYWxsaW5nXHJcblx0XHQvLyB0aGlzIG1ldGhvZCBhbmQgc3VwcG9zZWQgdG8gY29udGFpbiBvbmx5IHN0cmluZyB2YWx1ZXMpLlxyXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xyXG5cclxuXHRcdG1lLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XHJcblxyXG5cdFx0Ly8gQkFDS1dBUkQgQ09NUEFUOiBzeW5jaHJvbml6ZSBgX3RpY2tzYCB3aXRoIGxhYmVscyAoc28gcG90ZW50aWFsbHkgYHRoaXMudGlja3NgKVxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHR0aWNrc1tpXS5sYWJlbCA9IGxhYmVsc1tpXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGFiZWxzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldExhYmVsU2l6ZXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsYWJlbFNpemVzID0gbWUuX2xhYmVsU2l6ZXM7XHJcblxyXG5cdFx0aWYgKCFsYWJlbFNpemVzKSB7XHJcblx0XHRcdG1lLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IGNvbXB1dGVMYWJlbFNpemVzKG1lLmN0eCwgcGFyc2VUaWNrRm9udE9wdGlvbnMobWUub3B0aW9ucy50aWNrcyksIG1lLmdldFRpY2tzKCksIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xyXG5cdFx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYWJlbFNpemVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3BhcnNlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgc3RhcnQsIGVuZCwgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdHN0YXJ0ID0gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh2YWx1ZVswXSk7XHJcblx0XHRcdGVuZCA9ICt0aGlzLmdldFJpZ2h0VmFsdWUodmFsdWVbMV0pO1xyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcclxuXHRcdFx0bWF4ID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YWx1ZSA9ICt0aGlzLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xyXG5cdFx0XHRzdGFydCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0ZW5kID0gdmFsdWU7XHJcblx0XHRcdG1pbiA9IHZhbHVlO1xyXG5cdFx0XHRtYXggPSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRtaW46IG1pbixcclxuXHRcdFx0bWF4OiBtYXgsXHJcblx0XHRcdHN0YXJ0OiBzdGFydCxcclxuXHRcdFx0ZW5kOiBlbmRcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0KiBAcHJpdmF0ZVxyXG5cdCovXHJcblx0X2dldFNjYWxlTGFiZWw6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XHJcblx0XHR2YXIgdiA9IHRoaXMuX3BhcnNlVmFsdWUocmF3VmFsdWUpO1xyXG5cdFx0aWYgKHYuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gJ1snICsgdi5zdGFydCArICcsICcgKyB2LmVuZCArICddJztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxyXG5cdCAqIEBwYXJhbSBpbmRleFxyXG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcclxuXHQgKi9cclxuXHRnZXRMYWJlbEZvckluZGV4OiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcclxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcclxuXHQgKiBAcGFyYW0gdmFsdWVcclxuXHQgKiBAcGFyYW0gaW5kZXhcclxuXHQgKiBAcGFyYW0gZGF0YXNldEluZGV4XHJcblx0ICovXHJcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXHJcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXHJcblx0ICogQHBhcmFtIHBpeGVsXHJcblx0ICovXHJcblx0Z2V0VmFsdWVGb3JQaXhlbDogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxyXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xyXG5cdCAqL1xyXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XHJcblx0XHR2YXIgbnVtVGlja3MgPSBtZS5fdGlja3MubGVuZ3RoO1xyXG5cdFx0dmFyIHRpY2tXaWR0aCA9IDEgLyBNYXRoLm1heChudW1UaWNrcyAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xyXG5cclxuXHRcdHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPiBudW1UaWNrcyAtIDFcclxuXHRcdFx0PyBudWxsXHJcblx0XHRcdDogbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKGluZGV4ICogdGlja1dpZHRoICsgKG9mZnNldCA/IHRpY2tXaWR0aCAvIDIgOiAwKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXHJcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXHJcblx0ICovXHJcblx0Z2V0UGl4ZWxGb3JEZWNpbWFsOiBmdW5jdGlvbihkZWNpbWFsKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGlmIChtZS5fcmV2ZXJzZVBpeGVscykge1xyXG5cdFx0XHRkZWNpbWFsID0gMSAtIGRlY2ltYWw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIG1lLl9sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0Z2V0RGVjaW1hbEZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0dmFyIGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxyXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xyXG5cdCAqL1xyXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhc2VWYWx1ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcclxuXHRcdHZhciBtYXggPSBtZS5tYXg7XHJcblxyXG5cdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XHJcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XHJcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XHJcblx0XHRcdDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9hdXRvU2tpcDogZnVuY3Rpb24odGlja3MpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIGF4aXNMZW5ndGggPSBtZS5fbGVuZ3RoO1xyXG5cdFx0dmFyIHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGF4aXNMZW5ndGggLyBtZS5fdGlja1NpemUoKSArIDE7XHJcblx0XHR2YXIgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcclxuXHRcdHZhciBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xyXG5cdFx0dmFyIGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xyXG5cdFx0dmFyIGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XHJcblx0XHR2YXIgaSwgaWxlbiwgc3BhY2luZywgYXZnTWFqb3JTcGFjaW5nO1xyXG5cclxuXHRcdC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXHJcblx0XHRpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xyXG5cdFx0XHRza2lwTWFqb3JzKHRpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xyXG5cdFx0XHRyZXR1cm4gbm9uU2tpcHBlZCh0aWNrcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgYXhpc0xlbmd0aCwgdGlja3NMaW1pdCk7XHJcblxyXG5cdFx0aWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0XHRza2lwKHRpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyAobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSA6IG51bGw7XHJcblx0XHRcdHNraXAodGlja3MsIHNwYWNpbmcsIGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcclxuXHRcdFx0c2tpcCh0aWNrcywgc3BhY2luZywgbGFzdCwgaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xyXG5cdFx0XHRyZXR1cm4gbm9uU2tpcHBlZCh0aWNrcyk7XHJcblx0XHR9XHJcblx0XHRza2lwKHRpY2tzLCBzcGFjaW5nKTtcclxuXHRcdHJldHVybiBub25Ta2lwcGVkKHRpY2tzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF90aWNrU2l6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxyXG5cdFx0dmFyIHJvdCA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XHJcblx0XHR2YXIgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XHJcblx0XHR2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XHJcblxyXG5cdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xyXG5cdFx0dmFyIHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcclxuXHRcdHZhciB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XHJcblx0XHR2YXIgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxyXG5cdFx0cmV0dXJuIG1lLmlzSG9yaXpvbnRhbCgpXHJcblx0XHRcdD8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxyXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xyXG5cdFx0dmFyIGksIGlsZW4sIG1ldGE7XHJcblxyXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xyXG5cdFx0XHRyZXR1cm4gISFkaXNwbGF5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdoZW4gJ2F1dG8nLCB0aGUgc2NhbGUgaXMgdmlzaWJsZSBpZiBhdCBsZWFzdCBvbmUgYXNzb2NpYXRlZCBkYXRhc2V0IGlzIHZpc2libGUuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgfHwgbWV0YS55QXhpc0lEID09PSBtZS5pZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2NvbXB1dGVHcmlkTGluZUl0ZW1zOiBmdW5jdGlvbihjaGFydEFyZWEpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcclxuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcblx0XHR2YXIgb2Zmc2V0R3JpZExpbmVzID0gZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcztcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHRcdHZhciB0aWNrcyA9IG1lLl90aWNrc1RvRHJhdztcclxuXHRcdHZhciB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXRHcmlkTGluZXMgPyAxIDogMCk7XHJcblxyXG5cdFx0dmFyIHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZExpbmVzKTtcclxuXHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0dmFyIGF4aXNXaWR0aCA9IGdyaWRMaW5lcy5kcmF3Qm9yZGVyID8gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIDAsIDApIDogMDtcclxuXHRcdHZhciBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcclxuXHRcdHZhciBhbGlnblBpeGVsID0gaGVscGVycyQxLl9hbGlnblBpeGVsO1xyXG5cdFx0dmFyIGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0XHRyZXR1cm4gYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XHJcblx0XHR9O1xyXG5cdFx0dmFyIGJvcmRlclZhbHVlLCBpLCB0aWNrLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XHJcblx0XHR2YXIgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xyXG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUuYm90dG9tKTtcclxuXHRcdFx0dHkxID0gbWUuYm90dG9tIC0gdGw7XHJcblx0XHRcdHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0eTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0eTIgPSBjaGFydEFyZWEuYm90dG9tO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLnRvcCk7XHJcblx0XHRcdHkxID0gY2hhcnRBcmVhLnRvcDtcclxuXHRcdFx0eTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0dHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR0eTIgPSBtZS50b3AgKyB0bDtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUucmlnaHQpO1xyXG5cdFx0XHR0eDEgPSBtZS5yaWdodCAtIHRsO1xyXG5cdFx0XHR0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR4MiA9IGNoYXJ0QXJlYS5yaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5sZWZ0KTtcclxuXHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcclxuXHRcdFx0eDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHR4MiA9IG1lLmxlZnQgKyB0bDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7ICsraSkge1xyXG5cdFx0XHR0aWNrID0gdGlja3NbaV0gfHwge307XHJcblxyXG5cdFx0XHQvLyBhdXRvc2tpcHBlciBza2lwcGVkIHRoaXMgdGljayAoIzQ2MzUpXHJcblx0XHRcdGlmIChpc051bGxPclVuZGVmKHRpY2subGFiZWwpICYmIGkgPCB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGkgPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IG9mZnNldEdyaWRMaW5lcykge1xyXG5cdFx0XHRcdC8vIERyYXcgdGhlIGZpcnN0IGluZGV4IHNwZWNpYWxseVxyXG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xyXG5cdFx0XHRcdGxpbmVDb2xvciA9IGdyaWRMaW5lcy56ZXJvTGluZUNvbG9yO1xyXG5cdFx0XHRcdGJvcmRlckRhc2ggPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoIHx8IFtdO1xyXG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgaSwgMSk7XHJcblx0XHRcdFx0bGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgaSwgJ3JnYmEoMCwwLDAsMC4xKScpO1xyXG5cdFx0XHRcdGJvcmRlckRhc2ggPSBncmlkTGluZXMuYm9yZGVyRGFzaCB8fCBbXTtcclxuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKG1lLCB0aWNrLl9pbmRleCB8fCBpLCBvZmZzZXRHcmlkTGluZXMpO1xyXG5cclxuXHRcdFx0Ly8gU2tpcCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxyXG5cdFx0XHRpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxpZ25lZExpbmVWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcclxuXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHR0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aXRlbXMucHVzaCh7XHJcblx0XHRcdFx0dHgxOiB0eDEsXHJcblx0XHRcdFx0dHkxOiB0eTEsXHJcblx0XHRcdFx0dHgyOiB0eDIsXHJcblx0XHRcdFx0dHkyOiB0eTIsXHJcblx0XHRcdFx0eDE6IHgxLFxyXG5cdFx0XHRcdHkxOiB5MSxcclxuXHRcdFx0XHR4MjogeDIsXHJcblx0XHRcdFx0eTI6IHkyLFxyXG5cdFx0XHRcdHdpZHRoOiBsaW5lV2lkdGgsXHJcblx0XHRcdFx0Y29sb3I6IGxpbmVDb2xvcixcclxuXHRcdFx0XHRib3JkZXJEYXNoOiBib3JkZXJEYXNoLFxyXG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGl0ZW1zLnRpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XHJcblx0XHRpdGVtcy5ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xyXG5cclxuXHRcdHJldHVybiBpdGVtcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jb21wdXRlTGFiZWxJdGVtczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIG9wdGlvblRpY2tzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcblx0XHR2YXIgaXNNaXJyb3JlZCA9IG9wdGlvblRpY2tzLm1pcnJvcjtcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHRcdHZhciB0aWNrcyA9IG1lLl90aWNrc1RvRHJhdztcclxuXHRcdHZhciBmb250cyA9IHBhcnNlVGlja0ZvbnRPcHRpb25zKG9wdGlvblRpY2tzKTtcclxuXHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XHJcblx0XHR2YXIgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWRMaW5lcyk7XHJcblx0XHR2YXIgcm90YXRpb24gPSAtaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcclxuXHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0dmFyIGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xyXG5cdFx0XHR5ID0gbWUuYm90dG9tIC0gdGwgLSB0aWNrUGFkZGluZztcclxuXHRcdFx0dGV4dEFsaWduID0gIXJvdGF0aW9uID8gJ2NlbnRlcicgOiAnbGVmdCc7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xyXG5cdFx0XHR5ID0gbWUudG9wICsgdGwgKyB0aWNrUGFkZGluZztcclxuXHRcdFx0dGV4dEFsaWduID0gIXJvdGF0aW9uID8gJ2NlbnRlcicgOiAncmlnaHQnO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcblx0XHRcdHggPSBtZS5yaWdodCAtIChpc01pcnJvcmVkID8gMCA6IHRsKSAtIHRpY2tQYWRkaW5nO1xyXG5cdFx0XHR0ZXh0QWxpZ24gPSBpc01pcnJvcmVkID8gJ2xlZnQnIDogJ3JpZ2h0JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHggPSBtZS5sZWZ0ICsgKGlzTWlycm9yZWQgPyAwIDogdGwpICsgdGlja1BhZGRpbmc7XHJcblx0XHRcdHRleHRBbGlnbiA9IGlzTWlycm9yZWQgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dGljayA9IHRpY2tzW2ldO1xyXG5cdFx0XHRsYWJlbCA9IHRpY2subGFiZWw7XHJcblxyXG5cdFx0XHQvLyBhdXRvc2tpcHBlciBza2lwcGVkIHRoaXMgdGljayAoIzQ2MzUpXHJcblx0XHRcdGlmIChpc051bGxPclVuZGVmKGxhYmVsKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwaXhlbCA9IG1lLmdldFBpeGVsRm9yVGljayh0aWNrLl9pbmRleCB8fCBpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xyXG5cdFx0XHRmb250ID0gdGljay5tYWpvciA/IGZvbnRzLm1ham9yIDogZm9udHMubWlub3I7XHJcblx0XHRcdGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XHJcblx0XHRcdGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcclxuXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHR4ID0gcGl4ZWw7XHJcblx0XHRcdFx0dGV4dE9mZnNldCA9IHBvc2l0aW9uID09PSAndG9wJ1xyXG5cdFx0XHRcdFx0PyAoKCFyb3RhdGlvbiA/IDAuNSA6IDEpIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHRcclxuXHRcdFx0XHRcdDogKCFyb3RhdGlvbiA/IDAuNSA6IDApICogbGluZUhlaWdodDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR5ID0gcGl4ZWw7XHJcblx0XHRcdFx0dGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpdGVtcy5wdXNoKHtcclxuXHRcdFx0XHR4OiB4LFxyXG5cdFx0XHRcdHk6IHksXHJcblx0XHRcdFx0cm90YXRpb246IHJvdGF0aW9uLFxyXG5cdFx0XHRcdGxhYmVsOiBsYWJlbCxcclxuXHRcdFx0XHRmb250OiBmb250LFxyXG5cdFx0XHRcdHRleHRPZmZzZXQ6IHRleHRPZmZzZXQsXHJcblx0XHRcdFx0dGV4dEFsaWduOiB0ZXh0QWxpZ25cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGl0ZW1zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdHcmlkOiBmdW5jdGlvbihjaGFydEFyZWEpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZ3JpZExpbmVzID0gbWUub3B0aW9ucy5ncmlkTGluZXM7XHJcblxyXG5cdFx0aWYgKCFncmlkTGluZXMuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGFsaWduUGl4ZWwgPSBoZWxwZXJzJDEuX2FsaWduUGl4ZWw7XHJcblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xyXG5cdFx0dmFyIGl0ZW1zID0gbWUuX2dyaWRMaW5lSXRlbXMgfHwgKG1lLl9ncmlkTGluZUl0ZW1zID0gbWUuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xyXG5cdFx0dmFyIHdpZHRoLCBjb2xvciwgaSwgaWxlbiwgaXRlbTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGl0ZW0gPSBpdGVtc1tpXTtcclxuXHRcdFx0d2lkdGggPSBpdGVtLndpZHRoO1xyXG5cdFx0XHRjb2xvciA9IGl0ZW0uY29sb3I7XHJcblxyXG5cdFx0XHRpZiAod2lkdGggJiYgY29sb3IpIHtcclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHRcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XHJcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goaXRlbS5ib3JkZXJEYXNoKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGl0ZW0uYm9yZGVyRGFzaE9mZnNldDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHJcblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oaXRlbS50eDEsIGl0ZW0udHkxKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oaXRlbS50eDIsIGl0ZW0udHkyKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd09uQ2hhcnRBcmVhKSB7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKGl0ZW0ueDEsIGl0ZW0ueTEpO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhpdGVtLngyLCBpdGVtLnkyKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4aXNXaWR0aCkge1xyXG5cdFx0XHQvLyBEcmF3IHRoZSBsaW5lIGF0IHRoZSBlZGdlIG9mIHRoZSBheGlzXHJcblx0XHRcdHZhciBmaXJzdExpbmVXaWR0aCA9IGF4aXNXaWR0aDtcclxuXHRcdFx0dmFyIGxhc3RMaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgaXRlbXMudGlja3NMZW5ndGggLSAxLCAxKTtcclxuXHRcdFx0dmFyIGJvcmRlclZhbHVlID0gaXRlbXMuYm9yZGVyVmFsdWU7XHJcblx0XHRcdHZhciB4MSwgeDIsIHkxLCB5MjtcclxuXHJcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRcdHgxID0gYWxpZ25QaXhlbChjaGFydCwgbWUubGVmdCwgZmlyc3RMaW5lV2lkdGgpIC0gZmlyc3RMaW5lV2lkdGggLyAyO1xyXG5cdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eTEgPSB5MiA9IGJvcmRlclZhbHVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eDEgPSB4MiA9IGJvcmRlclZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdHgubGluZVdpZHRoID0gYXhpc1dpZHRoO1xyXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCAwKTtcclxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRjdHgubW92ZVRvKHgxLCB5MSk7XHJcblx0XHRcdGN0eC5saW5lVG8oeDIsIHkyKTtcclxuXHRcdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdMYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblxyXG5cdFx0aWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIGl0ZW1zID0gbWUuX2xhYmVsSXRlbXMgfHwgKG1lLl9sYWJlbEl0ZW1zID0gbWUuX2NvbXB1dGVMYWJlbEl0ZW1zKCkpO1xyXG5cdFx0dmFyIGksIGosIGlsZW4sIGpsZW4sIGl0ZW0sIHRpY2tGb250LCBsYWJlbCwgeTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGl0ZW0gPSBpdGVtc1tpXTtcclxuXHRcdFx0dGlja0ZvbnQgPSBpdGVtLmZvbnQ7XHJcblxyXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgZHJhdyB0ZXh0IGluIHRoZSBjb3JyZWN0IGNvbG9yIGFuZCBmb250XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGN0eC50cmFuc2xhdGUoaXRlbS54LCBpdGVtLnkpO1xyXG5cdFx0XHRjdHgucm90YXRlKGl0ZW0ucm90YXRpb24pO1xyXG5cdFx0XHRjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250LmNvbG9yO1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBpdGVtLnRleHRBbGlnbjtcclxuXHJcblx0XHRcdGxhYmVsID0gaXRlbS5sYWJlbDtcclxuXHRcdFx0eSA9IGl0ZW0udGV4dE9mZnNldDtcclxuXHRcdFx0aWYgKGlzQXJyYXkobGFiZWwpKSB7XHJcblx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xyXG5cdFx0XHRcdFx0Ly8gV2UganVzdCBtYWtlIHN1cmUgdGhlIG11bHRpbGluZSBlbGVtZW50IGlzIGEgc3RyaW5nIGhlcmUuLlxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KCcnICsgbGFiZWxbal0sIDAsIHkpO1xyXG5cdFx0XHRcdFx0eSArPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIHkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZHJhd1RpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XHJcblxyXG5cdFx0aWYgKCFzY2FsZUxhYmVsLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkYShzY2FsZUxhYmVsLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XHJcblx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlTGFiZWwpO1xyXG5cdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWwucGFkZGluZyk7XHJcblx0XHR2YXIgaGFsZkxpbmVIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0IC8gMjtcclxuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcblx0XHR2YXIgcm90YXRpb24gPSAwO1xyXG5cdFx0dmFyIHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWTtcclxuXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgbWUud2lkdGggLyAyOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcclxuXHRcdFx0c2NhbGVMYWJlbFkgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbSdcclxuXHRcdFx0XHQ/IG1lLmJvdHRvbSAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcuYm90dG9tXHJcblx0XHRcdFx0OiBtZS50b3AgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBpc0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2xlZnQnO1xyXG5cdFx0XHRzY2FsZUxhYmVsWCA9IGlzTGVmdFxyXG5cdFx0XHRcdD8gbWUubGVmdCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wXHJcblx0XHRcdFx0OiBtZS5yaWdodCAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xyXG5cdFx0XHRzY2FsZUxhYmVsWSA9IG1lLnRvcCArIG1lLmhlaWdodCAvIDI7XHJcblx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHgudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XHJcblx0XHRjdHgucm90YXRlKHJvdGF0aW9uKTtcclxuXHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBzY2FsZUxhYmVsRm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcclxuXHRcdGN0eC5mb250ID0gc2NhbGVMYWJlbEZvbnQuc3RyaW5nO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl9kcmF3R3JpZChjaGFydEFyZWEpO1xyXG5cdFx0bWUuX2RyYXdUaXRsZSgpO1xyXG5cdFx0bWUuX2RyYXdMYWJlbHMoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9sYXllcnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XHJcblx0XHR2YXIgZ3ogPSBvcHRzLmdyaWRMaW5lcyAmJiBvcHRzLmdyaWRMaW5lcy56IHx8IDA7XHJcblxyXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkgfHwgdHogPT09IGd6IHx8IG1lLmRyYXcgIT09IG1lLl9kcmF3KSB7XHJcblx0XHRcdC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGRyYXcgaGFzIGJlZW4gb3ZlcnJpZGRlbiBieSBjdXN0b20gc2NhbGVcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0ejogdHosXHJcblx0XHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRtZS5kcmF3LmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFt7XHJcblx0XHRcdHo6IGd6LFxyXG5cdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRtZS5fZHJhd0dyaWQuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0bWUuX2RyYXdUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwge1xyXG5cdFx0XHR6OiB0eixcclxuXHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bWUuX2RyYXdMYWJlbHMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdH1dO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzOiBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0cmV0dXJuIG1lLmNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKClcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihtZXRhKSB7XHJcblx0XHRcdFx0cmV0dXJuICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpXHJcblx0XHRcdFx0XHQmJiAoaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuU2NhbGUucHJvdG90eXBlLl9kcmF3ID0gU2NhbGUucHJvdG90eXBlLmRyYXc7XHJcblxyXG52YXIgY29yZV9zY2FsZSA9IFNjYWxlO1xuXG52YXIgaXNOdWxsT3JVbmRlZiQxID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWY7XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcclxuXHRwb3NpdGlvbjogJ2JvdHRvbSdcclxufTtcclxuXHJcbnZhciBzY2FsZV9jYXRlZ29yeSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGFiZWxzID0gbWUuX2dldExhYmVscygpO1xyXG5cdFx0dmFyIHRpY2tzT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgbWluID0gdGlja3NPcHRzLm1pbjtcclxuXHRcdHZhciBtYXggPSB0aWNrc09wdHMubWF4O1xyXG5cdFx0dmFyIG1pbkluZGV4ID0gMDtcclxuXHRcdHZhciBtYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xyXG5cdFx0dmFyIGZpbmRJbmRleDtcclxuXHJcblx0XHRpZiAobWluICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWluIHZhbHVlXHJcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1pbik7XHJcblx0XHRcdGlmIChmaW5kSW5kZXggPj0gMCkge1xyXG5cdFx0XHRcdG1pbkluZGV4ID0gZmluZEluZGV4O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1heCB2YWx1ZVxyXG5cdFx0XHRmaW5kSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtYXgpO1xyXG5cdFx0XHRpZiAoZmluZEluZGV4ID49IDApIHtcclxuXHRcdFx0XHRtYXhJbmRleCA9IGZpbmRJbmRleDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLm1pbkluZGV4ID0gbWluSW5kZXg7XHJcblx0XHRtZS5tYXhJbmRleCA9IG1heEluZGV4O1xyXG5cdFx0bWUubWluID0gbGFiZWxzW21pbkluZGV4XTtcclxuXHRcdG1lLm1heCA9IGxhYmVsc1ttYXhJbmRleF07XHJcblx0fSxcclxuXHJcblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcclxuXHRcdHZhciBtaW5JbmRleCA9IG1lLm1pbkluZGV4O1xyXG5cdFx0dmFyIG1heEluZGV4ID0gbWUubWF4SW5kZXg7XHJcblxyXG5cdFx0Ly8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcclxuXHRcdG1lLnRpY2tzID0gKG1pbkluZGV4ID09PSAwICYmIG1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluSW5kZXgsIG1heEluZGV4ICsgMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cclxuXHRcdGlmIChjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBtZS5pZCkge1xyXG5cdFx0XHRyZXR1cm4gbWUuZ2V0UmlnaHRWYWx1ZShjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtZS5fZ2V0TGFiZWxzKClbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdF9jb25maWd1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcclxuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzO1xyXG5cclxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLl9jb25maWd1cmUuY2FsbChtZSk7XHJcblxyXG5cdFx0aWYgKCFtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHQvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cclxuXHRcdFx0bWUuX3JldmVyc2VQaXhlbHMgPSAhbWUuX3JldmVyc2VQaXhlbHM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aWNrcykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwLjUgOiAwKTtcclxuXHRcdG1lLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXHJcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdmFsdWVDYXRlZ29yeSwgbGFiZWxzLCBpZHg7XHJcblxyXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDEoaW5kZXgpICYmICFpc051bGxPclVuZGVmJDEoZGF0YXNldEluZGV4KSkge1xyXG5cdFx0XHR2YWx1ZSA9IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB2YWx1ZSBpcyBhIGRhdGEgb2JqZWN0LCB0aGVuIGluZGV4IGlzIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSxcclxuXHRcdC8vIG5vdCB0aGUgaW5kZXggb2YgdGhlIHNjYWxlLiBXZSBuZWVkIHRvIGNoYW5nZSB0aGF0LlxyXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDEodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlQ2F0ZWdvcnkgPSBtZS5pc0hvcml6b250YWwoKSA/IHZhbHVlLnggOiB2YWx1ZS55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XHJcblx0XHRcdGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcclxuXHRcdFx0dmFsdWUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQodmFsdWVDYXRlZ29yeSwgdmFsdWUpO1xyXG5cdFx0XHRpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XHJcblx0XHRcdGluZGV4ID0gaWR4ICE9PSAtMSA/IGlkeCA6IGluZGV4O1xyXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpKSB7XHJcblx0XHRcdFx0aW5kZXggPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yRGVjaW1hbCgoaW5kZXggLSBtZS5fc3RhcnRWYWx1ZSkgLyBtZS5fdmFsdWVSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrcztcclxuXHRcdHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxXHJcblx0XHRcdD8gbnVsbFxyXG5cdFx0XHQ6IHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0sIGluZGV4ICsgdGhpcy5taW5JbmRleCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdmFsdWUgPSBNYXRoLnJvdW5kKG1lLl9zdGFydFZhbHVlICsgbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIG1lLl92YWx1ZVJhbmdlKTtcclxuXHRcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIG1lLnRpY2tzLmxlbmd0aCAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xyXG52YXIgX2RlZmF1bHRzID0gZGVmYXVsdENvbmZpZztcbnNjYWxlX2NhdGVnb3J5Ll9kZWZhdWx0cyA9IF9kZWZhdWx0cztcblxudmFyIG5vb3AgPSBoZWxwZXJzJDEubm9vcDtcclxudmFyIGlzTnVsbE9yVW5kZWYkMiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrc1xyXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcclxuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcclxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XHJcblx0dmFyIHRpY2tzID0gW107XHJcblx0Ly8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXHJcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3NcclxuXHQvLyBmb3IgZGV0YWlscy5cclxuXHJcblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XHJcblx0dmFyIHN0ZXBTaXplID0gZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemU7XHJcblx0dmFyIHVuaXQgPSBzdGVwU2l6ZSB8fCAxO1xyXG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XHJcblx0dmFyIG1pbiA9IGdlbmVyYXRpb25PcHRpb25zLm1pbjtcclxuXHR2YXIgbWF4ID0gZ2VuZXJhdGlvbk9wdGlvbnMubWF4O1xyXG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XHJcblx0dmFyIHJtaW4gPSBkYXRhUmFuZ2UubWluO1xyXG5cdHZhciBybWF4ID0gZGF0YVJhbmdlLm1heDtcclxuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XHJcblx0dmFyIGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xyXG5cclxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxyXG5cdC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3NcclxuXHRpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmIGlzTnVsbE9yVW5kZWYkMihtaW4pICYmIGlzTnVsbE9yVW5kZWYkMihtYXgpKSB7XHJcblx0XHRyZXR1cm4gW3JtaW4sIHJtYXhdO1xyXG5cdH1cclxuXHJcblx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xyXG5cdGlmIChudW1TcGFjZXMgPiBtYXhOdW1TcGFjZXMpIHtcclxuXHRcdC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XHJcblx0XHRzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcclxuXHR9XHJcblxyXG5cdGlmIChzdGVwU2l6ZSB8fCBpc051bGxPclVuZGVmJDIocHJlY2lzaW9uKSkge1xyXG5cdFx0Ly8gSWYgYSBwcmVjaXNpb24gaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGZhY3RvciBiYXNlZCBvbiBzcGFjaW5nXHJcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgaGVscGVycyQxLl9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG5cdFx0ZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XHJcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xyXG5cdH1cclxuXHJcblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcclxuXHRuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XHJcblxyXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cclxuXHRpZiAoc3RlcFNpemUpIHtcclxuXHRcdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHdob2xlIG51bWJlciwgdXNlIGl0LlxyXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDIobWluKSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWluIC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XHJcblx0XHRcdG5pY2VNaW4gPSBtaW47XHJcblx0XHR9XHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMihtYXgpICYmIGhlbHBlcnMkMS5hbG1vc3RXaG9sZShtYXggLyBzcGFjaW5nLCBzcGFjaW5nIC8gMTAwMCkpIHtcclxuXHRcdFx0bmljZU1heCA9IG1heDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xyXG5cdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cclxuXHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XHJcblx0XHRudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xyXG5cdH1cclxuXHJcblx0bmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblx0bmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblx0dGlja3MucHVzaChpc051bGxPclVuZGVmJDIobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xyXG5cdGZvciAodmFyIGogPSAxOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcclxuXHRcdHRpY2tzLnB1c2goTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IpO1xyXG5cdH1cclxuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYkMihtYXgpID8gbmljZU1heCA6IG1heCk7XHJcblxyXG5cdHJldHVybiB0aWNrcztcclxufVxyXG5cclxudmFyIHNjYWxlX2xpbmVhcmJhc2UgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XHJcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiArdmFsdWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRcdC8vIElmIHdlIGFyZSBmb3JjaW5nIGl0IHRvIGJlZ2luIGF0IDAsIGJ1dCAwIHdpbGwgYWxyZWFkeSBiZSByZW5kZXJlZCBvbiB0aGUgY2hhcnQsXHJcblx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XHJcblx0XHQvLyBheGlzLCB0aGV5IGNhbiBtYW51YWxseSBvdmVycmlkZSBpdFxyXG5cdFx0aWYgKHRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XHJcblx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycyQxLnNpZ24obWUubWluKTtcclxuXHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5tYXgpO1xyXG5cclxuXHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XHJcblx0XHRcdFx0Ly8gbW92ZSB0aGUgdG9wIHVwIHRvIDBcclxuXHRcdFx0XHRtZS5tYXggPSAwO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XHJcblx0XHRcdFx0Ly8gbW92ZSB0aGUgYm90dG9tIGRvd24gdG8gMFxyXG5cdFx0XHRcdG1lLm1pbiA9IDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XHJcblx0XHR2YXIgc2V0TWF4ID0gdGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0aWYgKHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLm1pbjtcclxuXHRcdH0gZWxzZSBpZiAodGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIHRpY2tPcHRzLnN1Z2dlc3RlZE1pbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bWUubWF4ID0gdGlja09wdHMubWF4O1xyXG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XHJcblx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMuc3VnZ2VzdGVkTWF4O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZXRNaW4gIT09IHNldE1heCkge1xyXG5cdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cclxuXHRcdFx0Ly8gU28gZW5zdXJlIHRoYXQgb3VyIHJhbmdlIGlzIGdvb2RcclxuXHRcdFx0Ly8gSW52ZXJ0ZWQgb3IgMCBsZW5ndGggcmFuZ2UgY2FuIGhhcHBlbiB3aGVuXHJcblx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxyXG5cdFx0XHRpZiAobWUubWluID49IG1lLm1heCkge1xyXG5cdFx0XHRcdGlmIChzZXRNaW4pIHtcclxuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1heCAtIDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XHJcblx0XHRcdG1lLm1heCsrO1xyXG5cclxuXHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xyXG5cdFx0XHRcdG1lLm1pbi0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0VGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIHN0ZXBTaXplID0gdGlja09wdHMuc3RlcFNpemU7XHJcblx0XHR2YXIgbWF4VGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQ7XHJcblx0XHR2YXIgbWF4VGlja3M7XHJcblxyXG5cdFx0aWYgKHN0ZXBTaXplKSB7XHJcblx0XHRcdG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1heFRpY2tzID0gbWUuX2NvbXB1dGVUaWNrTGltaXQoKTtcclxuXHRcdFx0bWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFRpY2tzTGltaXQpIHtcclxuXHRcdFx0bWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1heFRpY2tzO1xyXG5cdH0sXHJcblxyXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblx0fSxcclxuXHJcblx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBub29wLFxyXG5cclxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxyXG5cdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXHJcblx0XHQvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxyXG5cdFx0Ly8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xyXG5cdFx0dmFyIG1heFRpY2tzID0gbWUuZ2V0VGlja0xpbWl0KCk7XHJcblx0XHRtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcclxuXHJcblx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XHJcblx0XHRcdG1heFRpY2tzOiBtYXhUaWNrcyxcclxuXHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXHJcblx0XHRcdG1heDogdGlja09wdHMubWF4LFxyXG5cdFx0XHRwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcclxuXHRcdFx0c3RlcFNpemU6IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcclxuXHRcdH07XHJcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIG1lKTtcclxuXHJcblx0XHRtZS5oYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMoKTtcclxuXHJcblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXHJcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xyXG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XHJcblxyXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcclxuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XHJcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xyXG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcclxuXHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xyXG5cclxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xyXG5cdH0sXHJcblxyXG5cdF9jb25maWd1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrcyA9IG1lLmdldFRpY2tzKCk7XHJcblx0XHR2YXIgc3RhcnQgPSBtZS5taW47XHJcblx0XHR2YXIgZW5kID0gbWUubWF4O1xyXG5cdFx0dmFyIG9mZnNldDtcclxuXHJcblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5fY29uZmlndXJlLmNhbGwobWUpO1xyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdFx0b2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcclxuXHRcdFx0c3RhcnQgLT0gb2Zmc2V0O1xyXG5cdFx0XHRlbmQgKz0gb2Zmc2V0O1xyXG5cdFx0fVxyXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBzdGFydDtcclxuXHRcdG1lLl9lbmRWYWx1ZSA9IGVuZDtcclxuXHRcdG1lLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XHJcblx0fVxyXG59KTtcblxudmFyIGRlZmF1bHRDb25maWckMSA9IHtcclxuXHRwb3NpdGlvbjogJ2xlZnQnLFxyXG5cdHRpY2tzOiB7XHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxyXG5cdH1cclxufTtcclxuXHJcbnZhciBERUZBVUxUX01JTiA9IDA7XHJcbnZhciBERUZBVUxUX01BWCA9IDE7XHJcblxyXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tlZCwgbWV0YSkge1xyXG5cdHZhciBrZXkgPSBbXHJcblx0XHRtZXRhLnR5cGUsXHJcblx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXHJcblx0XHRzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkID8gbWV0YS5pbmRleCA6ICcnLFxyXG5cdFx0bWV0YS5zdGFja1xyXG5cdF0uam9pbignLicpO1xyXG5cclxuXHRpZiAoc3RhY2tzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0c3RhY2tzW2tleV0gPSB7XHJcblx0XHRcdHBvczogW10sXHJcblx0XHRcdG5lZzogW11cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc3RhY2tzW2tleV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YWNrRGF0YShzY2FsZSwgc3RhY2tzLCBtZXRhLCBkYXRhKSB7XHJcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciBzdGFja2VkID0gb3B0cy5zdGFja2VkO1xyXG5cdHZhciBzdGFjayA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja2VkLCBtZXRhKTtcclxuXHR2YXIgcG9zID0gc3RhY2sucG9zO1xyXG5cdHZhciBuZWcgPSBzdGFjay5uZWc7XHJcblx0dmFyIGlsZW4gPSBkYXRhLmxlbmd0aDtcclxuXHR2YXIgaSwgdmFsdWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdHZhbHVlID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YVtpXSk7XHJcblx0XHRpZiAoaXNOYU4odmFsdWUubWluKSB8fCBpc05hTih2YWx1ZS5tYXgpIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cG9zW2ldID0gcG9zW2ldIHx8IDA7XHJcblx0XHRuZWdbaV0gPSBuZWdbaV0gfHwgMDtcclxuXHJcblx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xyXG5cdFx0XHRwb3NbaV0gPSAxMDA7XHJcblx0XHR9IGVsc2UgaWYgKHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xyXG5cdFx0XHRuZWdbaV0gKz0gdmFsdWUubWluO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cG9zW2ldICs9IHZhbHVlLm1heDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZU1pbk1heChzY2FsZSwgbWV0YSwgZGF0YSkge1xyXG5cdHZhciBpbGVuID0gZGF0YS5sZW5ndGg7XHJcblx0dmFyIGksIHZhbHVlO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHR2YWx1ZSA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFbaV0pO1xyXG5cdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlLm1pbiA9IE1hdGgubWluKHNjYWxlLm1pbiwgdmFsdWUubWluKTtcclxuXHRcdHNjYWxlLm1heCA9IE1hdGgubWF4KHNjYWxlLm1heCwgdmFsdWUubWF4KTtcclxuXHR9XHJcbn1cclxuXHJcbnZhciBzY2FsZV9saW5lYXIgPSBzY2FsZV9saW5lYXJiYXNlLmV4dGVuZCh7XHJcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIG1ldGFzZXRzID0gbWUuX2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XHJcblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xyXG5cdFx0dmFyIHN0YWNrcyA9IHt9O1xyXG5cdFx0dmFyIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgbWV0YSwgZGF0YSwgdmFsdWVzO1xyXG5cclxuXHRcdG1lLm1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHRcdG1lLm1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHJcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Zm9yIChpID0gMDsgIWhhc1N0YWNrcyAmJiBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHRcdGhhc1N0YWNrcyA9IG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHRkYXRhID0gZGF0YXNldHNbbWV0YS5pbmRleF0uZGF0YTtcclxuXHRcdFx0aWYgKGhhc1N0YWNrcykge1xyXG5cdFx0XHRcdHN0YWNrRGF0YShtZSwgc3RhY2tzLCBtZXRhLCBkYXRhKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVNaW5NYXgobWUsIG1ldGEsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goc3RhY2tzLCBmdW5jdGlvbihzdGFja1ZhbHVlcykge1xyXG5cdFx0XHR2YWx1ZXMgPSBzdGFja1ZhbHVlcy5wb3MuY29uY2F0KHN0YWNrVmFsdWVzLm5lZyk7XHJcblx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgaGVscGVycyQxLm1pbih2YWx1ZXMpKTtcclxuXHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCBoZWxwZXJzJDEubWF4KHZhbHVlcykpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUubWluID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1pbikgJiYgIWlzTmFOKG1lLm1pbikgPyBtZS5taW4gOiBERUZBVUxUX01JTjtcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5tYXgpICYmICFpc05hTihtZS5tYXgpID8gbWUubWF4IDogREVGQVVMVF9NQVg7XHJcblxyXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xyXG5cdFx0bWUuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cclxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRpY2tGb250O1xyXG5cclxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLndpZHRoIC8gNDApO1xyXG5cdFx0fVxyXG5cdFx0dGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG1lLm9wdGlvbnMudGlja3MpO1xyXG5cdFx0cmV0dXJuIE1hdGguY2VpbChtZS5oZWlnaHQgLyB0aWNrRm9udC5saW5lSGVpZ2h0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxyXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XHJcblx0XHRcdHRoaXMudGlja3MucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTY2FsZUxhYmVsKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBVdGlsc1xyXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yRGVjaW1hbCgoK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UpO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrc0FzTnVtYmVycztcclxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcclxudmFyIF9kZWZhdWx0cyQxID0gZGVmYXVsdENvbmZpZyQxO1xuc2NhbGVfbGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQxO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIGxvZzEwID0gaGVscGVycyQxLm1hdGgubG9nMTA7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcclxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXHJcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXHJcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XHJcblx0dmFyIHRpY2tzID0gW107XHJcblxyXG5cdHZhciB0aWNrVmFsID0gdmFsdWVPckRlZmF1bHQkYihnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xyXG5cclxuXHR2YXIgZW5kRXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWF4KSk7XHJcblx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XHJcblx0dmFyIGV4cCwgc2lnbmlmaWNhbmQ7XHJcblxyXG5cdGlmICh0aWNrVmFsID09PSAwKSB7XHJcblx0XHRleHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XHJcblx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoZGF0YVJhbmdlLm1pbk5vdFplcm8gLyBNYXRoLnBvdygxMCwgZXhwKSk7XHJcblxyXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcclxuXHRcdHRpY2tWYWwgPSBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcclxuXHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xyXG5cdH1cclxuXHR2YXIgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XHJcblxyXG5cdGRvIHtcclxuXHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XHJcblxyXG5cdFx0KytzaWduaWZpY2FuZDtcclxuXHRcdGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcclxuXHRcdFx0c2lnbmlmaWNhbmQgPSAxO1xyXG5cdFx0XHQrK2V4cDtcclxuXHRcdFx0cHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xyXG5cdH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xyXG5cclxuXHR2YXIgbGFzdFRpY2sgPSB2YWx1ZU9yRGVmYXVsdCRiKGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XHJcblx0dGlja3MucHVzaChsYXN0VGljayk7XHJcblxyXG5cdHJldHVybiB0aWNrcztcclxufVxyXG5cclxudmFyIGRlZmF1bHRDb25maWckMiA9IHtcclxuXHRwb3NpdGlvbjogJ2xlZnQnLFxyXG5cclxuXHQvLyBsYWJlbCBzZXR0aW5nc1xyXG5cdHRpY2tzOiB7XHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyh2Myk6IGNoYW5nZSB0aGlzIHRvIHBvc2l0aXZlT3JEZWZhdWx0XHJcbmZ1bmN0aW9uIG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuXHJcbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRmdW5jdGlvbiBJRE1hdGNoZXMobWV0YSkge1xyXG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgZGF0YXNldEluZGV4LCBtZXRhLCB2YWx1ZSwgZGF0YSwgaSwgaWxlbjtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgUmFuZ2VcclxuXHRcdG1lLm1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHRcdG1lLm1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHRcdG1lLm1pbk5vdFplcm8gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcclxuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmb3IgKGRhdGFzZXRJbmRleCA9IDA7IGRhdGFzZXRJbmRleCA8IGRhdGFzZXRzLmxlbmd0aDsgZGF0YXNldEluZGV4KyspIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxyXG5cdFx0XHRcdFx0bWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdHMuc3RhY2tlZCB8fCBoYXNTdGFja3MpIHtcclxuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XHJcblxyXG5cdFx0XHRmb3IgKGRhdGFzZXRJbmRleCA9IDA7IGRhdGFzZXRJbmRleCA8IGRhdGFzZXRzLmxlbmd0aDsgZGF0YXNldEluZGV4KyspIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHR2YXIga2V5ID0gW1xyXG5cdFx0XHRcdFx0bWV0YS50eXBlLFxyXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxyXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxyXG5cdFx0XHRcdFx0bWV0YS5zdGFja1xyXG5cdFx0XHRcdF0uam9pbignLicpO1xyXG5cclxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xyXG5cdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YTtcclxuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XTtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBtZS5fcGFyc2VWYWx1ZShkYXRhW2ldKTtcclxuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcclxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuIHx8IHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlc1tpXSB8fCAwO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXNbaV0gKz0gdmFsdWUubWF4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcclxuXHRcdFx0XHRpZiAodmFsdWVzRm9yVHlwZS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXNGb3JUeXBlKTtcclxuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xyXG5cdFx0XHRcdFx0bWUubWluID0gTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xyXG5cdFx0XHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yIChkYXRhc2V0SW5kZXggPSAwOyBkYXRhc2V0SW5kZXggPCBkYXRhc2V0cy5sZW5ndGg7IGRhdGFzZXRJbmRleCsrKSB7XHJcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcclxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGE7XHJcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBtZS5fcGFyc2VWYWx1ZShkYXRhW2ldKTtcclxuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcclxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuIHx8IHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbih2YWx1ZS5taW4sIG1lLm1pbik7XHJcblx0XHRcdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KHZhbHVlLm1heCwgbWUubWF4KTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICh2YWx1ZS5taW4gIT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5taW4odmFsdWUubWluLCBtZS5taW5Ob3RaZXJvKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5taW4pID8gbWUubWluIDogbnVsbDtcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5tYXgpID8gbWUubWF4IDogbnVsbDtcclxuXHRcdG1lLm1pbk5vdFplcm8gPSBoZWxwZXJzJDEuaXNGaW5pdGUobWUubWluTm90WmVybykgPyBtZS5taW5Ob3RaZXJvIDogbnVsbDtcclxuXHJcblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXhcclxuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xyXG5cdH0sXHJcblxyXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgREVGQVVMVF9NSU4gPSAxO1xyXG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTA7XHJcblxyXG5cdFx0bWUubWluID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWluLCBtZS5taW4pO1xyXG5cdFx0bWUubWF4ID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xyXG5cclxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xyXG5cdFx0XHRpZiAobWUubWluICE9PSAwICYmIG1lLm1pbiAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1pbikpIC0gMSk7XHJcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAobWUubWF4KSkgKyAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcclxuXHRcdFx0XHRtZS5tYXggPSBERUZBVUxUX01BWDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xyXG5cdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChtZS5tYXgpKSAtIDEpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xyXG5cdFx0XHRtZS5tYXggPSBtZS5taW4gIT09IDBcclxuXHRcdFx0XHQ/IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1pbikpICsgMSlcclxuXHRcdFx0XHQ6IERFRkFVTFRfTUFYO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwpIHtcclxuXHRcdFx0aWYgKG1lLm1pbiA+IDApIHtcclxuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gbWUubWluO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1lLm1heCA8IDEpIHtcclxuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAobWUubWF4KSkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgcmV2ZXJzZSA9ICFtZS5pc0hvcml6b250YWwoKTtcclxuXHJcblx0XHR2YXIgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XHJcblx0XHRcdG1pbjogbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWluKSxcclxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXHJcblx0XHR9O1xyXG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIG1lKTtcclxuXHJcblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXHJcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcclxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xyXG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XHJcblxyXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcclxuXHRcdFx0cmV2ZXJzZSA9ICFyZXZlcnNlO1xyXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcclxuXHRcdFx0bWUuZW5kID0gbWUubWluO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XHJcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcclxuXHRcdH1cclxuXHRcdGlmIChyZXZlcnNlKSB7XHJcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLnRpY2tWYWx1ZXMgPSB0aGlzLnRpY2tzLnNsaWNlKCk7XHJcblxyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbCh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdG9vbHRpcCBsYWJlbFxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTY2FsZUxhYmVsKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgdGlja3MgPSB0aGlzLnRpY2tWYWx1ZXM7XHJcblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGljay5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBub3QgemVybyB2YWx1ZS5cclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaXJzdCB0aWNrIHZhbHVlLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldEZpcnN0VGlja1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIGV4cCA9IE1hdGguZmxvb3IobG9nMTAodmFsdWUpKTtcclxuXHRcdHZhciBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygxMCwgZXhwKSk7XHJcblxyXG5cdFx0cmV0dXJuIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XHJcblx0fSxcclxuXHJcblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHN0YXJ0ID0gbWUubWluO1xyXG5cdFx0dmFyIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuX2NvbmZpZ3VyZS5jYWxsKG1lKTtcclxuXHJcblx0XHRpZiAoc3RhcnQgPT09IDApIHtcclxuXHRcdFx0c3RhcnQgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XHJcblx0XHRcdG9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGIobWUub3B0aW9ucy50aWNrcy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSAvIG1lLl9sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XHJcblx0XHRtZS5fdmFsdWVPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRtZS5fdmFsdWVSYW5nZSA9IChsb2cxMChtZS5tYXgpIC0gbG9nMTAoc3RhcnQpKSAvICgxIC0gb2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkZWNpbWFsID0gMDtcclxuXHJcblx0XHR2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcclxuXHJcblx0XHRpZiAodmFsdWUgPiBtZS5taW4gJiYgdmFsdWUgPiAwKSB7XHJcblx0XHRcdGRlY2ltYWwgPSAobG9nMTAodmFsdWUpIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UgKyBtZS5fdmFsdWVPZmZzZXQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGRlY2ltYWwgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xyXG5cdFx0cmV0dXJuIGRlY2ltYWwgPT09IDAgJiYgbWUubWluID09PSAwXHJcblx0XHRcdD8gMFxyXG5cdFx0XHQ6IE1hdGgucG93KDEwLCBtZS5fc3RhcnRWYWx1ZSArIChkZWNpbWFsIC0gbWUuX3ZhbHVlT2Zmc2V0KSAqIG1lLl92YWx1ZVJhbmdlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXHJcbnZhciBfZGVmYXVsdHMkMiA9IGRlZmF1bHRDb25maWckMjtcbnNjYWxlX2xvZ2FyaXRobWljLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQyO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcclxudmFyIHJlc29sdmUkNCA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyQzID0ge1xyXG5cdGRpc3BsYXk6IHRydWUsXHJcblxyXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXHJcblx0YW5pbWF0ZTogdHJ1ZSxcclxuXHRwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXHJcblxyXG5cdGFuZ2xlTGluZXM6IHtcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRjb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXHJcblx0XHRsaW5lV2lkdGg6IDEsXHJcblx0XHRib3JkZXJEYXNoOiBbXSxcclxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxyXG5cdH0sXHJcblxyXG5cdGdyaWRMaW5lczoge1xyXG5cdFx0Y2lyY3VsYXI6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0Ly8gbGFiZWwgc2V0dGluZ3NcclxuXHR0aWNrczoge1xyXG5cdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcclxuXHRcdHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxyXG5cclxuXHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXHJcblx0XHRiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjc1KScsXHJcblxyXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXHJcblx0XHRiYWNrZHJvcFBhZGRpbmdZOiAyLFxyXG5cclxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcclxuXHRcdGJhY2tkcm9wUGFkZGluZ1g6IDIsXHJcblxyXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcclxuXHR9LFxyXG5cclxuXHRwb2ludExhYmVsczoge1xyXG5cdFx0Ly8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXHJcblx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcclxuXHRcdGZvbnRTaXplOiAxMCxcclxuXHJcblx0XHQvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcclxuXHRcdGNhbGxiYWNrOiBmdW5jdGlvbihsYWJlbCkge1xyXG5cdFx0XHRyZXR1cm4gbGFiZWw7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcclxuXHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcclxuXHRcdHJldHVybiB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSAqIDI7XHJcblx0fVxyXG5cdHJldHVybiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgbGluZUhlaWdodCwgbGFiZWwpIHtcclxuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkobGFiZWwpKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3OiBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY3R4LCBjdHguZm9udCwgbGFiZWwpLFxyXG5cdFx0XHRoOiBsYWJlbC5sZW5ndGggKiBsaW5lSGVpZ2h0XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHc6IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXHJcblx0XHRoOiBsaW5lSGVpZ2h0XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XHJcblx0aWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXHJcblx0XHRcdGVuZDogcG9zICsgKHNpemUgLyAyKVxyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzdGFydDogcG9zIC0gc2l6ZSxcclxuXHRcdFx0ZW5kOiBwb3NcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0c3RhcnQ6IHBvcyxcclxuXHRcdGVuZDogcG9zICsgc2l6ZVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xyXG4gKi9cclxuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XHJcblxyXG5cdC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcclxuXHQvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcclxuXHQvL1xyXG5cdC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcclxuXHQvL1xyXG5cdC8vIFNvbHV0aW9uOlxyXG5cdC8vXHJcblx0Ly8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XHJcblx0Ly8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cclxuXHQvL1xyXG5cdC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXHJcblx0Ly9cclxuXHQvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcclxuXHQvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXHJcblx0Ly9cclxuXHQvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxyXG5cdC8vIGFsb25nIHdpdGggbGFiZWxzLlxyXG5cdC8vXHJcblx0Ly8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxyXG5cdC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxyXG5cdC8vXHJcblx0Ly8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXHJcblx0Ly8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcclxuXHQvL1xyXG5cdC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxyXG5cclxuXHR2YXIgcGxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzKTtcclxuXHJcblx0Ly8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXHJcblx0Ly8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXHJcblx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xyXG5cdFx0bDogMCxcclxuXHRcdHI6IHNjYWxlLndpZHRoLFxyXG5cdFx0dDogMCxcclxuXHRcdGI6IHNjYWxlLmhlaWdodCAtIHNjYWxlLnBhZGRpbmdUb3BcclxuXHR9O1xyXG5cdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xyXG5cdHZhciBpLCB0ZXh0U2l6ZSwgcG9pbnRQb3NpdGlvbjtcclxuXHJcblx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xyXG5cdHNjYWxlLl9wb2ludExhYmVsU2l6ZXMgPSBbXTtcclxuXHJcblx0dmFyIHZhbHVlQ291bnQgPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7XHJcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xyXG5cdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyA1KTtcclxuXHRcdHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udC5saW5lSGVpZ2h0LCBzY2FsZS5wb2ludExhYmVsc1tpXSk7XHJcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XHJcblxyXG5cdFx0Ly8gQWRkIHF1YXJ0ZXIgY2lyY2xlIHRvIG1ha2UgZGVncmVlIDAgbWVhbiB0b3Agb2YgY2lyY2xlXHJcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcclxuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSAlIDM2MDtcclxuXHRcdHZhciBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XHJcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcclxuXHJcblx0XHRpZiAoaExpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLmwpIHtcclxuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XHJcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMucikge1xyXG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5yID0gaExpbWl0cy5lbmQ7XHJcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XHJcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnQgPSB2TGltaXRzLnN0YXJ0O1xyXG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy50ID0gYW5nbGVSYWRpYW5zO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh2TGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLmIpIHtcclxuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xyXG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c2NhbGUuc2V0UmVkdWN0aW9ucyhzY2FsZS5kcmF3aW5nQXJlYSwgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcclxuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xyXG5cdFx0cmV0dXJuICdjZW50ZXInO1xyXG5cdH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcclxuXHRcdHJldHVybiAnbGVmdCc7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gJ3JpZ2h0JztcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xyXG5cdHZhciB5ID0gcG9zaXRpb24ueSArIGxpbmVIZWlnaHQgLyAyO1xyXG5cdHZhciBpLCBpbGVuO1xyXG5cclxuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XHJcblx0XHRcdHkgKz0gbGluZUhlaWdodDtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHBvc2l0aW9uLngsIHkpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCB0ZXh0U2l6ZSwgcG9zaXRpb24pIHtcclxuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcclxuXHRcdHBvc2l0aW9uLnkgLT0gKHRleHRTaXplLmggLyAyKTtcclxuXHR9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcclxuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSkge1xyXG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XHJcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciBwb2ludExhYmVsT3B0cyA9IG9wdHMucG9pbnRMYWJlbHM7XHJcblx0dmFyIHRpY2tCYWNrZHJvcEhlaWdodCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKTtcclxuXHR2YXIgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heCk7XHJcblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQocG9pbnRMYWJlbE9wdHMpO1xyXG5cclxuXHRjdHguc2F2ZSgpO1xyXG5cclxuXHRjdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XHJcblx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRmb3IgKHZhciBpID0gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdC8vIEV4dHJhIHBpeGVscyBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xyXG5cdFx0dmFyIGV4dHJhID0gKGkgPT09IDAgPyB0aWNrQmFja2Ryb3BIZWlnaHQgLyAyIDogMCk7XHJcblx0XHR2YXIgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyA1KTtcclxuXHJcblx0XHQvLyBLZWVwIHRoaXMgaW4gbG9vcCBzaW5jZSB3ZSBtYXkgc3VwcG9ydCBhcnJheSBwcm9wZXJ0aWVzIGhlcmVcclxuXHRcdHZhciBwb2ludExhYmVsRm9udENvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEocG9pbnRMYWJlbE9wdHMuZm9udENvbG9yLCBpLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBwb2ludExhYmVsRm9udENvbG9yO1xyXG5cclxuXHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xyXG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcclxuXHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcclxuXHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0sIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xyXG5cdH1cclxuXHRjdHgucmVzdG9yZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XHJcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcclxuXHR2YXIgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XHJcblx0dmFyIHZhbHVlQ291bnQgPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7XHJcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcclxuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCwgaW5kZXggLSAxKTtcclxuXHR2YXIgcG9pbnRQb3NpdGlvbjtcclxuXHJcblx0aWYgKCghY2lyY3VsYXIgJiYgIXZhbHVlQ291bnQpIHx8ICFsaW5lQ29sb3IgfHwgIWxpbmVXaWR0aCkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Y3R4LnNhdmUoKTtcclxuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XHJcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XHJcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xyXG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xyXG5cdH1cclxuXHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGlmIChjaXJjdWxhcikge1xyXG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xyXG5cdFx0Y3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcclxuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XHJcblx0XHRjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xyXG5cdFx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xyXG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcclxuXHRcdH1cclxuXHR9XHJcblx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdGN0eC5zdHJva2UoKTtcclxuXHRjdHgucmVzdG9yZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBudW1iZXJPclplcm8ocGFyYW0pIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcclxufVxyXG5cclxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcclxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cclxuXHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG1lLm9wdGlvbnMpIC8gMjtcclxuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKG1lLndpZHRoIC8gMik7XHJcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcclxuXHRcdG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4obWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCwgbWUud2lkdGgpIC8gMjtcclxuXHR9LFxyXG5cclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblx0XHR2YXIgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XHJcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xyXG5cclxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xyXG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bWluID0gTWF0aC5taW4odmFsdWUsIG1pbik7XHJcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUubWluID0gKG1pbiA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID8gMCA6IG1pbik7XHJcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcclxuXHJcblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXHJcblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxyXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdHNjYWxlX2xpbmVhcmJhc2UucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xyXG5cclxuXHRcdC8vIFBvaW50IGxhYmVsc1xyXG5cdFx0bWUucG9pbnRMYWJlbHMgPSBtZS5jaGFydC5kYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBsYWJlbCA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBhcmd1bWVudHMsIG1lKTtcclxuXHRcdFx0cmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHR9LFxyXG5cclxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xyXG5cdFx0XHRmaXRXaXRoUG9pbnRMYWJlbHMobWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gZnVydGhlc3RMaW1pdHMubCAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLmwpO1xyXG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xyXG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XHJcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uQm90dG9tID0gLU1hdGgubWF4KGZ1cnRoZXN0TGltaXRzLmIgLSAobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCksIDApIC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMuYik7XHJcblxyXG5cdFx0cmFkaXVzUmVkdWN0aW9uTGVmdCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25MZWZ0KTtcclxuXHRcdHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblJpZ2h0KTtcclxuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xyXG5cdFx0cmFkaXVzUmVkdWN0aW9uQm90dG9tID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XHJcblxyXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcclxuXHRcdFx0TWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uTGVmdCArIHJhZGl1c1JlZHVjdGlvblJpZ2h0KSAvIDIpLFxyXG5cdFx0XHRNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25Ub3AgKyByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pIC8gMikpO1xyXG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcclxuXHR9LFxyXG5cclxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWF4UmlnaHQgPSBtZS53aWR0aCAtIHJpZ2h0TW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcclxuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XHJcblx0XHR2YXIgbWF4VG9wID0gdG9wTW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcclxuXHRcdHZhciBtYXhCb3R0b20gPSAobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLSBib3R0b21Nb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xyXG5cclxuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4TGVmdCArIG1heFJpZ2h0KSAvIDIpICsgbWUubGVmdCk7XHJcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heFRvcCArIG1heEJvdHRvbSkgLyAyKSArIG1lLnRvcCArIG1lLnBhZGRpbmdUb3ApO1xyXG5cdH0sXHJcblxyXG5cdGdldEluZGV4QW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0dmFyIGFuZ2xlTXVsdGlwbGllciA9IDM2MCAvIGNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcclxuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucyB8fCB7fTtcclxuXHRcdHZhciBzdGFydEFuZ2xlID0gb3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XHJcblxyXG5cdFx0Ly8gU3RhcnQgZnJvbSB0aGUgdG9wIGluc3RlYWQgb2YgcmlnaHQsIHNvIHJlbW92ZSBhIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxyXG5cdFx0dmFyIGFuZ2xlID0gKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgc3RhcnRBbmdsZSkgJSAzNjA7XHJcblxyXG5cdFx0cmV0dXJuIChhbmdsZSA8IDAgPyBhbmdsZSArIDM2MCA6IGFuZ2xlKSAqIE1hdGguUEkgKiAyIC8gMzYwO1xyXG5cdH0sXHJcblxyXG5cdGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBOYU47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxyXG5cdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pO1xyXG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xyXG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHZhbHVlIC0gbWUubWluKSAqIHNjYWxpbmdGYWN0b3I7XHJcblx0fSxcclxuXHJcblx0Z2V0UG9pbnRQb3NpdGlvbjogZnVuY3Rpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlcikge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aGlzQW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIChNYXRoLlBJIC8gMik7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcclxuXHRcdFx0eTogTWF0aC5zaW4odGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIG1lLnlDZW50ZXJcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlOiBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcclxuXHRcdHZhciBtYXggPSBtZS5tYXg7XHJcblxyXG5cdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLFxyXG5cdFx0XHRtZS5iZWdpbkF0WmVybyA/IDAgOlxyXG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxyXG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxyXG5cdFx0XHQwKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3R3JpZDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcclxuXHRcdHZhciBhbmdsZUxpbmVPcHRzID0gb3B0cy5hbmdsZUxpbmVzO1xyXG5cdFx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JGMoYW5nbGVMaW5lT3B0cy5saW5lV2lkdGgsIGdyaWRMaW5lT3B0cy5saW5lV2lkdGgpO1xyXG5cdFx0dmFyIGxpbmVDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGMoYW5nbGVMaW5lT3B0cy5jb2xvciwgZ3JpZExpbmVPcHRzLmNvbG9yKTtcclxuXHRcdHZhciBpLCBvZmZzZXQsIHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcclxuXHRcdFx0ZHJhd1BvaW50TGFiZWxzKG1lKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZ3JpZExpbmVPcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0aGVscGVycyQxLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xyXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gMCkge1xyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcclxuXHRcdFx0XHRcdGRyYXdSYWRpdXNMaW5lKG1lLCBncmlkTGluZU9wdHMsIG9mZnNldCwgaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFuZ2xlTGluZU9wdHMuZGlzcGxheSAmJiBsaW5lV2lkdGggJiYgbGluZUNvbG9yKSB7XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcclxuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xyXG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChyZXNvbHZlJDQoW2FuZ2xlTGluZU9wdHMuYm9yZGVyRGFzaCwgZ3JpZExpbmVPcHRzLmJvcmRlckRhc2gsIFtdXSkpO1xyXG5cdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHJlc29sdmUkNChbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCwgMC4wXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoaSA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gbWUubWluIDogbWUubWF4KTtcclxuXHRcdFx0XHRwb3NpdGlvbiA9IG1lLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcclxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0Y3R4Lm1vdmVUbyhtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcclxuXHRcdFx0XHRjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3TGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcclxuXHJcblx0XHRpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdGFydEFuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZSgwKTtcclxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQodGlja09wdHMpO1xyXG5cdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XHJcblx0XHR2YXIgb2Zmc2V0LCB3aWR0aDtcclxuXHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XHJcblx0XHRjdHgudHJhbnNsYXRlKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xyXG5cdFx0Y3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcclxuXHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XHJcblx0XHRcdGlmIChpbmRleCA9PT0gMCAmJiAhdGlja09wdHMucmV2ZXJzZSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcclxuXHJcblx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xyXG5cdFx0XHRcdHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcclxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja09wdHMuYmFja2Ryb3BDb2xvcjtcclxuXHJcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KFxyXG5cdFx0XHRcdFx0LXdpZHRoIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1gsXHJcblx0XHRcdFx0XHQtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZLFxyXG5cdFx0XHRcdFx0d2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcclxuXHRcdFx0XHRcdHRpY2tGb250LnNpemUgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xyXG5cdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIC1vZmZzZXQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3VGl0bGU6IGhlbHBlcnMkMS5ub29wXHJcbn0pO1xyXG5cclxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXHJcbnZhciBfZGVmYXVsdHMkMyA9IGRlZmF1bHRDb25maWckMztcbnNjYWxlX3JhZGlhbExpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMztcblxudmFyIGRlcHJlY2F0ZWQkMSA9IGhlbHBlcnMkMS5fZGVwcmVjYXRlZDtcclxudmFyIHJlc29sdmUkNSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcbnZhciB2YWx1ZU9yRGVmYXVsdCRkID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuLy8gSW50ZWdlciBjb25zdGFudHMgYXJlIGZyb20gdGhlIEVTNiBzcGVjLlxyXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcclxudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcclxuXHJcbnZhciBJTlRFUlZBTFMgPSB7XHJcblx0bWlsbGlzZWNvbmQ6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDEsXHJcblx0XHRzdGVwczogMTAwMFxyXG5cdH0sXHJcblx0c2Vjb25kOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAxMDAwLFxyXG5cdFx0c3RlcHM6IDYwXHJcblx0fSxcclxuXHRtaW51dGU6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDYwMDAwLFxyXG5cdFx0c3RlcHM6IDYwXHJcblx0fSxcclxuXHRob3VyOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAzNjAwMDAwLFxyXG5cdFx0c3RlcHM6IDI0XHJcblx0fSxcclxuXHRkYXk6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDg2NDAwMDAwLFxyXG5cdFx0c3RlcHM6IDMwXHJcblx0fSxcclxuXHR3ZWVrOiB7XHJcblx0XHRjb21tb246IGZhbHNlLFxyXG5cdFx0c2l6ZTogNjA0ODAwMDAwLFxyXG5cdFx0c3RlcHM6IDRcclxuXHR9LFxyXG5cdG1vbnRoOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAyLjYyOGU5LFxyXG5cdFx0c3RlcHM6IDEyXHJcblx0fSxcclxuXHRxdWFydGVyOiB7XHJcblx0XHRjb21tb246IGZhbHNlLFxyXG5cdFx0c2l6ZTogNy44ODRlOSxcclxuXHRcdHN0ZXBzOiA0XHJcblx0fSxcclxuXHR5ZWFyOiB7XHJcblx0XHRjb21tb246IHRydWUsXHJcblx0XHRzaXplOiAzLjE1NGUxMFxyXG5cdH1cclxufTtcclxuXHJcbnZhciBVTklUUyA9IE9iamVjdC5rZXlzKElOVEVSVkFMUyk7XHJcblxyXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xyXG5cdHJldHVybiBhIC0gYjtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlVbmlxdWUoaXRlbXMpIHtcclxuXHR2YXIgaGFzaCA9IHt9O1xyXG5cdHZhciBvdXQgPSBbXTtcclxuXHR2YXIgaSwgaWxlbiwgaXRlbTtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0aXRlbSA9IGl0ZW1zW2ldO1xyXG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XHJcblx0XHRcdGhhc2hbaXRlbV0gPSB0cnVlO1xyXG5cdFx0XHRvdXQucHVzaChpdGVtKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1pbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpbWUubWluLCBvcHRpb25zLnRpY2tzLm1pbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1heChvcHRpb25zKSB7XHJcblx0cmV0dXJuIGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpbWUubWF4LCBvcHRpb25zLnRpY2tzLm1heCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxyXG4gKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xyXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcclxuICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XHJcbiAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxyXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzIC0gdGltZXN0YW1wcyBzb3J0ZWQgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cclxuICogYW5kIG1heCByYW5nZSwgc28gYmFzaWNhbGx5LCB0aGUgdGFibGUgd2lsbCBjb250YWlucyBvbmx5IHR3byBpdGVtczoge21pbiwgMH0gYW5kIHttYXgsIDF9LlxyXG4gKiBJZiAnc2VyaWVzJywgdGltZXN0YW1wcyB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLiBJbiB0aGlzXHJcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxyXG4gKiBiZXN0IGNhc2UsIGFsbCB0aW1lc3RhbXBzIGFyZSBsaW5lYXIsIHRoZSB0YWJsZSBjb250YWlucyBvbmx5IG1pbiBhbmQgbWF4LlxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XHJcblx0aWYgKGRpc3RyaWJ1dGlvbiA9PT0gJ2xpbmVhcicgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxyXG5cdFx0XHR7dGltZTogbWF4LCBwb3M6IDF9XHJcblx0XHRdO1xyXG5cdH1cclxuXHJcblx0dmFyIHRhYmxlID0gW107XHJcblx0dmFyIGl0ZW1zID0gW21pbl07XHJcblx0dmFyIGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0Y3VyciA9IHRpbWVzdGFtcHNbaV07XHJcblx0XHRpZiAoY3VyciA+IG1pbiAmJiBjdXJyIDwgbWF4KSB7XHJcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpdGVtcy5wdXNoKG1heCk7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdG5leHQgPSBpdGVtc1tpICsgMV07XHJcblx0XHRwcmV2ID0gaXRlbXNbaSAtIDFdO1xyXG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xyXG5cclxuXHRcdC8vIG9ubHkgYWRkIHBvaW50cyB0aGF0IGJyZWFrcyB0aGUgc2NhbGUgbGluZWFyaXR5XHJcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xyXG5cdFx0XHR0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFibGU7XHJcbn1cclxuXHJcbi8vIEBzZWUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LmFudWpnYWtoYXIuY29tLzIwMTQvMDMvMDEvYmluYXJ5LXNlYXJjaC1pbi1qYXZhc2NyaXB0L1xyXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGtleSwgdmFsdWUpIHtcclxuXHR2YXIgbG8gPSAwO1xyXG5cdHZhciBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XHJcblx0dmFyIG1pZCwgaTAsIGkxO1xyXG5cclxuXHR3aGlsZSAobG8gPj0gMCAmJiBsbyA8PSBoaSkge1xyXG5cdFx0bWlkID0gKGxvICsgaGkpID4+IDE7XHJcblx0XHRpMCA9IHRhYmxlW21pZCAtIDFdIHx8IG51bGw7XHJcblx0XHRpMSA9IHRhYmxlW21pZF07XHJcblxyXG5cdFx0aWYgKCFpMCkge1xyXG5cdFx0XHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChiZWZvcmUgZmlyc3QgaXRlbSlcclxuXHRcdFx0cmV0dXJuIHtsbzogbnVsbCwgaGk6IGkxfTtcclxuXHRcdH0gZWxzZSBpZiAoaTFba2V5XSA8IHZhbHVlKSB7XHJcblx0XHRcdGxvID0gbWlkICsgMTtcclxuXHRcdH0gZWxzZSBpZiAoaTBba2V5XSA+IHZhbHVlKSB7XHJcblx0XHRcdGhpID0gbWlkIC0gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7bG86IGkwLCBoaTogaTF9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYWZ0ZXIgbGFzdCBpdGVtKVxyXG5cdHJldHVybiB7bG86IGkxLCBoaTogbnVsbH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsdWVgIHVzaW5nIHRoZSB0YWJsZSBpdGVtcyBgc2tleWAgdmFsdWVzIGFuZFxyXG4gKiByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGB0a2V5YCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIDQyLCAncG9zJylcclxuICogcmV0dXJucyB0aGUgcG9zaXRpb24gZm9yIGEgdGltZXN0YW1wIGVxdWFsIHRvIDQyLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXMgYXRcclxuICogaW5kZXggWzAsIDFdIG9yIFtuIC0gMSwgbl0gYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaW50ZXJwb2xhdGUkMSh0YWJsZSwgc2tleSwgc3ZhbCwgdGtleSkge1xyXG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XHJcblxyXG5cdC8vIE5vdGU6IHRoZSBsb29rdXAgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IDIgaXRlbXMgKG1pbiBhbmQgbWF4KVxyXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xyXG5cdHZhciBuZXh0ID0gIXJhbmdlLmxvID8gdGFibGVbMV0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAxXSA6IHJhbmdlLmhpO1xyXG5cclxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xyXG5cdHZhciByYXRpbyA9IHNwYW4gPyAoc3ZhbCAtIHByZXZbc2tleV0pIC8gc3BhbiA6IDA7XHJcblx0dmFyIG9mZnNldCA9IChuZXh0W3RrZXldIC0gcHJldlt0a2V5XSkgKiByYXRpbztcclxuXHJcblx0cmV0dXJuIHByZXZbdGtleV0gKyBvZmZzZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNjYWxlLCBpbnB1dCkge1xyXG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XHJcblx0dmFyIHBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xyXG5cdHZhciBmb3JtYXQgPSBwYXJzZXIgfHwgb3B0aW9ucy5mb3JtYXQ7XHJcblx0dmFyIHZhbHVlID0gaW5wdXQ7XHJcblxyXG5cdGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHQvLyBPbmx5IHBhcnNlIGlmIGl0cyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxyXG5cdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xyXG5cdFx0dmFsdWUgPSB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJ1xyXG5cdFx0XHQ/IGFkYXB0ZXIucGFyc2UodmFsdWUsIGZvcm1hdClcclxuXHRcdFx0OiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcclxuXHR9XHJcblxyXG5cdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuICt2YWx1ZTtcclxuXHR9XHJcblxyXG5cdC8vIExhYmVscyBhcmUgaW4gYW4gaW5jb21wYXRpYmxlIGZvcm1hdCBhbmQgbm8gYHBhcnNlcmAgaGFzIGJlZW4gcHJvdmlkZWQuXHJcblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiBmb3IgcGFyc2luZy5cclxuXHRpZiAoIXBhcnNlciAmJiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR2YWx1ZSA9IGZvcm1hdChpbnB1dCk7XHJcblxyXG5cdFx0Ly8gYGZvcm1hdGAgY291bGQgcmV0dXJuIHNvbWV0aGluZyBlbHNlIHRoYW4gYSB0aW1lc3RhbXAsIGlmIHNvLCBwYXJzZSBpdFxyXG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlID0gYWRhcHRlci5wYXJzZSh2YWx1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xyXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XHJcblx0dmFyIHZhbHVlID0gdG9UaW1lc3RhbXAoc2NhbGUsIHNjYWxlLmdldFJpZ2h0VmFsdWUoaW5wdXQpKTtcclxuXHRpZiAodmFsdWUgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XHJcblx0XHR2YWx1ZSA9ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBvcHRpb25zLnJvdW5kKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcclxuXHR2YXIgaWxlbiA9IFVOSVRTLmxlbmd0aDtcclxuXHR2YXIgaSwgaW50ZXJ2YWwsIGZhY3RvcjtcclxuXHJcblx0Zm9yIChpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcclxuXHRcdGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcclxuXHRcdGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBNQVhfSU5URUdFUjtcclxuXHJcblx0XHRpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcclxuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xyXG5cdHZhciBpLCB1bml0O1xyXG5cclxuXHRmb3IgKGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xyXG5cdFx0dW5pdCA9IFVOSVRTW2ldO1xyXG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XHJcblx0XHRcdHJldHVybiB1bml0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XHJcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcclxuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXHJcbiAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXHJcbiAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcclxuICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGUoc2NhbGUsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xyXG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcclxuXHR2YXIgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KTtcclxuXHR2YXIgc3RlcFNpemUgPSByZXNvbHZlJDUoW3RpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUsIDFdKTtcclxuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XHJcblx0dmFyIGZpcnN0ID0gbWluO1xyXG5cdHZhciB0aWNrcyA9IFtdO1xyXG5cdHZhciB0aW1lO1xyXG5cclxuXHQvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXHJcblx0aWYgKHdlZWtkYXkpIHtcclxuXHRcdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcclxuXHR9XHJcblxyXG5cdC8vIEFsaWduIGZpcnN0IHRpY2tzIG9uIHVuaXRcclxuXHRmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcclxuXHJcblx0Ly8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcclxuXHRpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xyXG5cdFx0dGhyb3cgbWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcjtcclxuXHR9XHJcblxyXG5cdGZvciAodGltZSA9IGZpcnN0OyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vcikpIHtcclxuXHRcdHRpY2tzLnB1c2godGltZSk7XHJcblx0fVxyXG5cclxuXHRpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XHJcblx0XHR0aWNrcy5wdXNoKHRpbWUpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRpY2tzO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XHJcbiAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cclxuICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XHJcblx0dmFyIHN0YXJ0ID0gMDtcclxuXHR2YXIgZW5kID0gMDtcclxuXHR2YXIgZmlyc3QsIGxhc3Q7XHJcblxyXG5cdGlmIChvcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdGZpcnN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1swXSwgJ3BvcycpO1xyXG5cdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRzdGFydCA9IDEgLSBmaXJzdDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0YXJ0ID0gKGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbMV0sICdwb3MnKSAtIGZpcnN0KSAvIDI7XHJcblx0XHR9XHJcblx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xyXG5cdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRlbmQgPSBsYXN0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZW5kID0gKGxhc3QgLSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdLCAncG9zJykpIC8gMjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcclxuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xyXG5cdHZhciBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XHJcblx0dmFyIGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcclxuXHR2YXIgbWFqb3IsIGluZGV4O1xyXG5cclxuXHRmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XHJcblx0XHRpbmRleCA9IG1hcFttYWpvcl07XHJcblx0XHRpZiAoaW5kZXggPj0gMCkge1xyXG5cdFx0XHR0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdGlja3M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XHJcblx0dmFyIHRpY2tzID0gW107XHJcblx0dmFyIG1hcCA9IHt9O1xyXG5cdHZhciBpbGVuID0gdmFsdWVzLmxlbmd0aDtcclxuXHR2YXIgaSwgdmFsdWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xyXG5cdFx0bWFwW3ZhbHVlXSA9IGk7XHJcblxyXG5cdFx0dGlja3MucHVzaCh7XHJcblx0XHRcdHZhbHVlOiB2YWx1ZSxcclxuXHRcdFx0bWFqb3I6IGZhbHNlXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXHJcblx0Ly8gaXMgZXhwZW5zaXZlIHdoZW4gdGhlcmUgaXMgYSBsYXJnZSBudW1iZXIgb2YgdGlja3NcclxuXHRyZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0Q29uZmlnJDQgPSB7XHJcblx0cG9zaXRpb246ICdib3R0b20nLFxyXG5cclxuXHQvKipcclxuXHQgKiBEYXRhIGRpc3RyaWJ1dGlvbiBhbG9uZyB0aGUgc2NhbGU6XHJcblx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxyXG5cdCAqIC0gJ3Nlcmllcyc6IGRhdGEgYXJlIHNwcmVhZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHRkaXN0cmlidXRpb246ICdsaW5lYXInLFxyXG5cclxuXHQvKipcclxuXHQgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXHJcblx0ICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXHJcblx0ICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXHJcblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHRib3VuZHM6ICdkYXRhJyxcclxuXHJcblx0YWRhcHRlcnM6IHt9LFxyXG5cdHRpbWU6IHtcclxuXHRcdHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxyXG5cdFx0dW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXHJcblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cclxuXHRcdGRpc3BsYXlGb3JtYXQ6IGZhbHNlLCAvLyBERVBSRUNBVEVEXHJcblx0XHRpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXkgLSBzZWUgaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2dldC1zZXQvaXNvLXdlZWtkYXkvXHJcblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxyXG5cdFx0ZGlzcGxheUZvcm1hdHM6IHt9XHJcblx0fSxcclxuXHR0aWNrczoge1xyXG5cdFx0YXV0b1NraXA6IGZhbHNlLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XHJcblx0XHQgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cclxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxyXG5cdFx0ICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxyXG5cdFx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcclxuXHRcdCAqIEBzaW5jZSAyLjcuMFxyXG5cdFx0ICovXHJcblx0XHRzb3VyY2U6ICdhdXRvJyxcclxuXHJcblx0XHRtYWpvcjoge1xyXG5cdFx0XHRlbmFibGVkOiBmYWxzZVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnZhciBzY2FsZV90aW1lID0gY29yZV9zY2FsZS5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpbWUgPSBvcHRpb25zLnRpbWUgfHwgKG9wdGlvbnMudGltZSA9IHt9KTtcclxuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXIgPSBuZXcgY29yZV9hZGFwdGVycy5fZGF0ZShvcHRpb25zLmFkYXB0ZXJzLmRhdGUpO1xyXG5cclxuXHRcdC8vIERFUFJFQ0FUSU9OUzogb3V0cHV0IGEgbWVzc2FnZSBvbmx5IG9uZSB0aW1lIHBlciB1cGRhdGVcclxuXHRcdGRlcHJlY2F0ZWQkMSgndGltZSBzY2FsZScsIHRpbWUuZm9ybWF0LCAndGltZS5mb3JtYXQnLCAndGltZS5wYXJzZXInKTtcclxuXHRcdGRlcHJlY2F0ZWQkMSgndGltZSBzY2FsZScsIHRpbWUubWluLCAndGltZS5taW4nLCAndGlja3MubWluJyk7XHJcblx0XHRkZXByZWNhdGVkJDEoJ3RpbWUgc2NhbGUnLCB0aW1lLm1heCwgJ3RpbWUubWF4JywgJ3RpY2tzLm1heCcpO1xyXG5cclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xyXG5cdFx0Ly8gc3VwcG9zZWQgdG8gY29udGFpbiAqYWxsKiB1bml0L3N0cmluZyBwYWlycyBidXQgdGhpcyBjYW4ndCBiZSByZXNvbHZlZFxyXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxyXG5cdFx0Ly8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxyXG5cdFx0aGVscGVycyQxLm1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xyXG5cclxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS51cGRhdGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQWxsb3dzIGRhdGEgdG8gYmUgcmVmZXJlbmNlZCB2aWEgJ3QnIGF0dHJpYnV0ZVxyXG5cdCAqL1xyXG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XHJcblx0XHRpZiAocmF3VmFsdWUgJiYgcmF3VmFsdWUudCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgcmF3VmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XHJcblx0XHR2YXIgbWluID0gTUFYX0lOVEVHRVI7XHJcblx0XHR2YXIgbWF4ID0gTUlOX0lOVEVHRVI7XHJcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gW107XHJcblx0XHR2YXIgbGFiZWxzID0gW107XHJcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wLCBsYWJlbHNBZGRlZDtcclxuXHRcdHZhciBkYXRhTGFiZWxzID0gbWUuX2dldExhYmVscygpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhTGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRsYWJlbHMucHVzaChwYXJzZShtZSwgZGF0YUxhYmVsc1tpXSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0ZGF0YSA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uZGF0YTtcclxuXHJcblx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cclxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KGRhdGFbMF0pKSB7XHJcblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xyXG5cdFx0XHRcdFx0XHR0aW1lc3RhbXAgPSBwYXJzZShtZSwgZGF0YVtqXSk7XHJcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaCh0aW1lc3RhbXApO1xyXG5cdFx0XHRcdFx0XHRkYXRhc2V0c1tpXVtqXSA9IHRpbWVzdGFtcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XHJcblx0XHRcdFx0XHRpZiAoIWxhYmVsc0FkZGVkKSB7XHJcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChsYWJlbHMpO1xyXG5cdFx0XHRcdFx0XHRsYWJlbHNBZGRlZCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFiZWxzLmxlbmd0aCkge1xyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIGxhYmVsc1swXSk7XHJcblx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XHJcblx0XHRcdHRpbWVzdGFtcHMgPSBpbGVuID4gMSA/IGFycmF5VW5pcXVlKHRpbWVzdGFtcHMpLnNvcnQoc29ydGVyKSA6IHRpbWVzdGFtcHMuc29ydChzb3J0ZXIpO1xyXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xyXG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWluID0gcGFyc2UobWUsIGdldE1pbihvcHRpb25zKSkgfHwgbWluO1xyXG5cdFx0bWF4ID0gcGFyc2UobWUsIGdldE1heChvcHRpb25zKSkgfHwgbWF4O1xyXG5cclxuXHRcdC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gdmFsaWQgbWluL21heCwgc2V0IGxpbWl0cyBiYXNlZCBvbiB1bml0IHRpbWUgb3B0aW9uXHJcblx0XHRtaW4gPSBtaW4gPT09IE1BWF9JTlRFR0VSID8gK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KSA6IG1pbjtcclxuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIGxvb2t1cCB0YWJsZSlcclxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcclxuXHRcdG1lLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XHJcblxyXG5cdFx0Ly8gUFJJVkFURVxyXG5cdFx0bWUuX3RhYmxlID0gW107XHJcblx0XHRtZS5fdGltZXN0YW1wcyA9IHtcclxuXHRcdFx0ZGF0YTogdGltZXN0YW1wcyxcclxuXHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxyXG5cdFx0XHRsYWJlbHM6IGxhYmVsc1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWluID0gbWUubWluO1xyXG5cdFx0dmFyIG1heCA9IG1lLm1heDtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XHJcblx0XHR2YXIgdGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzO1xyXG5cdFx0dmFyIHRpY2tzID0gW107XHJcblx0XHR2YXIgY2FwYWNpdHkgPSBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbik7XHJcblx0XHR2YXIgc291cmNlID0gdGlja09wdHMuc291cmNlO1xyXG5cdFx0dmFyIGRpc3RyaWJ1dGlvbiA9IG9wdGlvbnMuZGlzdHJpYnV0aW9uO1xyXG5cdFx0dmFyIGksIGlsZW4sIHRpbWVzdGFtcDtcclxuXHJcblx0XHRpZiAoc291cmNlID09PSAnZGF0YScgfHwgKHNvdXJjZSA9PT0gJ2F1dG8nICYmIGRpc3RyaWJ1dGlvbiA9PT0gJ3NlcmllcycpKSB7XHJcblx0XHRcdHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmRhdGE7XHJcblx0XHR9IGVsc2UgaWYgKHNvdXJjZSA9PT0gJ2xhYmVscycpIHtcclxuXHRcdFx0dGltZXN0YW1wcyA9IHRpbWVzdGFtcHMubGFiZWxzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGltZXN0YW1wcyA9IGdlbmVyYXRlKG1lLCBtaW4sIG1heCwgY2FwYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xyXG5cdFx0XHRtaW4gPSB0aW1lc3RhbXBzWzBdO1xyXG5cdFx0XHRtYXggPSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRW5mb3JjZSBsaW1pdHMgd2l0aCB1c2VyIG1pbi9tYXggb3B0aW9uc1xyXG5cdFx0bWluID0gcGFyc2UobWUsIGdldE1pbihvcHRpb25zKSkgfHwgbWluO1xyXG5cdFx0bWF4ID0gcGFyc2UobWUsIGdldE1heChvcHRpb25zKSkgfHwgbWF4O1xyXG5cclxuXHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0dGltZXN0YW1wID0gdGltZXN0YW1wc1tpXTtcclxuXHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2godGltZXN0YW1wKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLm1pbiA9IG1pbjtcclxuXHRcdG1lLm1heCA9IG1heDtcclxuXHJcblx0XHQvLyBQUklWQVRFXHJcblx0XHQvLyBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyByZWxpZXMgb24gdGhlIG51bWJlciBvZiB0aWNrcyBzbyB3ZSBkb24ndCB1c2UgaXQgd2hlblxyXG5cdFx0Ly8gYXV0b1NraXAgaXMgZW5hYmxlZCBiZWNhdXNlIHdlIGRvbid0IHlldCBrbm93IHdoYXQgdGhlIGZpbmFsIG51bWJlciBvZiB0aWNrcyB3aWxsIGJlXHJcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXHJcblx0XHRcdD8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCwgY2FwYWNpdHkpXHJcblx0XHRcdDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgbWUubWluLCBtZS5tYXgpKTtcclxuXHRcdG1lLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCBtZS5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXHJcblx0XHRcdDogZGV0ZXJtaW5lTWFqb3JVbml0KG1lLl91bml0KTtcclxuXHRcdG1lLl90YWJsZSA9IGJ1aWxkTG9va3VwVGFibGUobWUuX3RpbWVzdGFtcHMuZGF0YSwgbWluLCBtYXgsIGRpc3RyaWJ1dGlvbik7XHJcblx0XHRtZS5fb2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKG1lLl90YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xyXG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIHRpY2tzLCBtZS5fbWFqb3JVbml0KTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcclxuXHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcclxuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcclxuXHRcdHZhciBsYWJlbCA9IGRhdGEubGFiZWxzICYmIGluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoID8gZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF07XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdFx0bGFiZWwgPSBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XHJcblx0XHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcclxuXHRcdH1cclxuXHRcdGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiBsYWJlbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0aWNrRm9ybWF0RnVuY3Rpb246IGZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xyXG5cdFx0dmFyIG1pbm9yRm9ybWF0ID0gZm9ybWF0c1ttZS5fdW5pdF07XHJcblx0XHR2YXIgbWFqb3JVbml0ID0gbWUuX21ham9yVW5pdDtcclxuXHRcdHZhciBtYWpvckZvcm1hdCA9IGZvcm1hdHNbbWFqb3JVbml0XTtcclxuXHRcdHZhciB0aWNrID0gdGlja3NbaW5kZXhdO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XHJcblx0XHR2YXIgbGFiZWwgPSBhZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgPyBmb3JtYXQgOiBtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpO1xyXG5cdFx0dmFyIG5lc3RlZFRpY2tPcHRzID0gbWFqb3IgPyB0aWNrT3B0cy5tYWpvciA6IHRpY2tPcHRzLm1pbm9yO1xyXG5cdFx0dmFyIGZvcm1hdHRlciA9IHJlc29sdmUkNShbXHJcblx0XHRcdG5lc3RlZFRpY2tPcHRzLmNhbGxiYWNrLFxyXG5cdFx0XHRuZXN0ZWRUaWNrT3B0cy51c2VyQ2FsbGJhY2ssXHJcblx0XHRcdHRpY2tPcHRzLmNhbGxiYWNrLFxyXG5cdFx0XHR0aWNrT3B0cy51c2VyQ2FsbGJhY2tcclxuXHRcdF0pO1xyXG5cclxuXHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcclxuXHRcdHZhciBsYWJlbHMgPSBbXTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bGFiZWxzLnB1c2godGhpcy50aWNrRm9ybWF0RnVuY3Rpb24odGlja3NbaV0udmFsdWUsIGksIHRpY2tzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhYmVscztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFBpeGVsRm9yT2Zmc2V0OiBmdW5jdGlvbih0aW1lKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcclxuXHRcdHZhciBwb3MgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XHJcblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aW1lID0gbnVsbDtcclxuXHJcblx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aW1lID0gbWUuX3RpbWVzdGFtcHMuZGF0YXNldHNbZGF0YXNldEluZGV4XVtpbmRleF07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRpbWUgPT09IG51bGwpIHtcclxuXHRcdFx0dGltZSA9IHBhcnNlKG1lLCB2YWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRpbWUgIT09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yT2Zmc2V0KHRpbWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcclxuXHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoID9cclxuXHRcdFx0dGhpcy5nZXRQaXhlbEZvck9mZnNldCh0aWNrc1tpbmRleF0udmFsdWUpIDpcclxuXHRcdFx0bnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvZmZzZXRzID0gbWUuX29mZnNldHM7XHJcblx0XHR2YXIgcG9zID0gbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XHJcblx0XHR2YXIgdGltZSA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAncG9zJywgcG9zLCAndGltZScpO1xyXG5cclxuXHRcdC8vIERFUFJFQ0FUSU9OLCB3ZSBzaG91bGQgcmV0dXJuIHRpbWUgZGlyZWN0bHlcclxuXHRcdHJldHVybiBtZS5fYWRhcHRlci5fY3JlYXRlKHRpbWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldExhYmVsU2l6ZTogZnVuY3Rpb24obGFiZWwpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XHJcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcclxuXHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcclxuXHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRkKHRpY2tzT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxyXG5cdFx0XHRoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TGFiZWxTaXplKGxhYmVsKS53O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XHJcblx0XHR2YXIgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcclxuXHJcblx0XHQvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3RpbWF0aW9uXHJcblx0XHR2YXIgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XHJcblx0XHR2YXIgZXhhbXBsZUxhYmVsID0gbWUudGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCBbZXhhbXBsZVRpbWVdLCBtZS5fbWFqb3JVbml0KSwgZm9ybWF0KTtcclxuXHRcdHZhciBzaXplID0gbWUuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xyXG5cdFx0dmFyIGNhcGFjaXR5ID0gTWF0aC5mbG9vcihtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIC8gc2l6ZS53IDogbWUuaGVpZ2h0IC8gc2l6ZS5oKTtcclxuXHJcblx0XHRpZiAobWUub3B0aW9ucy5vZmZzZXQpIHtcclxuXHRcdFx0Y2FwYWNpdHktLTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcclxudmFyIF9kZWZhdWx0cyQ0ID0gZGVmYXVsdENvbmZpZyQ0O1xuc2NhbGVfdGltZS5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkNDtcblxudmFyIHNjYWxlcyA9IHtcclxuXHRjYXRlZ29yeTogc2NhbGVfY2F0ZWdvcnksXHJcblx0bGluZWFyOiBzY2FsZV9saW5lYXIsXHJcblx0bG9nYXJpdGhtaWM6IHNjYWxlX2xvZ2FyaXRobWljLFxyXG5cdHJhZGlhbExpbmVhcjogc2NhbGVfcmFkaWFsTGluZWFyLFxyXG5cdHRpbWU6IHNjYWxlX3RpbWVcclxufTtcblxudmFyIEZPUk1BVFMgPSB7XHJcblx0ZGF0ZXRpbWU6ICdNTU0gRCwgWVlZWSwgaDptbTpzcyBhJyxcclxuXHRtaWxsaXNlY29uZDogJ2g6bW06c3MuU1NTIGEnLFxyXG5cdHNlY29uZDogJ2g6bW06c3MgYScsXHJcblx0bWludXRlOiAnaDptbSBhJyxcclxuXHRob3VyOiAnaEEnLFxyXG5cdGRheTogJ01NTSBEJyxcclxuXHR3ZWVrOiAnbGwnLFxyXG5cdG1vbnRoOiAnTU1NIFlZWVknLFxyXG5cdHF1YXJ0ZXI6ICdbUV1RIC0gWVlZWScsXHJcblx0eWVhcjogJ1lZWVknXHJcbn07XHJcblxyXG5jb3JlX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XHJcblx0X2lkOiAnbW9tZW50JywgLy8gREVCVUcgT05MWVxyXG5cclxuXHRmb3JtYXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBGT1JNQVRTO1xyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XHJcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcclxuXHRcdH0gZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIG1vbWVudCkpIHtcclxuXHRcdFx0dmFsdWUgPSBtb21lbnQodmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlLmlzVmFsaWQoKSA/IHZhbHVlLnZhbHVlT2YoKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Zm9ybWF0OiBmdW5jdGlvbih0aW1lLCBmb3JtYXQpIHtcclxuXHRcdHJldHVybiBtb21lbnQodGltZSkuZm9ybWF0KGZvcm1hdCk7XHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbih0aW1lLCBhbW91bnQsIHVuaXQpIHtcclxuXHRcdHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xyXG5cdH0sXHJcblxyXG5cdGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XHJcblx0XHRyZXR1cm4gbW9tZW50KG1heCkuZGlmZihtb21lbnQobWluKSwgdW5pdCk7XHJcblx0fSxcclxuXHJcblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xyXG5cdFx0dGltZSA9IG1vbWVudCh0aW1lKTtcclxuXHRcdGlmICh1bml0ID09PSAnaXNvV2VlaycpIHtcclxuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGltZS5zdGFydE9mKHVuaXQpLnZhbHVlT2YoKTtcclxuXHR9LFxyXG5cclxuXHRlbmRPZjogZnVuY3Rpb24odGltZSwgdW5pdCkge1xyXG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gREVQUkVDQVRJT05TXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxyXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY3JlYXRlOiBmdW5jdGlvbih0aW1lKSB7XHJcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xyXG5cdH0sXHJcbn0gOiB7fSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdHBsdWdpbnM6IHtcclxuXHRcdGZpbGxlcjoge1xyXG5cdFx0XHRwcm9wYWdhdGU6IHRydWVcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIG1hcHBlcnMgPSB7XHJcblx0ZGF0YXNldDogZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcclxuXHRcdHZhciBjaGFydCA9IHNvdXJjZS5jaGFydDtcclxuXHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xyXG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xyXG5cdFx0dmFyIHBvaW50cyA9ICh2aXNpYmxlICYmIG1ldGEuZGF0YXNldC5fY2hpbGRyZW4pIHx8IFtdO1xyXG5cdFx0dmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggfHwgMDtcclxuXHJcblx0XHRyZXR1cm4gIWxlbmd0aCA/IG51bGwgOiBmdW5jdGlvbihwb2ludCwgaSkge1xyXG5cdFx0XHRyZXR1cm4gKGkgPCBsZW5ndGggJiYgcG9pbnRzW2ldLl92aWV3KSB8fCBudWxsO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgYm91bmRhcnkgPSBzb3VyY2UuYm91bmRhcnk7XHJcblx0XHR2YXIgeCA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueCA6IG51bGw7XHJcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGJvdW5kYXJ5KSkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcclxuXHRcdFx0XHRyZXR1cm4gYm91bmRhcnlbaV07XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0eDogeCA9PT0gbnVsbCA/IHBvaW50LnggOiB4LFxyXG5cdFx0XHRcdHk6IHkgPT09IG51bGwgPyBwb2ludC55IDogeSxcclxuXHRcdFx0fTtcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQHRvZG8gaWYgKGZpbGxbMF0gPT09ICcjJylcclxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XHJcblx0dmFyIG1vZGVsID0gZWwuX21vZGVsIHx8IHt9O1xyXG5cdHZhciBmaWxsID0gbW9kZWwuZmlsbDtcclxuXHR2YXIgdGFyZ2V0O1xyXG5cclxuXHRpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0fVxyXG5cclxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0aWYgKGZpbGwgPT09IHRydWUpIHtcclxuXHRcdHJldHVybiAnb3JpZ2luJztcclxuXHR9XHJcblxyXG5cdHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCwgMTApO1xyXG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XHJcblx0XHRpZiAoZmlsbFswXSA9PT0gJy0nIHx8IGZpbGxbMF0gPT09ICcrJykge1xyXG5cdFx0XHR0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZmlsbCkge1xyXG5cdC8vIGNvbXBhdGliaWxpdHlcclxuXHRjYXNlICdib3R0b20nOlxyXG5cdFx0cmV0dXJuICdzdGFydCc7XHJcblx0Y2FzZSAndG9wJzpcclxuXHRcdHJldHVybiAnZW5kJztcclxuXHRjYXNlICd6ZXJvJzpcclxuXHRcdHJldHVybiAnb3JpZ2luJztcclxuXHQvLyBzdXBwb3J0ZWQgYm91bmRhcmllc1xyXG5cdGNhc2UgJ29yaWdpbic6XHJcblx0Y2FzZSAnc3RhcnQnOlxyXG5cdGNhc2UgJ2VuZCc6XHJcblx0XHRyZXR1cm4gZmlsbDtcclxuXHQvLyBpbnZhbGlkIGZpbGwgdmFsdWVzXHJcblx0ZGVmYXVsdDpcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcclxuXHR2YXIgbW9kZWwgPSBzb3VyY2UuZWwuX21vZGVsIHx8IHt9O1xyXG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XHJcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcclxuXHR2YXIgdGFyZ2V0ID0gbnVsbDtcclxuXHR2YXIgaG9yaXpvbnRhbDtcclxuXHJcblx0aWYgKGlzRmluaXRlKGZpbGwpKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxyXG5cdC8vIHRoZSBtb2RlbCAoc2NhbGVUb3AsIHNjYWxlQm90dG9tIGFuZCBzY2FsZVplcm8pIGJlY2F1c2Ugc29tZSBleHRlcm5hbCBwbHVnaW5zIGFuZFxyXG5cdC8vIGNvbnRyb2xsZXJzIG1pZ2h0IHN0aWxsIHVzZSBpdCAoZS5nLiB0aGUgU21pdGggY2hhcnQpLlxyXG5cclxuXHRpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xyXG5cdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVCb3R0b20gPT09IHVuZGVmaW5lZCA/IHNjYWxlLmJvdHRvbSA6IG1vZGVsLnNjYWxlQm90dG9tO1xyXG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcclxuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlVG9wID09PSB1bmRlZmluZWQgPyBzY2FsZS50b3AgOiBtb2RlbC5zY2FsZVRvcDtcclxuXHR9IGVsc2UgaWYgKG1vZGVsLnNjYWxlWmVybyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XHJcblx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcclxuXHRcdHRhcmdldCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xyXG5cdH1cclxuXHJcblx0aWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gbnVsbCkge1xyXG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xyXG5cdFx0XHRob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0eDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXHJcblx0XHRcdFx0eTogaG9yaXpvbnRhbCA/IG51bGwgOiB0YXJnZXRcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcclxuXHR2YXIgc2NhbGUgPSBzb3VyY2UuZWwuX3NjYWxlO1xyXG5cdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcclxuXHR2YXIgbGVuZ3RoID0gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoO1xyXG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XHJcblx0dmFyIHRhcmdldCA9IFtdO1xyXG5cdHZhciBzdGFydCwgZW5kLCBjZW50ZXIsIGksIHBvaW50O1xyXG5cclxuXHRpZiAoIWxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzdGFydCA9IG9wdGlvbnMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcclxuXHRlbmQgPSBvcHRpb25zLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XHJcblx0Y2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuXHRcdHBvaW50ID0gZmlsbCA9PT0gJ3N0YXJ0JyB8fCBmaWxsID09PSAnZW5kJ1xyXG5cdFx0XHQ/IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCBmaWxsID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQpXHJcblx0XHRcdDogc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKGkpO1xyXG5cdFx0aWYgKG9wdGlvbnMuZ3JpZExpbmVzLmNpcmN1bGFyKSB7XHJcblx0XHRcdHBvaW50LmN4ID0gY2VudGVyLng7XHJcblx0XHRcdHBvaW50LmN5ID0gY2VudGVyLnk7XHJcblx0XHRcdHBvaW50LmFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSAtIE1hdGguUEkgLyAyO1xyXG5cdFx0fVxyXG5cdFx0dGFyZ2V0LnB1c2gocG9pbnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XHJcblx0dmFyIHNjYWxlID0gc291cmNlLmVsLl9zY2FsZSB8fCB7fTtcclxuXHJcblx0aWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xyXG5cdFx0cmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XHJcblx0fVxyXG5cdHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XHJcblx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xyXG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XHJcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xyXG5cdHZhciB0YXJnZXQ7XHJcblxyXG5cdGlmICghcHJvcGFnYXRlKSB7XHJcblx0XHRyZXR1cm4gZmlsbDtcclxuXHR9XHJcblxyXG5cdHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XHJcblx0XHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XHJcblx0XHRcdHJldHVybiBmaWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XHJcblx0XHRpZiAoIXRhcmdldCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRhcmdldC52aXNpYmxlKSB7XHJcblx0XHRcdHJldHVybiBmaWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcclxuXHRcdGZpbGwgPSB0YXJnZXQuZmlsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTWFwcGVyKHNvdXJjZSkge1xyXG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XHJcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XHJcblxyXG5cdGlmIChmaWxsID09PSBmYWxzZSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XHJcblx0XHR0eXBlID0gJ2JvdW5kYXJ5JztcclxuXHR9XHJcblxyXG5cdHJldHVybiBtYXBwZXJzW3R5cGVdKHNvdXJjZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRHJhd2FibGUocG9pbnQpIHtcclxuXHRyZXR1cm4gcG9pbnQgJiYgIXBvaW50LnNraXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpIHtcclxuXHR2YXIgaSwgY3gsIGN5LCByO1xyXG5cclxuXHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vIGJ1aWxkaW5nIGZpcnN0IGFyZWEgY3VydmUgKG5vcm1hbClcclxuXHRjdHgubW92ZVRvKGN1cnZlMFswXS54LCBjdXJ2ZTBbMF0ueSk7XHJcblx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTBbaSAtIDFdLCBjdXJ2ZTBbaV0pO1xyXG5cdH1cclxuXHJcblx0aWYgKGN1cnZlMVswXS5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRjeCA9IGN1cnZlMVswXS5jeDtcclxuXHRcdGN5ID0gY3VydmUxWzBdLmN5O1xyXG5cdFx0ciA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJ2ZTFbMF0ueCAtIGN4LCAyKSArIE1hdGgucG93KGN1cnZlMVswXS55IC0gY3ksIDIpKTtcclxuXHRcdGZvciAoaSA9IGxlbjEgLSAxOyBpID4gMDsgLS1pKSB7XHJcblx0XHRcdGN0eC5hcmMoY3gsIGN5LCByLCBjdXJ2ZTFbaV0uYW5nbGUsIGN1cnZlMVtpIC0gMV0uYW5nbGUsIHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Ly8gam9pbmluZyB0aGUgdHdvIGFyZWEgY3VydmVzXHJcblx0Y3R4LmxpbmVUbyhjdXJ2ZTFbbGVuMSAtIDFdLngsIGN1cnZlMVtsZW4xIC0gMV0ueSk7XHJcblxyXG5cdC8vIGJ1aWxkaW5nIG9wcG9zaXRlIGFyZWEgY3VydmUgKHJldmVyc2UpXHJcblx0Zm9yIChpID0gbGVuMSAtIDE7IGkgPiAwOyAtLWkpIHtcclxuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgbG9vcCkge1xyXG5cdHZhciBjb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xyXG5cdHZhciBjdXJ2ZTAgPSBbXTtcclxuXHR2YXIgY3VydmUxID0gW107XHJcblx0dmFyIGxlbjAgPSAwO1xyXG5cdHZhciBsZW4xID0gMDtcclxuXHR2YXIgaSwgaWxlbiwgaW5kZXgsIHAwLCBwMSwgZDAsIGQxLCBsb29wT2Zmc2V0O1xyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0aW5kZXggPSBpICUgY291bnQ7XHJcblx0XHRwMCA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XHJcblx0XHRwMSA9IG1hcHBlcihwMCwgaW5kZXgsIHZpZXcpO1xyXG5cdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcclxuXHRcdGQxID0gaXNEcmF3YWJsZShwMSk7XHJcblxyXG5cdFx0aWYgKGxvb3AgJiYgbG9vcE9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGQwKSB7XHJcblx0XHRcdGxvb3BPZmZzZXQgPSBpICsgMTtcclxuXHRcdFx0aWxlbiA9IGNvdW50ICsgbG9vcE9mZnNldDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZDAgJiYgZDEpIHtcclxuXHRcdFx0bGVuMCA9IGN1cnZlMC5wdXNoKHAwKTtcclxuXHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcclxuXHRcdH0gZWxzZSBpZiAobGVuMCAmJiBsZW4xKSB7XHJcblx0XHRcdGlmICghc3Bhbikge1xyXG5cdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xyXG5cdFx0XHRcdGxlbjAgPSBsZW4xID0gMDtcclxuXHRcdFx0XHRjdXJ2ZTAgPSBbXTtcclxuXHRcdFx0XHRjdXJ2ZTEgPSBbXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoZDApIHtcclxuXHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGQxKSB7XHJcblx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcclxuXHJcblx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuXHRjdHguZmlsbCgpO1xyXG59XHJcblxyXG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcclxuXHRpZDogJ2ZpbGxlcicsXHJcblxyXG5cdGFmdGVyRGF0YXNldHNVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XHJcblx0XHR2YXIgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xyXG5cdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xyXG5cdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdHZhciBtZXRhLCBpLCBlbCwgc291cmNlO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcblx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XHJcblx0XHRcdHNvdXJjZSA9IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgZWxlbWVudHMuTGluZSkge1xyXG5cdFx0XHRcdHNvdXJjZSA9IHtcclxuXHRcdFx0XHRcdHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXHJcblx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXHJcblx0XHRcdFx0XHRjaGFydDogY2hhcnQsXHJcblx0XHRcdFx0XHRlbDogZWxcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XHJcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XHJcblx0XHRcdGlmICghc291cmNlKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBwcm9wYWdhdGUpO1xyXG5cdFx0XHRzb3VyY2UuYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcclxuXHRcdFx0c291cmNlLm1hcHBlciA9IGNyZWF0ZU1hcHBlcihzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJlZm9yZURhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XHJcblx0XHR2YXIgY3R4ID0gY2hhcnQuY3R4O1xyXG5cdFx0dmFyIG1ldGEsIGksIGVsLCB2aWV3LCBwb2ludHMsIG1hcHBlciwgY29sb3I7XHJcblxyXG5cdFx0Zm9yIChpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XHJcblxyXG5cdFx0XHRpZiAoIW1ldGEgfHwgIW1ldGEudmlzaWJsZSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbCA9IG1ldGEuZWw7XHJcblx0XHRcdHZpZXcgPSBlbC5fdmlldztcclxuXHRcdFx0cG9pbnRzID0gZWwuX2NoaWxkcmVuIHx8IFtdO1xyXG5cdFx0XHRtYXBwZXIgPSBtZXRhLm1hcHBlcjtcclxuXHRcdFx0Y29sb3IgPSB2aWV3LmJhY2tncm91bmRDb2xvciB8fCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XHJcblxyXG5cdFx0XHRpZiAobWFwcGVyICYmIGNvbG9yICYmIHBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcclxuXHRcdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcclxuXHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY3R4KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIGdldFJ0bEhlbHBlciQxID0gaGVscGVycyQxLnJ0bC5nZXRSdGxBZGFwdGVyO1xyXG52YXIgbm9vcCQxID0gaGVscGVycyQxLm5vb3A7XHJcbnZhciB2YWx1ZU9yRGVmYXVsdCRlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0bGVnZW5kOiB7XHJcblx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3AnLFxyXG5cdFx0YWxpZ246ICdjZW50ZXInLFxyXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxyXG5cdFx0cmV2ZXJzZTogZmFsc2UsXHJcblx0XHR3ZWlnaHQ6IDEwMDAsXHJcblxyXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXHJcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XHJcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xyXG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0XHR2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKGluZGV4KTtcclxuXHJcblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxyXG5cdFx0XHRtZXRhLmhpZGRlbiA9IG1ldGEuaGlkZGVuID09PSBudWxsID8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XHJcblxyXG5cdFx0XHQvLyBXZSBoaWQgYSBkYXRhc2V0IC4uLiByZXJlbmRlciB0aGUgY2hhcnRcclxuXHRcdFx0Y2kudXBkYXRlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdG9uSG92ZXI6IG51bGwsXHJcblx0XHRvbkxlYXZlOiBudWxsLFxyXG5cclxuXHRcdGxhYmVsczoge1xyXG5cdFx0XHRib3hXaWR0aDogNDAsXHJcblx0XHRcdHBhZGRpbmc6IDEwLFxyXG5cdFx0XHQvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcclxuXHRcdFx0Ly8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XHJcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcclxuXHRcdFx0Ly8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcclxuXHRcdFx0Ly8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcclxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxyXG5cdFx0XHQvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXHJcblx0XHRcdC8vIGxpbmVEYXNoXHJcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcclxuXHRcdFx0Ly8gbGluZUpvaW4gOlxyXG5cdFx0XHQvLyBsaW5lV2lkdGggOlxyXG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdFx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0XHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5sZWdlbmQgfHwge307XHJcblx0XHRcdFx0dmFyIHVzZVBvaW50U3R5bGUgPSBvcHRpb25zLmxhYmVscyAmJiBvcHRpb25zLmxhYmVscy51c2VQb2ludFN0eWxlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcChmdW5jdGlvbihtZXRhKSB7XHJcblx0XHRcdFx0XHR2YXIgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxyXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRcdFx0aGlkZGVuOiAhY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShtZXRhLmluZGV4KSxcclxuXHRcdFx0XHRcdFx0bGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXHJcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxyXG5cdFx0XHRcdFx0XHRsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcclxuXHRcdFx0XHRcdFx0bGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcclxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdFx0XHRwb2ludFN0eWxlOiBzdHlsZS5wb2ludFN0eWxlLFxyXG5cdFx0XHRcdFx0XHRyb3RhdGlvbjogc3R5bGUucm90YXRpb24sXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xyXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgaSwgaWxlbiwgbGlzdEl0ZW0sIGxpc3RJdGVtU3BhbjtcclxuXHJcblx0XHRsaXN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjaGFydC5pZCArICctbGVnZW5kJyk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRsaXN0SXRlbSA9IGxpc3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XHJcblx0XHRcdGxpc3RJdGVtU3BhbiA9IGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XHJcblx0XHRcdGxpc3RJdGVtU3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRcdGlmIChkYXRhc2V0c1tpXS5sYWJlbCkge1xyXG5cdFx0XHRcdGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGFzZXRzW2ldLmxhYmVsKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGlzdC5vdXRlckhUTUw7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3ggd2lkdGggYmFzZWQgb24gdGhlIHVzZVBvaW50U3R5bGUgb3B0aW9uXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBsYWJlbG9wdHMgLSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIHRoZSBsYWJlbCBmb250IHNpemVcclxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgY29sb3IgYm94IGFyZWFcclxuICovXHJcbmZ1bmN0aW9uIGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpIHtcclxuXHRyZXR1cm4gbGFiZWxPcHRzLnVzZVBvaW50U3R5bGUgJiYgbGFiZWxPcHRzLmJveFdpZHRoID4gZm9udFNpemUgP1xyXG5cdFx0Zm9udFNpemUgOlxyXG5cdFx0bGFiZWxPcHRzLmJveFdpZHRoO1xyXG59XHJcblxyXG4vKipcclxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxyXG4gKi9cclxudmFyIExlZ2VuZCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKG1lLCBjb25maWcpO1xyXG5cclxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxyXG5cdFx0bWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuIFx0XHQgKiBAcHJpdmF0ZVxyXG4gXHRcdCAqL1xyXG5cdFx0bWUuX2hvdmVyZWRJdGVtID0gbnVsbDtcclxuXHJcblx0XHQvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXHJcblx0XHRtZS5kb3VnaG51dE1vZGUgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxyXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBsZWdlbmQgdHlwZXMuXHJcblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcclxuXHJcblx0YmVmb3JlVXBkYXRlOiBub29wJDEsXHJcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXHJcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcclxuXHJcblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcclxuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcclxuXHJcblx0XHQvLyBEaW1lbnNpb25zXHJcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuXHRcdC8vIExhYmVsc1xyXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcclxuXHRcdG1lLmJ1aWxkTGFiZWxzKCk7XHJcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XHJcblxyXG5cdFx0Ly8gRml0XHJcblx0XHRtZS5iZWZvcmVGaXQoKTtcclxuXHRcdG1lLmZpdCgpO1xyXG5cdFx0bWUuYWZ0ZXJGaXQoKTtcclxuXHRcdC8vXHJcblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBtZS5taW5TaXplO1xyXG5cdH0sXHJcblx0YWZ0ZXJVcGRhdGU6IG5vb3AkMSxcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQxLFxyXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRcdG1lLmxlZnQgPSAwO1xyXG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLnRvcCA9IDA7XHJcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXNldCBwYWRkaW5nXHJcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcclxuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcclxuXHJcblx0XHQvLyBSZXNldCBtaW5TaXplXHJcblx0XHRtZS5taW5TaXplID0ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0aGVpZ2h0OiAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wJDEsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDEsXHJcblx0YnVpbGRMYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcclxuXHRcdHZhciBsZWdlbmRJdGVtcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcclxuXHJcblx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xyXG5cdFx0XHRsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0cmV0dXJuIGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgbWUuY2hhcnQuZGF0YSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcclxuXHRcdFx0bGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XHJcblx0fSxcclxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDEsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUZpdDogbm9vcCQxLFxyXG5cdGZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xyXG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XHJcblxyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHJcblx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChsYWJlbE9wdHMpO1xyXG5cdFx0dmFyIGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XHJcblxyXG5cdFx0Ly8gUmVzZXQgaGl0IGJveGVzXHJcblx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xyXG5cclxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXHJcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSA/IDEwIDogMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBkaXNwbGF5ID8gMTAgOiAwO1xyXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcclxuXHRcdGlmICghZGlzcGxheSkge1xyXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGggPSBtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodCA9IDA7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcclxuXHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdC8vIExhYmVsc1xyXG5cclxuXHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXHJcblx0XHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocyA9IFswXTtcclxuXHRcdFx0dmFyIHRvdGFsSGVpZ2h0ID0gMDtcclxuXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XHJcblx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xyXG5cclxuXHRcdFx0XHRpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyB3aWR0aCArIDIgKiBsYWJlbE9wdHMucGFkZGluZyA+IG1pblNpemUud2lkdGgpIHtcclxuXHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxyXG5cdFx0XHRcdGhpdGJveGVzW2ldID0ge1xyXG5cdFx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcclxuXHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRtaW5TaXplLmhlaWdodCArPSB0b3RhbEhlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdlBhZGRpbmcgPSBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0dmFyIGNvbHVtbldpZHRocyA9IG1lLmNvbHVtbldpZHRocyA9IFtdO1xyXG5cdFx0XHR2YXIgY29sdW1uSGVpZ2h0cyA9IG1lLmNvbHVtbkhlaWdodHMgPSBbXTtcclxuXHRcdFx0dmFyIHRvdGFsV2lkdGggPSBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0dmFyIGN1cnJlbnRDb2xXaWR0aCA9IDA7XHJcblx0XHRcdHZhciBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XHJcblx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0dmFyIGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcclxuXHJcblx0XHRcdFx0Ly8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cclxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGZvbnRTaXplICsgMiAqIHZQYWRkaW5nID4gbWluU2l6ZS5oZWlnaHQpIHtcclxuXHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpOyAvLyBwcmV2aW91cyBjb2x1bW4gd2lkdGhcclxuXHRcdFx0XHRcdGNvbHVtbkhlaWdodHMucHVzaChjdXJyZW50Q29sSGVpZ2h0KTtcclxuXHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IDA7XHJcblx0XHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcclxuXHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XHJcblx0XHRcdFx0Y3VycmVudENvbEhlaWdodCArPSBmb250U2l6ZSArIHZQYWRkaW5nO1xyXG5cclxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxyXG5cdFx0XHRcdGhpdGJveGVzW2ldID0ge1xyXG5cdFx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRcdHdpZHRoOiBpdGVtV2lkdGgsXHJcblx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcclxuXHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTtcclxuXHRcdFx0Y29sdW1uSGVpZ2h0cy5wdXNoKGN1cnJlbnRDb2xIZWlnaHQpO1xyXG5cdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xyXG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XHJcblx0fSxcclxuXHRhZnRlckZpdDogbm9vcCQxLFxyXG5cclxuXHQvLyBTaGFyZWQgTWV0aG9kc1xyXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFjdHVhbGx5IGRyYXcgdGhlIGxlZ2VuZCBvbiB0aGUgY2FudmFzXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xyXG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblx0XHR2YXIgZGVmYXVsdENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xyXG5cdFx0dmFyIGxpbmVEZWZhdWx0ID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcclxuXHRcdHZhciBsZWdlbmRIZWlnaHQgPSBtZS5oZWlnaHQ7XHJcblx0XHR2YXIgY29sdW1uSGVpZ2h0cyA9IG1lLmNvbHVtbkhlaWdodHM7XHJcblx0XHR2YXIgbGVnZW5kV2lkdGggPSBtZS53aWR0aDtcclxuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcclxuXHJcblx0XHRpZiAoIW9wdHMuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlciQxKG9wdHMucnRsLCBtZS5sZWZ0LCBtZS5taW5TaXplLndpZHRoKTtcclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkZShsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcclxuXHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XHJcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcclxuXHRcdHZhciBjdXJzb3I7XHJcblxyXG5cdFx0Ly8gQ2FudmFzIHNldHVwXHJcblx0XHRjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cdFx0Y3R4LmxpbmVXaWR0aCA9IDAuNTtcclxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IGZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XHJcblx0XHRjdHguZmlsbFN0eWxlID0gZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcclxuXHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcclxuXHJcblx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcclxuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzO1xyXG5cclxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cclxuXHRcdHZhciBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xyXG5cdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblxyXG5cdFx0XHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpO1xyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcclxuXHRcdFx0Y3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZUNhcCwgbGluZURlZmF1bHQuYm9yZGVyQ2FwU3R5bGUpO1xyXG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2hPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZUpvaW4sIGxpbmVEZWZhdWx0LmJvcmRlckpvaW5TdHlsZSk7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcclxuXHJcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcclxuXHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcclxuXHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsYWJlbE9wdHMgJiYgbGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcclxuXHRcdFx0XHQvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcclxuXHRcdFx0XHQvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXHJcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGJveFdpZHRoICogTWF0aC5TUVJUMiAvIDI7XHJcblx0XHRcdFx0dmFyIGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcclxuXHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBmb250U2l6ZSAvIDI7XHJcblxyXG5cdFx0XHRcdC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXHJcblx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBsZWdlbmRJdGVtLnBvaW50U3R5bGUsIHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSwgbGVnZW5kSXRlbS5yb3RhdGlvbik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxyXG5cdFx0XHRcdGN0eC5maWxsUmVjdChydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCksIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0aWYgKGxpbmVXaWR0aCAhPT0gMCkge1xyXG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QocnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpLCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKSB7XHJcblx0XHRcdHZhciBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XHJcblx0XHRcdHZhciB4TGVmdCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCArIGhhbGZGb250U2l6ZSk7XHJcblx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcclxuXHJcblx0XHRcdGN0eC5maWxsVGV4dChsZWdlbmRJdGVtLnRleHQsIHhMZWZ0LCB5TWlkZGxlKTtcclxuXHJcblx0XHRcdGlmIChsZWdlbmRJdGVtLmhpZGRlbikge1xyXG5cdFx0XHRcdC8vIFN0cmlrZXRocm91Z2ggdGhlIHRleHQgaWYgaGlkZGVuXHJcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSAyO1xyXG5cdFx0XHRcdGN0eC5tb3ZlVG8oeExlZnQsIHlNaWRkbGUpO1xyXG5cdFx0XHRcdGN0eC5saW5lVG8ocnRsSGVscGVyLnhQbHVzKHhMZWZ0LCB0ZXh0V2lkdGgpLCB5TWlkZGxlKTtcclxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGFsaWdubWVudE9mZnNldCA9IGZ1bmN0aW9uKGRpbWVuc2lvbiwgYmxvY2tTaXplKSB7XHJcblx0XHRcdHN3aXRjaCAob3B0cy5hbGlnbikge1xyXG5cdFx0XHRjYXNlICdzdGFydCc6XHJcblx0XHRcdFx0cmV0dXJuIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHRjYXNlICdlbmQnOlxyXG5cdFx0XHRcdHJldHVybiBkaW1lbnNpb24gLSBibG9ja1NpemU7XHJcblx0XHRcdGRlZmF1bHQ6IC8vIGNlbnRlclxyXG5cdFx0XHRcdHJldHVybiAoZGltZW5zaW9uIC0gYmxvY2tTaXplICsgbGFiZWxPcHRzLnBhZGRpbmcpIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBIb3Jpem9udGFsXHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdGN1cnNvciA9IHtcclxuXHRcdFx0XHR4OiBtZS5sZWZ0ICsgYWxpZ25tZW50T2Zmc2V0KGxlZ2VuZFdpZHRoLCBsaW5lV2lkdGhzWzBdKSxcclxuXHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcclxuXHRcdFx0XHRsaW5lOiAwXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJzb3IgPSB7XHJcblx0XHRcdFx0eDogbWUubGVmdCArIGxhYmVsT3B0cy5wYWRkaW5nLFxyXG5cdFx0XHRcdHk6IG1lLnRvcCArIGFsaWdubWVudE9mZnNldChsZWdlbmRIZWlnaHQsIGNvbHVtbkhlaWdodHNbMF0pLFxyXG5cdFx0XHRcdGxpbmU6IDBcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRoZWxwZXJzJDEucnRsLm92ZXJyaWRlVGV4dERpcmVjdGlvbihtZS5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XHJcblxyXG5cdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcclxuXHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xyXG5cdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xyXG5cdFx0XHR2YXIgeCA9IGN1cnNvci54O1xyXG5cdFx0XHR2YXIgeSA9IGN1cnNvci55O1xyXG5cclxuXHRcdFx0cnRsSGVscGVyLnNldFdpZHRoKG1lLm1pblNpemUud2lkdGgpO1xyXG5cclxuXHRcdFx0Ly8gVXNlIChtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkgYW5kIChtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodClcclxuXHRcdFx0Ly8gaW5zdGVhZCBvZiBtZS5yaWdodCBhbmQgbWUuYm90dG9tIGJlY2F1c2UgbWUud2lkdGggYW5kIG1lLmhlaWdodFxyXG5cdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgc2luY2UgbWUubWluU2l6ZSB3YXMgY2FsY3VsYXRlZFxyXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdFx0aWYgKGkgPiAwICYmIHggKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID4gbWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIHtcclxuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xyXG5cdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcclxuXHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IG1lLmxlZnQgKyBhbGlnbm1lbnRPZmZzZXQobGVnZW5kV2lkdGgsIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGl0ZW1IZWlnaHQgPiBtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodCkge1xyXG5cdFx0XHRcdHggPSBjdXJzb3IueCA9IHggKyBtZS5jb2x1bW5XaWR0aHNbY3Vyc29yLmxpbmVdICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcclxuXHRcdFx0XHR5ID0gY3Vyc29yLnkgPSBtZS50b3AgKyBhbGlnbm1lbnRPZmZzZXQobGVnZW5kSGVpZ2h0LCBjb2x1bW5IZWlnaHRzW2N1cnNvci5saW5lXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xyXG5cclxuXHRcdFx0ZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XHJcblxyXG5cdFx0XHRoaXRib3hlc1tpXS5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocmVhbFgsIGhpdGJveGVzW2ldLndpZHRoKTtcclxuXHRcdFx0aGl0Ym94ZXNbaV0udG9wID0geTtcclxuXHJcblx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxyXG5cdFx0XHRmaWxsVGV4dChyZWFsWCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKTtcclxuXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5ydGwucmVzdG9yZVRleHREaXJlY3Rpb24obWUuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBpLCBoaXRCb3gsIGxoO1xyXG5cclxuXHRcdGlmICh4ID49IG1lLmxlZnQgJiYgeCA8PSBtZS5yaWdodCAmJiB5ID49IG1lLnRvcCAmJiB5IDw9IG1lLmJvdHRvbSkge1xyXG5cdFx0XHQvLyBTZWUgaWYgd2UgYXJlIHRvdWNoaW5nIG9uZSBvZiB0aGUgZGF0YXNldCBib3hlc1xyXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRoaXRCb3ggPSBsaFtpXTtcclxuXHJcblx0XHRcdFx0aWYgKHggPj0gaGl0Qm94LmxlZnQgJiYgeCA8PSBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aCAmJiB5ID49IGhpdEJveC50b3AgJiYgeSA8PSBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkge1xyXG5cdFx0XHRcdFx0Ly8gVG91Y2hpbmcgYW4gZWxlbWVudFxyXG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZSBhbiBldmVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxyXG5cdCAqL1xyXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdjbGljaycgOiBlLnR5cGU7XHJcblx0XHR2YXIgaG92ZXJlZEl0ZW07XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XHJcblx0XHRcdGlmICghb3B0cy5vbkhvdmVyICYmICFvcHRzLm9uTGVhdmUpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XHJcblx0XHRob3ZlcmVkSXRlbSA9IG1lLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdGlmIChob3ZlcmVkSXRlbSAmJiBvcHRzLm9uQ2xpY2spIHtcclxuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0b3B0cy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRzLm9uTGVhdmUgJiYgaG92ZXJlZEl0ZW0gIT09IG1lLl9ob3ZlcmVkSXRlbSkge1xyXG5cdFx0XHRcdGlmIChtZS5faG92ZXJlZEl0ZW0pIHtcclxuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bWUuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRzLm9uSG92ZXIgJiYgaG92ZXJlZEl0ZW0pIHtcclxuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0b3B0cy5vbkhvdmVyLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKSB7XHJcblx0dmFyIGxlZ2VuZCA9IG5ldyBMZWdlbmQoe1xyXG5cdFx0Y3R4OiBjaGFydC5jdHgsXHJcblx0XHRvcHRpb25zOiBsZWdlbmRPcHRzLFxyXG5cdFx0Y2hhcnQ6IGNoYXJ0XHJcblx0fSk7XHJcblxyXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XHJcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcclxuXHRjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XHJcbn1cclxuXHJcbnZhciBwbHVnaW5fbGVnZW5kID0ge1xyXG5cdGlkOiAnbGVnZW5kJyxcclxuXHJcblx0LyoqXHJcblx0ICogQmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2luY2UgMi4xLjUsIHRoZSBsZWdlbmQgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXHJcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxyXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXHJcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC8yNjQwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZWxlbWVudDogTGVnZW5kLFxyXG5cclxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcclxuXHJcblx0XHRpZiAobGVnZW5kT3B0cykge1xyXG5cdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XHJcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xyXG5cclxuXHRcdGlmIChsZWdlbmRPcHRzKSB7XHJcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKGxlZ2VuZE9wdHMsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmxlZ2VuZCk7XHJcblxyXG5cdFx0XHRpZiAobGVnZW5kKSB7XHJcblx0XHRcdFx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcclxuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChsZWdlbmQpIHtcclxuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbGVnZW5kKTtcclxuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcclxuXHRcdGlmIChsZWdlbmQpIHtcclxuXHRcdFx0bGVnZW5kLmhhbmRsZUV2ZW50KGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIG5vb3AkMiA9IGhlbHBlcnMkMS5ub29wO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0dGl0bGU6IHtcclxuXHRcdGRpc3BsYXk6IGZhbHNlLFxyXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXHJcblx0XHRmdWxsV2lkdGg6IHRydWUsXHJcblx0XHRwYWRkaW5nOiAxMCxcclxuXHRcdHBvc2l0aW9uOiAndG9wJyxcclxuXHRcdHRleHQ6ICcnLFxyXG5cdFx0d2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxyXG5cdH1cclxufSk7XHJcblxyXG4vKipcclxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxyXG4gKi9cclxudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY29uZmlnKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcclxuXHJcblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcclxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XHJcblx0fSxcclxuXHJcblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cclxuXHJcblx0YmVmb3JlVXBkYXRlOiBub29wJDIsXHJcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXHJcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcclxuXHJcblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcclxuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcclxuXHJcblx0XHQvLyBEaW1lbnNpb25zXHJcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XHJcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuXHRcdC8vIExhYmVsc1xyXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcclxuXHRcdG1lLmJ1aWxkTGFiZWxzKCk7XHJcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XHJcblxyXG5cdFx0Ly8gRml0XHJcblx0XHRtZS5iZWZvcmVGaXQoKTtcclxuXHRcdG1lLmZpdCgpO1xyXG5cdFx0bWUuYWZ0ZXJGaXQoKTtcclxuXHRcdC8vXHJcblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBtZS5taW5TaXplO1xyXG5cclxuXHR9LFxyXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AkMixcclxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxyXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxyXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xyXG5cdFx0XHRtZS5sZWZ0ID0gMDtcclxuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcclxuXHJcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxyXG5cdFx0XHRtZS50b3AgPSAwO1xyXG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xyXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xyXG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xyXG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XHJcblxyXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxyXG5cdFx0bWUubWluU2l6ZSA9IHtcclxuXHRcdFx0d2lkdGg6IDAsXHJcblx0XHRcdGhlaWdodDogMFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVCdWlsZExhYmVsczogbm9vcCQyLFxyXG5cdGJ1aWxkTGFiZWxzOiBub29wJDIsXHJcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVGaXQ6IG5vb3AkMixcclxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHt9O1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0dmFyIGxpbmVDb3VudCwgdGV4dFNpemU7XHJcblxyXG5cdFx0aWYgKCFvcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoID0gbWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQgPSAwO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGluZUNvdW50ID0gaGVscGVycyQxLmlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xyXG5cdFx0dGV4dFNpemUgPSBsaW5lQ291bnQgKiBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpLmxpbmVIZWlnaHQgKyBvcHRzLnBhZGRpbmcgKiAyO1xyXG5cclxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aCA9IGlzSG9yaXpvbnRhbCA/IG1lLm1heFdpZHRoIDogdGV4dFNpemU7XHJcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodCA9IGlzSG9yaXpvbnRhbCA/IHRleHRTaXplIDogbWUubWF4SGVpZ2h0O1xyXG5cdH0sXHJcblx0YWZ0ZXJGaXQ6IG5vb3AkMixcclxuXHJcblx0Ly8gU2hhcmVkIE1ldGhvZHNcclxuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xyXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKCFvcHRzLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb250T3B0cyA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0cyk7XHJcblx0XHR2YXIgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XHJcblx0XHR2YXIgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyBvcHRzLnBhZGRpbmc7XHJcblx0XHR2YXIgcm90YXRpb24gPSAwO1xyXG5cdFx0dmFyIHRvcCA9IG1lLnRvcDtcclxuXHRcdHZhciBsZWZ0ID0gbWUubGVmdDtcclxuXHRcdHZhciBib3R0b20gPSBtZS5ib3R0b207XHJcblx0XHR2YXIgcmlnaHQgPSBtZS5yaWdodDtcclxuXHRcdHZhciBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XHJcblxyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxyXG5cdFx0Y3R4LmZvbnQgPSBmb250T3B0cy5zdHJpbmc7XHJcblxyXG5cdFx0Ly8gSG9yaXpvbnRhbFxyXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdHRpdGxlWCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXHJcblx0XHRcdHRpdGxlWSA9IHRvcCArIG9mZnNldDtcclxuXHRcdFx0bWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgb2Zmc2V0IDogcmlnaHQgLSBvZmZzZXQ7XHJcblx0XHRcdHRpdGxlWSA9IHRvcCArICgoYm90dG9tIC0gdG9wKSAvIDIpO1xyXG5cdFx0XHRtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcclxuXHRcdFx0cm90YXRpb24gPSBNYXRoLlBJICogKG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IC0wLjUgOiAwLjUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHgudHJhbnNsYXRlKHRpdGxlWCwgdGl0bGVZKTtcclxuXHRcdGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XHJcblx0XHRcdHZhciB5ID0gMDtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcclxuXHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XHJcblx0dmFyIHRpdGxlID0gbmV3IFRpdGxlKHtcclxuXHRcdGN0eDogY2hhcnQuY3R4LFxyXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxyXG5cdFx0Y2hhcnQ6IGNoYXJ0XHJcblx0fSk7XHJcblxyXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xyXG5cdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcclxuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XHJcbn1cclxuXHJcbnZhciBwbHVnaW5fdGl0bGUgPSB7XHJcblx0aWQ6ICd0aXRsZScsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNpbmNlIDIuMS41LCB0aGUgdGl0bGUgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXHJcblx0ICogQ2hhcnQuVGl0bGUgb2Jzb2xldGUuIFRvIGF2b2lkIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBleHBvcnQgdGhlIFRpdGxlIGFzIHBhcnQgb2ZcclxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvMjY0MFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2VsZW1lbnQ6IFRpdGxlLFxyXG5cclxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XHJcblxyXG5cdFx0aWYgKHRpdGxlT3B0cykge1xyXG5cdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xyXG5cdFx0dmFyIHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xyXG5cclxuXHRcdGlmICh0aXRsZU9wdHMpIHtcclxuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYodGl0bGVPcHRzLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC50aXRsZSk7XHJcblxyXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xyXG5cdFx0XHRcdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlQmxvY2ssIHRpdGxlT3B0cyk7XHJcblx0XHRcdFx0dGl0bGVCbG9jay5vcHRpb25zID0gdGl0bGVPcHRzO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xyXG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcclxuXHRcdFx0ZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG52YXIgcGx1Z2lucyA9IHt9O1xyXG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcclxudmFyIGxlZ2VuZCA9IHBsdWdpbl9sZWdlbmQ7XHJcbnZhciB0aXRsZSA9IHBsdWdpbl90aXRsZTtcbnBsdWdpbnMuZmlsbGVyID0gZmlsbGVyO1xucGx1Z2lucy5sZWdlbmQgPSBsZWdlbmQ7XG5wbHVnaW5zLnRpdGxlID0gdGl0bGU7XG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0XHJcbiAqL1xyXG5cclxuXHJcbmNvcmVfY29udHJvbGxlci5oZWxwZXJzID0gaGVscGVycyQxO1xyXG5cclxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxyXG5jb3JlX2hlbHBlcnMoKTtcclxuXHJcbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xyXG5jb3JlX2NvbnRyb2xsZXIuQW5pbWF0aW9uID0gY29yZV9hbmltYXRpb247XHJcbmNvcmVfY29udHJvbGxlci5hbmltYXRpb25TZXJ2aWNlID0gY29yZV9hbmltYXRpb25zO1xyXG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcclxuY29yZV9jb250cm9sbGVyLkRhdGFzZXRDb250cm9sbGVyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlcjtcclxuY29yZV9jb250cm9sbGVyLmRlZmF1bHRzID0gY29yZV9kZWZhdWx0cztcclxuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XHJcbmNvcmVfY29udHJvbGxlci5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5jb3JlX2NvbnRyb2xsZXIuSW50ZXJhY3Rpb24gPSBjb3JlX2ludGVyYWN0aW9uO1xyXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcclxuY29yZV9jb250cm9sbGVyLnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbmNvcmVfY29udHJvbGxlci5wbHVnaW5zID0gY29yZV9wbHVnaW5zO1xyXG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xyXG5jb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlID0gY29yZV9zY2FsZVNlcnZpY2U7XHJcbmNvcmVfY29udHJvbGxlci5UaWNrcyA9IGNvcmVfdGlja3M7XHJcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xyXG5cclxuLy8gUmVnaXN0ZXIgYnVpbHQtaW4gc2NhbGVzXHJcblxyXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKHNjYWxlcywgZnVuY3Rpb24oc2NhbGUsIHR5cGUpIHtcclxuXHRjb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKHR5cGUsIHNjYWxlLCBzY2FsZS5fZGVmYXVsdHMpO1xyXG59KTtcclxuXHJcbi8vIExvYWQgdG8gcmVnaXN0ZXIgYnVpbHQtaW4gYWRhcHRlcnMgKGFzIHNpZGUgZWZmZWN0cylcclxuXHJcblxyXG4vLyBMb2FkaW5nIGJ1aWx0LWluIHBsdWdpbnNcclxuXHJcbmZvciAodmFyIGsgaW4gcGx1Z2lucykge1xyXG5cdGlmIChwbHVnaW5zLmhhc093blByb3BlcnR5KGspKSB7XHJcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcclxuXHR9XHJcbn1cclxuXHJcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybS5pbml0aWFsaXplKCk7XHJcblxyXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHR3aW5kb3cuQ2hhcnQgPSBjb3JlX2NvbnRyb2xsZXI7XHJcbn1cclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLkxlZ2VuZCA9IHBsdWdpbnMubGVnZW5kLl9lbGVtZW50O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5UaXRsZSA9IHBsdWdpbnMudGl0bGUuX2VsZW1lbnQ7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5wbHVnaW5zIGluc3RlYWRcclxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLnBsdWdpblNlcnZpY2UgPSBjb3JlX2NvbnRyb2xsZXIucGx1Z2lucztcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaW5oZXJpdGluZyBmcm9tIENoYXJ0LlBsdWdpbmdCYXNlIGhhcyBub1xyXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXHJcbiAqIEBpbnRlcmZhY2UgQ2hhcnQuUGx1Z2luQmFzZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuY2FudmFzSGVscGVyc1xyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmxheW91dFNlcnZpY2VcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuM1xyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGluZWFyU2NhbGVCYXNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44XHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcclxuICogYnkgc2V0dGluZyB0aGUgdHlwZSBpbiB0aGUgY29uZmlnIChgbmV3IENoYXJ0KGlkLCB7dHlwZTogJ3tjaGFydC10eXBlfSd9YCkuXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChcclxuXHRbXHJcblx0XHQnQmFyJyxcclxuXHRcdCdCdWJibGUnLFxyXG5cdFx0J0RvdWdobnV0JyxcclxuXHRcdCdMaW5lJyxcclxuXHRcdCdQb2xhckFyZWEnLFxyXG5cdFx0J1JhZGFyJyxcclxuXHRcdCdTY2F0dGVyJ1xyXG5cdF0sXHJcblx0ZnVuY3Rpb24oa2xhc3MpIHtcclxuXHRcdGNvcmVfY29udHJvbGxlcltrbGFzc10gPSBmdW5jdGlvbihjdHgsIGNmZykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IGNvcmVfY29udHJvbGxlcihjdHgsIGNvcmVfY29udHJvbGxlci5oZWxwZXJzLm1lcmdlKGNmZyB8fCB7fSwge1xyXG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcclxuXHRcdFx0fSkpO1xyXG5cdFx0fTtcclxuXHR9XHJcbik7XG5cbnJldHVybiBzcmM7XG5cbn0pKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///166\n")},17:function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzFkZTUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVybCIsIm9wdGlvbnMiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInRlc3QiLCJzbGljZSIsImhhc2giLCJuZWVkUXVvdGVzIiwiY29uY2F0IiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7QUFDdkMsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWjtBQUNBQSxXQUFPLEdBQUcsRUFBVjtBQUNELEdBSnNDLENBSXJDOzs7QUFHRkQsS0FBRyxHQUFHQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0UsVUFBWCxHQUF3QkYsR0FBRyxDQUFDRyxPQUE1QixHQUFzQ0gsR0FBNUM7O0FBRUEsTUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsV0FBT0EsR0FBUDtBQUNELEdBWHNDLENBV3JDOzs7QUFHRixNQUFJLGVBQWVJLElBQWYsQ0FBb0JKLEdBQXBCLENBQUosRUFBOEI7QUFDNUI7QUFDQUEsT0FBRyxHQUFHQSxHQUFHLENBQUNLLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJSixPQUFPLENBQUNLLElBQVosRUFBa0I7QUFDaEI7QUFDQU4sT0FBRyxJQUFJQyxPQUFPLENBQUNLLElBQWY7QUFDRCxHQXRCc0MsQ0FzQnJDO0FBQ0Y7OztBQUdBLE1BQUksY0FBY0YsSUFBZCxDQUFtQkosR0FBbkIsS0FBMkJDLE9BQU8sQ0FBQ00sVUFBdkMsRUFBbUQ7QUFDakQsV0FBTyxLQUFLQyxNQUFMLENBQVlSLEdBQUcsQ0FBQ1MsT0FBSixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUJBLE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLENBQVosRUFBNEQsSUFBNUQsQ0FBUDtBQUNEOztBQUVELFNBQU9ULEdBQVA7QUFDRCxDQS9CRCIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIHVybCA9IHVybCAmJiB1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},174:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(175);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(4).default\nvar update = add(\"52f15586\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzP2U1ZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBOEM7QUFDcEUsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUFnRDtBQUNsRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiIxNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xlYWZsZXQuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNTJmMTU1ODZcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///174\n")},175:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(17);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(176);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(177);\nvar ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(178);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\n// Module\nexports.push([module.i, "/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\"stretching\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg,\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: pan-x pan-y;\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t-ms-touch-action: pinch-zoom;\\r\\n\\t/* Fallback for FF which doesn\'t support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: none;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-tile {\\r\\n\\twill-change: opacity;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\t-webkit-transition: opacity 0.2s linear;\\r\\n\\t   -moz-transition: opacity 0.2s linear;\\r\\n\\t        transition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t    -ms-transform-origin: 0 0;\\r\\n\\t        transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\t-webkit-transition: none;\\r\\n\\t   -moz-transition: none;\\r\\n\\t        transition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:    -moz-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:    -moz-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline: 0;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-active {\\r\\n\\toutline: 2px solid orange;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont: 12px/1.5 \\"Helvetica Neue\\", Arial, Helvetica, sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px \'Lucida Console\', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.7);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-control-attribution,\\r\\n.leaflet-container .leaflet-control-scale {\\r\\n\\tfont-size: 11px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\tfont-size: 11px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 19px;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 18px 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\r\\n\\t-webkit-transform: rotate(45deg);\\r\\n\\t   -moz-transform: rotate(45deg);\\r\\n\\t    -ms-transform: rotate(45deg);\\r\\n\\t        transform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tpadding: 4px 4px 0 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 18px;\\r\\n\\theight: 14px;\\r\\n\\tfont: 16px/14px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #c3c3c3;\\r\\n\\ttext-decoration: none;\\r\\n\\tfont-weight: bold;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover {\\r\\n\\tcolor: #999;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\t-ms-zoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip-container {\\r\\n\\tmargin-top: -1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-clickable {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\"\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzRmODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRixzQ0FBc0MsbUJBQU8sQ0FBQyxFQUF5QztBQUN2RixvQ0FBb0MsbUJBQU8sQ0FBQyxHQUFxQjtBQUNqRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUF3QjtBQUNwRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFTLHNRQUFzUSx5QkFBeUIsY0FBYyxhQUFhLE9BQU8sd0JBQXdCLHVCQUF1QixPQUFPLHVFQUF1RSxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsT0FBTyxxRkFBcUYsOEJBQThCLEtBQUssMkhBQTJILGlEQUFpRCxPQUFPLHlIQUF5SCxvQkFBb0IscUJBQXFCLG9DQUFvQyxPQUFPLHFEQUFxRCxxQkFBcUIsT0FBTyxtZEFBbWQsaUNBQWlDLGtDQUFrQyxPQUFPLCtDQUErQyxvQ0FBb0MsZ0NBQWdDLE9BQU8sMkNBQTJDLG1DQUFtQyxxRkFBcUYsK0JBQStCLEtBQUssOERBQThELDZCQUE2Qix5QkFBeUIsS0FBSyx3QkFBd0IsK0NBQStDLEtBQUssMEJBQTBCLDJEQUEyRCxLQUFLLG1CQUFtQixzQkFBc0IseUJBQXlCLE9BQU8sMEJBQTBCLDBCQUEwQixPQUFPLHVCQUF1QixlQUFlLGdCQUFnQixrQ0FBa0Msa0NBQWtDLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTywrQkFBK0IsY0FBYyxFQUFFLCtCQUErQixjQUFjLEVBQUUsMkJBQTJCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLDJCQUEyQixjQUFjLEVBQUUsNkJBQTZCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsOEJBQThCLGNBQWMsRUFBRSw0QkFBNEIsaUJB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QixnQ0FBZ0MsT0FBTywyQkFBMkIsd0JBQXdCLEtBQUssNEJBQTRCLHVCQUF1QixLQUFLLG9FQUFvRSxlQUFlLHVCQUF1QixPQUFPLGtDQUFrQyxlQUFlLDBCQUEwQiw4QkFBOEIsT0FBTyxtQ0FBbUMsY0FBYyx5QkFBeUIsK0JBQStCLE9BQU87QUFDaHFmO0FBQ0EiLCJmaWxlIjoiMTc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSByZXF1aXJlKFwiLi9pbWFnZXMvbGF5ZXJzLnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyA9IHJlcXVpcmUoXCIuL2ltYWdlcy9sYXllcnMtMngucG5nXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gcmVxdWlyZShcIi4vaW1hZ2VzL21hcmtlci1pY29uLnBuZ1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiByZXF1aXJlZCBzdHlsZXMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wYW5lLFxcclxcbi5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lcixcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBjYW52YXMsXFxyXFxuLmxlYWZsZXQtem9vbS1ib3gsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtbGF5ZXIge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgLXdlYmtpdC11c2VyLWRyYWc6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi8qIFByZXZlbnRzIElFMTEgZnJvbSBoaWdobGlnaHRpbmcgdGlsZXMgaW4gYmx1ZSAqL1xcclxcbi5sZWFmbGV0LXRpbGU6OnNlbGVjdGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi8qIFNhZmFyaSByZW5kZXJzIG5vbi1yZXRpbmEgdGlsZSBvbiByZXRpbmEgYmV0dGVyIHdpdGggdGhpcywgYnV0IENocm9tZSBpcyB3b3JzZSAqL1xcclxcbi5sZWFmbGV0LXNhZmFyaSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRpbWFnZS1yZW5kZXJpbmc6IC13ZWJraXQtb3B0aW1pemUtY29udHJhc3Q7XFxyXFxuXFx0fVxcclxcbi8qIGhhY2sgdGhhdCBwcmV2ZW50cyBodyBsYXllcnMgXFxcInN0cmV0Y2hpbmdcXFwiIHdoZW4gbG9hZGluZyBuZXcgdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiAxNjAwcHg7XFxyXFxuXFx0aGVpZ2h0OiAxNjAwcHg7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4vKiAubGVhZmxldC1jb250YWluZXIgc3ZnOiByZXNldCBzdmcgbWF4LXdpZHRoIGRlY2xlcmF0aW9uIHNoaXBwZWQgaW4gSm9vbWxhISAoam9vbWxhLm9yZykgMy54ICovXFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIGltZzogbWFwIGlzIGJyb2tlbiBpbiBGRiBpZiB5b3UgaGF2ZSBtYXgtd2lkdGg6IDEwMCUgb24gdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtbWFya2VyLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1zaGFkb3ctcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXRpbGUtcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGltZy5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHRtYXgtaGVpZ2h0OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxuXFx0LyogRmFsbGJhY2sgZm9yIEZGIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwaW5jaC16b29tICovXFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGluY2gtem9vbTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoNTEsIDE4MSwgMjI5LCAwLjQpO1xcclxcbn1cXHJcXG4ubGVhZmxldC10aWxlIHtcXHJcXG5cXHRmaWx0ZXI6IGluaGVyaXQ7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLWxvYWRlZCB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaW5oZXJpdDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdHdpZHRoOiAwO1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHR9XFxyXFxuLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg4MzE5ICovXFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyB7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSAgICAgICAgIHsgei1pbmRleDogNDAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdGlsZS1wYW5lICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHsgei1pbmRleDogNDAwOyB9XFxyXFxuLmxlYWZsZXQtc2hhZG93LXBhbmUgIHsgei1pbmRleDogNTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFya2VyLXBhbmUgIHsgei1pbmRleDogNjAwOyB9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1wYW5lICAgeyB6LWluZGV4OiA2NTA7IH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lICAgeyB6LWluZGV4OiA3MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBjYW52YXMgeyB6LWluZGV4OiAxMDA7IH1cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBzdmcgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC12bWwtc2hhcGUge1xcclxcblxcdHdpZHRoOiAxcHg7XFxyXFxuXFx0aGVpZ2h0OiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sdm1sIHtcXHJcXG5cXHRiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY29udHJvbCBwb3NpdGlvbmluZyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCxcXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAxMDAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3Age1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxyXFxuXFx0Y2xlYXI6IGJvdGg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiByaWdodDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi10b3A6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHpvb20gYW5kIGZhZGUgYW5pbWF0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHR3aWxsLWNoYW5nZTogb3BhY2l0eTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAwO1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogICAgLW1vei10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogICAgICAgICB0cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20taGlkZSB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjdXJzb3JzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZ3JhYiB7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNyb3NzaGFpcixcXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogY3Jvc3NoYWlyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGN1cnNvcjogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYixcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUge1xcclxcblxcdGN1cnNvcjogbW92ZTtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiYmluZztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogbWFya2VyICYgb3ZlcmxheXMgaW50ZXJhY3Rpdml0eSAqL1xcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLFxcclxcbi5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24ubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbnN2Zy5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUgcGF0aCB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIHZpc3VhbCB0d2Vha3MgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGJhY2tncm91bmQ6ICNkZGQ7XFxyXFxuXFx0b3V0bGluZTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEge1xcclxcblxcdGNvbG9yOiAjMDA3OEE4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZSB7XFxyXFxuXFx0b3V0bGluZTogMnB4IHNvbGlkIG9yYW5nZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdGJvcmRlcjogMnB4IGRvdHRlZCAjMzhmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC41KTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0eXBvZ3JhcGh5ICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRmb250OiAxMnB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHRvb2xiYXIgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCA1cHggcmdiYSgwLDAsMCwwLjY1KTtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcclxcblxcdHdpZHRoOiAyNnB4O1xcclxcblxcdGhlaWdodDogMjZweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMjZweDtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGNvbG9yOiBibGFjaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCUgNTAlO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLmxlYWZsZXQtZGlzYWJsZWQge1xcclxcblxcdGN1cnNvcjogZGVmYXVsdDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdGNvbG9yOiAjYmJiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYSB7XFxyXFxuXFx0d2lkdGg6IDMwcHg7XFxyXFxuXFx0aGVpZ2h0OiAzMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAzMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB6b29tIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLXpvb20taW4sXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLW91dCB7XFxyXFxuXFx0Zm9udDogYm9sZCAxOHB4ICdMdWNpZGEgQ29uc29sZScsIE1vbmFjbywgbW9ub3NwYWNlO1xcclxcblxcdHRleHQtaW5kZW50OiAxcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1pbiwgLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLW91dCAge1xcclxcblxcdGZvbnQtc2l6ZTogMjJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogbGF5ZXJzIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpO1xcclxcblxcdHdpZHRoOiAzNnB4O1xcclxcblxcdGhlaWdodDogMzZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyArIFwiKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IDI2cHggMjZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHR3aWR0aDogNDRweDtcXHJcXG5cXHRoZWlnaHQ6IDQ0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3QsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRkaXNwbGF5OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIHtcXHJcXG5cXHRwYWRkaW5nOiA2cHggMTBweCA2cHggNnB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhciB7XFxyXFxuXFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcblxcdG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG5cXHRwYWRkaW5nLXJpZ2h0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAycHg7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdHRvcDogMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyBsYWJlbCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlcGFyYXRvciB7XFxyXFxuXFx0aGVpZ2h0OiAwO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdG1hcmdpbjogNXB4IC0xMHB4IDVweCAtNnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEZWZhdWx0IGljb24gVVJMcyAqL1xcclxcbi5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBhdHRyaWJ1dGlvbiBhbmQgc2NhbGUgY29udHJvbHMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxyXFxuXFx0bWFyZ2luOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0cGFkZGluZzogMCA1cHg7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYSB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGE6aG92ZXIge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItdG9wOiBub25lO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuXFx0cGFkZGluZzogMnB4IDVweCAxcHg7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci10b3A6IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsMCwwLDAuMik7XFxyXFxuXFx0YmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogcG9wdXAgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHR0ZXh0LWFsaWduOiBsZWZ0O1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDEycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQge1xcclxcblxcdG1hcmdpbjogMTNweCAxOXB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcCB7XFxyXFxuXFx0bWFyZ2luOiAxOHB4IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiA0MHB4O1xcclxcblxcdGhlaWdodDogMjBweDtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMjBweDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdHdpZHRoOiAxN3B4O1xcclxcblxcdGhlaWdodDogMTdweDtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFxyXFxuXFx0bWFyZ2luOiAtMTBweCBhdXRvIDA7XFxyXFxuXFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJhY2tncm91bmQ6IHdoaXRlO1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJveC1zaGFkb3c6IDAgM3B4IDE0cHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRwYWRkaW5nOiA0cHggNHB4IDAgMDtcXHJcXG5cXHRib3JkZXI6IG5vbmU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHdpZHRoOiAxOHB4O1xcclxcblxcdGhlaWdodDogMTRweDtcXHJcXG5cXHRmb250OiAxNnB4LzE0cHggVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcclxcblxcdGNvbG9yOiAjYzNjM2MzO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRmb250LXdlaWdodDogYm9sZDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXIge1xcclxcblxcdGNvbG9yOiAjOTk5O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCB7XFxyXFxuXFx0b3ZlcmZsb3c6IGF1dG87XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0LW1zLXpvb206IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDI0cHg7XFxyXFxuXFx0bWFyZ2luOiAwIGF1dG87XFxyXFxuXFxyXFxuXFx0LW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KVxcXCI7XFxyXFxuXFx0ZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdG1hcmdpbi10b3A6IC0xcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtem9vbSxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBkaXYgaWNvbiAqL1xcclxcblxcclxcbi5sZWFmbGV0LWRpdi1pY29uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM2NjY7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIFRvb2x0aXAgKi9cXHJcXG4vKiBCYXNlIHN0eWxlcyBmb3IgdGhlIGVsZW1lbnQgdGhhdCBoYXMgYSB0b29sdGlwICovXFxyXFxuLmxlYWZsZXQtdG9vbHRpcCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBhZGRpbmc6IDZweDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogM3B4O1xcclxcblxcdGNvbG9yOiAjMjIyO1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJvcmRlcjogNnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdGNvbnRlbnQ6IFxcXCJcXFwiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEaXJlY3Rpb25zICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b20ge1xcclxcblxcdG1hcmdpbi10b3A6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3Age1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXRvcC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTEycHg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0dG9wOiA1MCU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItbGVmdC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1yaWdodC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///175\n')},176:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers.png?416d91365b44e4b4f4777663e6f009f3");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nP2YwYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsZ0RBQWdEIiwiZmlsZSI6IjE3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMucG5nPzQxNmQ5MTM2NWI0NGU0YjRmNDc3NzY2M2U2ZjAwOWYzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n')},177:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers-2x.png?8f2c4d11474275fbc1614b9098334eae");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nP2UxMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsbURBQW1EIiwiZmlsZSI6IjE3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMtMngucG5nPzhmMmM0ZDExNDc0Mjc1ZmJjMTYxNGI5MDk4MzM0ZWFlXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///177\n')},178:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "marker-icon.png?2b3e1faf89f94a4835397e7a43b4f77d");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmc/NWM4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLG9GQUF1QixxREFBcUQiLCJmaWxlIjoiMTc4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIm1hcmtlci1pY29uLnBuZz8yYjNlMWZhZjg5Zjk0YTQ4MzUzOTdlN2E0M2I0Zjc3ZFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///178\n')},2:function(module,exports,__webpack_require__){eval("/* @preserve\n * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com\n * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n(function (global, factory) {\n   true ? factory(exports) : undefined;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.7.1\";\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n  // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n\n  function extend(dest) {\n    var i, j, len, src;\n\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n\n    return dest;\n  } // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n\n  var create = Object.create || function () {\n    function F() {}\n\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }(); // @function bind(fn: Function, ): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n\n\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  } // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n\n\n  var lastId = 0; // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  function stamp(obj) {\n    /*eslint-disable */\n    obj._leaflet_id = obj._leaflet_id || ++lastId;\n    return obj._leaflet_id;\n    /* eslint-enable */\n  } // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n\n\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n\n    return wrapperFn;\n  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n\n\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n        min = range[0],\n        d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  } // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n\n\n  function falseFn() {\n    return false;\n  } // @function formatNum(num: Number, digits?: Number): Number\n  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.\n\n\n  function formatNum(num, digits) {\n    var pow = Math.pow(10, digits === undefined ? 6 : digits);\n    return Math.round(num * pow) / pow;\n  } // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n\n\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  } // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n\n\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  } // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n\n\n  function setOptions(obj, options) {\n    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n      obj.options = obj.options ? create(obj.options) : {};\n    }\n\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n\n    return obj.options;\n  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  var templateRe = /\\{ *([\\w_-]+) *\\}/g; // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values  they will be evaluated passing `data` as an argument.\n\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return value;\n    });\n  } // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }; // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n\n\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n\n  var lastTime = 0; // fallback for IE 7-8\n\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n        timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n\n\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  } // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n\n\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n\n  var Util = {\n    extend: extend,\n    create: create,\n    bind: bind,\n    lastId: lastId,\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  }; // @class Class\n  // @aka L.Class\n  // @section\n  // @uninheritable\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      } // call all constructor hooks\n\n\n      this.callInitHooks();\n    };\n\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto; // inherit parent's statics\n\n    for (var i in this) {\n      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    } // mix static properties into the class\n\n\n    if (props.statics) {\n      extend(NewClass, props.statics);\n      delete props.statics;\n    } // mix includes into the prototype\n\n\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n      delete props.includes;\n    } // merge options\n\n\n    if (proto.options) {\n      props.options = extend(create(proto.options), props.options);\n    } // mix given properties into the prototype\n\n\n    extend(proto, props);\n    proto._initHooks = []; // add method for calling all hooks\n\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n\n      this._initHooksCalled = true;\n\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n\n    return NewClass;\n  }; // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n\n\n  Class.include = function (props) {\n    extend(this.prototype, props);\n    return this;\n  }; // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n\n\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  }; // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n\n\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n\n    this.prototype._initHooks.push(init);\n\n    return this;\n  };\n\n  function checkDeprecatedMixinEvents(includes) {\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n\n    includes = isArray(includes) ? includes : [includes];\n\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!types) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._off(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context) {\n      this._events = this._events || {};\n      /* get/init listeners for type */\n\n      var typeListeners = this._events[type];\n\n      if (!typeListeners) {\n        typeListeners = [];\n        this._events[type] = typeListeners;\n      }\n\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n\n      var newListener = {\n        fn: fn,\n        ctx: context\n      },\n          listeners = typeListeners; // check if fn already there\n\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return;\n        }\n      }\n\n      listeners.push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n\n      if (!this._events) {\n        return;\n      }\n\n      listeners = this._events[type];\n\n      if (!listeners) {\n        return;\n      }\n\n      if (!fn) {\n        // Set all removed listeners to noop so they are not called if remove happens in fire\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].fn = falseFn;\n        } // clear all listeners for a type if function isn't specified\n\n\n        delete this._events[type];\n        return;\n      }\n\n      if (context === this) {\n        context = undefined;\n      }\n\n      if (listeners) {\n        // find fn and remove it\n        for (i = 0, len = listeners.length; i < len; i++) {\n          var l = listeners[i];\n\n          if (l.ctx !== context) {\n            continue;\n          }\n\n          if (l.fn === fn) {\n            // set the removed listener to noop so that's not called if remove happens in fire\n            l.fn = falseFn;\n\n            if (this._firingCount) {\n              /* copy array in case events are being fired */\n              this._events[type] = listeners = listeners.slice();\n            }\n\n            listeners.splice(i, 1);\n            return;\n          }\n        }\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide an data\n    // object  the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n\n      if (this._events) {\n        var listeners = this._events[type];\n\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            l.fn.call(l.ctx || this, event);\n          }\n\n          this._firingCount--;\n        }\n      }\n\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n\n      return this;\n    },\n    // @method listens(type: String): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    listens: function (type, propagate) {\n      var listeners = this._events && this._events[type];\n\n      if (listeners && listeners.length) {\n        return true;\n      }\n\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, propagate)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    // @method once(): this\n    // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      if (typeof types === 'object') {\n        for (var type in types) {\n          this.once(type, types[type], fn);\n        }\n\n        return this;\n      }\n\n      var handler = bind(function () {\n        this.off(types, fn, context).off(types, handler, context);\n      }, this); // add a listener that's executed once and removed after that\n\n      return this.on(types, fn, context).on(types, handler, context);\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  }; // aliases; we should ditch those eventually\n  // @method addEventListener(): this\n  // Alias to [`on()`](#evented-on)\n\n  Events.addEventListener = Events.on; // @method removeEventListener(): this\n  // Alias to [`off()`](#evented-off)\n  // @method clearAllEventListeners(): this\n  // Alias to [`off()`](#evented-off)\n\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(): this\n  // Alias to [`once()`](#evented-once)\n\n  Events.addOneTimeEventListener = Events.once; // @method fireEvent(): this\n  // Alias to [`fire()`](#evented-fire)\n\n  Events.fireEvent = Events.fire; // @method hasEventListeners(): Boolean\n  // Alias to [`listens()`](#evented-listens)\n\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n    this.y = round ? Math.round(y) : y;\n  }\n\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n          y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  }; // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n\n    if (x === undefined || x === null) {\n      return x;\n    }\n\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n\n    return new Point(x, y, round);\n  }\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n\n    var points = b ? [a, b] : a;\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n    extend: function (point) {\n      // (Point)\n      point = toPoint(point); // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n\n      if (!this.min && !this.max) {\n        this.min = point.clone();\n        this.max = point.clone();\n      } else {\n        this.min.x = Math.min(point.x, this.min.x);\n        this.max.x = Math.max(point.x, this.max.x);\n        this.min.y = Math.min(point.y, this.min.y);\n        this.max.y = Math.max(point.y, this.max.y);\n      }\n\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return new Point(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return new Point(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xIntersects = max2.x >= min.x && min2.x <= max.x,\n          yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xOverlaps = max2.x > min.x && min2.x < max.x,\n          yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    isValid: function () {\n      return !!(this.min && this.max);\n    }\n  }; // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n\n    return new Bounds(a, b);\n  }\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  }; // TODO International date line?\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n\n    return new LatLngBounds(a, b);\n  }\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    } // @property lat: Number\n    // Latitude in degrees\n\n\n    this.lat = +lat; // @property lng: Number\n    // Longitude in degrees\n\n    this.lng = +lng; // @property alt: Number\n    // Altitude in meters (optional)\n\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n\n      return null;\n    }\n\n    if (a === undefined || a === null) {\n      return a;\n    }\n\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n\n    if (b === undefined) {\n      return null;\n    }\n\n    return new LatLng(a, b, c);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n          scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n          untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n\n      var b = this.projection.bounds,\n          s = this.scale(zoom),\n          min = this.transformation.transform(b.min, s),\n          max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n          alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n          newCenter = this.wrapLatLng(center),\n          latShift = center.lat - newCenter.lat,\n          lngShift = center.lng - newCenter.lng;\n\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n\n      var sw = bounds.getSouthWest(),\n          ne = bounds.getNorthEast(),\n          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see http://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection  the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          max = this.MAX_LATITUDE,\n          lat = Math.max(Math.min(max, latlng.lat), -max),\n          sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  }); // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  } // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n\n\n  function pointsToPath(rings, closed) {\n    var str = '',\n        i,\n        j,\n        len,\n        len2,\n        points,\n        p;\n\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      } // closes the ring for polygons; \"x\" is VML syntax\n\n\n      str += closed ? svg ? 'z' : 'x' : '';\n    } // SVG complains about empty path strings\n\n\n    return str || 'M0 0';\n  }\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n\n  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n\n  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n\n  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.\n\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n\n  var webkit = userAgentContains('webkit'); // @property android: Boolean\n  // `true` for any browser running on an Android platform.\n\n  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.\n\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)\n\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser\n\n  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.\n\n  var chrome = !edge && userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.\n\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom'); // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n\n  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform\n\n  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n\n  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n\n  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n\n  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n\n  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n\n  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n\n  var pointer = !!(window.PointerEvent || msPointer); // @property touch: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // This does not necessarily mean that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n\n  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n\n  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n\n  var mobileGecko = mobile && gecko; // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          // eslint-disable-line getter-return\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {// Errors can safely be ignored since this is only a browser support test.\n    }\n\n    return supportsPassiveOption;\n  }(); // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n\n\n  var canvas = function () {\n    return !!document.createElement('canvas').getContext;\n  }(); // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n\n\n  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n\n  var vml = !svg && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n\n  var Browser = {\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas,\n    svg: svg,\n    vml: vml\n  };\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var _pointers = {};\n  var _pointerDocListener = false; // Provides a touch events wrapper for (ms)pointer events.\n  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler, id) {\n    if (type === 'touchstart') {\n      _addPointerStart(obj, handler, id);\n    } else if (type === 'touchmove') {\n      _addPointerMove(obj, handler, id);\n    } else if (type === 'touchend') {\n      _addPointerEnd(obj, handler, id);\n    }\n\n    return this;\n  }\n\n  function removePointerListener(obj, type, id) {\n    var handler = obj['_leaflet_' + type + id];\n\n    if (type === 'touchstart') {\n      obj.removeEventListener(POINTER_DOWN, handler, false);\n    } else if (type === 'touchmove') {\n      obj.removeEventListener(POINTER_MOVE, handler, false);\n    } else if (type === 'touchend') {\n      obj.removeEventListener(POINTER_UP, handler, false);\n      obj.removeEventListener(POINTER_CANCEL, handler, false);\n    }\n\n    return this;\n  }\n\n  function _addPointerStart(obj, handler, id) {\n    var onDown = bind(function (e) {\n      // IE10 specific: MsTouch needs preventDefault. See #2000\n      if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n        preventDefault(e);\n      }\n\n      _handlePointer(e, handler);\n    });\n    obj['_leaflet_touchstart' + id] = onDown;\n    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation\n\n    if (!_pointerDocListener) {\n      // we listen document as any drags that end by moving the touch off the screen get fired there\n      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n  }\n\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n  }\n\n  function _handlePointer(e, handler) {\n    e.touches = [];\n\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n\n    e.changedTouches = [e];\n    handler(e);\n  }\n\n  function _addPointerMove(obj, handler, id) {\n    var onMove = function (e) {\n      // don't fire touch moves when mouse isn't down\n      if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse') && e.buttons === 0) {\n        return;\n      }\n\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchmove' + id] = onMove;\n    obj.addEventListener(POINTER_MOVE, onMove, false);\n  }\n\n  function _addPointerEnd(obj, handler, id) {\n    var onUp = function (e) {\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchend' + id] = onUp;\n    obj.addEventListener(POINTER_UP, onUp, false);\n    obj.addEventListener(POINTER_CANCEL, onUp, false);\n  }\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   */\n\n\n  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';\n\n  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';\n\n  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs\n\n  function addDoubleTapListener(obj, handler, id) {\n    var last,\n        touch$$1,\n        doubleTap = false,\n        delay = 250;\n\n    function onTouchStart(e) {\n      if (pointer) {\n        if (!e.isPrimary) {\n          return;\n        }\n\n        if (e.pointerType === 'mouse') {\n          return;\n        } // mouse fires native dblclick\n\n      } else if (e.touches.length > 1) {\n        return;\n      }\n\n      var now = Date.now(),\n          delta = now - (last || now);\n      touch$$1 = e.touches ? e.touches[0] : e;\n      doubleTap = delta > 0 && delta <= delay;\n      last = now;\n    }\n\n    function onTouchEnd(e) {\n      if (doubleTap && !touch$$1.cancelBubble) {\n        if (pointer) {\n          if (e.pointerType === 'mouse') {\n            return;\n          } // work around .type being readonly with MSPointer* events\n\n\n          var newTouch = {},\n              prop,\n              i;\n\n          for (i in touch$$1) {\n            prop = touch$$1[i];\n            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;\n          }\n\n          touch$$1 = newTouch;\n        }\n\n        touch$$1.type = 'dblclick';\n        touch$$1.button = 0;\n        handler(touch$$1);\n        last = null;\n      }\n    }\n\n    obj[_pre + _touchstart + id] = onTouchStart;\n    obj[_pre + _touchend + id] = onTouchEnd;\n    obj[_pre + 'dblclick' + id] = handler;\n    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {\n      passive: false\n    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),\n    // the browser doesn't fire touchend/pointerup events but does fire\n    // native dblclicks. See #4127.\n    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.\n\n    obj.addEventListener('dblclick', handler, false);\n    return this;\n  }\n\n  function removeDoubleTapListener(obj, id) {\n    var touchstart = obj[_pre + _touchstart + id],\n        touchend = obj[_pre + _touchend + id],\n        dblclick = obj[_pre + 'dblclick' + id];\n    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.removeEventListener(_touchend, touchend, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.removeEventListener('dblclick', dblclick, false);\n    return this;\n  }\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n\n\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  } // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n\n\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n\n    return value === 'auto' ? null : value;\n  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n\n\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n\n    if (container) {\n      container.appendChild(el);\n    }\n\n    return el;\n  } // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n\n\n  function remove(el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n      parent.removeChild(el);\n    }\n  } // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n\n\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  } // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n\n\n  function toFront(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  } // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n\n\n  function toBack(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  } // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n\n\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  } // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n\n\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  } // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n\n\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  } // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n\n\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  } // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n\n\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  } // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n\n\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n\n  function _setOpacityIE(el, value) {\n    var filter = false,\n        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist\n\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n\n    value = Math.round(value * 100);\n\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  } // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n\n\n  function testProp(props) {\n    var style = document.documentElement.style;\n\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n\n    return false;\n  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n\n\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  } // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n\n\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  } // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n\n\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n    return el._leaflet_pos || new Point(0, 0);\n  } // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n\n\n  var disableTextSelection;\n  var enableTextSelection;\n\n  var _userSelect;\n\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  } // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n\n\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  } // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n\n\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n\n  var _outlineElement, _outlineStyle; // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n\n\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n\n    if (!element.style) {\n      return;\n    }\n\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outline;\n    element.style.outline = 'none';\n    on(window, 'keydown', restoreOutline);\n  } // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n\n\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n\n    _outlineElement.style.outline = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  } // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n\n\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n\n    return element;\n  } // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n\n\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n\n  var DomUtil = {\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    disableTextSelection: disableTextSelection,\n    enableTextSelection: enableTextSelection,\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function on(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n\n    return this;\n  }\n\n  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function off(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else if (types) {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        removeOne(obj, types[i], fn, context);\n      }\n    } else {\n      for (var j in obj[eventsKey]) {\n        removeOne(obj, j, obj[eventsKey][j]);\n      }\n\n      delete obj[eventsKey];\n    }\n\n    return this;\n  }\n\n  function browserFiresNativeDblClick() {\n    // See https://github.com/w3c/pointerevents/issues/171\n    if (pointer) {\n      return !(edge || safari);\n    }\n  }\n\n  var mouseSubst = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout',\n    wheel: !('onwheel' in window) && 'mousewheel'\n  };\n\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n\n    var originalHandler = handler;\n\n    if (pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      addPointerListener(obj, type, handler, id);\n    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {\n      addDoubleTapListener(obj, handler, id);\n    } else if ('addEventListener' in obj) {\n      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {\n        obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n\n        obj.addEventListener(mouseSubst[type], handler, false);\n      } else {\n        obj.addEventListener(type, originalHandler, false);\n      }\n    } else if ('attachEvent' in obj) {\n      obj.attachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n\n  function removeOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),\n        handler = obj[eventsKey] && obj[eventsKey][id];\n\n    if (!handler) {\n      return this;\n    }\n\n    if (pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, id);\n    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {\n      removeDoubleTapListener(obj, id);\n    } else if ('removeEventListener' in obj) {\n      obj.removeEventListener(mouseSubst[type] || type, handler, false);\n    } else if ('detachEvent' in obj) {\n      obj.detachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey][id] = null;\n  } // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n\n    skipped(e);\n    return this;\n  } // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n\n\n  function disableScrollPropagation(el) {\n    addOne(el, 'wheel', stopPropagation);\n    return this;\n  } // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n\n\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick', stopPropagation);\n    addOne(el, 'click', fakeStop);\n    return this;\n  } // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n\n\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n\n    return this;\n  } // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n\n\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n\n\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n\n    var scale = getScale(container),\n        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point( // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),\n  // and Firefox scrolls device pixels, not CSS pixels\n\n\n  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n\n  function getWheelDelta(e) {\n    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages\n    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\n    0;\n  }\n\n  var skipEvents = {};\n\n  function fakeStop(e) {\n    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)\n    skipEvents[e.type] = true;\n  }\n\n  function skipped(e) {\n    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map\n\n    skipEvents[e.type] = false;\n    return events;\n  } // check if element really left/entered the event target (for mouseenter/mouseleave)\n\n\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n\n    if (!related) {\n      return true;\n    }\n\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n\n    return related !== el;\n  }\n\n  var DomEvent = {\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    fakeStop: fakeStop,\n    skipped: skipped,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var fx = new L.PosAnimation();\n   * fx.run(el, [300, 500], 0.5);\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date(); // @event start: Event\n      // Fired when the animation starts\n\n      this.fire('start');\n\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n\n      this._step(true);\n\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n          duration = this._duration * 1000;\n\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n\n      if (round) {\n        pos._round();\n      }\n\n      setPosition(this._el, pos); // @event step: Event\n      // Fired continuously during the animation.\n\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false; // @event end: Event\n      // Fired when the animation ends.\n\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API  it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n\n      this._initContainer(id);\n\n      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980\n\n\n      this._onResize = bind(this._onResize, this);\n\n      this._initEvents();\n\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n\n      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\n      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n\n      this._stop();\n\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        } // try animating pan or zoom\n\n\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      } // animation didn't start, just reset the map view\n\n\n      this._resetView(center, zoom);\n\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n          viewHalf = this.getSize().divideBy(2),\n          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n          swPoint = this.project(bounds.getSouthWest(), zoom),\n          nePoint = this.project(bounds.getNorthEast(), zoom),\n          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      } // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\n        return this;\n      }\n\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      } // don't fire movestart if animating inertia\n\n\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      } // animate pan unless animate: false specified\n\n\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n\n        var newPos = this._getMapPanePos().subtract(offset).round();\n\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n\n        this.fire('move').fire('moveend');\n      }\n\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n\n      if (options.animate === false || !any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n\n      this._stop();\n\n      var from = this.project(this.getCenter()),\n          to = this.project(targetCenter),\n          size = this.getSize(),\n          startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n          w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n          u1 = to.distanceTo(from) || 1,\n          rho = 1.42,\n          rho2 = rho * rho;\n\n      function r(i) {\n        var s1 = i ? -1 : 1,\n            s2 = i ? w1 : w0,\n            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n            b1 = 2 * s2 * rho2 * u1,\n            b = t1 / b1,\n            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n\n      var r0 = r(0);\n\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n\n      var start = Date.now(),\n          S = (r(1) - r0) / rho,\n          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n      function frame() {\n        var t = (Date.now() - start) / duration,\n            s = easeOut(t) * S;\n\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n\n      this._moveStart(true, options.noMoveStart);\n\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: LatLngBounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this.off('moveend', this._panInsideMaxBounds);\n      } else if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n\n      this.options.maxBounds = bounds;\n\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n\n      var center = this.getCenter(),\n          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit\n    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          center = this.getCenter(),\n          pixelCenter = this.project(center),\n          pixelPoint = this.project(latlng),\n          pixelBounds = this.getPixelBounds(),\n          halfPixelBounds = pixelBounds.getSize().divideBy(2),\n          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);\n\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var diff = pixelCenter.subtract(pixelPoint),\n            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);\n\n        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {\n          newCenter.x = pixelCenter.x - diff.x;\n\n          if (diff.x > 0) {\n            newCenter.x += halfPixelBounds.x - paddingTL.x;\n          } else {\n            newCenter.x -= halfPixelBounds.x - paddingBR.x;\n          }\n        }\n\n        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {\n          newCenter.y = pixelCenter.y - diff.y;\n\n          if (diff.y > 0) {\n            newCenter.y += halfPixelBounds.y - paddingTL.y;\n          } else {\n            newCenter.y -= halfPixelBounds.y - paddingBR.y;\n          }\n        }\n\n        this.panTo(this.unproject(newCenter), options);\n        this._enforcingBounds = false;\n      }\n\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so \n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so \n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n          oldCenter = oldSize.divideBy(2).round(),\n          newCenter = newSize.divideBy(2).round(),\n          offset = oldCenter.subtract(newCenter);\n\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n\n        this.fire('move');\n\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      } // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n\n\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n\n      }, options);\n\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n\n        return this;\n      }\n\n      var onResponse = bind(this._handleGeolocationResponse, this),\n          onError = bind(this._handleGeolocationError, this);\n\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      var c = error.code,\n          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      } // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n\n\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      var lat = pos.coords.latitude,\n          lng = pos.coords.longitude,\n          latlng = new LatLng(lat, lng),\n          bounds = latlng.toBounds(pos.coords.accuracy * 2),\n          options = this._locateOptions;\n\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      } // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n\n\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n\n      var handler = this[name] = new HandlerClass(this);\n\n      this._handlers.push(handler);\n\n      if (this.options[name]) {\n        handler.enable();\n      }\n\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n\n      this.off('moveend', this._panInsideMaxBounds);\n\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n\n        this._containerId = undefined;\n      }\n\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n\n      this._stop();\n\n      remove(this._mapPane);\n\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n\n      this._clearHandlers();\n\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n\n      var i;\n\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n          pane = create$1('div', className, container || this._mapPane);\n\n      if (name) {\n        this._panes[name] = pane;\n      }\n\n      return pane;\n    },\n    // @section Methods for Getting Map State\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter;\n      }\n\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n          sw = this.unproject(bounds.getBottomLeft()),\n          ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n          min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          nw = bounds.getNorthWest(),\n          se = bounds.getSouthEast(),\n          size = this.getSize().subtract(padding),\n          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n          snap = any3d ? this.options.zoomSnap : 1,\n          scalex = size.x / boundsSize.x,\n          scaley = size.y / boundsSize.y,\n          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && any3d;\n      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n        container.style.position = 'relative';\n      }\n\n      this._initPanes();\n\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {}; // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n\n      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n\n      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n\n      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n\n      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n\n      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n\n      this.createPane('popupPane');\n\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n    // @section Map state change events\n    _resetView: function (center, zoom) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n\n      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n\n\n      this.fire('viewreset'); // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n\n      return this;\n    },\n    _move: function (center, zoom, data) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event\n      // Fired repeatedly during any change in zoom level, including zoom\n      // and fly animations.\n\n      if (zoomChanged || data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      } // @event move: Event\n      // Fired repeatedly during any movement of the map, including pan and\n      // fly animations.\n\n\n      return this.fire('move', data);\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map has changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      } // @event moveend: Event\n      // Fired when the center of the map stops changing (e.g. user stopped\n      // dragging the map).\n\n\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n    // @section Interaction events\n    _initEvents: function (remove$$1) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove$$1 ? off : on; // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n\n      if (any3d && this.options.transform3DLimit) {\n        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n          target,\n          isHover = type === 'mouseout' || type === 'mouseover',\n          src = e.target || e.srcElement,\n          dragging = false;\n\n      while (src) {\n        target = this._targets[stamp(src)];\n\n        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n\n          targets.push(target);\n\n          if (isHover) {\n            break;\n          }\n        }\n\n        if (src === this._container) {\n          break;\n        }\n\n        src = src.parentNode;\n      }\n\n      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {\n        targets = [this];\n      }\n\n      return targets;\n    },\n    _handleDOMEvent: function (e) {\n      if (!this._loaded || skipped(e)) {\n        return;\n      }\n\n      var type = e.type;\n\n      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(e.target || e.srcElement);\n      }\n\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, targets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n\n        this._fireDOMEvent(synth, synth.type, targets);\n      }\n\n      if (e._stopped) {\n        return;\n      } // Find the layer the event is propagating from and its parents.\n\n\n      targets = (targets || []).concat(this._findEventTargets(e, type));\n\n      if (!targets.length) {\n        return;\n      }\n\n      var target = targets[0];\n\n      if (type === 'contextmenu' && target.listens(type, true)) {\n        preventDefault(e);\n      }\n\n      var data = {\n        originalEvent: e\n      };\n\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n\n      for (var i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n\n      return this;\n    },\n    // private methods for getting map state\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n\n      var centerPoint = this.project(center, zoom),\n          viewHalf = this.getSize().divideBy(2),\n          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n\n\n      if (offset.round().equals([0, 0])) {\n        return center;\n      }\n\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n\n      var viewBounds = this.getPixelBounds(),\n          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n          dx = this._rebound(minOffset.x, -maxOffset.x),\n          dy = this._rebound(minOffset.y, -maxOffset.y);\n\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          snap = any3d ? this.options.zoomSnap : 1;\n\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options\n\n\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n\n      this._panes.mapPane.appendChild(proxy);\n\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n            transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired\n\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n          z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n\n      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large\n\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      } // offset is the pixel coords of the zoom origin relative to the current center\n\n\n      var scale = this.getZoomScale(zoom),\n          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      requestAnimFrame(function () {\n        this._moveStart(true, false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n\n      if (startAnim) {\n        this._animatingZoom = true; // remember what center/zoom to set after animation\n\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      } // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n\n\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      this._animatingZoom = false;\n\n      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\n\n      requestAnimFrame(function () {\n        this._moveEnd(true);\n      }, this);\n    }\n  }); // @section\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n\n      if (map) {\n        map.removeControl(this);\n      }\n\n      this.options.position = position;\n\n      if (map) {\n        map.addControl(this);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n          pos = this.getPosition(),\n          corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n\n      this._map.on('unload', this.remove, this);\n\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n\n      remove(this._container);\n\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n\n      this._map.off('unload', this.remove, this);\n\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n\n  var control = function (options) {\n    return new Control(options);\n  };\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n\n\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n          l = 'leaflet-',\n          container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n\n      this._update();\n\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n\n      var obj = this._getLayer(stamp(layer));\n\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n\n      this._checkDisabledLayers();\n\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n          container = this._container = create$1('div', className),\n          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n\n        if (!android) {\n          on(container, {\n            mouseenter: this.expand,\n            mouseleave: this.collapse\n          }, this);\n        }\n      }\n\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n\n      if (touch) {\n        on(link, 'click', stop);\n        on(link, 'click', this.expand, this);\n      } else {\n        on(link, 'focus', this.expand, this);\n      }\n\n      if (!collapsed) {\n        this.expand();\n      }\n\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n          overlaysPresent,\n          i,\n          obj,\n          baseLayersCount = 0;\n\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n\n        this._addItem(obj);\n\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      } // Hide base layers section if there's only one layer.\n\n\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n\n      var obj = this._getLayer(stamp(e.target)); // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layers control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layers control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layers control](#control-layers).\n      // @namespace Control.Layers\n\n\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n          checked = this._map.hasLayer(obj.layer),\n          input;\n\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n\n      this._layerControlInputs.push(input);\n\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n\n      var holder = document.createElement('div');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n\n      this._checkDisabledLayers();\n\n      return label;\n    },\n    _onInputClick: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer;\n      var addedLayers = [],\n          removedLayers = [];\n      this._handlingClick = true;\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      } // Bugfix issue 2318: Should remove all old layers before readding new ones\n\n\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n\n      this._handlingClick = false;\n\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer,\n          zoom = this._map.getZoom();\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n\n      return this;\n    },\n    _expand: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.expand();\n    },\n    _collapse: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.collapse();\n    }\n  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '+'\n      // The text set on the 'zoom in' button.\n      zoomInText: '+',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '&#x2212;'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '&#x2212;',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n          container = create$1('div', zoomName + ' leaflet-bar'),\n          options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n\n      this._updateDisabled();\n\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n          className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n      }\n\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n      }\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  }); // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n          container = create$1('div', className),\n          options = this.options;\n\n      this._addScales(options, className + '-line', container);\n\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n          y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n          maxMiles,\n          miles,\n          feet;\n\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n          d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  }); // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container); // TODO ugly, refactor\n\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n\n      this._update();\n\n      return this._container;\n    },\n    // @method setPrefix(prefix: String): this\n    // Sets the text before the attributions.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n\n      this._update();\n\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n\n      this._attributions[text]++;\n\n      this._update();\n\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n\n        this._update();\n      }\n\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var attribs = [];\n\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n\n      var prefixAndAttribs = [];\n\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n\n      this._container.innerHTML = prefixAndAttribs.join(' | ');\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  }); // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    } // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n\n  }); // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n\n  var Mixin = {\n    Events: Events\n  };\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = touch ? 'touchstart mousedown' : 'mousedown';\n  var END = {\n    mousedown: 'mouseup',\n    touchstart: 'touchend',\n    pointerdown: 'touchend',\n    MSPointerDown: 'touchend'\n  };\n  var MOVE = {\n    mousedown: 'mousemove',\n    touchstart: 'touchmove',\n    pointerdown: 'touchmove',\n    MSPointerDown: 'touchmove'\n  };\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline$$1, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline$$1;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      } // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n\n\n      if (Draggable._dragging === this) {\n        this.finishDrag();\n      }\n\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this._moved = false;\n\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n\n      disableImageDrag();\n      disableTextSelection();\n\n      if (this._moving) {\n        return;\n      } // @event down: Event\n      // Fired when a drag is about to start.\n\n\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n          sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n\n      this._parentScale = getScale(sizedParent);\n      on(document, MOVE[e.type], this._onMove, this);\n      on(document, END[e.type], this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n\n      if (!offset.x && !offset.y) {\n        return;\n      }\n\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n\n\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        this._startPos = getPosition(this._element).subtract(offset);\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n\n        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      cancelAnimFrame(this._animRequest);\n      this._lastEvent = e;\n      this._animRequest = requestAnimFrame(this._updatePosition, this, true);\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      }; // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos); // @event drag: Event\n      // Fired continuously during dragging.\n\n      this.fire('drag', e);\n    },\n    _onUp: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this.finishDrag();\n    },\n    finishDrag: function () {\n      removeClass(document.body, 'leaflet-dragging');\n\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n\n      for (var i in MOVE) {\n        off(document, MOVE[i], this._onMove, this);\n        off(document, END[i], this._onUp, this);\n      }\n\n      enableImageDrag();\n      enableTextSelection();\n\n      if (this._moved && this._moving) {\n        // ensure drag is not fired after dragend\n        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n\n        this.fire('dragend', {\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n\n      this._moving = false;\n      Draggable._dragging = false;\n    }\n  });\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).\n\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n\n    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction\n\n    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification\n\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n\n\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n\n\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\n\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n        markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n    var i,\n        newPoints = [];\n\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n\n    return newPoints;\n  }\n\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n        index,\n        i,\n        sqDist;\n\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  } // reduce points that are too close to each other to a single point\n\n\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n\n    return reducedPoints;\n  }\n\n  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n\n\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n        codeB = _getBitCode(b, bounds),\n        codeOut,\n        p,\n        newCode; // save 2nd code to avoid calculating it on the next segment\n\n\n    _lastCode = codeB;\n\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      } // if a,b is outside the clip window (trivial reject)\n\n\n      if (codeA & codeB) {\n        return false;\n      } // other cases\n\n\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n        dy = b.y - a.y,\n        min = bounds.min,\n        max = bounds.max,\n        x,\n        y;\n\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n\n    return new Point(x, y, round);\n  }\n\n  function _getBitCode(p, bounds) {\n    var code = 0;\n\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n\n    return code;\n  } // square distance (to avoid unnecessary Math.sqrt calls)\n\n\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n        dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  } // return closest point on segment or distance to that point\n\n\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  } // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n\n\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  var LineUtil = {\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat\n  };\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n        edges = [1, 4, 2, 8],\n        i,\n        j,\n        k,\n        a,\n        b,\n        len,\n        edge,\n        p;\n\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    } // for each edge (left, bottom, right, top)\n\n\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j]; // if a is inside the clip window\n\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n\n          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n\n      points = clippedPoints;\n    }\n\n    return points;\n  }\n\n  var PolyUtil = {\n    clipPolygon: clipPolygon\n  };\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection  the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          r = this.R,\n          y = latlng.lat * d,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n          r = this.R,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          ts = Math.exp(-point.y / r),\n          phi = Math.PI / 2 - 2 * Math.atan(ts);\n\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n  /*\n   * @class Projection\n    * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).\n    * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n    * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n    * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n    * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n    */\n\n  var index = {\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n          dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \" OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    //\n    // @alternative\n    // @method removeFrom(group: LayerGroup): this\n    // Removes the layer from the given `LayerGroup`\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target; // check in case layer gets added and then removed before the map is ready\n\n      if (!map.hasLayer(this)) {\n        return;\n      }\n\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n\n      this.onAdd(map);\n\n      if (this.getAttribution && map.attributionControl) {\n        map.attributionControl.addAttribution(this.getAttribution());\n      }\n\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n\n      var id = stamp(layer);\n\n      if (this._layers[id]) {\n        return this;\n      }\n\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n\n      if (!this._layers[id]) {\n        return this;\n      }\n\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n\n      if (layer.getAttribution && this.attributionControl) {\n        this.attributionControl.removeAttribution(layer.getAttribution());\n      }\n\n      delete this._layers[id];\n\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return !!layer && stamp(layer) in this._layers;\n    },\n\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n          maxZoom = -Infinity,\n          oldZoomSpan = this._getZoomSpan();\n\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      if (!layer) {\n        return false;\n      }\n\n      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\n      return layerId in this._layers;\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, ): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          i,\n          layer;\n\n      for (i in this._layers) {\n        layer = this._layers[i];\n\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n\n      return bounds;\n    }\n  }); // @factory L.featureGroup(layers?: Layer[], options?: Object)\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\n\n  var featureGroup = function (layers, options) {\n    return new FeatureGroup(layers, options);\n  };\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0]\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n\n        return null;\n      }\n\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n\n      this._setIconStyles(img, name);\n\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n\n      var size = toPoint(sizeOption),\n          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  }); // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n\n  function icon(options) {\n    return new Icon(options);\n  }\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (!IconDefault.imagePath) {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      } // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n\n\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n\n      if (path === null || path.indexOf('url') !== 0) {\n        path = '';\n      } else {\n        path = path.replace(/^url\\([\"']?/, '').replace(/marker-icon\\.png[\"']?\\)$/, '');\n      }\n\n      return path;\n    }\n  });\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n          map = marker._map,\n          speed = this._marker.options.autoPanSpeed,\n          padding = this._marker.options.autoPanPadding,\n          iconPos = getPosition(marker._icon),\n          bounds = map.getPixelBounds(),\n          origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n\n        this._draggable._newPos._add(movement);\n\n        this._draggable._startPos._add(movement);\n\n        setPosition(marker._icon, this._draggable._newPos);\n\n        this._onDrag(e);\n\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n      this._oldLatLng = this._marker.getLatLng(); // When using ES6 imports it could not be set when `Popup` was not imported as well\n\n      this._marker.closePopup && this._marker.closePopup();\n\n      this._marker.fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n          shadow = marker._shadow,\n          iconPos = getPosition(marker._icon),\n          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position\n\n\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng; // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n      cancelAnimFrame(this._panRequest); // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n\n      delete this._oldLatLng;\n\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      title: '',\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the icon image (useful for accessibility).\n      alt: '',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option shadowPane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n\n      this._initIcon();\n\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n\n      delete this.dragging;\n\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n\n      this._removeIcon();\n\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n\n      if (this._map) {\n        this._initIcon();\n\n        this.update();\n      }\n\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n\n        this._setPos(pos);\n      }\n\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n          addIcon = false; // if we're not reusing the icon, remove the old one and init new one\n\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n\n        addIcon = true;\n\n        if (options.title) {\n          icon.title = options.title;\n        }\n\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n\n      addClass(icon, classToAdd);\n\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n      }\n\n      this._icon = icon;\n\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      var newShadow = options.icon.createShadow(this._shadow),\n          addShadow = false;\n\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n\n        addShadow = true;\n      }\n\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n\n      this._shadow = newShadow;\n\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n\n      this._initInteraction();\n\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n\n      this._zIndex = pos.y + this.options.zIndexOffset;\n\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n\n        this.dragging = new MarkerDrag(this);\n\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._map) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  }); // factory L.marker(latlng: LatLng, options? : Marker options)\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n\n      this._reset();\n\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n\n        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n          this._updateBounds();\n        }\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;\n    }\n  });\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n          r2 = this._radiusY || r,\n          w = this._clickTolerance(),\n          p = [r + w, r2 + w];\n\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      } // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n\n\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n          lat = this._latlng.lat,\n          map = this._map,\n          crs = map.options.crs;\n\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n            latR = this._mRadius / Earth.R / d,\n            top = map.project([lat + latR, lng]),\n            bottom = map.project([lat - latR, lng]),\n            p = top.add(bottom).divideBy(2),\n            lat2 = map.unproject(p).lat,\n            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n\n      this._updateBounds();\n    }\n  }); // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n          minPoint = null,\n          closest = _sqClosestPointOnSegment,\n          p1,\n          p2;\n\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          halfDist,\n          segDist,\n          dist,\n          p1,\n          p2,\n          ratio,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polyline centroid algorithm; only uses the first ring if there are multiple\n\n\n      for (i = 0, halfDist = 0; i < len - 1; i++) {\n        halfDist += points[i].distanceTo(points[i + 1]) / 2;\n      } // The line is so small in the current view that all points are on the same pixel.\n\n\n      if (halfDist === 0) {\n        return this._map.layerPointToLatLng(points[0]);\n      }\n\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);\n        }\n      }\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n\n      this._bounds.extend(latlng);\n\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n          flat = isFlat(latlngs);\n\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n          p = new Point(w, w);\n\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n          len = latlngs.length,\n          i,\n          ring;\n\n      if (flat) {\n        ring = [];\n\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      var parts = this._parts,\n          i,\n          j,\n          k,\n          len,\n          len2,\n          segment,\n          points;\n\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n          if (!segment) {\n            continue;\n          }\n\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part\n\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n          tolerance = this.options.smoothFactor;\n\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._clipPoints();\n\n      this._simplifyPoints();\n\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n          j,\n          k,\n          len,\n          len2,\n          part,\n          w = this._clickTolerance();\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // hit detection for polylines\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n\n\n  Polyline._flat = _flat;\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          j,\n          p1,\n          p2,\n          f,\n          area,\n          x,\n          y,\n          center,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polygon centroid algorithm; only uses the first ring if there are multiple\n\n\n      area = x = y = 0;\n\n      for (i = 0, j = len - 1; i < len; j = i++) {\n        p1 = points[i];\n        p2 = points[j];\n        f = p1.y * p2.x - p2.y * p1.x;\n        x += (p1.x + p2.x) * f;\n        y += (p1.y + p2.y) * f;\n        area += f * 3;\n      }\n\n      if (area === 0) {\n        // Polygon is so small that all points are on same pixel.\n        center = points[0];\n      } else {\n        center = [x / area, y / area];\n      }\n\n      return this._map.layerPointToLatLng(center);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n          len = result.length; // remove last point if it equals first one\n\n\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n      var bounds = this._renderer._bounds,\n          w = this.options.weight,\n          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges\n\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n          part,\n          p1,\n          p2,\n          i,\n          j,\n          k,\n          len,\n          len2;\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // ray casting algorithm for detecting if point is in polygon\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      } // also check if it's on polygon stroke\n\n\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n          i,\n          len,\n          feature;\n\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n\n        return this;\n      }\n\n      var options = this.options;\n\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n\n      var layer = geometryToLayer(geojson, options);\n\n      if (!layer) {\n        return this;\n      }\n\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      } // reset any custom styles\n\n\n      layer.options = extend({}, layer.defaultOptions);\n\n      this._setLayerStyle(layer, this.options.style);\n\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n\n        layer.setStyle(style);\n      }\n    }\n  }); // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n        coords = geometry ? geometry.coordinates : null,\n        layers = [],\n        pointToLayer = options && options.pointToLayer,\n        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n        latlng,\n        latlngs,\n        i,\n        len;\n\n    if (!coords && !geometry) {\n      return null;\n    }\n\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n\n        return new FeatureGroup(layers);\n\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var layer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n\n          if (layer) {\n            layers.push(layer);\n          }\n        }\n\n        return new FeatureGroup(layers);\n\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  } // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n\n\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n\n\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n\n    return latlngs;\n  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n\n\n  function latLngToCoords(latlng, precision) {\n    precision = typeof precision === 'number' ? precision : 6;\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n\n\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n\n    if (!levelsDeep && closed) {\n      coords.push(coords[0]);\n    }\n\n    return coords;\n  }\n\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  } // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n\n\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  }; // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n\n  Marker.include(PointToGeoJSON); // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON); // @namespace Polyline\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  }); // @namespace Polygon\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n          multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n\n      if (!holes) {\n        coords = [coords];\n      }\n\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  }); // @namespace LayerGroup\n\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number): Object\n    // `precision` is the number of decimal places for coordinates.\n    // The default value is 6 places.\n    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n\n      var isGeometryCollection = type === 'GeometryCollection',\n          jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json); // Squash nested feature collections\n\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  }); // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  } // Backward compatibility.\n\n\n  var geoJson = geoJSON;\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n\n      this.getPane().appendChild(this._image);\n\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._image) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n\n      if (this._image) {\n        this._image.src = url;\n      }\n\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n\n      if (this._map) {\n        this._reset();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn; // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n          size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    }\n  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n      keepAspectRatio: true,\n      // @option muted: Boolean = false\n      // Whether the video starts on mute when loaded.\n      muted: false\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn; // @event load: Event\n      // Fired when the video has finished loading the first frame\n\n      vid.onloadeddata = bind(this.fire, this, 'load');\n\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n\n      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n      vid.muted = !!this.options.muted;\n\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    } // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n\n  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    } // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n\n  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.\r\n   */\n  // @namespace DivOverlay\n\n\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position. Useful to control the anchor\n      // of the popup when opening it on some overlays.\n      offset: [0, 7],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: '',\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane'\n    },\n    initialize: function (options, source) {\n      setOptions(this, options);\n      this._source = source;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (!this._container) {\n        this._initLayout();\n      }\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n\n      this.bringToFront();\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n    },\n    // @namespace Popup\n    // @method getLatLng: LatLng\n    // Returns the geographical point of popup.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the popup will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n\n      if (this._map) {\n        this._updatePosition();\n\n        this._adjustPan();\n      }\n\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the popup.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Returns the HTML container of the popup.\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._container.style.visibility = 'hidden';\n\n      this._updateContent();\n\n      this._updateLayout();\n\n      this._updatePosition();\n\n      this._container.style.visibility = '';\n\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the popup is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this popup in front of other popups (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this popup to the back of other popups (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n\n      return this;\n    },\n    _prepareOpen: function (parent, layer, latlng) {\n      if (!(layer instanceof Layer)) {\n        latlng = layer;\n        layer = parent;\n      }\n\n      if (layer instanceof FeatureGroup) {\n        for (var id in parent._layers) {\n          layer = parent._layers[id];\n          break;\n        }\n      }\n\n      if (!latlng) {\n        if (layer.getCenter) {\n          latlng = layer.getCenter();\n        } else if (layer.getLatLng) {\n          latlng = layer.getLatLng();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      } // set overlay source to this layer\n\n\n      this._source = layer; // update the overlay (content, layout, ect...)\n\n      this.update();\n      return latlng;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n\n        node.appendChild(content);\n      }\n\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n\n      var bottom = this._containerBottom = -offset.y,\n          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)\n\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   * Here's a more complicated way to open a popup on a map:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n  // @namespace Popup\n\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.\n    openOn: function (map) {\n      map.openPopup(this);\n      return this;\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n\n      map.fire('popupopen', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true); // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n\n\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n\n      map.fire('popupclose', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this._close;\n      }\n\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closePopup(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(container);\n      disableScrollPropagation(this._contentNode);\n      on(container, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.href = '#close';\n        closeButton.innerHTML = '&#215;';\n        on(closeButton, 'click', this._onCloseButtonClick, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n          style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n          maxHeight = this.options.maxHeight,\n          scrolledClass = 'leaflet-popup-scrolled';\n\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n          anchor = this._getAnchor();\n\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      var map = this._map,\n          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n          containerHeight = this._container.offsetHeight + marginBottom,\n          containerWidth = this._containerWidth,\n          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n      layerPos._add(getPosition(this._container));\n\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n          padding = toPoint(this.options.autoPanPadding),\n          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n          size = map.getSize(),\n          dx = 0,\n          dy = 0;\n\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      } // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n\n\n      if (dx || dy) {\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _onCloseButtonClick: function (e) {\n      this._close();\n\n      stop(e);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  }); // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n\n\n  Map.mergeOptions({\n    closePopupOnClick: true\n  }); // @namespace Map\n  // @section Methods for Layers and Controls\n\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      if (!(popup instanceof Popup)) {\n        popup = new Popup(options).setContent(popup);\n      }\n\n      if (latlng) {\n        popup.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(popup)) {\n        return this;\n      }\n\n      if (this._popup && this._popup.options.autoClose) {\n        this.closePopup();\n      }\n\n      this._popup = popup;\n      return this.addLayer(popup);\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      if (!popup || popup === this._popup) {\n        popup = this._popup;\n        this._popup = null;\n      }\n\n      if (popup) {\n        this.removeLayer(popup);\n      }\n\n      return this;\n    }\n  });\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n  // @section Popup methods\n\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      if (content instanceof Popup) {\n        setOptions(content, options);\n        this._popup = content;\n        content._source = this;\n      } else {\n        if (!this._popup || options) {\n          this._popup = new Popup(options, this);\n        }\n\n        this._popup.setContent(content);\n      }\n\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (layer, latlng) {\n      if (this._popup && this._map) {\n        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map\n\n        this._map.openPopup(this._popup, latlng);\n      }\n\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup._close();\n      }\n\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function (target) {\n      if (this._popup) {\n        if (this._popup._map) {\n          this.closePopup();\n        } else {\n          this.openPopup(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._popup) {\n        return;\n      }\n\n      if (!this._map) {\n        return;\n      } // prevent map click\n\n\n      stop(e); // if this inherits from Path its a vector and we can just\n      // open the popup at the new location\n\n      if (layer instanceof Path) {\n        this.openPopup(e.layer || e.target, e.latlng);\n        return;\n      } // otherwise treat it like a marker and figure out\n      // if we should toggle it open/closed\n\n\n      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n        this.closePopup();\n      } else {\n        this.openPopup(layer, e.latlng);\n      }\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n  // @namespace Tooltip\n\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option interactive: Boolean = false\n      // If true, the tooltip will listen to the feature events.\n      interactive: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (touch && !this.options.permanent) {\n        events.preclick = this._close;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closeTooltip(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var subX,\n          subY,\n          map = this._map,\n          container = this._container,\n          centerPoint = map.latLngToContainerPoint(map.getCenter()),\n          tooltipPoint = map.layerPointToContainerPoint(pos),\n          direction = this.options.direction,\n          tooltipWidth = container.offsetWidth,\n          tooltipHeight = container.offsetHeight,\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (direction === 'top') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight;\n      } else if (direction === 'bottom') {\n        subX = tooltipWidth / 2;\n        subY = 0;\n      } else if (direction === 'center') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'right') {\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'left') {\n        subX = tooltipWidth;\n        subY = tooltipHeight / 2;\n      } else if (tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else {\n        direction = 'left';\n        subX = tooltipWidth + (offset.x + anchor.x) * 2;\n        subY = tooltipHeight / 2;\n      }\n\n      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  }); // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  }; // @namespace Map\n  // @section Methods for Layers and Controls\n\n\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      if (!(tooltip instanceof Tooltip)) {\n        tooltip = new Tooltip(options).setContent(tooltip);\n      }\n\n      if (latlng) {\n        tooltip.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(tooltip)) {\n        return this;\n      }\n\n      return this.addLayer(tooltip);\n    },\n    // @method closeTooltip(tooltip?: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      if (tooltip) {\n        this.removeLayer(tooltip);\n      }\n\n      return this;\n    }\n  });\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n  // @section Tooltip methods\n\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (content instanceof Tooltip) {\n        setOptions(content, options);\n        this._tooltip = content;\n        content._source = this;\n      } else {\n        if (!this._tooltip || options) {\n          this._tooltip = new Tooltip(options, this);\n        }\n\n        this._tooltip.setContent(content);\n      }\n\n      this._initTooltipInteractions();\n\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n\n      return this;\n    },\n    _initTooltipInteractions: function (remove$$1) {\n      if (!remove$$1 && this._tooltipHandlersAdded) {\n        return;\n      }\n\n      var onOff = remove$$1 ? 'off' : 'on',\n          events = {\n        remove: this.closeTooltip,\n        move: this._moveTooltip\n      };\n\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n\n        if (this._tooltip.options.sticky) {\n          events.mousemove = this._moveTooltip;\n        }\n\n        if (touch) {\n          events.click = this._openTooltip;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove$$1;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (layer, latlng) {\n      if (this._tooltip && this._map) {\n        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map\n\n        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never\n        // opened.\n\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          addClass(this._tooltip._container, 'leaflet-clickable');\n          this.addInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip._close();\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          removeClass(this._tooltip._container, 'leaflet-clickable');\n          this.removeInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function (target) {\n      if (this._tooltip) {\n        if (this._tooltip._map) {\n          this.closeTooltip();\n        } else {\n          this.openTooltip(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _openTooltip: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n          containerPoint,\n          layerPoint;\n\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n          options = this.options;\n\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n\n      this._setIconStyles(div, 'icon');\n\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  }); // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n\n      this._levels = {};\n      this._tiles = {};\n\n      this._resetView();\n\n      this._update();\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n\n      remove(this._container);\n\n      map._removeZoomLimit(this);\n\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n\n        this._setAutoZIndex(Math.max);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n\n        this._setAutoZIndex(Math.min);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      this._updateOpacity();\n\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n\n        this._update();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n\n        events.move = this._onMove;\n      }\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n      var layers = this.getPane().children,\n          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\n\n      if (ielt9) {\n        return;\n      }\n\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n          nextFrame = false,\n          willPrune = false;\n\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n\n          tile.active = true;\n        }\n      }\n\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n\n      this._updateZIndex();\n\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom;\n\n      if (zoom === undefined) {\n        return undefined;\n      }\n\n      for (var z in this._levels) {\n        z = Number(z);\n\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n\n          this._removeTilesAtZoom(z);\n\n          this._onRemoveLevel(z);\n\n          delete this._levels[z];\n        }\n      }\n\n      var level = this._levels[zoom],\n          map = this._map;\n\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n\n        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition\n\n\n        falseFn(level.el.offsetWidth);\n\n        this._onCreateLevel(level);\n      }\n\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var key, tile;\n\n      var zoom = this._map.getZoom();\n\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n\n        return;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n\n        this._onRemoveLevel(Number(z));\n\n        delete this._levels[z];\n      }\n\n      this._removeAllTiles();\n\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n          y2 = Math.floor(y / 2),\n          z2 = z - 1,\n          coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n\n      var key = this._tileCoordsToKey(coords2),\n          tile = this._tiles[key];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n\n          var key = this._tileCoordsToKey(coords),\n              tile = this._tiles[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = Math.round(zoom);\n\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      } else {\n        tileZoom = this._clampZoom(tileZoom);\n      }\n\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n\n        this._updateLevels();\n\n        this._resetGrid();\n\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n\n        if (!noPrune) {\n          this._pruneTiles();\n        } // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n\n\n        this._noPrune = !!noPrune;\n      }\n\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n      if (any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n          crs = map.options.crs,\n          tileSize = this._tileSize = this.getTileSize(),\n          tileZoom = this._tileZoom;\n\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n          scale = map.getZoomScale(mapZoom, this._tileZoom),\n          pixelCenter = map.project(center, this._tileZoom).floor(),\n          halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n\n      if (!map) {\n        return;\n      }\n\n      var zoom = this._clampZoom(map.getZoom());\n\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n          tileRange = this._pxBoundsToTileRange(pixelBounds),\n          tileCenter = tileRange.getCenter(),\n          queue = [],\n          margin = this.options.keepBuffer,\n          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.\n\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      } // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n\n\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n\n        return;\n      } // create a queue of coordinates to load tiles from\n\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      } // sort tile queue to load tiles in order of their distance to center\n\n\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true; // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n\n          this.fire('loading');\n        } // create DOM fragment to append tiles in one batch\n\n\n        var fragment = document.createDocumentFragment();\n\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n\n      if (!this.options.bounds) {\n        return true;\n      } // don't load tile if it doesn't intersect the bounds in options\n\n\n      var tileBounds = this._tileCoordsToBounds(coords);\n\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n          tileSize = this.getTileSize(),\n          nwPoint = coords.scaleBy(tileSize),\n          sePoint = nwPoint.add(tileSize),\n          nw = map.unproject(nwPoint, coords.z),\n          se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n          bounds = new LatLngBounds(bp[0], bp[1]);\n\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n          coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      remove(tile.el);\n      delete this._tiles[key]; // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems\n\n      if (ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      } // without this hack, tiles disappear after zoom on Chrome for Android\n      // https://github.com/Leaflet/Leaflet/issues/2078\n\n\n      if (android && !android23) {\n        tile.style.WebkitBackfaceVisibility = 'hidden';\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n          key = this._tileCoordsToKey(coords);\n\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n      this._initTile(tile); // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n\n\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n\n      setPosition(tile, tilePos); // save tile in cache\n\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile); // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n\n      var key = this._tileCoordsToKey(coords);\n\n      tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      tile.loaded = +new Date();\n\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n\n        this._pruneTiles();\n      }\n\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent\n        // Fired when a tile loads.\n\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n\n      if (this._noTilesToLoad()) {\n        this._loading = false; // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n\n        this.fire('load');\n\n        if (ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }); // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>'}).addTo(map);\r\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels\n\n      if (options.detectRetina && retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom--;\n        } else {\n          options.zoomOffset--;\n          options.minZoom++;\n        }\n\n        options.minZoom = Math.max(0, options.minZoom);\n      }\n\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      } // for https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!android) {\n        this.on('tileunload', this._onTileRemove);\n      }\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n\n      this._url = url;\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      /*\r\n       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n       http://www.w3.org/TR/WCAG20-TECHS/H67\r\n      */\n\n\n      tile.alt = '';\n      /*\r\n       Set role=\"presentation\" to force screen readers to ignore this\r\n       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n      */\n\n      tile.setAttribute('role', 'presentation');\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n\n        data['-y'] = invertedY;\n      }\n\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom,\n          zoomReverse = this.options.zoomReverse,\n          zoomOffset = this.options.zoomOffset;\n\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            remove(tile);\n            delete this._tiles[i];\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      } // Cancels any pending http requests associated with the tile\n      // unless we're on Android's stock browser,\n      // see https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!androidStock) {\n        tile.el.setAttribute('src', emptyImageUrl);\n      }\n\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data  2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params\n\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n          crs = this._crs,\n          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n          min = bounds.min,\n          max = bounds.max,\n          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n          url = TileLayer.prototype.getTileUrl.call(this, coords);\n\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    }\n  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1,\n      // @option tolerance: Number = 0\n      // How much to extend click tolerance round a path/object on the map\n      tolerance: 0\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n\n        if (this._zoomAnimated) {\n          addClass(this._container, 'leaflet-zoom-animated');\n        }\n      }\n\n      this.getPane().appendChild(this._container);\n\n      this._update();\n\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n          position = getPosition(this._container),\n          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n          currentCenterPoint = this._map.project(this._center, zoom),\n          destCenterPoint = this._map.project(center, zoom),\n          centerOffset = destCenterPoint.subtract(currentCenterPoint),\n          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n      if (any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n\n      this._updateTransform(this._center, this._zoom);\n\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n          size = this._map.getSize(),\n          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n\n      var layer;\n      this._redrawBounds = null;\n\n      for (var id in this._layers) {\n        layer = this._layers[id];\n\n        layer._update();\n      }\n\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          container = this._container,\n          size = b.getSize(),\n          m = retina ? 2 : 1;\n      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina\n\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n\n      if (retina) {\n        this._ctx.scale(2, 2);\n      } // translate so we use the same path coordinates after canvas element moves\n\n\n      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves\n\n\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n\n      layer._project();\n\n      layer._update(); // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n\n\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n            dashArray = [],\n            dashValue,\n            i;\n\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths\n\n          if (isNaN(dashValue)) {\n            return;\n          }\n\n          dashArray.push(dashValue);\n        }\n\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n\n      this._extendRedrawBounds(layer);\n\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n\n        this._redrawBounds.max._ceil();\n      }\n\n      this._clear(); // clear layers in redraw bounds\n\n\n      this._draw(); // draw layers\n\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.save();\n\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n\n        this._ctx.restore();\n      }\n    },\n    _draw: function () {\n      var layer,\n          bounds = this._redrawBounds;\n\n      this._ctx.save();\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.beginPath();\n\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n\n        this._ctx.clip();\n      }\n\n      this._drawing = true;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n\n      this._drawing = false;\n\n      this._ctx.restore(); // Restore state before clipping.\n\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n\n      var i,\n          j,\n          len2,\n          p,\n          parts = layer._parts,\n          len = parts.length,\n          ctx = this._ctx;\n\n      if (!len) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n\n      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n\n      var p = layer._point,\n          ctx = this._ctx,\n          r = Math.max(Math.round(layer._radius), 1),\n          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n      if (s !== 1) {\n        ctx.restore();\n      }\n\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n          layer,\n          clickedLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          if (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {\n            clickedLayer = layer;\n          }\n        }\n      }\n\n      if (clickedLayer) {\n        fakeStop(e);\n\n        this._fireEvent([clickedLayer], e);\n      }\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n\n      var point = this._map.mouseEventToLayerPoint(e);\n\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n\n        this._fireEvent([layer], e, 'mouseout');\n\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n\n      var layer, candidateHoveredLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n\n      if (this._hoveredLayer) {\n        this._fireEvent([this._hoveredLayer], e);\n      }\n\n      this._mouseHoverThrottled = true;\n      setTimeout(bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n\n      this._requestRedraw(layer);\n    }\n  }); // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n\n  function canvas$1(options) {\n    return canvas ? new Canvas(options) : null;\n  }\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      return function (name) {\n        return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n      };\n    }\n  }();\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n\n\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n\n      this._container.appendChild(container);\n\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n          fill = layer._fill,\n          options = layer.options,\n          container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n          r = Math.round(layer._radius),\n          r2 = Math.round(layer._radiusY || r);\n\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create$2 = vml ? vmlCreate : svgCreate;\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.zoomstart = this._onZoomStart;\n      return events;\n    },\n    _initContainer: function () {\n      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths\n\n      this._container.setAttribute('pointer-events', 'none');\n\n      this._rootGroup = create$2('g');\n\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _onZoomStart: function () {\n      // Drag-then-pinch interactions might mess up the center and zoom.\n      // In this case, the easiest way to prevent this is re-do the renderer\n      //   bounds and padding when the zooming starts.\n      this._update();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          size = b.getSize(),\n          container = this._container; // set size of svg-container if changed\n\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      } // movement: update container viewBox so that we don't have to change coordinates of individual layers\n\n\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n    _initPath: function (layer) {\n      var path = layer._path = create$2('path'); // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n\n      this._rootGroup.appendChild(layer._path);\n\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n          options = layer.options;\n\n      if (!path) {\n        return;\n      }\n\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n          r = Math.max(Math.round(layer._radius), 1),\n          r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs\n\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n\n  if (vml) {\n    SVG.include(vmlMixin);\n  } // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n\n\n  function svg$1(options) {\n    return svg || vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n\n      var renderer = this._paneRenderers[name];\n\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas$1(options) || svg$1(options);\n    }\n  });\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create$2;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      } // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n\n\n      this._clearDeferredResetState();\n\n      this._resetState();\n\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n\n        this._map.fire('boxzoomstart');\n      }\n\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n          size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n\n      this._finish();\n\n      if (!this._moved) {\n        return;\n      } // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n\n\n      this._clearDeferredResetState();\n\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n      }\n    }\n  }); // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n          oldZoom = map.getZoom(),\n          delta = map.options.zoomDelta,\n          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  }); // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map be draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default unless running on old Android devices.\n    inertia: !android23,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second.\n    inertiaDeceleration: 3400,\n    // px/s^2\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n\n      this._draggable.enable();\n\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n\n      map._stop();\n\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n\n      map.fire('movestart').fire('dragstart');\n\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n        this._positions.push(pos);\n\n        this._times.push(time);\n\n        this._prunePositions(time);\n      }\n\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n      var limit = this._offsetLimit;\n\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n          halfWidth = Math.round(worldWidth / 2),\n          dx = this._initialWorldOffset,\n          x = this._draggable._newPos.x,\n          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n          options = map.options,\n          noInertia = !options.inertia || this._times.length < 2;\n      map.fire('dragend', e);\n\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n\n        var direction = this._lastPos.subtract(this._positions[0]),\n            duration = (this._lastTime - this._times[0]) / 1000,\n            ease = options.easeLinearity,\n            speedVector = direction.multiplyBy(ease / duration),\n            speed = speedVector.distanceTo([0, 0]),\n            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  }); // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n\n  Map.addInitHook('addHandler', 'dragging', Drag);\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Keyboard Navigation Options\n\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n\n      this._setPanDelta(map.options.keyboardPanDelta);\n\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container; // make the container focusable by tabbing\n\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n\n      var body = document.body,\n          docEl = document.documentElement,\n          top = body.scrollTop || docEl.scrollTop,\n          left = body.scrollLeft || docEl.scrollLeft;\n\n      this._map._container.focus();\n\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      var key = e.keyCode,\n          map = this._map,\n          offset;\n\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n\n          map.panBy(offset);\n\n          if (map.options.maxBounds) {\n            map.panInsideBounds(map.options.maxBounds);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n\n      stop(e);\n    }\n  }); // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Mouse wheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'wheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'wheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n          zoom = map.getZoom(),\n          snap = this._map.options.zoomSnap || 0;\n\n      map._stop(); // stop panning and fly animations if any\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n\n\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n\n      if (!delta) {\n        return;\n      }\n\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  }); // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n  /*\n   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tap: Boolean = true\n    // Enables mobile hacks for supporting instant taps (fixing 200ms click\n    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).\n    tap: true,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var Tap = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      if (!e.touches) {\n        return;\n      }\n\n      preventDefault(e);\n      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch\n\n      if (e.touches.length > 1) {\n        this._fireClick = false;\n        clearTimeout(this._holdTimeout);\n        return;\n      }\n\n      var first = e.touches[0],\n          el = first.target;\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it\n\n      if (el.tagName && el.tagName.toLowerCase() === 'a') {\n        addClass(el, 'leaflet-active');\n      } // simulate long hold but setting a timeout\n\n\n      this._holdTimeout = setTimeout(bind(function () {\n        if (this._isTapValid()) {\n          this._fireClick = false;\n\n          this._onUp();\n\n          this._simulateEvent('contextmenu', first);\n        }\n      }, this), 1000);\n\n      this._simulateEvent('mousedown', first);\n\n      on(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n    },\n    _onUp: function (e) {\n      clearTimeout(this._holdTimeout);\n      off(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n\n      if (this._fireClick && e && e.changedTouches) {\n        var first = e.changedTouches[0],\n            el = first.target;\n\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n          removeClass(el, 'leaflet-active');\n        }\n\n        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much\n\n\n        if (this._isTapValid()) {\n          this._simulateEvent('click', first);\n        }\n      }\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n\n      this._simulateEvent('mousemove', first);\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = document.createEvent('MouseEvents');\n      simulatedEvent._simulated = true;\n      e.target._simulatedClick = true;\n      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  }); // @section Handlers\n  // @property tap: Handler\n  // Mobile touch hacks (quick tap and touch hold) handler.\n\n  if (touch && (!pointer || safari)) {\n    Map.addInitHook('addHandler', 'tap', Tap);\n  }\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers except for old Androids.\n    touchZoom: touch && !android23,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n\n      map._stop();\n\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n\n      var map = this._map,\n          p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]),\n          scale = p1.distanceTo(p2) / this._startDist;\n\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n\n      if (!this._moved) {\n        map._moveStart(true, false);\n\n        this._moved = true;\n      }\n\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      });\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove, this);\n      off(document, 'touchend', this._onTouchEnd, this); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  }); // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.Tap = Tap;\n  Map.TouchZoom = TouchZoom;\n  exports.version = version;\n  exports.Control = Control;\n  exports.control = control;\n  exports.Browser = Browser;\n  exports.Evented = Evented;\n  exports.Mixin = Mixin;\n  exports.Util = Util;\n  exports.Class = Class;\n  exports.Handler = Handler;\n  exports.extend = extend;\n  exports.bind = bind;\n  exports.stamp = stamp;\n  exports.setOptions = setOptions;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.PosAnimation = PosAnimation;\n  exports.Draggable = Draggable;\n  exports.LineUtil = LineUtil;\n  exports.PolyUtil = PolyUtil;\n  exports.Point = Point;\n  exports.point = toPoint;\n  exports.Bounds = Bounds;\n  exports.bounds = toBounds;\n  exports.Transformation = Transformation;\n  exports.transformation = toTransformation;\n  exports.Projection = index;\n  exports.LatLng = LatLng;\n  exports.latLng = toLatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.latLngBounds = toLatLngBounds;\n  exports.CRS = CRS;\n  exports.GeoJSON = GeoJSON;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.layerGroup = layerGroup;\n  exports.FeatureGroup = FeatureGroup;\n  exports.featureGroup = featureGroup;\n  exports.ImageOverlay = ImageOverlay;\n  exports.imageOverlay = imageOverlay;\n  exports.VideoOverlay = VideoOverlay;\n  exports.videoOverlay = videoOverlay;\n  exports.SVGOverlay = SVGOverlay;\n  exports.svgOverlay = svgOverlay;\n  exports.DivOverlay = DivOverlay;\n  exports.Popup = Popup;\n  exports.popup = popup;\n  exports.Tooltip = Tooltip;\n  exports.tooltip = tooltip;\n  exports.Icon = Icon;\n  exports.icon = icon;\n  exports.DivIcon = DivIcon;\n  exports.divIcon = divIcon;\n  exports.Marker = Marker;\n  exports.marker = marker;\n  exports.TileLayer = TileLayer;\n  exports.tileLayer = tileLayer;\n  exports.GridLayer = GridLayer;\n  exports.gridLayer = gridLayer;\n  exports.SVG = SVG;\n  exports.svg = svg$1;\n  exports.Renderer = Renderer;\n  exports.Canvas = Canvas;\n  exports.canvas = canvas$1;\n  exports.Path = Path;\n  exports.CircleMarker = CircleMarker;\n  exports.circleMarker = circleMarker;\n  exports.Circle = Circle;\n  exports.circle = circle;\n  exports.Polyline = Polyline;\n  exports.polyline = polyline;\n  exports.Polygon = Polygon;\n  exports.polygon = polygon;\n  exports.Rectangle = Rectangle;\n  exports.rectangle = rectangle;\n  exports.Map = Map;\n  exports.map = createMap;\n  var oldL = window.L;\n\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  }; // Always export us to window global (see #2364)\n\n\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvVXRpbC5qcz8yZTY0Iiwid2VicGFjazovLy8uLi9zcmMvY29yZS9DbGFzcy5qcz8wMWFjIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9FdmVudHMuanM/MTM2ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzPzE1NDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanM/MWM3OSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmdCb3VuZHMuanM/YjU3YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmcuanM/NWI2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLmpzP2IyY2QiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcz8xMDE5Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcz8xZTVlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanM/YzI1MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzP2YyMmUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanM/OTBjMSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvQnJvd3Nlci5qcz83ZGUzIiwid2VicGFjazovLy8uLi9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanM/ODY0NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanM/ZTc2ZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21VdGlsLmpzPzdjOTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kb20vRG9tRXZlbnQuanM/MWVhYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanM/YjZiMSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9NYXAuanM/NzNlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5qcz81MjkxIiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcz82NGQ0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanM/MTU1MCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcz84YzY0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzPzJjZDciLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb250cm9sL2luZGV4LmpzPzBjYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL0hhbmRsZXIuanM/NGU1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW5kZXguanM/ZTBlMCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9EcmFnZ2FibGUuanM/Y2NlYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L0xpbmVVdGlsLmpzPzE4N2EiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcz9kNTdlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanM/OWQ4NSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanM/YjJiYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzP2ZkYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcz8wYzNiIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanM/ZDk4MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcz85YmU4Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9pbmRleC5qcz82NmQ5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvTGF5ZXIuanM/NjcwMyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanM/N2Y2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcz8yNDRhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanM/MDU4OCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanM/MjdlNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcz8yZmI1Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcz8zZGQyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanM/MjQ4ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanM/OWQxYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcz85YzM3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanM/MjcyNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0dlb0pTT04uanM/YWFlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcz8wMTg5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzPzAzZTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9TVkdPdmVybGF5LmpzPzNjZjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzPzAwMjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9Qb3B1cC5qcz84ZTExIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVG9vbHRpcC5qcz8wZGIyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanM/ZTBkZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9pbmRleC5qcz84ZjM4Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanM/Mzg4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzPzI2MjAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanM/ZjllNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvaW5kZXguanM/NDI4YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcz8xMGVlIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcz9iOWViIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanM/YzkzNCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanM/Zjg0YiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcz81ZmE3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcz8wZDdhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzPzFlMTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9pbmRleC5qcz8xMjIyIiwid2VicGFjazovLy8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanM/ZTljYyIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanM/MDJkNSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzP2JjZDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanM/M2YzYiIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanM/MWYxNCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanM/OTFiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9pbmRleC5qcz8yMDUyIl0sIm5hbWVzIjpbIlV0aWwuY3JlYXRlIiwiVXRpbC5leHRlbmQiLCJVdGlsLmlzQXJyYXkiLCJVdGlsLnNwbGl0V29yZHMiLCJVdGlsLmZhbHNlRm4iLCJVdGlsLmJpbmQiLCJVdGlsLnN0YW1wIiwiVXRpbC5mb3JtYXROdW0iLCJVdGlsLndyYXBOdW0iLCJCcm93c2VyLnN2ZyIsInN0eWxlIiwiQnJvd3Nlci5tc1BvaW50ZXIiLCJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsIkJyb3dzZXIucG9pbnRlciIsInRvdWNoIiwiQnJvd3Nlci5wYXNzaXZlRXZlbnRzIiwiY3JlYXRlIiwiVXRpbC50cmltIiwiQnJvd3Nlci5pZTNkIiwiQnJvd3Nlci5hbnkzZCIsIkRvbUV2ZW50Lm9uIiwiRG9tRXZlbnQub2ZmIiwiQnJvd3Nlci5lZGdlIiwiQnJvd3Nlci5zYWZhcmkiLCJCcm93c2VyLnRvdWNoIiwiQnJvd3Nlci53aW4iLCJCcm93c2VyLmNocm9tZSIsIkJyb3dzZXIuZ2Vja28iLCJEb21VdGlsLmdldFBvc2l0aW9uIiwiVXRpbC5yZXF1ZXN0QW5pbUZyYW1lIiwiRG9tVXRpbC5zZXRQb3NpdGlvbiIsIlV0aWwuY2FuY2VsQW5pbUZyYW1lIiwiVXRpbC5zZXRPcHRpb25zIiwiRG9tVXRpbC5UUkFOU0lUSU9OIiwiQnJvd3Nlci5tb2JpbGVPcGVyYSIsIkRvbVV0aWwuVFJBTlNJVElPTl9FTkQiLCJEb21VdGlsLmFkZENsYXNzIiwiRG9tVXRpbC5yZW1vdmUiLCJEb21VdGlsLmNyZWF0ZSIsIkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24iLCJEb21VdGlsLmdldCIsIkJyb3dzZXIucmV0aW5hIiwiQnJvd3Nlci5pZWx0OSIsIkRvbVV0aWwuZ2V0U3R5bGUiLCJyZW1vdmUiLCJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwiRG9tRXZlbnQuc2tpcHBlZCIsIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCJVdGlsLmluZGV4T2YiLCJEb21VdGlsLnJlbW92ZUNsYXNzIiwiRG9tVXRpbC5UUkFOU0ZPUk0iLCJEb21VdGlsLnNldFRyYW5zZm9ybSIsIkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwiRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiQnJvd3Nlci5hbmRyb2lkIiwiRG9tRXZlbnQuc3RvcCIsIkRvbVV0aWwuZW1wdHkiLCJwcmV2ZW50T3V0bGluZSIsIkRvbVV0aWwuaGFzQ2xhc3MiLCJEb21VdGlsLmRpc2FibGVJbWFnZURyYWciLCJEb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uIiwiRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUiLCJEb21VdGlsLmdldFNjYWxlIiwiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCJEb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24iLCJMaW5lVXRpbC5fZ2V0Qml0Q29kZSIsIkxpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9pbnQiLCJsYXRMbmciLCJEb21VdGlsLnNldE9wYWNpdHkiLCJMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJMaW5lVXRpbC5pc0ZsYXQiLCJMaW5lVXRpbC5jbGlwU2VnbWVudCIsIkxpbmVVdGlsLnNpbXBsaWZ5IiwiTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIkxpbmVVdGlsLl9mbGF0IiwiUG9seVV0aWwuY2xpcFBvbHlnb24iLCJEb21VdGlsLnRvRnJvbnQiLCJEb21VdGlsLnRvQmFjayIsIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsIkJyb3dzZXIubW9iaWxlIiwiVXRpbC50aHJvdHRsZSIsImxhdExuZ0JvdW5kcyIsIkJyb3dzZXIuYW5kcm9pZDIzIiwiVXRpbC50ZW1wbGF0ZSIsIlV0aWwuZW1wdHlJbWFnZVVybCIsIkJyb3dzZXIuYW5kcm9pZFN0b2NrIiwiRG9tRXZlbnQuZmFrZVN0b3AiLCJjYW52YXMiLCJCcm93c2VyLmNhbnZhcyIsIkJyb3dzZXIudm1sIiwic3ZnIiwiRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNPLFdBQVMsTUFBVCxDQUFnQixJQUFoQixFQUFzQjtBQUM1QixRQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixFQUFlLEdBQWY7O0FBRUEsU0FBSyxDQUFDLEdBQUcsQ0FBSixFQUFPLEdBQUcsR0FBRyxTQUFTLENBQUMsTUFBNUIsRUFBb0MsQ0FBQyxHQUFHLEdBQXhDLEVBQTZDLENBQUMsRUFBOUMsRUFBa0Q7QUFDakQsU0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFELENBQWY7O0FBQ0EsV0FBSyxDQUFMLElBQVUsR0FBVixFQUFlO0FBQ2QsWUFBSSxDQUFDLENBQUQsQ0FBSixHQUFVLEdBQUcsQ0FBQyxDQUFELENBQWI7QUFDQTtBQUNEOztBQUNELFdBQU8sSUFBUDtBQUNBLEcsQ0FFRDtBQUNBOzs7QUFDTyxNQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBUCxJQUFrQixZQUFZO0FBQ2pELGFBQVMsQ0FBVCxHQUFhLENBQUU7O0FBQ2YsV0FBTyxVQUFVLEtBQVYsRUFBaUI7QUFDdkIsT0FBQyxDQUFDLFNBQUYsR0FBYyxLQUFkO0FBQ0EsYUFBTyxJQUFJLENBQUosRUFBUDtBQUNBLEtBSEQ7QUFJQSxHQU5vQyxFQUE5QixDLENBUVA7QUFDQTtBQUNBOzs7QUFDTyxXQUFTLElBQVQsQ0FBYyxFQUFkLEVBQWtCLEdBQWxCLEVBQXVCO0FBQzdCLFFBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxTQUFOLENBQWdCLEtBQTVCOztBQUVBLFFBQUksRUFBRSxDQUFDLElBQVAsRUFBYTtBQUNaLGFBQU8sRUFB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O0FBRUEsS0FBRyxDQUFDLFFBQUosR0FBZSxRQUFmO0FBRUEsS0FBRyxDQUFDLGVBQUosR0FBc0IsZUFBdEI7QUFFQSxLQUFHLENBQUMsR0FBSixHQUFVLEdBQVY7QUFFQSxLQUFHLENBQUMsU0FBSixHQUFnQixTQUFoQiIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrbGFzdElkO1xyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA2IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBkaWdpdHMpIHtcclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIChkaWdpdHMgPT09IHVuZGVmaW5lZCA/IDYgOiBkaWdpdHMpKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdvcHRpb25zJykpIHtcclxuXHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBjcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0fVxyXG5cdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4vLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbi8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbi8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdHZhciBwYXJhbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxufVxyXG5cclxudmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd18tXSspICpcXH0vZztcclxuXHJcbi8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcbi8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4vLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4vLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZShzdHIsIGRhdGEpIHtcclxuXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxuZXhwb3J0IHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4vLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbi8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuZXhwb3J0IHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5leHBvcnQgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXHJcblx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcblx0dmFyIHByb3RvID0gVXRpbC5jcmVhdGUocGFyZW50UHJvdG8pO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdFV0aWwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKFV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBVdGlsLmlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuIiwiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdC8vIEBwcm9wZXJ0eSB4OiBOdW1iZXI7IFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufVxyXG5cclxudmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG5cdHJldHVybiB2ID4gMCA/IE1hdGguZmxvb3IodikgOiBNYXRoLmNlaWwodik7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRydW5jKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuXHR0cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IHRydW5jKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKGlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeC54LCB4LnkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG5cdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG5cdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcclxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDUlMgPSB7XHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIGdpdmVuIHpvb20uXHJcblx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24uX3RyYW5zZm9ybShwcm9qZWN0ZWRQb2ludCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBsYXRMbmdUb1BvaW50YC4gUHJvamVjdHMgcGl4ZWwgY29vcmRpbmF0ZXMgb24gYSBnaXZlblxyXG5cdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdCh1bnRyYW5zZm9ybWVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gY29vcmRpbmF0ZXMgaW4gdW5pdHMgYWNjZXB0ZWQgZm9yXHJcblx0Ly8gdGhpcyBDUlMgKGUuZy4gbWV0ZXJzIGZvciBFUFNHOjM4NTcsIGZvciBwYXNzaW5nIGl0IHRvIFdNUyBzZXJ2aWNlcykuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwcm9qZWN0ZWQgY29vcmRpbmF0ZSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIExhdExuZy5cclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIHVzZWQgd2hlbiB0cmFuc2Zvcm1pbmcgcHJvamVjdGVkIGNvb3JkaW5hdGVzIGludG9cclxuXHQvLyBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBwYXJ0aWN1bGFyIHpvb20uIEZvciBleGFtcGxlLCBpdCByZXR1cm5zXHJcblx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb20oc2NhbGU6IE51bWJlcik6IE51bWJlclxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlKClgLCByZXR1cm5zIHRoZSB6b29tIGxldmVsIGNvcnJlc3BvbmRpbmcgdG8gYSBzY2FsZVxyXG5cdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UHJvamVjdGVkQm91bmRzKHpvb206IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3Rpb24ncyBib3VuZHMgc2NhbGVkIGFuZCB0cmFuc2Zvcm1lZCBmb3IgdGhlIHByb3ZpZGVkIGB6b29tYC5cclxuXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRpZiAodGhpcy5pbmZpbml0ZSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuXHRcdHZhciBiID0gdGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxcclxuXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICBtaW4gPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1pbiwgcyksXHJcblx0XHQgICAgbWF4ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5tYXgsIHMpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuXHQvLyBAcHJvcGVydHkgY29kZTogU3RyaW5nXHJcblx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExuZzogTnVtYmVyW11cclxuXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgKGhvcml6b250YWwpIGNvb3JkaW5hdGVcclxuXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG5cdC8vIGdlb2dyYXBoaWNhbCBDUlNzLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGxvbmdpdHVkZSBheGlzIGRvZXMgbm90IHdyYXAgYXJvdW5kLlxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcblx0Ly8gTGlrZSBgd3JhcExuZ2AsIGJ1dCBmb3IgdGhlIGxhdGl0dWRlICh2ZXJ0aWNhbCkgYXhpcy5cclxuXHJcblx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuXHQvLyBAcHJvcGVydHkgaW5maW5pdGU6IEJvb2xlYW5cclxuXHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxyXG5cdGluZmluaXRlOiBmYWxzZSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGxhdCBhbmQgbG5nIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgbG5nID0gdGhpcy53cmFwTG5nID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG5cdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IFV0aWwud3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcclxuXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuXHQvLyB0aGF0IGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdCb3VuZHNgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMud3JhcExhdExuZyhjZW50ZXIpLFxyXG5cdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcblx0XHQgICAgbG5nU2hpZnQgPSBjZW50ZXIubG5nIC0gbmV3Q2VudGVyLmxuZztcclxuXHJcblx0XHRpZiAobGF0U2hpZnQgPT09IDAgJiYgbG5nU2hpZnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblx0XHQgICAgbmV3U3cgPSBuZXcgTGF0TG5nKHN3LmxhdCAtIGxhdFNoaWZ0LCBzdy5sbmcgLSBsbmdTaGlmdCksXHJcblx0XHQgICAgbmV3TmUgPSBuZXcgTGF0TG5nKG5lLmxhdCAtIGxhdFNoaWZ0LCBuZS5sbmcgLSBsbmdTaGlmdCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuXHR9XHJcbn07XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxuZXhwb3J0IHZhciBFYXJ0aCA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBzaW5ETGF0ID0gTWF0aC5zaW4oKGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQpICogcmFkIC8gMiksXG5cdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcblx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuXHRcdCAgICBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcblx0XHRyZXR1cm4gdGhpcy5SICogYztcblx0fVxufSk7XG4iLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3JcclxuICpcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICogdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpc1xyXG4gKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gKi9cclxuXHJcbnZhciBlYXJ0aFJhZGl1cyA9IDYzNzgxMzc7XHJcblxyXG5leHBvcnQgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiBlYXJ0aFJhZGl1cyxcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICBzaW4gPSBNYXRoLnNpbihsYXQgKiBkKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuXHRcdFx0dGhpcy5SICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gZWFydGhSYWRpdXMgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICogXHRwMiA9IHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShwKSwgLy8gIEwucG9pbnQoNywgOClcclxuICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkpIHtcclxuXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcblx0XHR0aGlzLl9hID0gYVswXTtcclxuXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG5cdFx0dGhpcy5fYyA9IGFbMl07XHJcblx0XHR0aGlzLl9kID0gYVszXTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn1cclxuXHJcblRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG5cdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcblx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGNvZWZmaWNpZW50czogQXJyYXkpOiBUcmFuc2Zvcm1hdGlvblxyXG4vLyBFeHBlY3RzIGFuIGNvZWZmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4vLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0czODU3ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBFUFNHOTAwOTEzID0gVXRpbC5leHRlbmQoe30sIEVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbi8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4vLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuLy8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0fVxuXG5cdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdHJldHVybiBzdHIgfHwgJ00wIDAnO1xufVxuXG5cblxuXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcbmltcG9ydCB7c3ZnQ3JlYXRlfSBmcm9tICcuLi9sYXllci92ZWN0b3IvU1ZHLlV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG5leHBvcnQgdmFyIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxuZXhwb3J0IHZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbmV4cG9ydCB2YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbmV4cG9ydCB2YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxuZXhwb3J0IHZhciBhbmRyb2lkMjMgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAyJykgfHwgdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMycpO1xyXG5cclxuLyogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzk2MTI2NiBmb3IgZGV0YWlscyBvbiBkZXRlY3Rpbmcgc3RvY2sgQW5kcm9pZCAqL1xyXG52YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkU3RvY2s6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG5leHBvcnQgdmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxuZXhwb3J0IHZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxuZXhwb3J0IHZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG5leHBvcnQgdmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxuZXhwb3J0IHZhciBwaGFudG9tID0gdXNlckFnZW50Q29udGFpbnMoJ3BoYW50b20nKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbmV4cG9ydCB2YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG5leHBvcnQgdmFyIHdpbiA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdXaW4nKSA9PT0gMDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgbW9iaWxlV2Via2l0M2QgPSBtb2JpbGUgJiYgd2Via2l0M2Q7XHJcblxyXG4vLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG5leHBvcnQgdmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxuZXhwb3J0IHZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbi8vIFRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbi8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuLy8gdG91Y2ggZXZlbnRzLlxyXG5leHBvcnQgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmIChwb2ludGVyIHx8ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxyXG5cdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuZXhwb3J0IHZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4vLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxuZXhwb3J0IHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2V0dGVyLXJldHVyblxyXG5cdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuXHR9XHJcblx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxufSgpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuZXhwb3J0IHZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbmV4cG9ydCB2YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuZXhwb3J0IHZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG5cbnZhciBfcG9pbnRlcnMgPSB7fTtcbnZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0X2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IFV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdC8vIElFMTAgc3BlY2lmaWM6IE1zVG91Y2ggbmVlZHMgcHJldmVudERlZmF1bHQuIFNlZSAjMjAwMFxuXHRcdGlmIChlLk1TUE9JTlRFUl9UWVBFX1RPVUNIICYmIGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0gpIHtcblx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHRcdH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9KTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoc3RhcnQnICsgaWRdID0gb25Eb3duO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSAmJiBlLmJ1dHRvbnMgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNobW92ZScgKyBpZF0gPSBvbk1vdmU7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uVXAgPSBmdW5jdGlvbiAoZSkge1xuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hlbmQnICsgaWRdID0gb25VcDtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgb25VcCwgZmFsc2UpO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xufVxuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbnZhciBfdG91Y2hzdGFydCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JztcclxudmFyIF90b3VjaGVuZCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJztcclxudmFyIF9wcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHQgICAgZGVsYXkgPSAyNTA7XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRpZiAoIWUuaXNQcmltYXJ5KSB7IHJldHVybjsgfVxyXG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH0gLy8gbW91c2UgZmlyZXMgbmF0aXZlIGRibGNsaWNrXHJcblx0XHR9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0dG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaC5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHQgICAgcHJvcCwgaTtcclxuXHJcblx0XHRcdFx0Zm9yIChpIGluIHRvdWNoKSB7XHJcblx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKHRvdWNoKSA6IHByb3A7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdH1cclxuXHRcdFx0dG91Y2gudHlwZSA9ICdkYmxjbGljayc7XHJcblx0XHRcdHRvdWNoLmJ1dHRvbiA9IDA7XHJcblx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0b2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXSA9IGhhbmRsZXI7XHJcblxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCBvblRvdWNoRW5kLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lPDU1IG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcblx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIHRvdWNoZW5kL3BvaW50ZXJ1cCBldmVudHMgYnV0IGRvZXMgZmlyZVxyXG5cdC8vIG5hdGl2ZSBkYmxjbGlja3MuIFNlZSAjNDEyNy5cclxuXHQvLyBFZGdlIDE0IGFsc28gZmlyZXMgbmF0aXZlIGRibGNsaWNrcywgYnV0IG9ubHkgZm9yIHBvaW50ZXJUeXBlIG1vdXNlLCBzZWUgIzUxODAuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpIHtcclxuXHR2YXIgdG91Y2hzdGFydCA9IG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0sXHJcblx0ICAgIHRvdWNoZW5kID0gb2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0sXHJcblx0ICAgIGRibGNsaWNrID0gb2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdO1xyXG5cclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIHRvdWNoZW5kLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuZXhwb3J0IHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG5cdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4vLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcblx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0fVxyXG5cdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IFV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgVXRpbC50cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcblx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcblx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG5cdH1cclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcblx0ZG8ge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuXHRyZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4vLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcblx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG5cdH07XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuaW1wb3J0IHtnZXRTY2FsZX0gZnJvbSAnLi9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh0eXBlcykge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKHZhciBqIGluIG9ialtldmVudHNLZXldKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIGosIG9ialtldmVudHNLZXldW2pdKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBicm93c2VyRmlyZXNOYXRpdmVEYmxDbGljaygpIHtcclxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3czYy9wb2ludGVyZXZlbnRzL2lzc3Vlcy8xNzFcclxuXHRpZiAoQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRyZXR1cm4gIShCcm93c2VyLmVkZ2UgfHwgQnJvd3Nlci5zYWZhcmkpO1xyXG5cdH1cclxufVxyXG5cclxudmFyIG1vdXNlU3Vic3QgPSB7XHJcblx0bW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXHJcblx0bW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcclxuXHR3aGVlbDogISgnb253aGVlbCcgaW4gd2luZG93KSAmJiAnbW91c2V3aGVlbCdcclxufTtcclxuXHJcbmZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0fTtcclxuXHJcblx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcblx0XHRhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgIWJyb3dzZXJGaXJlc05hdGl2ZURibENsaWNrKCkpIHtcclxuXHRcdGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd3aGVlbCcgfHwgIHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XHJcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb3JpZ2luYWxIYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgIWJyb3dzZXJGaXJlc05hdGl2ZURibENsaWNrKCkpIHtcclxuXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cdHNraXBwZWQoZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnd2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICd3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZG91YmxlY2xpY2snYCxcclxuLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRhZGRPbmUoZWwsICdjbGljaycsIGZha2VTdG9wKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4vLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbi8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbi8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG5cdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcChlKSB7XHJcblx0cHJldmVudERlZmF1bHQoZSk7XHJcblx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbi8vIGBjb250YWluZXJgIChib3JkZXIgZXhjbHVkZWQpIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG5cdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHR9XHJcblxyXG5cdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXHJcblx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdC8vIG9mZnNldC5sZWZ0L3RvcCB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgY2xpZW50WC9ZKSxcclxuXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG5cdFx0KGUuY2xpZW50WCAtIG9mZnNldC5sZWZ0KSAvIHNjYWxlLnggLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdChlLmNsaWVudFkgLSBvZmZzZXQudG9wKSAvIHNjYWxlLnkgLSBjb250YWluZXIuY2xpZW50VG9wXHJcblx0KTtcclxufVxyXG5cclxuLy8gQ2hyb21lIG9uIFdpbiBzY3JvbGxzIGRvdWJsZSB0aGUgcGl4ZWxzIGFzIGluIG90aGVyIHBsYXRmb3JtcyAoc2VlICM0NTM4KSxcclxuLy8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG52YXIgd2hlZWxQeEZhY3RvciA9XHJcblx0KEJyb3dzZXIud2luICYmIEJyb3dzZXIuY2hyb21lKSA/IDIgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0QnJvd3Nlci5nZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIHdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbi8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbi8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcblx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuXHQgICAgICAgMDtcclxufVxyXG5cclxudmFyIHNraXBFdmVudHMgPSB7fTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWtlU3RvcChlKSB7XHJcblx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBza2lwcGVkKGUpXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNraXBwZWQoZSkge1xyXG5cdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XHJcblx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRyZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcblx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR0cnkge1xyXG5cdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5leHBvcnQge29uIGFzIGFkZExpc3RlbmVyfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5leHBvcnQge29mZiBhcyByZW1vdmVMaXN0ZW5lcn07XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQge0VQU0czODU3fSBmcm9tICcuLi9nZW8vY3JzL0NSUy5FUFNHMzg1Nyc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtCb3VuZHMsIHRvQm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi4vZG9tL1Bvc0FuaW1hdGlvbic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IFV0aWwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IERvbVV0aWwuVFJBTlNJVElPTiAmJiBCcm93c2VyLmFueTNkICYmICFCcm93c2VyLm1vYmlsZU9wZXJhICYmXHJcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKHRoaXMuX3Byb3h5LCBEb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChtb3ZlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gYHBhZGRpbmdgLCBgcGFkZGluZ1RvcExlZnRgIGFuZCBgcGFkZGluZ1RvcFJpZ2h0YCBvcHRpb25zIHRvIGZpdFxyXG5cdC8vIHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMsIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcblx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcblx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdChjZW50ZXIpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBoYWxmUGl4ZWxCb3VuZHMgPSBwaXhlbEJvdW5kcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKTtcclxuXHJcblx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgZGlmZiA9IHBpeGVsQ2VudGVyLnN1YnRyYWN0KHBpeGVsUG9pbnQpLFxyXG5cdFx0XHQgICAgbmV3Q2VudGVyID0gdG9Qb2ludChwaXhlbFBvaW50LnggKyBkaWZmLngsIHBpeGVsUG9pbnQueSArIGRpZmYueSk7XHJcblxyXG5cdFx0XHRpZiAocGl4ZWxQb2ludC54IDwgcGFkZGVkQm91bmRzLm1pbi54IHx8IHBpeGVsUG9pbnQueCA+IHBhZGRlZEJvdW5kcy5tYXgueCkge1xyXG5cdFx0XHRcdG5ld0NlbnRlci54ID0gcGl4ZWxDZW50ZXIueCAtIGRpZmYueDtcclxuXHRcdFx0XHRpZiAoZGlmZi54ID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggKz0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggLT0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nQlIueDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueSA8IHBhZGRlZEJvdW5kcy5taW4ueSB8fCBwaXhlbFBvaW50LnkgPiBwYWRkZWRCb3VuZHMubWF4LnkpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueSA9IHBpeGVsQ2VudGVyLnkgLSBkaWZmLnk7XHJcblx0XHRcdFx0aWYgKGRpZmYueSA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55ICs9IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55IC09IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ0JSLnk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QobmV3Q2VudGVyKSwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG5cdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcblx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG5cdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcblx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0XHR3YXRjaDogZmFsc2VcclxuXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdCAgICBvbkVycm9yID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG5cdFx0XHRjb2RlOiBjLFxyXG5cdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcblx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcblx0XHQgICAgbGF0bG5nID0gbmV3IExhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IFV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciB2ZWN0b3JzIChgUGF0aGBzLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzKSwgYEltYWdlT3ZlcmxheWBzIGFuZCBgVmlkZW9PdmVybGF5YHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gRG9tRXZlbnQub2ZmIDogRG9tRXZlbnQub247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcblx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcblx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiBEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IERvbUV2ZW50LnNraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nIHx8IHR5cGUgPT09ICdrZXlwcmVzcycgfHwgdHlwZSA9PT0gJ2tleXVwJyB8fCB0eXBlID09PSAna2V5ZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IFV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBVdGlsLmluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gRG9tVXRpbC5UUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcHJveHkpO1xyXG5cdFx0dGhpcy5vZmYoJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbU1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpXHJcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE90aGVyIEV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcblx0XHQvLyBGaXJlZCBhdCBsZWFzdCBvbmNlIHBlciB6b29tIGFuaW1hdGlvbi4gRm9yIGNvbnRpbnVvdXMgem9vbSwgbGlrZSBwaW5jaCB6b29taW5nLCBmaXJlZCBvbmNlIHBlciBmcmFtZSBkdXJpbmcgem9vbS5cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xyXG5cclxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb24gPSBEb21VdGlsLmNyZWF0ZSgnc2VjdGlvbicsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuZXhwb3J0IHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJysnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnJiN4MjIxMjsnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICcmI3gyMjEyOycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuXHRcdC8vIEBwcm9wZXJ0eSB6b29tQ29udHJvbDogQ29udHJvbC5ab29tXHJcblx0XHQvLyBUaGUgZGVmYXVsdCB6b29tIGNvbnRyb2wgKG9ubHkgYXZhaWxhYmxlIGlmIHRoZVxyXG5cdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuZXhwb3J0IHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XHJcbiIsIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xufTtcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbmV4cG9ydCB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q29udHJvbCwgY29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCB7TGF5ZXJzLCBsYXllcnN9IGZyb20gJy4vQ29udHJvbC5MYXllcnMnO1xuaW1wb3J0IHtab29tLCB6b29tfSBmcm9tICcuL0NvbnRyb2wuWm9vbSc7XG5pbXBvcnQge1NjYWxlLCBzY2FsZX0gZnJvbSAnLi9Db250cm9sLlNjYWxlJztcbmltcG9ydCB7QXR0cmlidXRpb24sIGF0dHJpYnV0aW9ufSBmcm9tICcuL0NvbnRyb2wuQXR0cmlidXRpb24nO1xuXG5Db250cm9sLkxheWVycyA9IExheWVycztcbkNvbnRyb2wuWm9vbSA9IFpvb207XG5Db250cm9sLlNjYWxlID0gU2NhbGU7XG5Db250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbmNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuY29udHJvbC56b29tID0gem9vbTtcbmNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbmNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuZXhwb3J0IHtDb250cm9sLCBjb250cm9sfTtcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5leHBvcnQgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4vLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbi8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5IYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuL0Jyb3dzZXInO1xuZXhwb3J0IHtCcm93c2VyfTtcblxuZXhwb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi9FdmVudHMnO1xuaW1wb3J0IHtFdmVudHN9IGZyb20gJy4vRXZlbnRzJztcbmV4cG9ydCB7RXZlbnRlZH07XG5leHBvcnQgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuZXhwb3J0IHtIYW5kbGVyfSBmcm9tICcuL0hhbmRsZXInO1xuXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XG5leHBvcnQge1V0aWx9O1xuZXhwb3J0IHtleHRlbmQsIGJpbmQsIHN0YW1wLCBzZXRPcHRpb25zfSBmcm9tICcuL1V0aWwnO1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG52YXIgRU5EID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG59O1xyXG52YXIgTU9WRSA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcblx0XHQgICAgc2l6ZWRQYXJlbnQgPSBEb21VdGlsLmdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdC8vIENhY2hlIHRoZSBzY2FsZSwgc28gdGhhdCB3ZSBjYW4gY29udGludW91c2x5IGNvbXBlbnNhdGUgZm9yIGl0IGR1cmluZyBkcmFnIChfb25Nb3ZlKS5cclxuXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gRG9tVXRpbC5nZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIE1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBFTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcblx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSAmJiB0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIE1PVkUpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBNT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIEVORFtpXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbi8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4vLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbi8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbi8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbi8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmNvbS9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcblx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuXHRcdFx0YSA9IHA7XHJcblx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGIgPSBwO1xyXG5cdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0ICAgIHgsIHk7XHJcblxyXG5cdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtYXgueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtaW4ueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0eCA9IG1heC54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdHggPSBtaW4ueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5leHBvcnQgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0dmFyIHggPSBwMS54LFxyXG5cdCAgICB5ID0gcDEueSxcclxuXHQgICAgZHggPSBwMi54IC0geCxcclxuXHQgICAgZHkgPSBwMi55IC0geSxcclxuXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcblx0ICAgIHQ7XHJcblxyXG5cdGlmIChkb3QgPiAwKSB7XHJcblx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuXHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0eSA9IHAyLnk7XHJcblx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHR5ICs9IGR5ICogdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR4ID0gcC54IC0geDtcclxuXHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG5cdHJldHVybiAhVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcblx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIExvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuIiwiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxuXG4gKi9cblxuZXhwb3J0IHtMb25MYXR9IGZyb20gJy4vUHJvamVjdGlvbi5Mb25MYXQnO1xuZXhwb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcbmV4cG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVQU0czMzk1ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqXHJcbiAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0c0MzI2ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5leHBvcnQgdmFyIFNpbXBsZSA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGUuZy4gXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLiBJdCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEgYW5kIGlzIG9mdGVuIGEgbGVnYWwgb2JsaWdhdGlvbiB0b3dhcmRzIGNvcHlyaWdodCBob2xkZXJzIGFuZCB0aWxlIHByb3ZpZGVycy5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHQvL1xuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKGdyb3VwOiBMYXllckdyb3VwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBgTGF5ZXJHcm91cGBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldID0gdGhpcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiBtYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKGxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcblx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKFV0aWwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKFV0aWwuaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG5cdFx0fVxuXHR9XG59KTtcbiIsIlxyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCFsYXllcikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdHZhciBsYXllcklkID0gdHlwZW9mIGxheWVyID09PSAnbnVtYmVyJyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHRcdHJldHVybiBsYXllcklkIGluIHRoaXMuX2xheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBmZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7c2V0T3B0aW9uc30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7cmV0aW5hfSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gcG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gcG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiByZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICogQGFrYSBMLkljb24uRGVmYXVsdFxuICogQHNlY3Rpb25cbiAqXG4gKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gKiByZWxlYXNlcy5cbiAqXG4gKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAqIGBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uYCB3aXRoIHlvdXIgb3duIGljb24gaW5zdGVhZC5cbiAqL1xuXG5leHBvcnQgdmFyIEljb25EZWZhdWx0ID0gSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcblx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcblx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoIUljb25EZWZhdWx0LmltYWdlUGF0aCkge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdGlmIChwYXRoID09PSBudWxsIHx8IHBhdGguaW5kZXhPZigndXJsJykgIT09IDApIHtcblx0XHRcdHBhdGggPSAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXnVybFxcKFtcIiddPy8sICcnKS5yZXBsYWNlKC9tYXJrZXItaWNvblxcLnBuZ1tcIiddP1xcKSQvLCAnJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge3JlcXVlc3RBbmltRnJhbWUsIGNhbmNlbEFuaW1GcmFtZX0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFya2VyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICpcbiAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAqIGBgYFxuICpcbiAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS4gT25seSB2YWxpZCB3aGVuIHRoZSBtYXJrZXIgaXMgb24gdGhlIG1hcCAoT3RoZXJ3aXNlIHNldCBbYG1hcmtlci5vcHRpb25zLmRyYWdnYWJsZWBdKCNtYXJrZXItZHJhZ2dhYmxlKSkuXG4gKi9cblxuZXhwb3J0IHZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cblx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHRcdH1cblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIG1hcCA9IG1hcmtlci5fbWFwLFxuXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcblx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcblx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cblx0XHR2YXIgcGFuQm91bmRzID0gdG9Cb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLl9zdWJ0cmFjdChvcmlnaW4pLmFkZChwYWRkaW5nKSxcblx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcblx0XHQpO1xuXG5cdFx0aWYgKCFwYW5Cb3VuZHMuY29udGFpbnMoaWNvblBvcykpIHtcblx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcblx0XHRcdHZhciBtb3ZlbWVudCA9IHRvUG9pbnQoXG5cdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWF4LngpIC8gKGJvdW5kcy5tYXgueCAtIHBhbkJvdW5kcy5tYXgueCkgLVxuXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG5cdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWF4LnkpIC8gKGJvdW5kcy5tYXgueSAtIHBhbkJvdW5kcy5tYXgueSkgLVxuXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1pbi55KSAvIChib3VuZHMubWluLnkgLSBwYW5Cb3VuZHMubWluLnkpXG5cdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG5cdFx0XHRtYXAucGFuQnkobW92ZW1lbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5fYWRkKG1vdmVtZW50KTtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG5cdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cblx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuXHRcdHRoaXMuX21hcmtlci5jbG9zZVBvcHVwICYmIHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCk7XG5cblx0XHR0aGlzLl9tYXJrZXJcblx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdFx0LmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xyXG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc2hhZG93UGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMFxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0SWNvbjogSWNvblxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fSxcclxuXHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5leHBvcnQgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyB0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FYXJ0aCc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IExpbmVVdGlsLmlzRmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHMoW1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuXHRcdF0pO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdGlmIChMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IExpbmVVdGlsLl9mbGF0O1xuIiwiaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCAqIGFzIFBvbHlVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvbHlVdGlsJztcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFBvbHlnb24gPSBQb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXIsXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbal07XG5cblx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcblx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG5cdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhID09PSAwKSB7XG5cdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBQb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge01hcmtlcn0gZnJvbSAnLi9tYXJrZXIvTWFya2VyJztcclxuaW1wb3J0IHtDaXJjbGV9IGZyb20gJy4vdmVjdG9yL0NpcmNsZSc7XHJcbmltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGVNYXJrZXInO1xyXG5pbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL3ZlY3Rvci9Qb2x5bGluZSc7XHJcbmltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi92ZWN0b3IvUG9seWdvbic7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcblx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcblx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQpIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29vcmRzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG5leHBvcnQgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcblx0Ly8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcblx0Ly8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuZXhwb3J0IHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnSU1HJztcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCdpbWcnKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdGltZy5vbmxvYWQgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cdFx0aW1nLm9uZXJyb3IgPSBVdGlsLmJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQGV2ZW50IGVycm9yOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcblx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuXHRcdGxvb3A6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG5cdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gQnJvd3NlciBjb21wYXRpYmlsaXR5LSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdFxyXG5cdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbXV0ZWQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIG9uIG11dGUgd2hlbiBsb2FkZWQuXHJcblx0XHRtdXRlZDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuXHRcdFx0dmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJztcclxuXHRcdH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgc291cmNlID0gRG9tVXRpbC5jcmVhdGUoJ3NvdXJjZScpO1xyXG5cdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG5cdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgU1ZHT3ZlcmxheVxuICogQGFrYSBMLlNWR092ZXJsYXlcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAqXG4gKiBVc2VkIHRvIGxvYWQsIGRpc3BsYXkgYW5kIHByb3ZpZGUgRE9NIGFjY2VzcyB0byBhbiBTVkcgZmlsZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxuICpcbiAqIEFuIFNWRyBvdmVybGF5IHVzZXMgdGhlIFtgPHN2Zz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdmcpIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIDIwMCAyMDBcIik7XG4gKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICogdmFyIHN2Z0VsZW1lbnRCb3VuZHMgPSBbIFsgMzIsIC0xMzAgXSwgWyAxMywgLTEwMCBdIF07XG4gKiBMLnN2Z092ZXJsYXkoc3ZnRWxlbWVudCwgc3ZnRWxlbWVudEJvdW5kcykuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5faW1hZ2UgPSB0aGlzLl91cmw7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cblxuXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0ZWwub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cdH1cblxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogU1ZHRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudClcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnN2Z092ZXJsYXkoc3ZnOiBTdHJpbmd8U1ZHRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBTVkdPdmVybGF5IG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4vLyBBIHZpZXdCb3ggYXR0cmlidXRlIGlzIHJlcXVpcmVkIG9uIHRoZSBTVkcgZWxlbWVudCB0byB6b29tIGluIGFuZCBvdXQgcHJvcGVybHkuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTVkdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuZXhwb3J0IHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi4gVXNlZnVsIHRvIGNvbnRyb2wgdGhlIGFuY2hvclxyXG5cdFx0Ly8gb2YgdGhlIHBvcHVwIHdoZW4gb3BlbmluZyBpdCBvbiBzb21lIG92ZXJsYXlzLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZSdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChEb21VdGlsLnJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGNvbnRhaW5lciBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIHRvIHRoZSBiYWNrIG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChwYXJlbnQsIGxheWVyLCBsYXRsbmcpIHtcclxuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpKSB7XHJcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xyXG5cdFx0XHRsYXllciA9IHBhcmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gcGFyZW50Ll9sYXllcnMpIHtcclxuXHRcdFx0XHRsYXllciA9IHBhcmVudC5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGF0bG5nKSB7XHJcblx0XHRcdGlmIChsYXllci5nZXRDZW50ZXIpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChsYXllci5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBsYXllci5nZXRMYXRMbmcoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCBvdmVybGF5IHNvdXJjZSB0byB0aGlzIGxheWVyXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuXHJcblx0XHQvLyB1cGRhdGUgdGhlIG92ZXJsYXkgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG5cdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgcG9wdXAgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFswLCAwXTtcclxuXHR9XHJcblxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi92ZWN0b3IvUGF0aCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9wdXBcclxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcclxuICogQGFrYSBMLlBvcHVwXHJcbiAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICogb3BlbiBwb3B1cHMgd2hpbGUgbWFraW5nIHN1cmUgdGhhdCBvbmx5IG9uZSBwb3B1cCBpcyBvcGVuIGF0IG9uZSB0aW1lXHJcbiAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICogYGBgXHJcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gKiBIZXJlJ3MgYSBtb3JlIGNvbXBsaWNhdGVkIHdheSB0byBvcGVuIGEgcG9wdXAgb24gYSBtYXA6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICogXHQub3Blbk9uKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbmV4cG9ydCB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcblx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG5cdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuZXhwb3J0IHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgUG9wdXApIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF0bG5nID0gdGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxyXG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcblx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcblx0fSxcclxuXHJcblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdC8vIGlmIHRoaXMgaW5oZXJpdHMgZnJvbSBQYXRoIGl0cyBhIHZlY3RvciBhbmQgd2UgY2FuIGp1c3RcclxuXHRcdC8vIG9wZW4gdGhlIHBvcHVwIGF0IHRoZSBuZXcgbG9jYXRpb25cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIFBhdGgpIHtcclxuXHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXllciB8fCBlLnRhcmdldCwgZS5sYXRsbmcpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcbiIsIlxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKEJyb3dzZXIudG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBzdWJYLCBzdWJZLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IDA7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5leHBvcnQgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtlbXB0eX0gZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuZXhwb3J0IHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG5cdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHRlbXB0eShkaXYpO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IHBvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5leHBvcnQge2ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XG5JY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcbmV4cG9ydCB7SWNvbn07XG5cbmV4cG9ydCB7RGl2SWNvbiwgZGl2SWNvbn0gZnJvbSAnLi9EaXZJY29uJztcbmV4cG9ydCB7TWFya2VyLCBtYXJrZXJ9IGZyb20gJy4vTWFya2VyJztcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuZXhwb3J0IHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3Rpbmdcblx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0eiA9IE51bWJlcih6KTtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aWxlWm9vbSk7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEJyb3dzZXIuYW5kcm9pZCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMpIHtcblx0XHRcdHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBVdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBVdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7R3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJ01hcCBkYXRhICZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvXCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzLCA8YSBocmVmPVwiaHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzIuMC9cIj5DQy1CWS1TQTwvYT4nfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyID0gR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtaW5ab29tOiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1heFpvb206IDE4LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHQvKlxyXG5cdFx0IFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuXHRcdCBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEvcm9sZXMjdGV4dGFsdGVybmF0aXZlY29tcHV0YXRpb25cclxuXHRcdCovXHJcblx0XHR0aWxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBVdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgVXRpbC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHQvLyB1bmxlc3Mgd2UncmUgb24gQW5kcm9pZCdzIHN0b2NrIGJyb3dzZXIsXHJcblx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZFN0b2NrKSB7XHJcblx0XHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBVdGlsLmVtcHR5SW1hZ2VVcmwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gVXRpbC5lbXB0eUltYWdlVXJsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge1RpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xyXG5pbXBvcnQge2V4dGVuZCwgc2V0T3B0aW9ucywgZ2V0UGFyYW1TdHJpbmd9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7cmV0aW5hfSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xLFxuXG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdHRvbGVyYW5jZSA6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRVdGlsLnN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG5cdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSAhPT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaWNrZWRMYXllcikgIHtcblx0XHRcdERvbUV2ZW50LmZha2VTdG9wKGUpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZUhvdmVyZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgIT09IHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cblx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9LCB0aGlzKSwgMzIpO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxuZXhwb3J0IHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5leHBvcnQgdmFyIHZtbE1peGluID0ge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0RG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBVdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7c3RhbXB9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3N2Z0NyZWF0ZSwgcG9pbnRzVG9QYXRofSBmcm9tICcuL1NWRy5VdGlsJztcbmV4cG9ydCB7cG9pbnRzVG9QYXRofTtcbmltcG9ydCB7dm1sTWl4aW4sIHZtbENyZWF0ZX0gZnJvbSAnLi9TVkcuVk1MJztcblxuZXhwb3J0IHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uLy4uL21hcC9NYXAnO1xuaW1wb3J0IHtjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7c3ZnfSBmcm9tICcuL1NWRyc7XG5cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG5cdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6IG5hbWV9KTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9jcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKG9wdGlvbnMpKSB8fCBzdmcob3B0aW9ucyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuIiwiZXhwb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5leHBvcnQge0xheWVyR3JvdXAsIGxheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XG5leHBvcnQge0ZlYXR1cmVHcm91cCwgZmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5pbXBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb24sIGdlb21ldHJ5VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIGNvb3Jkc1RvTGF0TG5ncywgbGF0TG5nVG9Db29yZHMsIGxhdExuZ3NUb0Nvb3JkcywgZ2V0RmVhdHVyZSwgYXNGZWF0dXJlfSBmcm9tICcuL0dlb0pTT04nO1xuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbkdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3Jkcztcbkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbkdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuZXhwb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29ufTtcblxuZXhwb3J0IHtJbWFnZU92ZXJsYXksIGltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuZXhwb3J0IHtWaWRlb092ZXJsYXksIHZpZGVvT3ZlcmxheX0gZnJvbSAnLi9WaWRlb092ZXJsYXknO1xuZXhwb3J0IHtTVkdPdmVybGF5LCBzdmdPdmVybGF5fSBmcm9tICcuL1NWR092ZXJsYXknO1xuXG5leHBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5leHBvcnQge1BvcHVwLCBwb3B1cH0gZnJvbSAnLi9Qb3B1cCc7XG5leHBvcnQge1Rvb2x0aXAsIHRvb2x0aXB9IGZyb20gJy4vVG9vbHRpcCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vbWFya2VyL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdGlsZS9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3ZlY3Rvci9pbmRleCc7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmUpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcblx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcblx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG5cdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgRG91YmxlQ2xpY2tab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy9cbi8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gYGBganNcbi8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuLy8gYGBgXG4vL1xuLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuLy8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGJlIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0IHVubGVzcyBydW5uaW5nIG9uIG9sZCBBbmRyb2lkIGRldmljZXMuXG5cdGluZXJ0aWE6ICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbmV4cG9ydCB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSBsYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG5cdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRtYXBcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcblx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucyh0aW1lKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9wcnVuZVBvc2l0aW9uczogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR3aGlsZSAodGhpcy5fcG9zaXRpb25zLmxlbmd0aCA+IDEgJiYgdGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtvbiwgb2ZmLCBzdG9wfSBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5leHBvcnQgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRvbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBNb3VzZSB3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG5leHBvcnQgdmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IERvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcDogQm9vbGVhbiA9IHRydWVcblx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcblx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHR0YXA6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuZXhwb3J0IHZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKEJyb3dzZXIudG91Y2ggJiYgKCFCcm93c2VyLnBvaW50ZXIgfHwgQnJvd3Nlci5zYWZhcmkpKSB7XG5cdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoICYmICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBVdGlsLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRhcCc7XG5NYXAuVGFwID0gVGFwO1xuaW1wb3J0IHtUb3VjaFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuVG91Y2hab29tJztcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbmV4cG9ydCB7TWFwLCBjcmVhdGVNYXAgYXMgbWFwfSBmcm9tICcuL01hcCc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},200:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(201);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(4).default\nvar update = add(\"52ac88d4\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5taW4uY3NzPzdhYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBZ0Q7QUFDdEUsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUFnRDtBQUNsRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiIyMDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL0NoYXJ0Lm1pbi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI1MmFjODhkNFwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL0NoYXJ0Lm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL0NoYXJ0Lm1pbi5jc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///200\n")},201:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5taW4uY3NzP2M3M2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRjtBQUNBO0FBQ0EsY0FBYyxRQUFTLHVDQUF1QyxLQUFLLFlBQVksR0FBRyxXQUFXLHdCQUF3Qix1Q0FBdUMsZ0ZBQWdGLGtCQUFrQixjQUFjLE9BQU8sTUFBTSxRQUFRLFNBQVMsZ0JBQWdCLG9CQUFvQixrQkFBa0IsV0FBVyxpQ0FBaUMsa0JBQWtCLGdCQUFnQixpQkFBaUIsT0FBTyxNQUFNLGlDQUFpQyxrQkFBa0IsV0FBVyxZQUFZLE9BQU8sTUFBTTtBQUNuaUI7QUFDQSIsImZpbGUiOiIyMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAa2V5ZnJhbWVzIGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbntmcm9te29wYWNpdHk6Ljk5fXRve29wYWNpdHk6MX19LmNoYXJ0anMtcmVuZGVyLW1vbml0b3J7YW5pbWF0aW9uOmNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAxbXN9LmNoYXJ0anMtc2l6ZS1tb25pdG9yLC5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQsLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmlua3twb3NpdGlvbjphYnNvbHV0ZTtkaXJlY3Rpb246bHRyO2xlZnQ6MDt0b3A6MDtyaWdodDowO2JvdHRvbTowO292ZXJmbG93OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lO3Zpc2liaWxpdHk6aGlkZGVuO3otaW5kZXg6LTF9LmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZD5kaXZ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwMDAwMHB4O2hlaWdodDoxMDAwMDAwcHg7bGVmdDowO3RvcDowfS5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbms+ZGl2e3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjIwMCU7aGVpZ2h0OjIwMCU7bGVmdDowO3RvcDowfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///201\n')},3:function(module,exports,__webpack_require__){"use strict";eval('\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sIm1hcHBpbmdzIjoiQUFBYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVVDLFlBQVYsRUFBd0I7QUFDdkMsTUFBSUMsSUFBSSxHQUFHLEVBQVgsQ0FEdUMsQ0FDeEI7O0FBRWZBLE1BQUksQ0FBQ0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ2xDLFdBQU8sS0FBS0MsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7QUFDOUIsVUFBSUMsT0FBTyxHQUFHQyxzQkFBc0IsQ0FBQ0YsSUFBRCxFQUFPSixZQUFQLENBQXBDOztBQUVBLFVBQUlJLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtBQUNYLGVBQU8sVUFBVUcsTUFBVixDQUFpQkgsSUFBSSxDQUFDLENBQUQsQ0FBckIsRUFBMEIsSUFBMUIsRUFBZ0NHLE1BQWhDLENBQXVDRixPQUF2QyxFQUFnRCxHQUFoRCxDQUFQO0FBQ0Q7O0FBRUQsYUFBT0EsT0FBUDtBQUNELEtBUk0sRUFRSkcsSUFSSSxDQVFDLEVBUkQsQ0FBUDtBQVNELEdBVkQsQ0FIdUMsQ0FhcEM7QUFDSDs7O0FBR0FQLE1BQUksQ0FBQ1EsQ0FBTCxHQUFTLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxNQUEvQixFQUF1QztBQUM5QyxRQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0I7QUFDQUEsYUFBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWO0FBQ0Q7O0FBRUQsUUFBSUcsc0JBQXNCLEdBQUcsRUFBN0I7O0FBRUEsUUFBSUQsTUFBSixFQUFZO0FBQ1YsV0FBSyxJQUFJSCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtLLE1BQXpCLEVBQWlDTCxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDO0FBQ0EsWUFBSU0sRUFBRSxHQUFHLEtBQUtOLENBQUwsRUFBUSxDQUFSLENBQVQ7O0FBRUEsWUFBSU0sRUFBRSxJQUFJLElBQVYsRUFBZ0I7QUFDZEYsZ0NBQXNCLENBQUNFLEVBQUQsQ0FBdEIsR0FBNkIsSUFBN0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBSyxJQUFJQyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHTixPQUFPLENBQUNJLE1BQTlCLEVBQXNDRSxFQUFFLEVBQXhDLEVBQTRDO0FBQzFDLFVBQUlaLElBQUksR0FBRyxHQUFHRyxNQUFILENBQVVHLE9BQU8sQ0FBQ00sRUFBRCxDQUFqQixDQUFYOztBQUVBLFVBQUlKLE1BQU0sSUFBSUMsc0JBQXNCLENBQUNULElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7QUFDN0M7QUFDQTtBQUNEOztBQUVELFVBQUlPLFVBQUosRUFBZ0I7QUFDZCxZQUFJLENBQUNQLElBQUksQ0FBQyxDQUFELENBQVQsRUFBYztBQUNaQSxjQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVVPLFVBQVY7QUFDRCxTQUZELE1BRU87QUFDTFAsY0FBSSxDQUFDLENBQUQsQ0FBSixHQUFVLEdBQUdHLE1BQUgsQ0FBVUksVUFBVixFQUFzQixPQUF0QixFQUErQkosTUFBL0IsQ0FBc0NILElBQUksQ0FBQyxDQUFELENBQTFDLENBQVY7QUFDRDtBQUNGOztBQUVESCxVQUFJLENBQUNnQixJQUFMLENBQVViLElBQVY7QUFDRDtBQUNGLEdBckNEOztBQXVDQSxTQUFPSCxJQUFQO0FBQ0QsQ0F6REQ7O0FBMkRBLFNBQVNLLHNCQUFULENBQWdDRixJQUFoQyxFQUFzQ0osWUFBdEMsRUFBb0Q7QUFDbEQsTUFBSUssT0FBTyxHQUFHRCxJQUFJLENBQUMsQ0FBRCxDQUFKLElBQVcsRUFBekIsQ0FEa0QsQ0FDckI7O0FBRTdCLE1BQUljLFVBQVUsR0FBR2QsSUFBSSxDQUFDLENBQUQsQ0FBckI7O0FBRUEsTUFBSSxDQUFDYyxVQUFMLEVBQWlCO0FBQ2YsV0FBT2IsT0FBUDtBQUNEOztBQUVELE1BQUlMLFlBQVksSUFBSSxPQUFPbUIsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtBQUM5QyxRQUFJQyxhQUFhLEdBQUdDLFNBQVMsQ0FBQ0gsVUFBRCxDQUE3QjtBQUNBLFFBQUlJLFVBQVUsR0FBR0osVUFBVSxDQUFDSyxPQUFYLENBQW1CcEIsR0FBbkIsQ0FBdUIsVUFBVXFCLE1BQVYsRUFBa0I7QUFDeEQsYUFBTyxpQkFBaUJqQixNQUFqQixDQUF3QlcsVUFBVSxDQUFDTyxVQUFYLElBQXlCLEVBQWpELEVBQXFEbEIsTUFBckQsQ0FBNERpQixNQUE1RCxFQUFvRSxLQUFwRSxDQUFQO0FBQ0QsS0FGZ0IsQ0FBakI7QUFHQSxXQUFPLENBQUNuQixPQUFELEVBQVVFLE1BQVYsQ0FBaUJlLFVBQWpCLEVBQTZCZixNQUE3QixDQUFvQyxDQUFDYSxhQUFELENBQXBDLEVBQXFEWixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxDQUFDSCxPQUFELEVBQVVHLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDRCxDLENBQUM7OztBQUdGLFNBQVNhLFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0FBQzVCO0FBQ0EsTUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlTCxTQUFmLENBQUQsQ0FBbkIsQ0FBVCxDQUFqQjtBQUNBLE1BQUlNLElBQUksR0FBRywrREFBK0R6QixNQUEvRCxDQUFzRW9CLE1BQXRFLENBQVg7QUFDQSxTQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')}}]);