(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{11:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ chart_esm_Chart; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ adapters; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ registerables; });\n\n// UNUSED EXPORTS: defaults, Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, DatasetController, Decimation, DomPlatform, DoughnutController, Element, Filler, Interaction, Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, SubTitle, Ticks, TimeScale, TimeSeriesScale, Title, Tooltip, _detectPlatform, animator, controllers, elements, layouts, plugins, registry, scales\n\n// CONCATENATED MODULE: ./node_modules/chart.js/dist/chunks/helpers.segment.js\n/*!\n * Chart.js v3.5.1\n * https://www.chartjs.org\n * (c) 2021 Chart.js Contributors\n * Released under the MIT License\n */\nfunction helpers_segment_fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\nconst requestAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return function (callback) {\n      return callback();\n    };\n  }\n\n  return window.requestAnimationFrame;\n}();\n\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || (args => Array.prototype.slice.call(args));\n\n  let ticking = false;\n  let args = [];\n  return function (...rest) {\n    args = updateArgs(rest);\n\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\n\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay);\n    } else {\n      fn();\n    }\n\n    return delay;\n  };\n}\n\nconst _toLeftRightCenter = align => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\nfunction noop() {}\n\nconst uid = function () {\n  let id = 0;\n  return function () {\n    return id++;\n  };\n}();\n\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\n\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n\n  const type = Object.prototype.toString.call(value);\n\n  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\nconst isNumberFinite = value => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nconst toPercentage = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : value / dimension;\n\nconst toDimension = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n\n  if (isArray(loopable)) {\n    len = loopable.length;\n\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\n\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n\n    if (!isObject(source)) {\n      continue;\n    }\n\n    const keys = Object.keys(source);\n\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n\n  return target;\n}\n\nfunction mergeIf(target, source) {\n  return merge(target, source, {\n    merger: _mergerIf\n  });\n}\n\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\n\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\nconst emptyString = '';\nconst dot = '.';\n\nfunction indexOfDotOrLength(key, start) {\n  const idx = key.indexOf(dot, start);\n  return idx === -1 ? key.length : idx;\n}\n\nfunction resolveObjectKey(obj, key) {\n  if (key === emptyString) {\n    return obj;\n  }\n\n  let pos = 0;\n  let idx = indexOfDotOrLength(key, pos);\n\n  while (obj && idx > pos) {\n    obj = obj[key.substr(pos, idx - pos)];\n    pos = idx + 1;\n    idx = indexOfDotOrLength(key, pos);\n  }\n\n  return obj;\n}\n\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nconst defined = value => typeof value !== 'undefined';\n\nconst isFunction = value => typeof value === 'function';\n\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\n\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\n\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\n\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\n\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n\n  let e = 1;\n  let p = 0;\n\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n\n  return p;\n}\n\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < -0.5 * PI) {\n    angle += TAU;\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\n\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n\n  const s = _normalizeAngle(start);\n\n  const e = _normalizeAngle(end);\n\n  const angleToStart = _normalizeAngle(s - a);\n\n  const angleToEnd = _normalizeAngle(e - a);\n\n  const startToAngle = _normalizeAngle(a - s);\n\n  const endToAngle = _normalizeAngle(a - e);\n\n  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\n\nconst atEdge = t => t === 0 || t === 1;\n\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\n\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t) {\n    let s = 1.70158;\n\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n    }\n\n    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n\n    if (t < 1 / d) {\n      return m * t * t;\n    }\n\n    if (t < 2 / d) {\n      return m * (t -= 1.5 / d) * t + 0.75;\n    }\n\n    if (t < 2.5 / d) {\n      return m * (t -= 2.25 / d) * t + 0.9375;\n    }\n\n    return m * (t -= 2.625 / d) * t + 0.984375;\n  },\n\n  easeInOutBounce: t => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n/*!\n * @kurkle/color v0.1.9\n * https://github.com/kurkle/color#readme\n * (c) 2020 Jukka Kurkela\n * Released under the MIT License\n */\n\nconst map = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15\n};\nconst hex = '0123456789ABCDEF';\n\nconst h1 = b => hex[b & 0xF];\n\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\n\nconst eq = b => (b & 0xF0) >> 4 === (b & 0xF);\n\nfunction isShort(v) {\n  return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\n}\n\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map[str[1]] * 17,\n        g: 255 & map[str[2]] * 17,\n        b: 255 & map[str[3]] * 17,\n        a: len === 5 ? map[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map[str[1]] << 4 | map[str[2]],\n        g: map[str[3]] << 4 | map[str[4]],\n        b: map[str[5]] << 4 | map[str[6]],\n        a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255\n      };\n    }\n  }\n\n  return ret;\n}\n\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v ? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '') : v;\n}\n\nfunction helpers_segment_round(v) {\n  return v + 0.5 | 0;\n}\n\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\n\nfunction p2b(v) {\n  return lim(helpers_segment_round(v * 2.55), 0, 255);\n}\n\nfunction n2b(v) {\n  return lim(helpers_segment_round(v * 255), 0, 255);\n}\n\nfunction b2n(v) {\n  return lim(helpers_segment_round(v / 2.55) / 100, 0, 1);\n}\n\nfunction n2p(v) {\n  return lim(helpers_segment_round(v * 100), 0, 100);\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n\n  if (!m) {\n    return;\n  }\n\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = 255 & (m[8] ? p2b(v) : v * 255);\n  }\n\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : r);\n  g = 255 & (m[4] ? p2b(g) : g);\n  b = 255 & (m[6] ? p2b(b) : b);\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\n\nfunction rgbString(v) {\n  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n\n  return [f(0), f(8), f(4)];\n}\n\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n\n  return [f(5), f(3), f(1)];\n}\n\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n\n  return rgb;\n}\n\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n    h = h * 60 + 0.5;\n  }\n\n  return [h | 0, s || 0, l];\n}\n\nfunction calln(f, a, b, c) {\n  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);\n}\n\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\n\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\n\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\n\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\n\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n\n  if (!m) {\n    return;\n  }\n\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\n\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\n\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map$1 = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst helpers_segment_names = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\n\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(helpers_segment_names);\n  const tkeys = Object.keys(map$1);\n  let i, j, k, ok, nk;\n\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map$1[k]);\n    }\n\n    k = parseInt(helpers_segment_names[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n\n  return unpacked;\n}\n\nlet names$1;\n\nfunction nameParse(str) {\n  if (!names$1) {\n    names$1 = unpack();\n    names$1.transparent = [0, 0, 0, 0];\n  }\n\n  const a = names$1[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\n\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\n\nfunction fromObject(input) {\n  var v = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  };\n\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {\n        r: input[0],\n        g: input[1],\n        b: input[2],\n        a: 255\n      };\n\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    });\n    v.a = n2b(v.a);\n  }\n\n  return v;\n}\n\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n\n  return hueParse(str);\n}\n\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n\n    const type = typeof input;\n    let v;\n\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n\n    this._rgb = v;\n    this._valid = !!v;\n  }\n\n  get valid() {\n    return this._valid;\n  }\n\n  get rgb() {\n    var v = clone(this._rgb);\n\n    if (v) {\n      v.a = b2n(v.a);\n    }\n\n    return v;\n  }\n\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : this._rgb;\n  }\n\n  hexString() {\n    return this._valid ? hexString(this._rgb) : this._rgb;\n  }\n\n  hslString() {\n    return this._valid ? hslString(this._rgb) : this._rgb;\n  }\n\n  mix(color, weight) {\n    const me = this;\n\n    if (color) {\n      const c1 = me.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      me.rgb = c1;\n    }\n\n    return me;\n  }\n\n  clone() {\n    return new Color(this.rgb);\n  }\n\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n\n  greyscale() {\n    const rgb = this._rgb;\n    const val = helpers_segment_round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nconst isPatternOrGradient = value => value instanceof CanvasGradient || value instanceof CanvasPattern;\n\nfunction helpers_segment_color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\n\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst helpers_segment_descriptors = Object.create(null);\n\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n\n  const keys = key.split('.');\n\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n\n  return node;\n}\n\nfunction helpers_segment_set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n\n  return merge(getScope$1(root, ''), scope);\n}\n\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n\n    this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();\n\n    this.elements = {};\n    this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.describe(_descriptors);\n  }\n\n  set(scope, values) {\n    return helpers_segment_set(this, scope, values);\n  }\n\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n\n  describe(scope, values) {\n    return helpers_segment_set(helpers_segment_descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return helpers_segment_set(overrides, scope, values);\n  }\n\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n\n          return valueOrDefault(local, target);\n        },\n\n        set(value) {\n          this[privateName] = value;\n        }\n\n      }\n    });\n  }\n\n}\n\nvar defaults = new Defaults({\n  _scriptable: name => !name.startsWith('on'),\n  _indexable: name => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n\n  return longest;\n}\n\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n  const gcLen = gc.length / 2;\n\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n\n    gc.splice(0, gcLen);\n  }\n\n  return longest;\n}\n\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nfunction drawPoint(ctx, options, x, y) {\n  let type, xOffset, yOffset, size, cornerRadius;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n    default:\n      ctx.arc(x, y, radius, 0, TAU);\n      ctx.closePath();\n      break;\n\n    case 'triangle':\n      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n\n    case 'rectRounded':\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        ctx.rect(x - size, y - size, 2 * size, 2 * size);\n        break;\n      }\n\n      rad += QUARTER_PI;\n\n    case 'rectRot':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      ctx.closePath();\n      break;\n\n    case 'crossRot':\n      rad += QUARTER_PI;\n\n    case 'cross':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n\n    case 'star':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      rad += QUARTER_PI;\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n\n    case 'line':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n      break;\n  }\n\n  ctx.fill();\n\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\n\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\n\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n\n  ctx.lineTo(target.x, target.y);\n}\n\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n\n  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\n\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n\n  ctx.restore();\n}\n\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction addRoundedRectPath(ctx, rect) {\n  const {\n    x,\n    y,\n    w,\n    h,\n    radius\n  } = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\n\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n\n    case '%':\n      value /= 100;\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = v => +v || 0;\n\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n\n  return ret;\n}\n\nfunction toTRBL(value) {\n  return _readValueToProps(value, {\n    top: 'y',\n    right: 'x',\n    bottom: 'y',\n    left: 'x'\n  });\n}\n\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\n\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n\n  let style = valueOrDefault(options.style, fallback.style);\n\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\n\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n\n    if (value === undefined) {\n      continue;\n    }\n\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n\n      return value;\n    }\n  }\n}\n\nfunction _addGrace(minmax, grace) {\n  const {\n    min,\n    max\n  } = minmax;\n  return {\n    min: min - Math.abs(toDimension(grace, min)),\n    max: max + toDimension(grace, max)\n  };\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || (index => table[index] < value);\n\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n\n  while (hi - lo > 1) {\n    mid = lo + hi >> 1;\n\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {\n    lo,\n    hi\n  };\n}\n\nconst _lookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] < value);\n\nconst _rlookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] >= value);\n\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach(key => {\n    const method = '_onData' + _capitalize(key);\n\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach(object => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n\n    });\n  });\n}\n\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach(key => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\n\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n\n  if (set.size === ilen) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: scope => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n\n    get(target, prop) {\n      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      storage[prop] = value;\n      delete target[prop];\n      delete target._keys;\n      return true;\n    }\n\n  });\n}\n\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n\n    get(target, prop, receiver) {\n      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n        enumerable: true,\n        configurable: true\n      } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n\n  });\n}\n\nfunction _descriptors(proxy, defaults = {\n  scriptable: true,\n  indexable: true\n}) {\n  const {\n    _scriptable = defaults.scriptable,\n    _indexable = defaults.indexable,\n    _allKeys = defaults.allKeys\n  } = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\n\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters';\n\nfunction _cached(target, prop, resolve) {\n  let value = target[prop];\n\n  if (defined(value)) {\n    return value;\n  }\n\n  value = resolve();\n\n  if (defined(value)) {\n    target[prop] = value;\n  }\n\n  return value;\n}\n\nfunction _resolveWithContext(target, prop, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors\n  } = target;\n  let value = _proxy[prop];\n\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n\n  return value;\n}\n\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _stack\n  } = target;\n\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n\n  _stack.add(prop);\n\n  value = value(_context, _subProxy || receiver);\n\n  _stack.delete(prop);\n\n  if (isObject(value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n\n  return value;\n}\n\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors\n  } = target;\n\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n\n    value = [];\n\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n\n  return value;\n}\n\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key, parent) => key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(set, parentScopes, key, parentFallback) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, scope);\n\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n\n  return false;\n}\n\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop);\n\n  if (key === null) {\n    return false;\n  }\n\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key);\n\n    if (key === null) {\n      return false;\n    }\n  }\n\n  return _createResolver(Array.from(set), [''], rootScopes, fallback, () => subGetTarget(resolver, prop, value));\n}\n\nfunction addScopesFromKey(set, allScopes, key, fallback) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback);\n  }\n\n  return key;\n}\n\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n\n  const target = parent[prop];\n\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n\n  return target;\n}\n\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n\n    if (defined(value)) {\n      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n    }\n  }\n}\n\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n\n    const value = scope[key];\n\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n\n  return Array.from(set);\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\n\nconst getValueAxis = indexAxis => indexAxis === 'x' ? 'y' : 'x';\n\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n\n    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n\n  let inAreaNext = _isPointInArea(points[0], area);\n\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n\n    if (!inArea) {\n      continue;\n    }\n\n    point = points[i];\n\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n\n  if (options.spanGaps) {\n    points = points.filter(pt => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n\n  return parent;\n}\n\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = element => window.getComputedStyle(element, null);\n\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\n\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\n\nfunction getCanvasPosition(evt, canvas) {\n  const e = evt.native || evt;\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {\n    offsetX,\n    offsetY\n  } = source;\n  let box = false;\n  let x, y;\n\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n\n  return {\n    x,\n    y,\n    box\n  };\n}\n\nfunction getRelativePosition(evt, chart) {\n  const {\n    canvas,\n    currentDevicePixelRatio\n  } = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {\n    x,\n    y,\n    box\n  } = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {\n    width,\n    height\n  } = chart;\n\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = v => Math.round(v * 10) / 10;\n\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {\n    width,\n    height\n  } = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n\n  return {\n    width,\n    height\n  };\n}\n\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n\n  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n\n  return false;\n}\n\nconst supportsEventListenerOptions = function () {\n  let passiveSupported = false;\n\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {}\n\n  return passiveSupported;\n}();\n\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n  };\n}\n\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {\n    x: p1.cp2x,\n    y: p1.cp2y\n  };\n  const cp2 = {\n    x: p2.cp1x,\n    y: p2.cp1y\n  };\n\n  const a = _pointInLine(p1, cp1, t);\n\n  const b = _pointInLine(cp1, cp2, t);\n\n  const c = _pointInLine(cp2, p2, t);\n\n  const d = _pointInLine(a, b, t);\n\n  const e = _pointInLine(b, c, t);\n\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\n\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n\n  return formatter;\n}\n\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function (rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n\n    setWidth(w) {\n      width = w;\n    },\n\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n\n      return align === 'right' ? 'left' : 'right';\n    },\n\n    xPlus(x, value) {\n      return x - value;\n    },\n\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    }\n\n  };\n};\n\nconst getLeftToRightAdapter = function () {\n  return {\n    x(x) {\n      return x;\n    },\n\n    setWidth(w) {},\n\n    textAlign(align) {\n      return align;\n    },\n\n    xPlus(x, value) {\n      return x + value;\n    },\n\n    leftForLtr(x, _itemWidth) {\n      return x;\n    }\n\n  };\n};\n\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\n\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle\n    };\n  }\n\n  return {\n    between: (n, s, e) => n >= Math.min(s, e) && n <= Math.max(e, s),\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({\n  start,\n  end,\n  count,\n  loop,\n  style\n}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const {\n    between,\n    normalize\n  } = propertyFn(property);\n  const count = points.length;\n  let {\n    start,\n    end,\n    loop\n  } = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n\n      start--;\n      end--;\n    }\n\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n\n  return {\n    start,\n    end,\n    loop,\n    style: segment.style\n  };\n}\n\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const count = points.length;\n  const {\n    compare,\n    between,\n    normalize\n  } = propertyFn(property);\n  const {\n    start,\n    end,\n    loop,\n    style\n  } = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n\n  const shouldStart = () => inside || startIsBefore();\n\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({\n        start: subStart,\n        end: i,\n        loop,\n        count,\n        style\n      }));\n      subStart = null;\n    }\n\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({\n      start: subStart,\n      end,\n      loop,\n      count,\n      style\n    }));\n  }\n\n  return result;\n}\n\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n\n  return result;\n}\n\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  start %= count;\n\n  if (loop) {\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  end %= count;\n  return {\n    start,\n    end\n  };\n}\n\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({\n          start: start % count,\n          end: (end - 1) % count,\n          loop\n        });\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n\n      if (prev.skip) {\n        start = end;\n      }\n    }\n\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({\n      start: start % count,\n      end: last % count,\n      loop\n    });\n  }\n\n  return result;\n}\n\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {\n    start,\n    end\n  } = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{\n      start,\n      end,\n      loop\n    }], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const baseStyle = readStyle(line.options);\n  const count = points.length;\n  const result = [];\n  let start = segments[0].start;\n  let i = start;\n\n  for (const segment of segments) {\n    let prevStyle = baseStyle;\n    let prev = points[start % count];\n    let style;\n\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext({\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex: line._datasetIndex\n      }));\n\n      if (styleChanged(style, prevStyle)) {\n        result.push({\n          start: start,\n          end: i - 1,\n          loop: segment.loop,\n          style: prevStyle\n        });\n        prevStyle = style;\n        start = i - 1;\n      }\n\n      prev = pt;\n      prevStyle = style;\n    }\n\n    if (start < i - 1) {\n      result.push({\n        start,\n        end: i - 1,\n        loop: segment.loop,\n        style\n      });\n      start = i - 1;\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n\n// CONCATENATED MODULE: ./node_modules/chart.js/dist/chart.esm.js\n/*!\n * Chart.js v3.5.1\n * https://www.chartjs.org\n * (c) 2021 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\nclass chart_esm_Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  _refresh() {\n    const me = this;\n\n    if (me._request) {\n      return;\n    }\n\n    me._running = true;\n    me._request = requestAnimFrame.call(window, () => {\n      me._update();\n\n      me._request = null;\n\n      if (me._running) {\n        me._refresh();\n      }\n    });\n  }\n\n  _update(date = Date.now()) {\n    const me = this;\n    let remaining = 0;\n\n    me._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n\n        me._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n\n        me._notify(chart, anims, date, 'complete');\n\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    me._lastDate = date;\n\n    if (remaining === 0) {\n      me._running = false;\n    }\n  }\n\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n\n    return anims;\n  }\n\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n\n    this._getAnims(chart).items.push(...items);\n  }\n\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  start(chart) {\n    const anims = this._charts.get(chart);\n\n    if (!anims) {\n      return;\n    }\n\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n\n    const anims = this._charts.get(chart);\n\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n\n    return true;\n  }\n\n  stop(chart) {\n    const anims = this._charts.get(chart);\n\n    if (!anims || !anims.items.length) {\n      return;\n    }\n\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n\n    anims.items = [];\n\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n\n}\n\nvar animator = new chart_esm_Animator();\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n\n  color(from, to, factor) {\n    const c0 = helpers_segment_color(from || transparent);\n    const c1 = c0.valid && helpers_segment_color(to || transparent);\n    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n  },\n\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n\n};\n\nclass chart_esm_Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    const me = this;\n\n    if (me._active) {\n      me._notify(false);\n\n      const currentValue = me._target[me._prop];\n      const elapsed = date - me._start;\n      const remain = me._duration - elapsed;\n      me._start = date;\n      me._duration = Math.floor(Math.max(remain, cfg.duration));\n      me._total += elapsed;\n      me._loop = !!cfg.loop;\n      me._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      me._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    const me = this;\n\n    if (me._active) {\n      me.tick(Date.now());\n      me._active = false;\n\n      me._notify(false);\n    }\n  }\n\n  tick(date) {\n    const me = this;\n    const elapsed = date - me._start;\n    const duration = me._duration;\n    const prop = me._prop;\n    const from = me._from;\n    const loop = me._loop;\n    const to = me._to;\n    let factor;\n    me._active = from !== to && (loop || elapsed < duration);\n\n    if (!me._active) {\n      me._target[prop] = to;\n\n      me._notify(true);\n\n      return;\n    }\n\n    if (elapsed < 0) {\n      me._target[prop] = from;\n      return;\n    }\n\n    factor = elapsed / duration % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = me._easing(Math.min(1, Math.max(0, factor)));\n    me._target[prop] = me._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({\n        res,\n        rej\n      });\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined\n});\nconst chart_esm_animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: name => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  }\n});\ndefaults.describe('animations', {\n  _fallback: 'animation'\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      }\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      }\n    }\n  }\n});\n\nclass chart_esm_Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n\n      if (!isObject(cfg)) {\n        return;\n      }\n\n      const resolved = {};\n\n      for (const option of chart_esm_animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach(prop => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {});\n    }\n\n    return animations;\n  }\n\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new chart_esm_Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n\n    return animations;\n  }\n\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n\n  let options = target.options;\n\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {\n      $shared: false,\n      $animations: {}\n    });\n  }\n\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n\n      break;\n    }\n\n    otherValue = stack.values[datasetIndex];\n\n    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n      value += otherValue;\n    }\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || stacked === undefined && meta.stack !== undefined;\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {\n    min,\n    max,\n    minDefined,\n    maxDefined\n  } = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive) {\n  for (const meta of vScale.getMatchingVisibleMetas('bar').reverse()) {\n    const value = stack[meta.index];\n\n    if (positive && value > 0 || !positive && value < 0) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {\n    chart,\n    _cachedMeta: meta\n  } = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {\n    iScale,\n    vScale,\n    index: datasetIndex\n  } = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {\n      [iAxis]: index,\n      [vAxis]: value\n    } = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true);\n    stack._bottom = getLastIndexInStack(stack, vScale, false);\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return Object.assign(Object.create(parent), {\n    active: false,\n    dataset: undefined,\n    datasetIndex: index,\n    index,\n    mode: 'default',\n    type: 'dataset'\n  });\n}\n\nfunction createDataContext(parent, index, element) {\n  return Object.assign(Object.create(parent), {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n\n    delete stacks[axis][datasetIndex];\n  }\n}\n\nconst isDirectUpdateMode = mode => mode === 'reset' || mode === 'none';\n\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\n\nclass chart_esm_DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n\n  initialize() {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.configure();\n    me.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    me.addElements();\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const me = this;\n    const chart = me.chart;\n    const meta = me._cachedMeta;\n    const dataset = me.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = me.getScaleForId(xid);\n    meta.yScale = me.getScaleForId(yid);\n    meta.rScale = me.getScaleForId(rid);\n    meta.iScale = me.getScaleForId(iid);\n    meta.vScale = me.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale ? meta.vScale : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  _destroy() {\n    const meta = this._cachedMeta;\n\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  _dataCheck() {\n    const me = this;\n    const dataset = me.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = me._data;\n\n    if (isObject(data)) {\n      me._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, me);\n        const meta = me._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, me);\n      }\n\n      me._syncList = [];\n      me._data = data;\n    }\n  }\n\n  addElements() {\n    const me = this;\n    const meta = me._cachedMeta;\n\n    me._dataCheck();\n\n    if (me.datasetElementType) {\n      meta.dataset = new me.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const dataset = me.getDataset();\n    let stackChanged = false;\n\n    me._dataCheck();\n\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    me._resyncElements(resetNewElements);\n\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(me, meta._parsed);\n    }\n  }\n\n  configure() {\n    const me = this;\n    const config = me.chart.config;\n    const scopeKeys = config.datasetScopeKeys(me._type);\n    const scopes = config.getOptionScopes(me.getDataset(), scopeKeys, true);\n    me.options = config.createResolver(scopes, me.getContext());\n    me._parsing = me.options.parsing;\n  }\n\n  parse(start, count) {\n    const me = this;\n    const {\n      _cachedMeta: meta,\n      _data: data\n    } = me;\n    const {\n      iScale,\n      _stacked\n    } = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (me._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = me.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = me.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = me.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n\n          prev = cur;\n        }\n      }\n\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(me, parsed);\n    }\n  }\n\n  parsePrimitiveData(meta, data, start, count) {\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n\n    return parsed;\n  }\n\n  parseArrayData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n\n    return parsed;\n  }\n\n  parseObjectData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const {\n      xAxisKey = 'x',\n      yAxisKey = 'y'\n    } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n\n    return parsed;\n  }\n\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {\n      mode\n    });\n  }\n\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n\n    if (stack && values) {\n      stack.values = values;\n      range.min = Math.min(range.min, value);\n      range.max = Math.max(range.max, value);\n      value = applyStack(stack, parsedValue, this._cachedMeta.index, {\n        all: true\n      });\n    }\n\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  getMinMax(scale, canStack) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n\n    const otherScale = me._getOtherScale(scale);\n\n    const stack = canStack && meta._stacked && {\n      keys: getSortedDatasetIndices(me.chart, true),\n      values: null\n    };\n    const range = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n    const {\n      min: otherMin,\n      max: otherMax\n    } = getUserBounds(otherScale);\n    let i, value, parsed, otherValue;\n\n    function _skip() {\n      parsed = _parsed[i];\n      value = parsed[scale.axis];\n      otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(value) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n\n      me.updateRangeFromParsed(range, scale, parsed, stack);\n\n      if (sorted) {\n        break;\n      }\n    }\n\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n\n        me.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n\n    return values;\n  }\n\n  getMaxOverflow() {\n    return false;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = me.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  _update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.configure();\n    me._cachedDataOpts = {};\n    me.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(me.options.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));\n  }\n\n  update(mode) {}\n\n  draw() {\n    const me = this;\n    const ctx = me._ctx;\n    const chart = me.chart;\n    const meta = me._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = me._drawStart || 0;\n    const count = me._drawCount || elements.length - start;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n\n      if (element.hidden) {\n        continue;\n      }\n\n      if (element.active) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  getContext(index, active, mode) {\n    const me = this;\n    const dataset = me.getDataset();\n    let context;\n\n    if (index >= 0 && index < me._cachedMeta.data.length) {\n      const element = me._cachedMeta.data[index];\n      context = element.$context || (element.$context = createDataContext(me.getContext(), index, element));\n      context.parsed = me.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = me.$context || (me.$context = createDatasetContext(me.chart.getContext(), me.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = me.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const me = this;\n    const active = mode === 'active';\n    const cache = me._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = me.enableOptionSharing && defined(index);\n\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n\n    const config = me.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(me._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n\n    const context = () => me.getContext(index, active);\n\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n  _resolveAnimations(index, transition, active) {\n    const me = this;\n    const chart = me.chart;\n    const cache = me._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n\n    if (cached) {\n      return cached;\n    }\n\n    let options;\n\n    if (chart.options.animation !== false) {\n      const config = me.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(me._type, transition);\n      const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, me.getContext(index, active, transition));\n    }\n\n    const animations = new chart_esm_Animations(chart, options && options.animations);\n\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: !active && this.getSharedOptions(options) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  _resyncElements(resetNewElements) {\n    const me = this;\n    const data = me._data;\n    const elements = me._cachedMeta.data;\n\n    for (const [method, arg1, arg2] of me._syncList) {\n      me[method](arg1, arg2);\n    }\n\n    me._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      me.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      me._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      me._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  _insertElements(start, count, resetNewElements = true) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = arr => {\n      arr.length += count;\n\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new me.dataElementType();\n    }\n\n    if (me._parsing) {\n      move(meta._parsed);\n    }\n\n    me.parse(start, count);\n\n    if (resetNewElements) {\n      me.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {}\n\n  _removeElements(start, count) {\n    const me = this;\n    const meta = me._cachedMeta;\n\n    if (me._parsing) {\n      const removed = meta._parsed.splice(start, count);\n\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n\n    meta.data.splice(start, count);\n  }\n\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    this._sync(['_removeElements', start, count]);\n\n    this._sync(['_insertElements', start, arguments.length - 2]);\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n\n}\n\nchart_esm_DatasetController.defaults = {};\nchart_esm_DatasetController.prototype.datasetElementType = null;\nchart_esm_DatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale) {\n  if (!scale._cache.$bar) {\n    const metas = scale.getMatchingVisibleMetas('bar');\n    let values = [];\n\n    for (let i = 0, ilen = metas.length; i < ilen; i++) {\n      values = values.concat(metas[i].controller.getAllParsedValues(scale));\n    }\n\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n\n  return scale._cache.$bar;\n}\n\nfunction computeMinSampleSize(scale) {\n  const values = getAllScaleValues(scale);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - size / 2\n  };\n}\n\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n\n  return {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  };\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  const {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  } = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nclass chart_esm_BarController extends chart_esm_DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  parseObjectData(meta, data, start, count) {\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const {\n      xAxisKey = 'x',\n      yAxisKey = 'y'\n    } = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n\n    return parsed;\n  }\n\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  getMaxOverflow() {\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const parsed = me.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    const me = this;\n    me.enableOptionSharing = true;\n    super.initialize();\n    const meta = me._cachedMeta;\n    meta.stack = me.getDataset().stack;\n  }\n\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      index,\n      _cachedMeta: {\n        vScale\n      }\n    } = me;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n\n    const ruler = me._getRuler();\n\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = me.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n        base,\n        head: base\n      } : me._calculateBarValuePixels(i);\n\n      const ipixels = me._calculateBarIndexPixels(i, ruler);\n\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || me.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n\n      setBorderSkipped(properties, properties.options || bars[i].options, stack, index);\n      me.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  _getStacks(last, dataIndex) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const iScale = meta.iScale;\n    const metasets = iScale.getMatchingVisibleMetas(me._type);\n    const stacked = iScale.options.stacked;\n    const ilen = metasets.length;\n    const stacks = [];\n    let i, item;\n\n    for (i = 0; i < ilen; ++i) {\n      item = metasets[i];\n\n      if (!item.controller.options.grouped) {\n        continue;\n      }\n\n      if (typeof dataIndex !== 'undefined') {\n        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];\n\n        if (isNullOrUndef(val) || isNaN(val)) {\n          continue;\n        }\n      }\n\n      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === undefined && item.stack === undefined) {\n        stacks.push(item.stack);\n      }\n\n      if (item.index === last) {\n        break;\n      }\n    }\n\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n\n    const index = name !== undefined ? stacks.indexOf(name) : -1;\n    return index === -1 ? stacks.length - 1 : index;\n  }\n\n  _getRuler() {\n    const me = this;\n    const opts = me.options;\n    const meta = me._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(iScale);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: me._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  _calculateBarValuePixels(index) {\n    const me = this;\n    const {\n      _cachedMeta: {\n        vScale,\n        _stacked\n      },\n      options: {\n        base: baseValue,\n        minBarLength\n      }\n    } = me;\n    const actualBase = baseValue || 0;\n    const parsed = me.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (me.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n\n      head = base + size;\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  _calculateBarIndexPixels(index, ruler) {\n    const me = this;\n    const scale = ruler.scale;\n    const options = me.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n\n    if (ruler.grouped) {\n      const stackCount = skipNull ? me._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack, skipNull ? index : undefined);\n\n      center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(me.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const me = this;\n    const meta = me._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (me.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(me._ctx);\n      }\n    }\n  }\n\n}\n\nchart_esm_BarController.id = 'bar';\nchart_esm_BarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nchart_esm_BarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true\n    }\n  }\n};\n\nclass chart_esm_BubbleController extends chart_esm_DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  parseObjectData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const {\n      xAxisKey = 'x',\n      yAxisKey = 'y'\n    } = this._parsing;\n    const parsed = [];\n    let i, ilen, item;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      item = data[i];\n      parsed.push({\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), i),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), i),\n        _custom: item && item.r && +item.r\n      });\n    }\n\n    return parsed;\n  }\n\n  getMaxOverflow() {\n    const {\n      data,\n      _parsed\n    } = this._cachedMeta;\n    let max = 0;\n\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);\n    }\n\n    return max > 0 && max;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = me.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const me = this;\n    const points = me._cachedMeta.data;\n    me.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      iScale,\n      vScale\n    } = me._cachedMeta;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && me.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = me.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      me.updateElement(point, i, properties, mode);\n    }\n\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    if (values.$shared) {\n      values = Object.assign({}, values, {\n        $shared: false\n      });\n    }\n\n    const radius = values.radius;\n\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n\n}\n\nchart_esm_BubbleController.id = 'bubble';\nchart_esm_BubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nchart_esm_BubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n\n  return {\n    ratioX,\n    ratioY,\n    offsetX,\n    offsetY\n  };\n}\n\nclass chart_esm_DoughnutController extends chart_esm_DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    let i, ilen;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      meta._parsed[i] = +data[i];\n    }\n  }\n\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    const me = this;\n\n    for (let i = 0; i < me.chart.data.datasets.length; ++i) {\n      if (me.chart.isDatasetVisible(i)) {\n        const controller = me.chart.getDatasetMeta(i).controller;\n\n        const rotation = controller._getRotation();\n\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min\n    };\n  }\n\n  update(mode) {\n    const me = this;\n    const chart = me.chart;\n    const {\n      chartArea\n    } = chart;\n    const meta = me._cachedMeta;\n    const arcs = meta.data;\n    const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs) + me.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(me.options.cutout, maxSize), 1);\n\n    const chartWeight = me._getRingWeight(me.index);\n\n    const {\n      circumference,\n      rotation\n    } = me._getRotationExtents();\n\n    const {\n      ratioX,\n      ratioY,\n      offsetX,\n      offsetY\n    } = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(me.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n\n    const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();\n\n    me.offsetX = offsetX * outerRadius;\n    me.offsetY = offsetY * outerRadius;\n    meta.total = me.calculateTotal();\n    me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);\n    me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);\n    me.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  _circumference(i, reset) {\n    const me = this;\n    const opts = me.options;\n    const meta = me._cachedMeta;\n\n    const circumference = me._getCircumference();\n\n    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n\n    return me.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const chart = me.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : me.innerRadius;\n    const outerRadius = animateScale ? 0 : me.outerRadius;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n\n    let startAngle = me._getRotation();\n\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += me._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = me._circumference(i, reset);\n\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + me.offsetX,\n        y: centerY + me.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || me.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n\n      startAngle += circumference;\n      me.updateElement(arc, i, properties, mode);\n    }\n\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const chart = me.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    const me = this;\n    let max = 0;\n    const chart = me.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n\n          if (controller !== me) {\n            controller.configure();\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n\n    return max;\n  }\n\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n\n}\n\nchart_esm_DoughnutController.id = 'doughnut';\nchart_esm_DoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    }\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r'\n};\nchart_esm_DoughnutController.descriptors = {\n  _scriptable: name => name !== 'spacing',\n  _indexable: name => name !== 'spacing'\n};\nchart_esm_DoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            const {\n              labels: {\n                pointStyle\n              }\n            } = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n\n      },\n\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return dataLabel;\n        }\n\n      }\n    }\n  }\n};\n\nclass chart_esm_LineController extends chart_esm_DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const {\n      dataset: line,\n      data: points = [],\n      _dataset\n    } = meta;\n    const animationsDisabled = me.chart._animationsDisabled;\n    let {\n      start,\n      count\n    } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    me._drawStart = start;\n    me._drawCount = count;\n\n    if (scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    line._datasetIndex = me.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = me.resolveDatasetElementOptions(mode);\n\n    if (!me.options.showLine) {\n      options.borderWidth = 0;\n    }\n\n    options.segment = me.options.segment;\n    me.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    me.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      iScale,\n      vScale,\n      _stacked\n    } = me._cachedMeta;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const spanGaps = me.options.spanGaps;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = me.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && me.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = me.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? me.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;\n      properties.parsed = parsed;\n\n      if (includeOptions) {\n        properties.options = sharedOptions || me.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        me.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  getMaxOverflow() {\n    const me = this;\n    const meta = me._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(me.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n\n}\n\nchart_esm_LineController.id = 'line';\nchart_esm_LineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false\n};\nchart_esm_LineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category'\n    },\n    _value_: {\n      type: 'linear'\n    }\n  }\n};\n\nfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {\n      iScale,\n      _parsed\n    } = meta;\n    const axis = iScale.axis;\n    const {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n    }\n\n    if (maxDefined) {\n      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {\n    start,\n    count\n  };\n}\n\nfunction scaleRangesChanged(meta) {\n  const {\n    xScale,\n    yScale,\n    _scaleRanges\n  } = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n\n  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nclass chart_esm_PolarAreaController extends chart_esm_DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const chart = me.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value\n    };\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  _updateRadius() {\n    const me = this;\n    const chart = me.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    me.outerRadius = outerRadius - radiusLength * me.index;\n    me.innerRadius = me.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const chart = me.chart;\n    const dataset = me.getDataset();\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = me._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / me.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += me._computeAngle(i, mode, defaultAngle);\n    }\n\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n\n      let endAngle = angle + me._computeAngle(i, mode, defaultAngle);\n\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: me.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      me.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const dataset = this.getDataset();\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n  }\n\n}\n\nchart_esm_PolarAreaController.id = 'polarArea';\nchart_esm_PolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    }\n  },\n  indexAxis: 'r',\n  startAngle: 0\n};\nchart_esm_PolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            const {\n              labels: {\n                pointStyle\n              }\n            } = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n\n      },\n\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends chart_esm_DoughnutController {}\n\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends chart_esm_DatasetController {\n  getLabelAndValue(index) {\n    const me = this;\n    const vScale = me._cachedMeta.vScale;\n    const parsed = me.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n\n    if (mode !== 'resize') {\n      const options = me.resolveDatasetElementOptions(mode);\n\n      if (!me.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      me.updateElement(line, undefined, properties, mode);\n    }\n\n    me.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const me = this;\n    const dataset = me.getDataset();\n    const scale = me._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = me.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      me.updateElement(point, i, properties, mode);\n    }\n  }\n\n}\n\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  }\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear'\n    }\n  }\n};\n\nclass ScatterController extends chart_esm_LineController {}\n\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\nvar controllers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BarController: chart_esm_BarController,\n  BubbleController: chart_esm_BubbleController,\n  DoughnutController: chart_esm_DoughnutController,\n  LineController: chart_esm_LineController,\n  PolarAreaController: chart_esm_PolarAreaController,\n  PieController: PieController,\n  RadarController: RadarController,\n  ScatterController: ScatterController\n});\n\nfunction chart_esm_abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n\n  formats() {\n    return chart_esm_abstract();\n  }\n\n  parse(value, format) {\n    return chart_esm_abstract();\n  }\n\n  format(timestamp, format) {\n    return chart_esm_abstract();\n  }\n\n  add(timestamp, amount, unit) {\n    return chart_esm_abstract();\n  }\n\n  diff(a, b, unit) {\n    return chart_esm_abstract();\n  }\n\n  startOf(timestamp, unit, weekday) {\n    return chart_esm_abstract();\n  }\n\n  endOf(timestamp, unit) {\n    return chart_esm_abstract();\n  }\n\n}\n\nDateAdapter.override = function (members) {\n  Object.assign(DateAdapter.prototype, members);\n};\n\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction chart_esm_getRelativePosition(e, chart) {\n  if ('native' in e) {\n    return {\n      x: e.x,\n      y: e.y\n    };\n  }\n\n  return getRelativePosition(e, chart);\n}\n\nfunction evaluateAllVisibleItems(chart, handler) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  let index, data, element;\n\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    ({\n      index,\n      data\n    } = metasets[i]);\n\n    for (let j = 0, jlen = data.length; j < jlen; ++j) {\n      element = data[j];\n\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {\n    controller,\n    data,\n    _sorted\n  } = metaset;\n  const iScale = controller._cachedMeta.iScale;\n\n  if (iScale && axis === iScale.axis && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {\n          lo: start.lo,\n          hi: end.hi\n        };\n      }\n    }\n  }\n\n  return {\n    lo: 0,\n    hi: data.length - 1\n  };\n}\n\nfunction optimizedEvaluateItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {\n      index,\n      data\n    } = metasets[i];\n    const {\n      lo,\n      hi\n    } = binarySearch(metasets[i], axis, value, intersect);\n\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function (pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\nfunction getIntersectItems(chart, position, axis, useFinalPosition) {\n  const items = [];\n\n  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n\n  const evaluationFunc = function (element, datasetIndex, index) {\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({\n        element,\n        datasetIndex,\n        index\n      });\n    }\n  };\n\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition) {\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  let items = [];\n\n  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n\n  const evaluationFunc = function (element, datasetIndex, index) {\n    if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n\n    if (!_isPointInArea(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n\n    if (distance < minDistance) {\n      items = [{\n        element,\n        datasetIndex,\n        index\n      }];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({\n        element,\n        datasetIndex,\n        index\n      });\n    }\n  };\n\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\nfunction getAxisItems(chart, e, options, useFinalPosition) {\n  const position = chart_esm_getRelativePosition(e, chart);\n  const items = [];\n  const axis = options.axis;\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({\n        element,\n        datasetIndex,\n        index\n      });\n    }\n\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      intersectsItem = true;\n    }\n  });\n\n  if (options.intersect && !intersectsItem) {\n    return [];\n  }\n\n  return items;\n}\n\nvar Interaction = {\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach(meta => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        if (element && !element.skip) {\n          elements.push({\n            element,\n            datasetIndex: meta.index,\n            index\n          });\n        }\n      });\n      return elements;\n    },\n\n    dataset(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n\n        for (let i = 0; i < data.length; ++i) {\n          items.push({\n            element: data[i],\n            datasetIndex,\n            index: i\n          });\n        }\n      }\n\n      return items;\n    },\n\n    point(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getIntersectItems(chart, position, axis, useFinalPosition);\n    },\n\n    nearest(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\n    },\n\n    x(chart, e, options, useFinalPosition) {\n      options.axis = 'x';\n      return getAxisItems(chart, e, options, useFinalPosition);\n    },\n\n    y(chart, e, options, useFinalPosition) {\n      options.axis = 'y';\n      return getAxisItems(chart, e, options, useFinalPosition);\n    }\n\n  }\n};\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({\n      position: pos,\n      options: {\n        stack,\n        stackWeight = 1\n      }\n    } = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && pos + stack,\n      stackWeight\n    });\n  }\n\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n\n  for (const wrap of layouts) {\n    const {\n      stack,\n      pos,\n      stackWeight\n    } = wrap;\n\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n\n    const _stack = stacks[stack] || (stacks[stack] = {\n      count: 0,\n      placed: 0,\n      weight: 0,\n      size: 0\n    });\n\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n\n  return stacks;\n}\n\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {\n    vBoxMaxWidth,\n    hBoxMaxHeight\n  } = params;\n  let i, ilen, layout;\n\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {\n      fullSize\n    } = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {\n    pos,\n    box\n  } = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n\n    const stack = stacks[layout.stack] || {\n      size: 0,\n      count: 1\n    };\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal ? {\n    same: widthChanged,\n    other: heightChanged\n  } : {\n    same: heightChanged,\n    other: widthChanged\n  };\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    positions.forEach(pos => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n    const {\n      same,\n      other\n    } = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {\n    x,\n    y\n  } = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {\n      count: 1,\n      placed: 0,\n      weight: 1\n    };\n    const weight = layout.stackWeight / stack.weight || 1;\n\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\ndefaults.set('layout', {\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n\n    item._layers = item._layers || function () {\n      return [{\n        z: 0,\n\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w\n    };\n    each(boxes.chartArea, layout => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h);\n    });\n  }\n\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n\n  releaseContext(context) {\n    return false;\n  }\n\n  addEventListener(chart, type, listener) {}\n\n  removeEventListener(chart, type, listener) {}\n\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  isAttached(canvas) {\n    return true;\n  }\n\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\nconst eventListenerOptions = supportsEventListenerOptions ? {\n  passive: true\n} : false;\n\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {\n    x,\n    y\n  } = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null\n  };\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n\n  const container = canvas && _getParentNode(canvas);\n\n  const element = container || canvas;\n  const observer = new MutationObserver(entries => {\n    const parent = _getParentNode(element);\n\n    entries.forEach(entry => {\n      for (let i = 0; i < entry.addedNodes.length; i++) {\n        const added = entry.addedNodes[i];\n\n        if (added === element || added === parent) {\n          listener(entry.target);\n        }\n      }\n    });\n  });\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n\n  const container = canvas && _getParentNode(canvas);\n\n  if (!container) {\n    return;\n  }\n\n  const observer = new MutationObserver(entries => {\n    entries.forEach(entry => {\n      for (let i = 0; i < entry.removedNodes.length; i++) {\n        if (entry.removedNodes[i] === canvas) {\n          listener();\n          break;\n        }\n      }\n    });\n  });\n  observer.observe(container, {\n    childList: true\n  });\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n\n  const container = canvas && _getParentNode(canvas);\n\n  if (!container) {\n    return;\n  }\n\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n\n    if (width === 0 && height === 0) {\n      return;\n    }\n\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled(event => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, args => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\n\nclass chart_esm_DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  releaseContext(context) {\n    const canvas = context.canvas;\n\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach(prop => {\n      const value = initial[prop];\n\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach(key => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n\n    return !!(container && container.isConnected);\n  }\n\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return BasicPlatform;\n  }\n\n  return chart_esm_DomPlatform;\n}\n\nclass chart_esm_Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n\n  tooltipPosition(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  getProps(props, final) {\n    const me = this;\n    const anims = this.$animations;\n\n    if (!final || !anims) {\n      return me;\n    }\n\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];\n    });\n    return ret;\n  }\n\n}\n\nchart_esm_Element.defaults = {};\nchart_esm_Element.defaultRoutes = undefined;\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {\n      notation,\n      minimumFractionDigits: numDecimal,\n      maximumFractionDigits: numDecimal\n    };\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n\n    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n\n    return '';\n  }\n\n};\n\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n\n  return delta;\n}\n\nvar Ticks = {\n  formatters\n};\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: name => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: name => name !== 'borderDash' && name !== 'tickBorderDash'\n});\ndefaults.describe('scales', {\n  _fallback: 'scale'\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: name => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: name => name !== 'backdropPadding'\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    chart_esm_skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      chart_esm_skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n\n    chart_esm_skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n\n  chart_esm_skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n\n  const tickLength = scale._tickSize();\n\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n\n  return Math.max(spacing, 1);\n}\n\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\nfunction chart_esm_skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n\n  return diff;\n}\n\nconst reverseAlign = align => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\n\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\n\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n\n  return result;\n}\n\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n\n    lineValue += validIndex < index ? offset : -offset;\n\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n\n  return lineValue;\n}\n\nfunction garbageCollect(caches, length) {\n  each(caches, cache => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return lines * font.lineHeight + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return Object.assign(Object.create(parent), {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return Object.assign(Object.create(parent), {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n\n  if (reverse && position !== 'right' || !reverse && position === 'right') {\n    ret = reverseAlign(ret);\n  }\n\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {\n    top,\n    left,\n    bottom,\n    right,\n    chart\n  } = scale;\n  const {\n    chartArea,\n    scales\n  } = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n\n  return {\n    titleX,\n    titleY,\n    maxWidth,\n    rotation\n  };\n}\n\nclass chart_esm_Scale extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  init(options) {\n    const me = this;\n    me.options = options.setContext(me.getContext());\n    me.axis = options.axis;\n    me._userMin = me.parse(options.min);\n    me._userMax = me.parse(options.max);\n    me._suggestedMin = me.parse(options.suggestedMin);\n    me._suggestedMax = me.parse(options.suggestedMax);\n  }\n\n  parse(raw, index) {\n    return raw;\n  }\n\n  getUserBounds() {\n    let {\n      _userMin,\n      _userMax,\n      _suggestedMin,\n      _suggestedMax\n    } = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n\n  getMinMax(canStack) {\n    const me = this;\n    let {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {\n        min,\n        max\n      };\n    }\n\n    const metas = me.getMatchingVisibleMetas();\n\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(me, canStack);\n\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  getPadding() {\n    const me = this;\n    return {\n      left: me.paddingLeft || 0,\n      top: me.paddingTop || 0,\n      right: me.paddingRight || 0,\n      bottom: me.paddingBottom || 0\n    };\n  }\n\n  getTicks() {\n    return this.ticks;\n  }\n\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const tickOpts = me.options.ticks;\n    const sampleSize = tickOpts.sampleSize;\n    me.beforeUpdate();\n    me.maxWidth = maxWidth;\n    me.maxHeight = maxHeight;\n    me._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    me.ticks = null;\n    me._labelSizes = null;\n    me._gridLineItems = null;\n    me._labelItems = null;\n    me.beforeSetDimensions();\n    me.setDimensions();\n    me.afterSetDimensions();\n    me._maxLength = me.isHorizontal() ? me.width + margins.left + margins.right : me.height + margins.top + margins.bottom;\n\n    if (!me._dataLimitsCached) {\n      me.beforeDataLimits();\n      me.determineDataLimits();\n      me.afterDataLimits();\n      me._range = _addGrace(me, me.options.grace);\n      me._dataLimitsCached = true;\n    }\n\n    me.beforeBuildTicks();\n    me.ticks = me.buildTicks() || [];\n    me.afterBuildTicks();\n    const samplingEnabled = sampleSize < me.ticks.length;\n\n    me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);\n\n    me.configure();\n    me.beforeCalculateLabelRotation();\n    me.calculateLabelRotation();\n    me.afterCalculateLabelRotation();\n\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      me.ticks = autoSkip(me, me.ticks);\n      me._labelSizes = null;\n    }\n\n    if (samplingEnabled) {\n      me._convertTicksToLabels(me.ticks);\n    }\n\n    me.beforeFit();\n    me.fit();\n    me.afterFit();\n    me.afterUpdate();\n  }\n\n  configure() {\n    const me = this;\n    let reversePixels = me.options.reverse;\n    let startPixel, endPixel;\n\n    if (me.isHorizontal()) {\n      startPixel = me.left;\n      endPixel = me.right;\n    } else {\n      startPixel = me.top;\n      endPixel = me.bottom;\n      reversePixels = !reversePixels;\n    }\n\n    me._startPixel = startPixel;\n    me._endPixel = endPixel;\n    me._reversePixels = reversePixels;\n    me._length = endPixel - startPixel;\n    me._alignToPixels = me.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n\n  setDimensions() {\n    const me = this;\n\n    if (me.isHorizontal()) {\n      me.width = me.maxWidth;\n      me.left = 0;\n      me.right = me.width;\n    } else {\n      me.height = me.maxHeight;\n      me.top = 0;\n      me.bottom = me.height;\n    }\n\n    me.paddingLeft = 0;\n    me.paddingTop = 0;\n    me.paddingRight = 0;\n    me.paddingBottom = 0;\n  }\n\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    const me = this;\n    me.chart.notifyPlugins(name, me.getContext());\n    callback(me.options[name], [me]);\n  }\n\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n\n  determineDataLimits() {}\n\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n\n  buildTicks() {\n    return [];\n  }\n\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n\n  generateTickLabels(ticks) {\n    const me = this;\n    const tickOpts = me.options.ticks;\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], me);\n    }\n  }\n\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n\n  calculateLabelRotation() {\n    const me = this;\n    const options = me.options;\n    const tickOpts = options.ticks;\n    const numTicks = me.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\n      me.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = me._getLabelSizes();\n\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    const maxWidth = _limitValue(me.chart.width - maxLabelWidth, 0, me.maxWidth);\n\n    tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = me.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, me.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    me.labelRotation = labelRotation;\n  }\n\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n\n  fit() {\n    const me = this;\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {\n      chart,\n      options: {\n        ticks: tickOpts,\n        title: titleOpts,\n        grid: gridOpts\n      }\n    } = me;\n\n    const display = me._isVisible();\n\n    const isHorizontal = me.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = me.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      if (tickOpts.display && me.ticks.length) {\n        const {\n          first,\n          last,\n          widest,\n          highest\n        } = me._getLabelSizes();\n\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(me.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n\n        me._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    me._handleMargins();\n\n    if (isHorizontal) {\n      me.width = me._length = chart.width - me._margins.left - me._margins.right;\n      me.height = minSize.height;\n    } else {\n      me.width = minSize.width;\n      me.height = me._length = chart.height - me._margins.top - me._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const me = this;\n    const {\n      ticks: {\n        align,\n        padding\n      },\n      position\n    } = me.options;\n    const isRotated = me.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && me.axis === 'x';\n\n    if (me.isHorizontal()) {\n      const offsetLeft = me.getPixelForTick(0) - me.left;\n      const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);\n      me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      me.paddingTop = paddingTop + padding;\n      me.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  _handleMargins() {\n    const me = this;\n\n    if (me._margins) {\n      me._margins.left = Math.max(me.paddingLeft, me._margins.left);\n      me._margins.top = Math.max(me.paddingTop, me._margins.top);\n      me._margins.right = Math.max(me.paddingRight, me._margins.right);\n      me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n\n  isHorizontal() {\n    const {\n      axis,\n      position\n    } = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  _convertTicksToLabels(ticks) {\n    const me = this;\n    me.beforeTickToLabelConversion();\n    me.generateTickLabels(ticks);\n    let i, ilen;\n\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    me.afterTickToLabelConversion();\n  }\n\n  _getLabelSizes() {\n    const me = this;\n    let labelSizes = me._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = me.options.ticks.sampleSize;\n      let ticks = me.ticks;\n\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);\n    }\n\n    return labelSizes;\n  }\n\n  _computeLabelSizes(ticks, length) {\n    const {\n      ctx,\n      _longestTextCache: caches\n    } = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {\n        data: {},\n        gc: []\n      };\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = idx => ({\n      width: widths[idx] || 0,\n      height: heights[idx] || 0\n    });\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights\n    };\n  }\n\n  getLabelForValue(value) {\n    return value;\n  }\n\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n\n  getValueForPixel(pixel) {}\n\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getPixelForDecimal(decimal) {\n    const me = this;\n\n    if (me._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = me._startPixel + decimal * me._length;\n    return _int16Range(me._alignToPixels ? _alignPixel(me.chart, pixel, 0) : pixel);\n  }\n\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  getBaseValue() {\n    const {\n      min,\n      max\n    } = this;\n    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n  }\n\n  getContext(index) {\n    const me = this;\n    const ticks = me.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context || (tick.$context = createTickContext(me.getContext(), index, tick));\n    }\n\n    return me.$context || (me.$context = createScaleContext(me.chart.getContext(), me));\n  }\n\n  _tickSize() {\n    const me = this;\n    const optionTicks = me.options.ticks;\n    const rot = toRadians(me.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = me._getLabelSizes();\n\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  _computeGridLineItems(chartArea) {\n    const me = this;\n    const axis = me.axis;\n    const chart = me.chart;\n    const options = me.options;\n    const {\n      grid,\n      position\n    } = options;\n    const offset = grid.offset;\n    const isHorizontal = me.isHorizontal();\n    const ticks = me.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(me.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n\n    const alignBorderValue = function (pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(me.bottom);\n      ty1 = me.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(me.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = me.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(me.right);\n      tx1 = me.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(me.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = me.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(me.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = grid.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(me, i, offset);\n\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset\n      });\n    }\n\n    me._ticksLength = ticksLength;\n    me._borderValue = borderValue;\n    return items;\n  }\n\n  _computeLabelItems(chartArea) {\n    const me = this;\n    const axis = me.axis;\n    const options = me.options;\n    const {\n      position,\n      ticks: optionTicks\n    } = options;\n    const isHorizontal = me.isHorizontal();\n    const ticks = me.ticks;\n    const {\n      align,\n      crossAlign,\n      padding,\n      mirror\n    } = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(me.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = me.bottom - hTickAndPadding;\n      textAlign = me._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = me.top + hTickAndPadding;\n      textAlign = me._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = me._getYAxisLabelAlignment(tl);\n\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = me._getYAxisLabelAlignment(tl);\n\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n\n      textAlign = me._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = me.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n\n      textAlign = me._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = me._getLabelSizes();\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(me.getContext(i));\n      pixel = me.getPixelForTick(i) + optionTicks.labelOffset;\n      font = me._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n\n        switch (textBaseline) {\n          case 'middle':\n            top -= height / 2;\n            break;\n\n          case 'bottom':\n            top -= height;\n            break;\n        }\n\n        switch (textAlign) {\n          case 'center':\n            left -= width / 2;\n            break;\n\n          case 'right':\n            left -= width;\n            break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor\n        };\n      }\n\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const me = this;\n    const {\n      position,\n      ticks\n    } = me.options;\n    const rotation = -toRadians(me.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const me = this;\n    const {\n      position,\n      ticks: {\n        crossAlign,\n        mirror,\n        padding\n      }\n    } = me.options;\n\n    const labelSizes = me._getLabelSizes();\n\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = me.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = me.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= widest / 2;\n        } else {\n          textAlign = 'left';\n          x = me.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = me.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= widest / 2;\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = me.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = me.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {\n      textAlign,\n      x\n    };\n  }\n\n  _computeLabelArea() {\n    const me = this;\n\n    if (me.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = me.chart;\n    const position = me.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {\n        top: 0,\n        left: me.left,\n        bottom: chart.height,\n        right: me.right\n      };\n    }\n\n    if (position === 'top' || position === 'bottom') {\n      return {\n        top: me.top,\n        left: 0,\n        bottom: me.bottom,\n        right: chart.width\n      };\n    }\n  }\n\n  drawBackground() {\n    const {\n      ctx,\n      options: {\n        backgroundColor\n      },\n      left,\n      top,\n      width,\n      height\n    } = this;\n\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const me = this;\n    const grid = me.options.grid;\n\n    if (!me._isVisible() || !grid.display) {\n      return 0;\n    }\n\n    const ticks = me.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n\n    if (index >= 0) {\n      const opts = grid.setContext(me.getContext(index));\n      return opts.lineWidth;\n    }\n\n    return 0;\n  }\n\n  drawGrid(chartArea) {\n    const me = this;\n    const grid = me.options.grid;\n    const ctx = me.ctx;\n\n    const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\n\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine({\n            x: item.x1,\n            y: item.y1\n          }, {\n            x: item.x2,\n            y: item.y2\n          }, item);\n        }\n\n        if (grid.drawTicks) {\n          drawLine({\n            x: item.tx1,\n            y: item.ty1\n          }, {\n            x: item.tx2,\n            y: item.ty2\n          }, {\n            color: item.tickColor,\n            width: item.tickWidth,\n            borderDash: item.tickBorderDash,\n            borderDashOffset: item.tickBorderDashOffset\n          });\n        }\n      }\n    }\n  }\n\n  drawBorder() {\n    const me = this;\n    const {\n      chart,\n      ctx,\n      options: {\n        grid\n      }\n    } = me;\n    const borderOpts = grid.setContext(me.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n\n    if (!axisWidth) {\n      return;\n    }\n\n    const lastLineWidth = grid.setContext(me.getContext(0)).lineWidth;\n    const borderValue = me._borderValue;\n    let x1, x2, y1, y2;\n\n    if (me.isHorizontal()) {\n      x1 = _alignPixel(chart, me.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, me.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  drawLabels(chartArea) {\n    const me = this;\n    const optionTicks = me.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = me.ctx;\n\n    const area = me._computeLabelArea();\n\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));\n\n    let i, ilen;\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  drawTitle() {\n    const {\n      ctx,\n      options: {\n        position,\n        title,\n        reverse\n      }\n    } = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    } = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY]\n    });\n  }\n\n  draw(chartArea) {\n    const me = this;\n\n    if (!me._isVisible()) {\n      return;\n    }\n\n    me.drawBackground();\n    me.drawGrid(chartArea);\n    me.drawBorder();\n    me.drawTitle();\n    me.drawLabels(chartArea);\n  }\n\n  _layers() {\n    const me = this;\n    const opts = me.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n\n    if (!me._isVisible() || me.draw !== chart_esm_Scale.prototype.draw) {\n      return [{\n        z: tz,\n\n        draw(chartArea) {\n          me.draw(chartArea);\n        }\n\n      }];\n    }\n\n    return [{\n      z: gz,\n\n      draw(chartArea) {\n        me.drawBackground();\n        me.drawGrid(chartArea);\n        me.drawTitle();\n      }\n\n    }, {\n      z: gz + 1,\n\n      draw() {\n        me.drawBorder();\n      }\n\n    }, {\n      z: tz,\n\n      draw(chartArea) {\n        me.drawLabels(chartArea);\n      }\n\n    }];\n  }\n\n  getMatchingVisibleMetas(type) {\n    const me = this;\n    const metas = me.chart.getSortedVisibleDatasetMetas();\n    const axisID = me.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n\n      if (meta[axisID] === me.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  _maxDigits() {\n    const me = this;\n\n    const fontSize = me._resolveTickFontOptions(0).lineHeight;\n\n    return (me.isHorizontal() ? me.width : me.height) / fontSize;\n  }\n\n}\n\nclass chart_esm_TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  register(item) {\n    const me = this;\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      parentScope = me.register(proto);\n    }\n\n    const items = me.items;\n    const id = item.id;\n    const scope = me.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n\n    if (me.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  get(id) {\n    return this.items[id];\n  }\n\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [parentScope ? defaults.get(parentScope) : {}, defaults.get(scope), item.defaults]);\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass chart_esm_Registry {\n  constructor() {\n    this.controllers = new chart_esm_TypedRegistry(chart_esm_DatasetController, 'datasets', true);\n    this.elements = new chart_esm_TypedRegistry(chart_esm_Element, 'elements');\n    this.plugins = new chart_esm_TypedRegistry(Object, 'plugins');\n    this.scales = new chart_esm_TypedRegistry(chart_esm_Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  _each(method, args, typedRegistry) {\n    const me = this;\n    [...args].forEach(arg => {\n      const reg = typedRegistry || me._getRegistryForType(arg);\n\n      if (typedRegistry || reg.isForType(arg) || reg === me.plugins && arg.id) {\n        me._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || me._getRegistryForType(item);\n\n          me._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n\n    return this.plugins;\n  }\n\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n\n    return item;\n  }\n\n}\n\nvar chart_esm_registry = new chart_esm_Registry();\n\nclass chart_esm_PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  notify(chart, hook, args, filter) {\n    const me = this;\n\n    if (hook === 'beforeInit') {\n      me._init = me._createDescriptors(chart, true);\n\n      me._notify(me._init, chart, 'install');\n    }\n\n    const descriptors = filter ? me._descriptors(chart).filter(filter) : me._descriptors(chart);\n\n    const result = me._notify(descriptors, chart, hook, args);\n\n    if (hook === 'destroy') {\n      me._notify(descriptors, chart, 'stop');\n\n      me._notify(me._init, chart, 'uninstall');\n    }\n\n    return result;\n  }\n\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n\n}\n\nfunction allPlugins(config) {\n  const plugins = [];\n  const keys = Object.keys(chart_esm_registry.plugins.items);\n\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(chart_esm_registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n    }\n  }\n\n  return plugins;\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n\n  if (options === true) {\n    return {};\n  }\n\n  return options;\n}\n\nfunction createDescriptors(chart, plugins, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (let i = 0; i < plugins.length; i++) {\n    const plugin = plugins[i];\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n\n    if (opts === null) {\n      continue;\n    }\n\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, plugin, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, plugin, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {\n    scales: {}\n  };\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{\n      axis\n    }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{\n        axis\n      }, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nclass chart_esm_Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n\n    this._resolverCache.clear();\n  }\n\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType, () => [[`datasets.${datasetType}`, '']]);\n  }\n\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`, () => [[`datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}`], [`datasets.${datasetType}`, '']]);\n  }\n\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`, () => [[`datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, '']]);\n  }\n\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`, () => [[`plugins.${id}`, ...(plugin.additionalOptionScopes || [])]]);\n  }\n\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n\n    let cache = _scopeCache.get(mainScope);\n\n    if (!cache || resetCache) {\n      cache = new Map();\n\n      _scopeCache.set(mainScope, cache);\n    }\n\n    return cache;\n  }\n\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {\n      options,\n      type\n    } = this;\n\n    const cache = this._cachedScopes(mainScope, resetCache);\n\n    const cached = cache.get(keyLists);\n\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, helpers_segment_descriptors, key));\n    });\n    const array = Array.from(scopes);\n\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n\n    return array;\n  }\n\n  chartOptionScopes() {\n    const {\n      options,\n      type\n    } = this;\n    return [options, overrides[type] || {}, defaults.datasets[type] || {}, {\n      type\n    }, defaults, helpers_segment_descriptors];\n  }\n\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {\n      $shared: true\n    };\n    const {\n      resolver,\n      subPrefixes\n    } = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n\n    return result;\n  }\n\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {\n      resolver\n    } = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n  }\n\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n\n  return cached;\n}\n\nfunction needContext(proxy, names) {\n  const {\n    isScriptable,\n    isIndexable\n  } = _descriptors(proxy);\n\n  for (const prop of names) {\n    if (isScriptable(prop) && isFunction(proxy[prop]) || isIndexable(prop) && isArray(proxy[prop])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar version = \"3.5.1\";\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\n\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\n\nfunction compare2Level(l1, l2) {\n  return function (a, b) {\n    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n\n  return item;\n}\n\nconst instances = {};\n\nconst getChart = key => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter(c => c.canvas === canvas).pop();\n};\n\nclass chart_esm_Chart {\n  constructor(item, userConfig) {\n    const me = this;\n    const config = this.config = new chart_esm_Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n\n    if (existingChart) {\n      throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas can be reused.');\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), me.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    const context = me.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new chart_esm_PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(() => this.update('resize'), options.resizeDelay || 0);\n    instances[me.id] = me;\n\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(me, 'complete', onAnimationsComplete);\n    animator.listen(me, 'progress', onAnimationProgress);\n\n    me._initialize();\n\n    if (me.attached) {\n      me.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {\n      options: {\n        aspectRatio,\n        maintainAspectRatio\n      },\n      width,\n      height,\n      _aspectRatio\n    } = this;\n\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  _initialize() {\n    const me = this;\n    me.notifyPlugins('beforeInit');\n\n    if (me.options.responsive) {\n      me.resize();\n    } else {\n      retinaScale(me, me.options.devicePixelRatio);\n    }\n\n    me.bindEvents();\n    me.notifyPlugins('afterInit');\n    return me;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {\n        width,\n        height\n      };\n    }\n  }\n\n  _resize(width, height) {\n    const me = this;\n    const options = me.options;\n    const canvas = me.canvas;\n    const aspectRatio = options.maintainAspectRatio && me.aspectRatio;\n    const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || me.platform.getDevicePixelRatio();\n    me.width = newSize.width;\n    me.height = newSize.height;\n    me._aspectRatio = me.aspectRatio;\n\n    if (!retinaScale(me, newRatio, true)) {\n      return;\n    }\n\n    me.notifyPlugins('resize', {\n      size: newSize\n    });\n    callback(options.onResize, [me, newSize], me);\n\n    if (me.attached) {\n      if (me._doResize()) {\n        me.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  buildOrUpdateScales() {\n    const me = this;\n    const options = me.options;\n    const scaleOpts = options.scales;\n    const scales = me.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(Object.keys(scaleOpts).map(id => {\n        const scaleOptions = scaleOpts[id];\n        const axis = determineAxis(id, scaleOptions);\n        const isRadial = axis === 'r';\n        const isHorizontal = axis === 'x';\n        return {\n          options: scaleOptions,\n          dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n          dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n        };\n      }));\n    }\n\n    each(items, item => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = chart_esm_registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: me.ctx,\n          chart: me\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, scale => {\n      layouts.configure(me, scale, scale.options);\n      layouts.addBox(me, scale);\n    });\n  }\n\n  _updateMetasets() {\n    const me = this;\n    const metasets = me._metasets;\n    const numData = me.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        me._destroyDatasetMeta(i);\n      }\n\n      metasets.splice(numData, numMeta - numData);\n    }\n\n    me._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  _removeUnreferencedMetasets() {\n    const me = this;\n    const {\n      _metasets: metasets,\n      data: {\n        datasets\n      }\n    } = me;\n\n    if (metasets.length > datasets.length) {\n      delete me._stacks;\n    }\n\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        me._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const me = this;\n    const newControllers = [];\n    const datasets = me.data.datasets;\n    let i, ilen;\n\n    me._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = me.getDatasetMeta(i);\n      const type = dataset.type || me.config.type;\n\n      if (meta.type && meta.type !== type) {\n        me._destroyDatasetMeta(i);\n\n        meta = me.getDatasetMeta(i);\n      }\n\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = me.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = chart_esm_registry.getController(type);\n        const {\n          datasetElementType,\n          dataElementType\n        } = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: chart_esm_registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && chart_esm_registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(me, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    me._updateMetasets();\n\n    return newControllers;\n  }\n\n  _resetElements() {\n    const me = this;\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      me.getDatasetMeta(datasetIndex).controller.reset();\n    }, me);\n  }\n\n  reset() {\n    this._resetElements();\n\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const me = this;\n    const config = me.config;\n    config.update();\n    me._options = config.createResolver(config.chartOptionScopes(), me.getContext());\n    each(me.scales, scale => {\n      layouts.removeBox(me, scale);\n    });\n    const animsDisabled = me._animationsDisabled = !me.options.animation;\n    me.ensureScalesHaveIDs();\n    me.buildOrUpdateScales();\n    const existingEvents = new Set(Object.keys(me._listeners));\n    const newEvents = new Set(me.options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== me.options.responsive) {\n      me.unbindEvents();\n      me.bindEvents();\n    }\n\n    me._plugins.invalidate();\n\n    if (me.notifyPlugins('beforeUpdate', {\n      mode,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    const newControllers = me.buildOrUpdateControllers();\n    me.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n\n    for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\n      const {\n        controller\n      } = me.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n\n    me._minPadding = minPadding;\n\n    me._updateLayout(minPadding);\n\n    if (!animsDisabled) {\n      each(newControllers, controller => {\n        controller.reset();\n      });\n    }\n\n    me._updateDatasets(mode);\n\n    me.notifyPlugins('afterUpdate', {\n      mode\n    });\n\n    me._layers.sort(compare2Level('z', '_idx'));\n\n    if (me._lastEvent) {\n      me._eventHandler(me._lastEvent, true);\n    }\n\n    me.render();\n  }\n\n  _updateLayout(minPadding) {\n    const me = this;\n\n    if (me.notifyPlugins('beforeLayout', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    layouts.update(me, me.width, me.height, minPadding);\n    const area = me.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    me._layers = [];\n    each(me.boxes, box => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n\n      if (box.configure) {\n        box.configure();\n      }\n\n      me._layers.push(...box._layers());\n    }, me);\n\n    me._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    me.notifyPlugins('afterLayout');\n  }\n\n  _updateDatasets(mode) {\n    const me = this;\n    const isFunction = typeof mode === 'function';\n\n    if (me.notifyPlugins('beforeDatasetsUpdate', {\n      mode,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n      me._updateDataset(i, isFunction ? mode({\n        datasetIndex: i\n      }) : mode);\n    }\n\n    me.notifyPlugins('afterDatasetsUpdate', {\n      mode\n    });\n  }\n\n  _updateDataset(index, mode) {\n    const me = this;\n    const meta = me.getDatasetMeta(index);\n    const args = {\n      meta,\n      index,\n      mode,\n      cancelable: true\n    };\n\n    if (me.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    me.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    const me = this;\n\n    if (me.notifyPlugins('beforeRender', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    if (animator.has(me)) {\n      if (me.attached && !animator.running(me)) {\n        animator.start(me);\n      }\n    } else {\n      me.draw();\n      onAnimationsComplete({\n        chart: me\n      });\n    }\n  }\n\n  draw() {\n    const me = this;\n    let i;\n\n    if (me._resizeBeforeDraw) {\n      const {\n        width,\n        height\n      } = me._resizeBeforeDraw;\n\n      me._resize(width, height);\n\n      me._resizeBeforeDraw = null;\n    }\n\n    me.clear();\n\n    if (me.width <= 0 || me.height <= 0) {\n      return;\n    }\n\n    if (me.notifyPlugins('beforeDraw', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    const layers = me._layers;\n\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(me.chartArea);\n    }\n\n    me._drawDatasets();\n\n    for (; i < layers.length; ++i) {\n      layers[i].draw(me.chartArea);\n    }\n\n    me.notifyPlugins('afterDraw');\n  }\n\n  _getSortedDatasetMetas(filterVisible) {\n    const me = this;\n    const metasets = me._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  _drawDatasets() {\n    const me = this;\n\n    if (me.notifyPlugins('beforeDatasetsDraw', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    const metasets = me.getSortedVisibleDatasetMetas();\n\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      me._drawDataset(metasets[i]);\n    }\n\n    me.notifyPlugins('afterDatasetsDraw');\n  }\n\n  _drawDataset(meta) {\n    const me = this;\n    const ctx = me.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = me.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (me.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? me.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    me.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const me = this;\n    const dataset = me.data.datasets[datasetIndex];\n    const metasets = me._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = {\n      chart: this,\n      type: 'chart'\n    });\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const me = this;\n    const mode = visible ? 'show' : 'hide';\n    const meta = me.getDatasetMeta(datasetIndex);\n\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      me.update();\n    } else {\n      me.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {\n        visible\n      });\n      me.update(ctx => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  _destroyDatasetMeta(datasetIndex) {\n    const me = this;\n    const meta = me._metasets && me._metasets[datasetIndex];\n\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n\n      delete me._metasets[datasetIndex];\n    }\n  }\n\n  destroy() {\n    const me = this;\n    const {\n      canvas,\n      ctx\n    } = me;\n    let i, ilen;\n    me.stop();\n    animator.remove(me);\n\n    for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n      me._destroyDatasetMeta(i);\n    }\n\n    me.config.clearCache();\n\n    if (canvas) {\n      me.unbindEvents();\n      clearCanvas(canvas, ctx);\n      me.platform.releaseContext(ctx);\n      me.canvas = null;\n      me.ctx = null;\n    }\n\n    me.notifyPlugins('destroy');\n    delete instances[me.id];\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  bindEvents() {\n    this.bindUserEvents();\n\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  bindUserEvents() {\n    const me = this;\n    const listeners = me._listeners;\n    const platform = me.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(me, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = function (e, x, y) {\n      e.offsetX = x;\n      e.offsetY = y;\n\n      me._eventHandler(e);\n    };\n\n    each(me.options.events, type => _add(type, listener));\n  }\n\n  bindResponsiveEvents() {\n    const me = this;\n\n    if (!me._responsiveListeners) {\n      me._responsiveListeners = {};\n    }\n\n    const listeners = me._responsiveListeners;\n    const platform = me.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(me, type, listener);\n      listeners[type] = listener;\n    };\n\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(me, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (me.canvas) {\n        me.resize(width, height);\n      }\n    };\n\n    let detached;\n\n    const attached = () => {\n      _remove('attach', attached);\n\n      me.attached = true;\n      me.resize();\n\n      _add('resize', listener);\n\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      me.attached = false;\n\n      _remove('resize', listener);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(me.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  unbindEvents() {\n    const me = this;\n    each(me._listeners, (listener, type) => {\n      me.platform.removeEventListener(me, type, listener);\n    });\n    me._listeners = {};\n    each(me._responsiveListeners, (listener, type) => {\n      me.platform.removeEventListener(me, type, listener);\n    });\n    me._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  setActiveElements(activeElements) {\n    const me = this;\n    const lastActive = me._active || [];\n    const active = activeElements.map(({\n      datasetIndex,\n      index\n    }) => {\n      const meta = me.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      me._active = active;\n\n      me._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  _updateHoverStyles(active, lastActive, replay) {\n    const me = this;\n    const hoverOptions = me.options.hover;\n\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      me.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      me.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  _eventHandler(e, replay) {\n    const me = this;\n    const args = {\n      event: e,\n      replay,\n      cancelable: true\n    };\n\n    const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.type);\n\n    if (me.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = me._handleEvent(e, replay);\n\n    args.cancelable = false;\n    me.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      me.render();\n    }\n\n    return me;\n  }\n\n  _handleEvent(e, replay) {\n    const me = this;\n    const {\n      _active: lastActive = [],\n      options\n    } = me;\n    const hoverOptions = options.hover;\n    const useFinalPosition = replay;\n    let active = [];\n    let changed = false;\n    let lastEvent = null;\n\n    if (e.type !== 'mouseout') {\n      active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n      lastEvent = e.type === 'click' ? me._lastEvent : e;\n    }\n\n    me._lastEvent = null;\n\n    if (_isPointInArea(e, me.chartArea, me._minPadding)) {\n      callback(options.onHover, [e, active, me], me);\n\n      if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {\n        callback(options.onClick, [e, active, me], me);\n      }\n    }\n\n    changed = !_elementsEqual(active, lastActive);\n\n    if (changed || replay) {\n      me._active = active;\n\n      me._updateHoverStyles(active, lastActive, replay);\n    }\n\n    me._lastEvent = lastEvent;\n    return changed;\n  }\n\n}\n\nconst invalidatePlugins = () => each(chart_esm_Chart.instances, chart => chart._plugins.invalidate());\n\nconst enumerable = true;\nObject.defineProperties(chart_esm_Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: chart_esm_registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      chart_esm_registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      chart_esm_registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {\n    startAngle,\n    pixelMargin,\n    x,\n    y,\n    outerRadius,\n    innerRadius\n  } = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  const computeOuterLimit = val => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n  };\n}\n\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta)\n  };\n}\n\nfunction pathArc(ctx, element, offset, spacing, end) {\n  const {\n    x,\n    y,\n    startAngle: start,\n    pixelMargin,\n    innerRadius: innerR\n  } = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {\n    outerStart,\n    outerEnd,\n    innerStart,\n    innerEnd\n  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n\n  if (outerEnd > 0) {\n    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n  }\n\n  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n  ctx.lineTo(p4.x, p4.y);\n\n  if (innerEnd > 0) {\n    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n  }\n\n  ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);\n\n  if (innerStart > 0) {\n    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n  }\n\n  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n  ctx.lineTo(p8.x, p8.y);\n\n  if (outerStart > 0) {\n    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(ctx, element, offset, spacing) {\n  const {\n    fullCircles,\n    startAngle,\n    circumference\n  } = element;\n  let endAngle = element.endAngle;\n\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU);\n\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {\n    x,\n    y,\n    startAngle,\n    pixelMargin,\n    fullCircles\n  } = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\n\nfunction drawBorder(ctx, element, offset, spacing, endAngle) {\n  const {\n    options\n  } = element;\n  const inner = options.borderAlign === 'inner';\n\n  if (!options.borderWidth) {\n    return;\n  }\n\n  if (inner) {\n    ctx.lineWidth = options.borderWidth * 2;\n    ctx.lineJoin = 'round';\n  } else {\n    ctx.lineWidth = options.borderWidth;\n    ctx.lineJoin = 'bevel';\n  }\n\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.stroke();\n}\n\nclass chart_esm_ArcElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {\n      angle,\n      distance\n    } = getAngleFromPoint(point, {\n      x: chartX,\n      y: chartY\n    });\n    const {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius,\n      circumference\n    } = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n\n    const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n\n    const withinRadius = distance >= innerRadius + rAdjust && distance <= outerRadius + rAdjust;\n    return betweenAngles && withinRadius;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius\n    } = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);\n    const {\n      offset,\n      spacing\n    } = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx) {\n    const me = this;\n    const {\n      options,\n      circumference\n    } = me;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    me.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n    me.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n    let radiusOffset = 0;\n\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (me.startAngle + me.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n\n      if (me.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, me, radiusOffset, spacing);\n    drawBorder(ctx, me, radiusOffset, spacing, endAngle);\n    ctx.restore();\n  }\n\n}\n\nchart_esm_ArcElement.id = 'arc';\nchart_esm_ArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined\n};\nchart_esm_ArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {\n    start: paramsStart = 0,\n    end: paramsEnd = count - 1\n  } = params;\n  const {\n    start: segmentStart,\n    end: segmentEnd\n  } = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\nfunction pathSegment(ctx, line, segment, params) {\n  const {\n    points,\n    options\n  } = line;\n  const {\n    count,\n    start,\n    loop,\n    ilen\n  } = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {\n    move = true,\n    reverse\n  } = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {\n    count,\n    start,\n    ilen\n  } = pathVars(points, segment, params);\n  const {\n    move = true,\n    reverse\n  } = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;\n\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n\n    lastY = y;\n  }\n\n  drawX();\n}\n\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n\n  if (!path) {\n    path = line._path = new Path2D();\n\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {\n    segments,\n    options\n  } = line;\n\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n\n    if (segmentMethod(ctx, line, segment, {\n      start,\n      end: start + count - 1\n    })) {\n      ctx.closePath();\n    }\n\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && line.segments.length === 1) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nclass chart_esm_LineElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const me = this;\n    const options = me.options;\n\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !me._pointsUpdated) {\n      const loop = options.spanGaps ? me._loop : me._fullLoop;\n\n      _updateBezierControlPoints(me._points, options, chartArea, loop, indexAxis);\n\n      me._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    const me = this;\n    me._points = points;\n    delete me._segments;\n    delete me._path;\n    me._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  interpolate(point, property) {\n    const me = this;\n    const options = me.options;\n    const value = point[property];\n    const points = me.points;\n\n    const segments = _boundSegments(me, {\n      property,\n      start: value,\n      end: value\n    });\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n\n    const _interpolate = _getInterpolationMethod(options);\n\n    let i, ilen;\n\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {\n        start,\n        end\n      } = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  path(ctx, start, count) {\n    const me = this;\n    const segments = me.segments;\n\n    const segmentMethod = _getSegmentMethod(me);\n\n    let loop = me._loop;\n    start = start || 0;\n    count = count || me.points.length - start;\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, me, segment, {\n        start,\n        end: start + count - 1\n      });\n    }\n\n    return !!loop;\n  }\n\n  draw(ctx, chartArea, start, count) {\n    const me = this;\n    const options = me.options || {};\n    const points = me.points || [];\n\n    if (!points.length || !options.borderWidth) {\n      return;\n    }\n\n    ctx.save();\n    draw(ctx, me, start, count);\n    ctx.restore();\n\n    if (me.animated) {\n      me._pointsUpdated = false;\n      me._path = undefined;\n    }\n  }\n\n}\n\nchart_esm_LineElement.id = 'line';\nchart_esm_LineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0\n};\nchart_esm_LineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nchart_esm_LineElement.descriptors = {\n  _scriptable: true,\n  _indexable: name => name !== 'borderDash' && name !== 'fill'\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {\n    [axis]: value\n  } = el.getProps([axis], useFinalPosition);\n  return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\n\nclass chart_esm_PointElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx, area) {\n    const me = this;\n    const options = me.options;\n\n    if (me.skip || options.radius < 0.1 || !_isPointInArea(me, area, me.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, me.x, me.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n\n}\n\nchart_esm_PointElement.id = 'point';\nchart_esm_PointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nchart_esm_PointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {\n    x,\n    y,\n    base,\n    width,\n    height\n  } = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {\n    enableBorderRadius\n  } = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nclass chart_esm_BarElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const {\n      inner,\n      outer\n    } = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    const inflateAmount = 0.33;\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = options.borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount, outer));\n    ctx.fillStyle = options.backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      base,\n      horizontal\n    } = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n\n}\n\nchart_esm_BarElement.id = 'bar';\nchart_esm_BarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  enableBorderRadius: true,\n  pointStyle: undefined\n};\nchart_esm_BarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nvar chart_esm_elements = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArcElement: chart_esm_ArcElement,\n  LineElement: chart_esm_LineElement,\n  PointElement: chart_esm_PointElement,\n  BarElement: chart_esm_BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {\n      x: pointAx,\n      y: pointAy\n    } = data[a];\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({ ...data[intermediateIndex1],\n            x: avgX\n          });\n        }\n\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({ ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      value: data\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach(dataset => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {\n    iScale\n  } = meta;\n  const {\n    min,\n    max,\n    minDefined,\n    maxDefined\n  } = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {\n    start,\n    count\n  };\n}\n\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {\n        _data,\n        indexAxis\n      } = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n\n      if (meta.type !== 'line') {\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n\n      if (chart.options.parsing) {\n        return;\n      }\n\n      let {\n        start,\n        count\n      } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function () {\n            return this._decimated;\n          },\n          set: function (d) {\n            this._data = d;\n          }\n        });\n      }\n\n      let decimated;\n\n      switch (options.algorithm) {\n        case 'lttb':\n          decimated = lttbDecimation(data, start, count, availableWidth, options);\n          break;\n\n        case 'min-max':\n          decimated = minMaxDecimation(data, start, count, availableWidth);\n          break;\n\n        default:\n          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n\n};\n\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n\n  return fill;\n}\n\nfunction decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    if (fill[0] === '-' || fill[0] === '+') {\n      target = index + target;\n    }\n\n    if (target === index || target < 0 || target >= count) {\n      return false;\n    }\n\n    return target;\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction computeLinearBoundary(source) {\n  const {\n    scale = {},\n    fill\n  } = source;\n  let target = null;\n  let horizontal;\n\n  if (fill === 'start') {\n    target = scale.bottom;\n  } else if (fill === 'end') {\n    target = scale.top;\n  } else if (isObject(fill)) {\n    target = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    target = scale.getBasePixel();\n  }\n\n  if (isNumberFinite(target)) {\n    horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? target : null,\n      y: horizontal ? null : target\n    };\n  }\n\n  return null;\n}\n\nclass chart_esm_simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {\n      x,\n      y,\n      radius\n    } = this;\n    bounds = bounds || {\n      start: 0,\n      end: TAU\n    };\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {\n      x,\n      y,\n      radius\n    } = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n\n}\n\nfunction computeCircularBoundary(source) {\n  const {\n    scale,\n    fill\n  } = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const target = [];\n  const start = options.reverse ? scale.max : scale.min;\n  const end = options.reverse ? scale.min : scale.max;\n  let i, center, value;\n\n  if (fill === 'start') {\n    value = start;\n  } else if (fill === 'end') {\n    value = end;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n\n  if (options.grid.circular) {\n    center = scale.getPointPositionForValue(0, start);\n    return new chart_esm_simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n\n  return target;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n\n  return computeLinearBoundary(source);\n}\n\nfunction findSegmentEnd(start, end, points) {\n  for (; end > start; end--) {\n    const point = points[end];\n\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n\n  return end;\n}\n\nfunction pointsFromSegments(boundary, line) {\n  const {\n    x = null,\n    y = null\n  } = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({\n    start,\n    end\n  }) => {\n    end = findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n\n    if (y !== null) {\n      points.push({\n        x: first.x,\n        y\n      });\n      points.push({\n        x: last.x,\n        y\n      });\n    } else if (x !== null) {\n      points.push({\n        x,\n        y: first.y\n      });\n      points.push({\n        x,\n        y: last.y\n      });\n    }\n  });\n  return points;\n}\n\nfunction buildStackLine(source) {\n  const {\n    chart,\n    scale,\n    index,\n    line\n  } = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(chart, index);\n  linesBelow.push(createBoundaryLine({\n    x: null,\n    y: scale.bottom\n  }, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n\n  return new chart_esm_LineElement({\n    points,\n    options: {}\n  });\n}\n\nconst isLineAndNotInHideAnimation = meta => meta.type === 'line' && !meta.hidden;\n\nfunction getLinesBelow(chart, index) {\n  const below = [];\n  const metas = chart.getSortedVisibleDatasetMetas();\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n\n    if (meta.index === index) {\n      break;\n    }\n\n    if (isLineAndNotInHideAnimation(meta)) {\n      below.unshift(meta.dataset);\n    }\n  }\n\n  return below;\n}\n\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {\n      first,\n      last,\n      point\n    } = findPoint(line, sourcePoint, 'x');\n\n    if (!point || first && last) {\n      continue;\n    }\n\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n\n      if (!last) {\n        break;\n      }\n    }\n  }\n\n  points.push(...postponed);\n}\n\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n\n    if (pointValue >= firstValue && pointValue <= lastValue) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n\n  return {\n    first,\n    last,\n    point\n  };\n}\n\nfunction getTarget(source) {\n  const {\n    chart,\n    fill,\n    line\n  } = source;\n\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof chart_esm_simpleArc) {\n    return boundary;\n  }\n\n  return createBoundaryLine(boundary, line);\n}\n\nfunction createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new chart_esm_LineElement({\n    points,\n    options: {\n      tension: 0\n    },\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\nfunction _clip(ctx, target, clipY) {\n  ctx.beginPath();\n  target.path(ctx);\n  ctx.lineTo(target.last().x, clipY);\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n\n  return {\n    property,\n    start,\n    end\n  };\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {\n      start,\n      end\n    } = segment;\n    end = findSegmentEnd(start, end, points);\n    const bounds = getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n\n  return parts;\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {\n    top,\n    bottom\n  } = scale.chart.chartArea;\n  const {\n    property,\n    start,\n    end\n  } = bounds || {};\n\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nfunction _fill(ctx, cfg) {\n  const {\n    line,\n    target,\n    property,\n    color,\n    scale\n  } = cfg;\n\n  const segments = _segments(line, target, property);\n\n  for (const {\n    source: src,\n    target: tgt,\n    start,\n    end\n  } of segments) {\n    const {\n      style: {\n        backgroundColor = color\n      } = {}\n    } = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {\n        move: lineLoop,\n        reverse: true\n      });\n      loop = lineLoop && targetLoop;\n\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {\n    line,\n    target,\n    above,\n    below,\n    area,\n    scale\n  } = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    _clip(ctx, target, area.top);\n\n    _fill(ctx, {\n      line,\n      target,\n      color: above,\n      scale,\n      property\n    });\n\n    ctx.restore();\n    ctx.save();\n\n    _clip(ctx, target, area.bottom);\n  }\n\n  _fill(ctx, {\n    line,\n    target,\n    color: below,\n    scale,\n    property\n  });\n\n  ctx.restore();\n}\n\nfunction drawfill(ctx, source, area) {\n  const target = getTarget(source);\n  const {\n    line,\n    scale,\n    axis\n  } = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {\n    above = color,\n    below = color\n  } = fillOption || {};\n\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {\n      line,\n      target,\n      above,\n      below,\n      area,\n      scale,\n      axis\n    });\n    unclipArea(ctx);\n  }\n}\n\nvar plugin_filler = {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof chart_esm_LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n\n      if (draw) {\n        drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (source) {\n        drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {\n    boxHeight = fontSize,\n    boxWidth = fontSize\n  } = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nclass chart_esm_Legend extends chart_esm_Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    me.maxWidth = maxWidth;\n    me.maxHeight = maxHeight;\n    me._margins = margins;\n    me.setDimensions();\n    me.buildLabels();\n    me.fit();\n  }\n\n  setDimensions() {\n    const me = this;\n\n    if (me.isHorizontal()) {\n      me.width = me.maxWidth;\n      me.left = me._margins.left;\n      me.right = me.width;\n    } else {\n      me.height = me.maxHeight;\n      me.top = me._margins.top;\n      me.bottom = me.height;\n    }\n  }\n\n  buildLabels() {\n    const me = this;\n    const labelOpts = me.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter(item => labelOpts.filter(item, me.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));\n    }\n\n    if (me.options.reverse) {\n      legendItems.reverse();\n    }\n\n    me.legendItems = legendItems;\n  }\n\n  fit() {\n    const me = this;\n    const {\n      options,\n      ctx\n    } = me;\n\n    if (!options.display) {\n      me.width = me.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n\n    const titleHeight = me._computeTitleHeight();\n\n    const {\n      boxWidth,\n      itemHeight\n    } = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n\n    if (me.isHorizontal()) {\n      width = me.maxWidth;\n      height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = me.maxHeight;\n      width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n\n    me.width = Math.min(width, options.maxWidth || me.maxWidth);\n    me.height = Math.min(height, options.maxHeight || me.maxHeight);\n  }\n\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const me = this;\n    const {\n      ctx,\n      maxWidth,\n      options: {\n        labels: {\n          padding\n        }\n      }\n    } = me;\n    const hitboxes = me.legendHitBoxes = [];\n    const lineWidths = me.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    me.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {\n        left: 0,\n        top,\n        row,\n        width: itemWidth,\n        height: itemHeight\n      };\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const me = this;\n    const {\n      ctx,\n      maxHeight,\n      options: {\n        labels: {\n          padding\n        }\n      }\n    } = me;\n    const hitboxes = me.legendHitBoxes = [];\n    const columnSizes = me.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    me.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({\n          width: currentColWidth,\n          height: currentColHeight\n        });\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      hitboxes[i] = {\n        left,\n        top: currentColHeight,\n        col,\n        width: itemWidth,\n        height: itemHeight\n      };\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({\n      width: currentColWidth,\n      height: currentColHeight\n    });\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    const me = this;\n\n    if (!me.options.display) {\n      return;\n    }\n\n    const titleHeight = me._computeTitleHeight();\n\n    const {\n      legendHitBoxes: hitboxes,\n      options: {\n        align,\n        labels: {\n          padding\n        },\n        rtl\n      }\n    } = me;\n    const rtlHelper = getRtlAdapter(rtl, me.left, me.width);\n\n    if (this.isHorizontal()) {\n      let row = 0;\n\n      let left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\n\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\n        }\n\n        hitbox.top += me.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n\n      let top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\n\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\n        }\n\n        hitbox.top = top;\n        hitbox.left += me.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    const me = this;\n\n    if (me.options.display) {\n      const ctx = me.ctx;\n      clipArea(ctx, me);\n\n      me._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  _draw() {\n    const me = this;\n    const {\n      options: opts,\n      columnSizes,\n      lineWidths,\n      ctx\n    } = me;\n    const {\n      align,\n      labels: labelOpts\n    } = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\n    const labelFont = toFont(labelOpts.font);\n    const {\n      color: fontColor,\n      padding\n    } = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    me.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {\n      boxWidth,\n      boxHeight,\n      itemHeight\n    } = getBoxSize(labelOpts, fontSize);\n\n    const drawLegendBox = function (x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxWidth * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPoint(ctx, drawOptions, centerX, centerY);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function (x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    const isHorizontal = me.isHorizontal();\n\n    const titleHeight = this._computeTitleHeight();\n\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, me.left + padding, me.right - lineWidths[0]),\n        y: me.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: me.left + padding,\n        y: _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(me.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    me.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(me.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > me.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, me.left + padding, me.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > me.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : me.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(me.ctx, opts.textDirection);\n  }\n\n  drawTitle() {\n    const me = this;\n    const opts = me.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\n    const ctx = me.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = me.left;\n    let maxWidth = me.width;\n\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...me.lineWidths);\n      y = me.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, me.right - maxWidth);\n    } else {\n      const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());\n    }\n\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  _getLegendItemAt(x, y) {\n    const me = this;\n    let i, hitBox, lh;\n\n    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n      lh = me.legendHitBoxes;\n\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n          return me.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  handleEvent(e) {\n    const me = this;\n    const opts = me.options;\n\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    const hoveredItem = me._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove') {\n      const previous = me._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, me], me);\n      }\n\n      me._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, me], me);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, me], me);\n    }\n  }\n\n}\n\nfunction isListened(type, opts) {\n  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n\n  return false;\n}\n\nvar plugin_legend = {\n  id: 'legend',\n  _element: chart_esm_Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new chart_esm_Legend({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: ctx => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {\n          labels: {\n            usePointStyle,\n            pointStyle,\n            textAlign,\n            color\n          }\n        } = chart.legend.options;\n        return chart._getSortedDatasetMetas().map(meta => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n\n    },\n    title: {\n      color: ctx => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: ''\n    }\n  },\n  descriptors: {\n    _scriptable: name => !name.startsWith('on'),\n    labels: {\n      _scriptable: name => !['generateLabels', 'filter', 'sort'].includes(name)\n    }\n  }\n};\n\nclass chart_esm_Title extends chart_esm_Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const me = this;\n    const opts = me.options;\n    me.left = 0;\n    me.top = 0;\n\n    if (!opts.display) {\n      me.width = me.height = me.right = me.bottom = 0;\n      return;\n    }\n\n    me.width = me.right = maxWidth;\n    me.height = me.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    me._padding = toPadding(opts.padding);\n\n    const textSize = lineCount * toFont(opts.font).lineHeight + me._padding.height;\n\n    if (me.isHorizontal()) {\n      me.height = textSize;\n    } else {\n      me.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {\n      top,\n      left,\n      bottom,\n      right,\n      options\n    } = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n\n      maxWidth = bottom - top;\n    }\n\n    return {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    };\n  }\n\n  draw() {\n    const me = this;\n    const ctx = me.ctx;\n    const opts = me.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + me._padding.top;\n\n    const {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    } = me._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY]\n    });\n  }\n\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new chart_esm_Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nvar plugin_title = {\n  id: 'title',\n  _element: chart_esm_Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold'\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nconst chart_esm_map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new chart_esm_Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    chart_esm_map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart_esm_map.get(chart));\n    chart_esm_map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart_esm_map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal'\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n\n};\n\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n\n  return str;\n}\n\nfunction createTooltipItem(chart, item) {\n  const {\n    element,\n    datasetIndex,\n    index\n  } = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {\n    label,\n    value\n  } = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip._chart.ctx;\n  const {\n    body,\n    footer,\n    title\n  } = tooltip;\n  const {\n    boxWidth,\n    boxHeight\n  } = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n  }\n\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n  }\n\n  if (footerLineCount) {\n    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  let widthPadding = 0;\n\n  const maxLineWidth = function (line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? boxWidth + 2 : 0;\n  each(body, bodyItem => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {\n    width,\n    height\n  };\n}\n\nfunction determineYAlign(chart, size) {\n  const {\n    y,\n    height\n  } = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > chart.height - height / 2) {\n    return 'bottom';\n  }\n\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {\n    x,\n    width\n  } = size;\n  const caret = options.caretSize + options.caretPadding;\n\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {\n    x,\n    width\n  } = size;\n  const {\n    width: chartWidth,\n    chartArea: {\n      left,\n      right\n    }\n  } = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\nfunction determineAlignment(chart, options, size) {\n  const yAlign = options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {\n    x,\n    width\n  } = size;\n\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {\n    y,\n    height\n  } = size;\n\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= height / 2;\n  }\n\n  return y;\n}\n\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {\n    caretSize,\n    caretPadding,\n    cornerRadius\n  } = options;\n  const {\n    xAlign,\n    yAlign\n  } = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const radiusAndPadding = cornerRadius + caretPadding;\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= radiusAndPadding;\n  } else if (xAlign === 'right') {\n    x += radiusAndPadding;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return Object.assign(Object.create(parent), {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nclass chart_esm_Tooltip extends chart_esm_Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._chart = config._chart;\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  _resolveAnimations() {\n    const me = this;\n    const cached = me._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = me._chart;\n    const options = me.options.setContext(me.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new chart_esm_Animations(me._chart, opts);\n\n    if (opts._cacheable) {\n      me._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  getContext() {\n    const me = this;\n    return me.$context || (me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const me = this;\n    const {\n      callbacks\n    } = options;\n    const beforeTitle = callbacks.beforeTitle.apply(me, [context]);\n    const title = callbacks.title.apply(me, [context]);\n    const afterTitle = callbacks.afterTitle.apply(me, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n\n  getBody(tooltipItems, options) {\n    const me = this;\n    const {\n      callbacks\n    } = options;\n    const bodyItems = [];\n    each(tooltipItems, context => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(me, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n\n  getFooter(tooltipItems, options) {\n    const me = this;\n    const {\n      callbacks\n    } = options;\n    const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);\n    const footer = callbacks.footer.apply(me, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n\n  _createItems(options) {\n    const me = this;\n    const active = me._active;\n    const data = me._chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(me._chart, active[i]));\n    }\n\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    each(tooltipItems, context => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(me, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(me, context));\n      labelTextColors.push(scoped.labelTextColor.call(me, context));\n    });\n    me.labelColors = labelColors;\n    me.labelPointStyles = labelPointStyles;\n    me.labelTextColors = labelTextColors;\n    me.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const me = this;\n    const options = me.options.setContext(me.getContext());\n    const active = me._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (me.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(me, active, me._eventPosition);\n      tooltipItems = me._createItems(options);\n      me.title = me.getTitle(tooltipItems, options);\n      me.beforeBody = me.getBeforeBody(tooltipItems, options);\n      me.body = me.getBody(tooltipItems, options);\n      me.afterBody = me.getAfterBody(tooltipItems, options);\n      me.footer = me.getFooter(tooltipItems, options);\n      const size = me._size = getTooltipSize(me, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(me._chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, me._chart);\n      me.xAlign = alignment.xAlign;\n      me.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    me._tooltipItems = tooltipItems;\n    me.$context = undefined;\n\n    if (properties) {\n      me._resolveAnimations().update(me, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(me, {\n        chart: me._chart,\n        tooltip: me,\n        replay\n      });\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {\n      xAlign,\n      yAlign\n    } = this;\n    const {\n      cornerRadius,\n      caretSize\n    } = options;\n    const {\n      x: ptX,\n      y: ptY\n    } = tooltipPoint;\n    const {\n      width,\n      height\n    } = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + height / 2;\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + cornerRadius + caretSize;\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - cornerRadius - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n\n      y3 = y1;\n    }\n\n    return {\n      x1,\n      x2,\n      x3,\n      y1,\n      y2,\n      y3\n    };\n  }\n\n  drawTitle(pt, ctx, options) {\n    const me = this;\n    const title = me.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\n      pt.x = getAlignedX(me, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const me = this;\n    const labelColors = me.labelColors[i];\n    const labelPointStyle = me.labelPointStyles[i];\n    const {\n      boxHeight,\n      boxWidth\n    } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(me, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = labelColors.borderWidth || 1;\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    ctx.fillStyle = me.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const me = this;\n    const {\n      body\n    } = me;\n    const {\n      bodySpacing,\n      bodyAlign,\n      displayColors,\n      boxHeight,\n      boxWidth\n    } = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\n\n    const fillLineOfText = function (line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(me, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(me.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + 1 : boxWidth + 2 : 0;\n\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = me.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n\n      if (displayColors && lines.length) {\n        me._drawColorBox(ctx, pt, i, rtlHelper, options);\n\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(me.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n\n  drawFooter(pt, ctx, options) {\n    const me = this;\n    const footer = me.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\n      pt.x = getAlignedX(me, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {\n      xAlign,\n      yAlign\n    } = this;\n    const {\n      x,\n      y\n    } = pt;\n    const {\n      width,\n      height\n    } = tooltipSize;\n    const radius = options.cornerRadius;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  _updateAnimationTarget(options) {\n    const me = this;\n    const chart = me._chart;\n    const anims = me.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n\n    if (animX || animY) {\n      const position = positioners[options.position].call(me, me._active, me._eventPosition);\n\n      if (!position) {\n        return;\n      }\n\n      const size = me._size = getTooltipSize(me, options);\n      const positionAndSize = Object.assign({}, position, me._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n\n      if (animX._to !== point.x || animY._to !== point.y) {\n        me.xAlign = alignment.xAlign;\n        me.yAlign = alignment.yAlign;\n        me.width = size.width;\n        me.height = size.height;\n        me.caretX = position.x;\n        me.caretY = position.y;\n\n        me._resolveAnimations().update(me, point);\n      }\n    }\n  }\n\n  draw(ctx) {\n    const me = this;\n    const options = me.options.setContext(me.getContext());\n    let opacity = me.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    me._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: me.width,\n      height: me.height\n    };\n    const pt = {\n      x: me.x,\n      y: me.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      me.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      me.drawTitle(pt, ctx, options);\n      me.drawBody(pt, ctx, options);\n      me.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  setActiveElements(activeElements, eventPosition) {\n    const me = this;\n    const lastActive = me._active;\n    const active = activeElements.map(({\n      datasetIndex,\n      index\n    }) => {\n      const meta = me._chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n\n    const positionChanged = me._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      me._active = active;\n      me._eventPosition = eventPosition;\n      me.update(true);\n    }\n  }\n\n  handleEvent(e, replay) {\n    const me = this;\n    const options = me.options;\n    const lastActive = me._active || [];\n    let changed = false;\n    let active = [];\n\n    if (e.type !== 'mouseout') {\n      active = me._chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n      if (options.reverse) {\n        active.reverse();\n      }\n    }\n\n    const positionChanged = me._positionChanged(active, e);\n\n    changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    if (changed) {\n      me._active = active;\n\n      if (options.enabled || options.external) {\n        me._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        me.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  _positionChanged(active, e) {\n    const {\n      caretX,\n      caretY,\n      options\n    } = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n\n}\n\nchart_esm_Tooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: chart_esm_Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new chart_esm_Tooltip({\n        _chart: chart,\n        options\n      });\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    const args = {\n      tooltip\n    };\n\n    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n      return;\n    }\n\n    if (tooltip) {\n      tooltip.draw(chart.ctx);\n    }\n\n    chart.notifyPlugins('afterTooltipDraw', args);\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold'\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold'\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart'\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY']\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n\n        return '';\n      },\n\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n\n        let label = tooltipItem.dataset.label || '';\n\n        if (label) {\n          label += ': ';\n        }\n\n        const value = tooltipItem.formattedValue;\n\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n\n        return label;\n      },\n\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0\n        };\n      },\n\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation\n        };\n      },\n\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: name => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\nvar chart_esm_plugins = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Decimation: plugin_decimation,\n  Filler: plugin_filler,\n  Legend: plugin_legend,\n  SubTitle: plugin_subtitle,\n  Title: plugin_title,\n  Tooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index) => typeof raw === 'string' ? labels.push(raw) - 1 : isNaN(raw) ? null : index;\n\nfunction findOrAddLabel(labels, raw, index) {\n  const first = labels.indexOf(raw);\n\n  if (first === -1) {\n    return addIfString(labels, raw, index);\n  }\n\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nclass chart_esm_CategoryScale extends chart_esm_Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw));\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const {\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let {\n      min,\n      max\n    } = me.getMinMax(true);\n\n    if (me.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n\n      if (!maxDefined) {\n        max = me.getLabels().length - 1;\n      }\n    }\n\n    me.min = min;\n    me.max = max;\n  }\n\n  buildTicks() {\n    const me = this;\n    const min = me.min;\n    const max = me.max;\n    const offset = me.options.offset;\n    const ticks = [];\n    let labels = me.getLabels();\n    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n    me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    me._startValue = me.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({\n        value\n      });\n    }\n\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    const me = this;\n    const labels = me.getLabels();\n\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n\n    return value;\n  }\n\n  configure() {\n    const me = this;\n    super.configure();\n\n    if (!me.isHorizontal()) {\n      me._reversePixels = !me._reversePixels;\n    }\n  }\n\n  getPixelForValue(value) {\n    const me = this;\n\n    if (typeof value !== 'number') {\n      value = me.parse(value);\n    }\n\n    return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);\n  }\n\n  getPixelForTick(index) {\n    const me = this;\n    const ticks = me.ticks;\n\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n\n    return me.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n\n}\n\nchart_esm_CategoryScale.id = 'category';\nchart_esm_CategoryScale.defaults = {\n  ticks: {\n    callback: chart_esm_CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {\n    bounds,\n    step,\n    min,\n    max,\n    precision,\n    count,\n    maxTicks,\n    maxDigits,\n    includeBounds\n  } = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {\n    min: rmin,\n    max: rmax\n  } = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{\n      value: rmin\n    }, {\n      value: rmax\n    }];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({\n        value: min\n      });\n\n      if (niceMin < min) {\n        j++;\n      }\n\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    ticks.push({\n      value: Math.round((niceMin + j * spacing) * factor) / factor\n    });\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({\n        value: max\n      });\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({\n      value: niceMax\n    });\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {\n  horizontal,\n  minRotation\n}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nclass chart_esm_LinearScaleBase extends chart_esm_Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const me = this;\n    const {\n      beginAtZero\n    } = me.options;\n    const {\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let {\n      min,\n      max\n    } = me;\n\n    const setMin = v => min = minDefined ? min : v;\n\n    const setMax = v => max = maxDefined ? max : v;\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = 1;\n\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n\n    me.min = min;\n    me.max = max;\n  }\n\n  getTickLimit() {\n    const me = this;\n    const tickOpts = me.options.ticks;\n    let {\n      maxTicksLimit,\n      stepSize\n    } = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n    } else {\n      maxTicks = me.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const me = this;\n    const opts = me.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = me.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: me._maxDigits(),\n      horizontal: me.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = me._range || me;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, me, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n      me.start = me.max;\n      me.end = me.min;\n    } else {\n      me.start = me.min;\n      me.end = me.max;\n    }\n\n    return ticks;\n  }\n\n  configure() {\n    const me = this;\n    const ticks = me.ticks;\n    let start = me.min;\n    let end = me.max;\n    super.configure();\n\n    if (me.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n\n    me._startValue = start;\n    me._endValue = end;\n    me._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale);\n  }\n\n}\n\nclass chart_esm_LinearScale extends chart_esm_LinearScaleBase {\n  determineDataLimits() {\n    const me = this;\n    const {\n      min,\n      max\n    } = me.getMinMax(true);\n    me.min = isNumberFinite(min) ? min : 0;\n    me.max = isNumberFinite(max) ? max : 1;\n    me.handleTickRangeOptions();\n  }\n\n  computeTickLimit() {\n    const me = this;\n    const horizontal = me.isHorizontal();\n    const length = horizontal ? me.width : me.height;\n    const minRotation = toRadians(me.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n\n    const tickFont = me._resolveTickFontOptions(0);\n\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n\n}\n\nchart_esm_LinearScale.id = 'linear';\nchart_esm_LinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));\n  return remain === 1;\n}\n\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n  do {\n    ticks.push({\n      value: tickVal,\n      major: isMajor(tickVal)\n    });\n    ++significand;\n\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({\n    value: lastTick,\n    major: isMajor(tickVal)\n  });\n  return ticks;\n}\n\nclass chart_esm_LogarithmicScale extends chart_esm_Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = chart_esm_LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const {\n      min,\n      max\n    } = me.getMinMax(true);\n    me.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    me.max = isNumberFinite(max) ? Math.max(0, max) : null;\n\n    if (me.options.beginAtZero) {\n      me._zero = true;\n    }\n\n    me.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const me = this;\n    const {\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let min = me.min;\n    let max = me.max;\n\n    const setMin = v => min = minDefined ? min : v;\n\n    const setMax = v => max = maxDefined ? max : v;\n\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n\n    if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {\n      setMin(exp(min, -1));\n    }\n\n    me.min = min;\n    me.max = max;\n  }\n\n  buildTicks() {\n    const me = this;\n    const opts = me.options;\n    const generationOptions = {\n      min: me._userMin,\n      max: me._userMax\n    };\n    const ticks = generateTicks(generationOptions, me);\n\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, me, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n      me.start = me.max;\n      me.end = me.min;\n    } else {\n      me.start = me.min;\n      me.end = me.max;\n    }\n\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return value === undefined ? '0' : formatNumber(value, this.chart.options.locale);\n  }\n\n  configure() {\n    const me = this;\n    const start = me.min;\n    super.configure();\n    me._startValue = log10(start);\n    me._valueRange = log10(me.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    const me = this;\n\n    if (value === undefined || value === 0) {\n      value = me.min;\n    }\n\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n\n    return me.getPixelForDecimal(value === me.min ? 0 : (log10(value) - me._startValue) / me._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    const decimal = me.getDecimalForPixel(pixel);\n    return Math.pow(10, me._startValue + decimal * me._valueRange);\n  }\n\n}\n\nchart_esm_LogarithmicScale.id = 'logarithmic';\nchart_esm_LogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - size / 2,\n      end: pos + size / 2\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\nfunction fitWithPointLabels(scale) {\n  const furthestLimits = {\n    l: 0,\n    r: scale.width,\n    t: 0,\n    b: scale.height - scale.paddingTop\n  };\n  const furthestAngles = {};\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale.getLabels().length;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = scale.getIndexAngle(i);\n    const angle = toDegrees(angleRadians);\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n    if (hLimits.start < furthestLimits.l) {\n      furthestLimits.l = hLimits.start;\n      furthestAngles.l = angleRadians;\n    }\n\n    if (hLimits.end > furthestLimits.r) {\n      furthestLimits.r = hLimits.end;\n      furthestAngles.r = angleRadians;\n    }\n\n    if (vLimits.start < furthestLimits.t) {\n      furthestLimits.t = vLimits.start;\n      furthestAngles.t = angleRadians;\n    }\n\n    if (vLimits.end > furthestLimits.b) {\n      furthestLimits.b = vLimits.end;\n      furthestAngles.b = angleRadians;\n    }\n  }\n\n  scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale.getLabels().length;\n  const opts = scale.options;\n  const tickBackdropHeight = getTickBackdropHeight(opts);\n  const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n  for (let i = 0; i < valueCount; i++) {\n    const extra = i === 0 ? tickBackdropHeight / 2 : 0;\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);\n    const angle = toDegrees(scale.getIndexAngle(i));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= w / 2;\n  }\n\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= h / 2;\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n\n  return y;\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {\n    ctx,\n    options: {\n      pointLabels\n    }\n  } = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {\n      x,\n      y,\n      textAlign,\n      left,\n      top,\n      right,\n      bottom\n    } = scale._pointLabelItems[i];\n    const {\n      backdropColor\n    } = optsAtIndex;\n\n    if (!isNullOrUndef(backdropColor)) {\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\n    }\n\n    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n      color: optsAtIndex.color,\n      textAlign: textAlign,\n      textBaseline: 'middle'\n    });\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {\n    ctx\n  } = scale;\n\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {\n    color,\n    lineWidth\n  } = gridLineOpts;\n\n  if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction chart_esm_numberOrZero(param) {\n  return isNumber(param) ? param : 0;\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return Object.assign(Object.create(parent), {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nclass chart_esm_RadialLinearScale extends chart_esm_LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    const me = this;\n    me.width = me.maxWidth;\n    me.height = me.maxHeight;\n    me.paddingTop = getTickBackdropHeight(me.options) / 2;\n    me.xCenter = Math.floor(me.width / 2);\n    me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n    me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const {\n      min,\n      max\n    } = me.getMinMax(false);\n    me.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    me.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    me.handleTickRangeOptions();\n  }\n\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    const me = this;\n    chart_esm_LinearScaleBase.prototype.generateTickLabels.call(me, ticks);\n    me._pointLabels = me.getLabels().map((value, index) => {\n      const label = callback(me.options.pointLabels.callback, [value, index], me);\n      return label || label === 0 ? label : '';\n    });\n  }\n\n  fit() {\n    const me = this;\n    const opts = me.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(me);\n    } else {\n      me.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\n    const me = this;\n    let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n    let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n    let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n    let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n    radiusReductionLeft = chart_esm_numberOrZero(radiusReductionLeft);\n    radiusReductionRight = chart_esm_numberOrZero(radiusReductionRight);\n    radiusReductionTop = chart_esm_numberOrZero(radiusReductionTop);\n    radiusReductionBottom = chart_esm_numberOrZero(radiusReductionBottom);\n    me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));\n    me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    const me = this;\n    const maxRight = me.width - rightMovement - me.drawingArea;\n    const maxLeft = leftMovement + me.drawingArea;\n    const maxTop = topMovement + me.drawingArea;\n    const maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;\n    me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);\n    me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / this.getLabels().length;\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    const me = this;\n\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    const scalingFactor = me.drawingArea / (me.max - me.min);\n\n    if (me.options.reverse) {\n      return (me.max - value) * scalingFactor;\n    }\n\n    return (value - me.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const me = this;\n    const scaledDistance = distance / (me.drawingArea / (me.max - me.min));\n    return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const me = this;\n    const pointLabels = me._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(me.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter) {\n    const me = this;\n    const angle = me.getIndexAngle(index) - HALF_PI;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + me.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + me.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom\n    };\n  }\n\n  drawBackground() {\n    const me = this;\n    const {\n      backgroundColor,\n      grid: {\n        circular\n      }\n    } = me.options;\n\n    if (backgroundColor) {\n      const ctx = me.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  drawGrid() {\n    const me = this;\n    const ctx = me.ctx;\n    const opts = me.options;\n    const {\n      angleLines,\n      grid\n    } = opts;\n    const labelCount = me.getLabels().length;\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(me, labelCount);\n    }\n\n    if (grid.display) {\n      me.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = me.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(me.getContext(index - 1));\n          drawRadiusLine(me, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = me.getLabels().length - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(me.getPointLabelContext(i));\n        const {\n          color,\n          lineWidth\n        } = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\n        position = me.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(me.xCenter, me.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  drawBorder() {}\n\n  drawLabels() {\n    const me = this;\n    const ctx = me.ctx;\n    const opts = me.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = me.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(me.xCenter, me.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    me.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(me.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = me.getDistanceFromCenterForValue(me.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color\n      });\n    });\n    ctx.restore();\n  }\n\n  drawTitle() {}\n\n}\n\nchart_esm_RadialLinearScale.id = 'radialLinear';\nchart_esm_RadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n\n    callback(label) {\n      return label;\n    },\n\n    padding: 5\n  }\n};\nchart_esm_RadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nchart_esm_RadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: 1000\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: 60\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: 60\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: 24\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: 30\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: 4\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: 12\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: 4\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n  return a - b;\n}\n\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {\n    parser,\n    round,\n    isoWeekday\n  } = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n\n  return ticks;\n}\n\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nclass chart_esm_TimeScale extends chart_esm_Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const options = me.options;\n    const adapter = me._adapter;\n    const unit = options.time.unit || 'day';\n    let {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    if (!minDefined || !maxDefined) {\n      _applyBounds(me._getLabelBounds());\n\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(me.getMinMax(false));\n      }\n    }\n\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    me.min = Math.min(min, max - 1);\n    me.max = Math.max(min + 1, max);\n  }\n\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n\n    return {\n      min,\n      max\n    };\n  }\n\n  buildTicks() {\n    const me = this;\n    const options = me.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? me.getLabelTimestamps() : me._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      me.min = me._userMin || timestamps[0];\n      me.max = me._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = me.min;\n    const max = me.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min)) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\n    me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined : determineMajorUnit(me._unit);\n    me.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(me, ticks, me._majorUnit);\n  }\n\n  initOffsets(timestamps) {\n    const me = this;\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (me.options.offset && timestamps.length) {\n      first = me.getDecimalForValue(timestamps[0]);\n\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (me.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n\n      last = me.getDecimalForValue(timestamps[timestamps.length - 1]);\n\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    me._offsets = {\n      start,\n      end,\n      factor: 1 / (start + 1 + end)\n    };\n  }\n\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const min = me.min;\n    const max = me.max;\n    const options = me.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && me.getDataTimestamps();\n\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n\n  getLabelForValue(value) {\n    const me = this;\n    const adapter = me._adapter;\n    const timeOpts = me.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  _tickFormatFunction(time, index, ticks, format) {\n    const me = this;\n    const options = me.options;\n    const formats = options.time.displayFormats;\n    const unit = me._unit;\n    const majorUnit = me._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    const label = me._adapter.format(time, format || (major ? majorFormat : minorFormat));\n\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], me) : label;\n  }\n\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  getDecimalForValue(value) {\n    const me = this;\n    return value === null ? NaN : (value - me.min) / (me.max - me.min);\n  }\n\n  getPixelForValue(value) {\n    const me = this;\n    const offsets = me._offsets;\n    const pos = me.getDecimalForValue(value);\n    return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    const offsets = me._offsets;\n    const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return me.min + pos * (me.max - me.min);\n  }\n\n  _getLabelSize(label) {\n    const me = this;\n    const ticksOpts = me.options.ticks;\n    const tickLabelWidth = me.ctx.measureText(label).width;\n    const angle = toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n\n    const tickFontSize = me._resolveTickFontOptions(0).size;\n\n    return {\n      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n    };\n  }\n\n  _getLabelCapacity(exampleTime) {\n    const me = this;\n    const timeOpts = me.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n\n    const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\n\n    const size = me._getLabelSize(exampleLabel);\n\n    const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  getDataTimestamps() {\n    const me = this;\n    let timestamps = me._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = me.getMatchingVisibleMetas();\n\n    if (me._normalized && metas.length) {\n      return me._cache.data = metas[0].controller.getAllParsedValues(me);\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));\n    }\n\n    return me._cache.data = me.normalize(timestamps);\n  }\n\n  getLabelTimestamps() {\n    const me = this;\n    const timestamps = me._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = me.getLabels();\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(me, labels[i]));\n    }\n\n    return me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps);\n  }\n\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n\n}\n\nchart_esm_TimeScale.id = 'time';\nchart_esm_TimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({\n        lo,\n        hi\n      } = _lookupByKey(table, 'pos', val));\n    }\n\n    ({\n      pos: prevSource,\n      time: prevTarget\n    } = table[lo]);\n    ({\n      pos: nextSource,\n      time: nextTarget\n    } = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({\n        lo,\n        hi\n      } = _lookupByKey(table, 'time', val));\n    }\n\n    ({\n      time: prevSource,\n      pos: prevTarget\n    } = table[lo]);\n    ({\n      time: nextSource,\n      pos: nextTarget\n    } = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends chart_esm_TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n\n  initOffsets() {\n    const me = this;\n\n    const timestamps = me._getTimestampsForTable();\n\n    const table = me._table = me.buildLookupTable(timestamps);\n    me._minPos = interpolate(table, me.min);\n    me._tableRange = interpolate(table, me.max) - me._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  buildLookupTable(timestamps) {\n    const {\n      min,\n      max\n    } = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      return [{\n        time: min,\n        pos: 0\n      }, {\n        time: max,\n        pos: 1\n      }];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({\n          time: curr,\n          pos: i / (ilen - 1)\n        });\n      }\n    }\n\n    return table;\n  }\n\n  _getTimestampsForTable() {\n    const me = this;\n    let timestamps = me._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = me.getDataTimestamps();\n    const label = me.getLabelTimestamps();\n\n    if (data.length && label.length) {\n      timestamps = me.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n\n    timestamps = me._cache.all = timestamps;\n    return timestamps;\n  }\n\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    const offsets = me._offsets;\n    const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(me._table, decimal * me._tableRange + me._minPos, true);\n  }\n\n}\n\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = chart_esm_TimeScale.defaults;\nvar chart_esm_scales = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CategoryScale: chart_esm_CategoryScale,\n  LinearScale: chart_esm_LinearScale,\n  LogarithmicScale: chart_esm_LogarithmicScale,\n  RadialLinearScale: chart_esm_RadialLinearScale,\n  TimeScale: chart_esm_TimeScale,\n  TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [controllers, chart_esm_elements, chart_esm_plugins, chart_esm_scales];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaHVua3MvaGVscGVycy5zZWdtZW50LmpzP2RkM2QiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQuZXNtLmpzPzliNGEiXSwibmFtZXMiOlsiZm9udFN0cmluZyIsInBpeGVsU2l6ZSIsImZvbnRTdHlsZSIsImZvbnRGYW1pbHkiLCJyZXF1ZXN0QW5pbUZyYW1lIiwid2luZG93IiwiY2FsbGJhY2siLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aHJvdHRsZWQiLCJmbiIsInRoaXNBcmciLCJ1cGRhdGVGbiIsInVwZGF0ZUFyZ3MiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJ0aWNraW5nIiwicmVzdCIsImFwcGx5IiwiZGVib3VuY2UiLCJkZWxheSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiYWxpZ24iLCJfYWxpZ25TdGFydEVuZCIsInN0YXJ0IiwiZW5kIiwiX3RleHRYIiwibGVmdCIsInJpZ2h0IiwicnRsIiwiY2hlY2siLCJub29wIiwidWlkIiwiaWQiLCJpc051bGxPclVuZGVmIiwidmFsdWUiLCJpc0FycmF5IiwidHlwZSIsIk9iamVjdCIsInRvU3RyaW5nIiwic3Vic3RyIiwiaXNPYmplY3QiLCJpc051bWJlckZpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiZmluaXRlT3JEZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwidmFsdWVPckRlZmF1bHQiLCJ0b1BlcmNlbnRhZ2UiLCJkaW1lbnNpb24iLCJlbmRzV2l0aCIsInBhcnNlRmxvYXQiLCJ0b0RpbWVuc2lvbiIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJpIiwibGVuIiwia2V5cyIsImxlbmd0aCIsIl9lbGVtZW50c0VxdWFsIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwiZGF0YXNldEluZGV4IiwiaW5kZXgiLCJjbG9uZSQxIiwic291cmNlIiwibWFwIiwidGFyZ2V0IiwiY3JlYXRlIiwia2xlbiIsImsiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiaW5kZXhPZiIsIl9tZXJnZXIiLCJvcHRpb25zIiwidHZhbCIsInN2YWwiLCJtZXJnZSIsInNvdXJjZXMiLCJtZXJnZXIiLCJtZXJnZUlmIiwiX21lcmdlcklmIiwiaGFzT3duUHJvcGVydHkiLCJfZGVwcmVjYXRlZCIsInNjb3BlIiwicHJldmlvdXMiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwiY29uc29sZSIsIndhcm4iLCJlbXB0eVN0cmluZyIsImRvdCIsImluZGV4T2ZEb3RPckxlbmd0aCIsImlkeCIsInJlc29sdmVPYmplY3RLZXkiLCJvYmoiLCJwb3MiLCJfY2FwaXRhbGl6ZSIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJzZXRzRXF1YWwiLCJhIiwiYiIsInNpemUiLCJpdGVtIiwiaGFzIiwiUEkiLCJNYXRoIiwiVEFVIiwiUElUQVUiLCJJTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiUkFEX1BFUl9ERUciLCJIQUxGX1BJIiwiUVVBUlRFUl9QSSIsIlRXT19USElSRFNfUEkiLCJsb2cxMCIsInNpZ24iLCJuaWNlTnVtIiwicmFuZ2UiLCJyb3VuZGVkUmFuZ2UiLCJyb3VuZCIsImFsbW9zdEVxdWFscyIsIm5pY2VSYW5nZSIsInBvdyIsImZsb29yIiwiZnJhY3Rpb24iLCJuaWNlRnJhY3Rpb24iLCJfZmFjdG9yaXplIiwicmVzdWx0Iiwic3FydCIsInB1c2giLCJzb3J0IiwicG9wIiwiaXNOdW1iZXIiLCJuIiwiaXNOYU4iLCJ4IiwieSIsImVwc2lsb24iLCJhYnMiLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJhcnJheSIsInByb3BlcnR5IiwibWluIiwibWF4IiwidG9SYWRpYW5zIiwiZGVncmVlcyIsInRvRGVncmVlcyIsInJhZGlhbnMiLCJfZGVjaW1hbFBsYWNlcyIsImUiLCJwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0YW5jZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsIl9hbmdsZURpZmYiLCJfbm9ybWFsaXplQW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwicyIsImFuZ2xlVG9TdGFydCIsImFuZ2xlVG9FbmQiLCJzdGFydFRvQW5nbGUiLCJlbmRUb0FuZ2xlIiwiX2xpbWl0VmFsdWUiLCJfaW50MTZSYW5nZSIsImF0RWRnZSIsInQiLCJlbGFzdGljSW4iLCJzaW4iLCJlbGFzdGljT3V0IiwiZWZmZWN0cyIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiY29zIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJtIiwiZCIsImVhc2VJbk91dEJvdW5jZSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImMiLCJmIiwiaGV4IiwiaDEiLCJoMiIsImVxIiwiaXNTaG9ydCIsInYiLCJyIiwiZyIsImhleFBhcnNlIiwicmV0IiwiaGV4U3RyaW5nIiwibGltIiwibCIsImgiLCJwMmIiLCJuMmIiLCJiMm4iLCJuMnAiLCJSR0JfUkUiLCJyZ2JQYXJzZSIsImV4ZWMiLCJyZ2JTdHJpbmciLCJIVUVfUkUiLCJoc2wycmdibiIsImhzdjJyZ2JuIiwiaHdiMnJnYm4iLCJ3IiwicmdiIiwicmdiMmhzbCIsImNhbGxuIiwiaHNsMnJnYiIsImh3YjJyZ2IiLCJoc3YycmdiIiwiaHVlIiwiaHVlUGFyc2UiLCJwMSIsInAyIiwicm90YXRlIiwiZGVnIiwiaHNsU3RyaW5nIiwibWFwJDEiLCJaIiwiWSIsIlgiLCJXIiwiViIsIlUiLCJUIiwiUyIsIlIiLCJRIiwiUCIsIk8iLCJOIiwiTSIsIkwiLCJLIiwiRyIsIkgiLCJJIiwiSiIsIm5hbWVzIiwiT2ljZVhlIiwiYW50aXF1ZXdFdGUiLCJhcXVhIiwiYXF1YW1hclJlIiwiYXp1WSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuS2VkT21vbmQiLCJYZSIsIlhldmlUZXQiLCJiUHduIiwiYnVybHl3b29kIiwiY2FNdFhlIiwiS2FydFl1c2UiLCJLb2NUYXRlIiwiY1NPIiwiY1NuZmxvd2VyWGUiLCJjU25zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJ4WGUiLCJ4Y3lhbiIsInhnVE1uUGQiLCJ4V2F5IiwieGdZRiIsInhnWXkiLCJ4a2hha2kiLCJ4bWFnRnRhIiwieFRpdmVnWUYiLCJ4U2FuZ2UiLCJ4U2NFZCIsInhZZCIsInhzT21vbiIsInhzSGdZRiIsInhVWGUiLCJ4VVdheSIsInhVZ1l5IiwieFFlIiwieHZpVGV0IiwiZEFwcFJrIiwiZEFwc2t5WGUiLCJkaW1XYXkiLCJkaW1nWXkiLCJkb2RnZXJYZSIsImZpWWJyaWNrIiwiZmxTT3dFdGUiLCJmb1lzdFdBbiIsImZ1S3NpYSIsImdhUnNiU28iLCJnaG9zdHdFdGUiLCJnVGQiLCJnVE1uUGQiLCJXYXkiLCJnWUYiLCJnWUZMdyIsImdZeSIsImhvbmV5TXciLCJob3RwUmsiLCJSZGlhbllkIiwiUmRpZ28iLCJpdlN5Iiwia2hha2kiLCJsYXZGTXIiLCJsYXZGTXJYc2giLCJsYXduZ1lGIiwiTm1vbmNFZmZvbiIsIlpYZSIsIlpjU08iLCJaY3lhbiIsIlpnVE1uUGRMdyIsIlpXYXkiLCJaZ1lGIiwiWmdZeSIsIlpwUmsiLCJac09tb24iLCJac0hnWUYiLCJac2t5WGUiLCJaVVdheSIsIlpVZ1l5IiwiWnN0QWxYZSIsIlpMdyIsImxpbWUiLCJsaW1lZ1lGIiwibFJGIiwibWFnRnRhIiwibWFQb24iLCJWYXF1YW1hclJlIiwiVlhlIiwiVlNjRWQiLCJWcHVycE4iLCJWc0hnWUYiLCJWVVhlIiwiVnNwclJnZ1lGIiwiVlFlIiwiVnZpVGV0WWQiLCJtaWRuaWdodFhlIiwibVJ0Y1lhbSIsIm1pc3R5UHNlIiwibW9jY2FzUiIsIm5hdmFqb3dFdGUiLCJuYXZ5IiwiVGRsYWNlIiwiVGl2ZSIsIlRpdmVkQmIiLCJTYW5nZSIsIlNhbmdlWWQiLCJTY0VkIiwicE9lZ1RNblBkIiwicE9lZ1lGIiwicE9lUWUiLCJwT2V2aVRldFlkIiwicGFwYXlhd0VwIiwicEhLcHVmZiIsInBlcnUiLCJwUmsiLCJwbHVtIiwicG93TXJYZSIsInB1cnBOIiwiWWJlY2NhcHVycE4iLCJZZCIsIlBzeWJyb3duIiwiUHlPWGUiLCJzYWRkTmJQd24iLCJzT21vbiIsInNhbmR5YlB3biIsInNIZ1lGIiwic0hzaGVsbCIsInNpRm5hIiwic2lsdmVyIiwic2t5WGUiLCJVWGUiLCJVV2F5IiwiVWdZeSIsInNub3ciLCJzcHJSZ2dZRiIsInN0QWxYZSIsInRhbiIsInRlTyIsInRFc3ROIiwidG9tYXRvIiwiUWUiLCJ2aVRldCIsIkpIdCIsIndFdGUiLCJ3RXRlc21va2UiLCJMdyIsIkx3Z1lGIiwidW5wYWNrIiwidW5wYWNrZWQiLCJ0a2V5cyIsImoiLCJvayIsIm5rIiwicmVwbGFjZSIsInBhcnNlSW50IiwibmFtZXMkMSIsIm5hbWVQYXJzZSIsInRyYW5zcGFyZW50IiwidG9Mb3dlckNhc2UiLCJtb2RIU0wiLCJyYXRpbyIsInRtcCIsImNsb25lIiwicHJvdG8iLCJhc3NpZ24iLCJmcm9tT2JqZWN0IiwiaW5wdXQiLCJmdW5jdGlvblBhcnNlIiwiQ29sb3IiLCJjb25zdHJ1Y3RvciIsIl9yZ2IiLCJfdmFsaWQiLCJ2YWxpZCIsIm1peCIsImNvbG9yIiwid2VpZ2h0IiwibWUiLCJjMSIsImMyIiwidzIiLCJ3MSIsImFscGhhIiwiY2xlYXJlciIsImdyZXlzY2FsZSIsInZhbCIsIm9wYXF1ZXIiLCJuZWdhdGUiLCJsaWdodGVuIiwiZGFya2VuIiwic2F0dXJhdGUiLCJkZXNhdHVyYXRlIiwiaW5kZXhfZXNtIiwiaXNQYXR0ZXJuT3JHcmFkaWVudCIsIkNhbnZhc0dyYWRpZW50IiwiQ2FudmFzUGF0dGVybiIsImdldEhvdmVyQ29sb3IiLCJvdmVycmlkZXMiLCJkZXNjcmlwdG9ycyIsImdldFNjb3BlJDEiLCJub2RlIiwic3BsaXQiLCJzZXQiLCJyb290IiwidmFsdWVzIiwiRGVmYXVsdHMiLCJfZGVzY3JpcHRvcnMiLCJhbmltYXRpb24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImRhdGFzZXRzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNvbnRleHQiLCJjaGFydCIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImVsZW1lbnRzIiwiZXZlbnRzIiwiZm9udCIsImZhbWlseSIsInN0eWxlIiwibGluZUhlaWdodCIsImhvdmVyIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJjdHgiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJDb2xvciIsImluZGV4QXhpcyIsImludGVyYWN0aW9uIiwibW9kZSIsImludGVyc2VjdCIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJvbkhvdmVyIiwib25DbGljayIsInBhcnNpbmciLCJwbHVnaW5zIiwicmVzcG9uc2l2ZSIsInNjYWxlIiwic2NhbGVzIiwic2hvd0xpbmUiLCJkZXNjcmliZSIsImdldCIsIm92ZXJyaWRlIiwicm91dGUiLCJuYW1lIiwidGFyZ2V0U2NvcGUiLCJ0YXJnZXROYW1lIiwic2NvcGVPYmplY3QiLCJ0YXJnZXRTY29wZU9iamVjdCIsInByaXZhdGVOYW1lIiwiZGVmaW5lUHJvcGVydGllcyIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImxvY2FsIiwiZGVmYXVsdHMiLCJfc2NyaXB0YWJsZSIsInN0YXJ0c1dpdGgiLCJfaW5kZXhhYmxlIiwiX2ZhbGxiYWNrIiwidG9Gb250U3RyaW5nIiwiX21lYXN1cmVUZXh0IiwiZGF0YSIsImdjIiwibG9uZ2VzdCIsInN0cmluZyIsInRleHRXaWR0aCIsIm1lYXN1cmVUZXh0Iiwid2lkdGgiLCJfbG9uZ2VzdFRleHQiLCJhcnJheU9mVGhpbmdzIiwiY2FjaGUiLCJnYXJiYWdlQ29sbGVjdCIsInNhdmUiLCJqbGVuIiwidGhpbmciLCJuZXN0ZWRUaGluZyIsInJlc3RvcmUiLCJnY0xlbiIsInNwbGljZSIsIl9hbGlnblBpeGVsIiwicGl4ZWwiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsImhhbGZXaWR0aCIsImNsZWFyQ2FudmFzIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsInJlc2V0VHJhbnNmb3JtIiwiY2xlYXJSZWN0IiwiaGVpZ2h0IiwiZHJhd1BvaW50IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXJSYWRpdXMiLCJwb2ludFN0eWxlIiwicm90YXRpb24iLCJyYWRpdXMiLCJyYWQiLCJ0cmFuc2xhdGUiLCJkcmF3SW1hZ2UiLCJiZWdpblBhdGgiLCJhcmMiLCJjbG9zZVBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJTUVJUMV8yIiwicmVjdCIsImZpbGwiLCJib3JkZXJXaWR0aCIsInN0cm9rZSIsIl9pc1BvaW50SW5BcmVhIiwicG9pbnQiLCJhcmVhIiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwiY2xpcEFyZWEiLCJjbGlwIiwidW5jbGlwQXJlYSIsIl9zdGVwcGVkTGluZVRvIiwiZmxpcCIsIm1pZHBvaW50IiwiX2JlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiY3AxeCIsImNwMngiLCJjcDF5IiwiY3AyeSIsInJlbmRlclRleHQiLCJ0ZXh0Iiwib3B0cyIsImxpbmVzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VDb2xvciIsImxpbmUiLCJzZXRSZW5kZXJPcHRzIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VUZXh0IiwibWF4V2lkdGgiLCJmaWxsVGV4dCIsImRlY29yYXRlVGV4dCIsInRyYW5zbGF0aW9uIiwiZmlsbFN0eWxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwic3RyaWtldGhyb3VnaCIsInVuZGVybGluZSIsIm1ldHJpY3MiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJ5RGVjb3JhdGlvbiIsImRlY29yYXRpb25XaWR0aCIsImFkZFJvdW5kZWRSZWN0UGF0aCIsInRvcExlZnQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJ0b3BSaWdodCIsIkxJTkVfSEVJR0hUIiwiUmVnRXhwIiwiRk9OVF9TVFlMRSIsInRvTGluZUhlaWdodCIsIm1hdGNoZXMiLCJtYXRjaCIsIm51bWJlck9yWmVybyIsIl9yZWFkVmFsdWVUb1Byb3BzIiwicHJvcHMiLCJvYmpQcm9wcyIsInJlYWQiLCJwcm9wIiwidG9UUkJMIiwidG9UUkJMQ29ybmVycyIsInRvUGFkZGluZyIsInRvRm9udCIsImZhbGxiYWNrIiwicmVzb2x2ZSIsImlucHV0cyIsImluZm8iLCJjYWNoZWFibGUiLCJfYWRkR3JhY2UiLCJtaW5tYXgiLCJncmFjZSIsIl9sb29rdXAiLCJ0YWJsZSIsImNtcCIsImhpIiwibG8iLCJtaWQiLCJfbG9va3VwQnlLZXkiLCJfcmxvb2t1cEJ5S2V5IiwiX2ZpbHRlckJldHdlZW4iLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsImxpc3RlbmVycyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZm9yRWFjaCIsIm1ldGhvZCIsImJhc2UiLCJyZXMiLCJvYmplY3QiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsIl9hcnJheVVuaXF1ZSIsIml0ZW1zIiwiU2V0IiwiYWRkIiwiZnJvbSIsIl9jcmVhdGVSZXNvbHZlciIsInNjb3BlcyIsInByZWZpeGVzIiwicm9vdFNjb3BlcyIsImdldFRhcmdldCIsIl9yZXNvbHZlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJfY2FjaGVhYmxlIiwiX3Njb3BlcyIsIl9yb290U2NvcGVzIiwiX2dldFRhcmdldCIsIlByb3h5IiwiZGVsZXRlUHJvcGVydHkiLCJfa2V5cyIsIl9jYWNoZWQiLCJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlJlZmxlY3QiLCJnZXRQcm90b3R5cGVPZiIsImdldEtleXNGcm9tQWxsU2NvcGVzIiwiaW5jbHVkZXMiLCJvd25LZXlzIiwic3RvcmFnZSIsIl9zdG9yYWdlIiwiX2F0dGFjaENvbnRleHQiLCJwcm94eSIsInN1YlByb3h5IiwiZGVzY3JpcHRvckRlZmF1bHRzIiwiX3Byb3h5IiwiX2NvbnRleHQiLCJfc3ViUHJveHkiLCJfc3RhY2siLCJzZXRDb250ZXh0IiwicmVjZWl2ZXIiLCJfcmVzb2x2ZVdpdGhDb250ZXh0IiwiYWxsS2V5cyIsInNjcmlwdGFibGUiLCJpbmRleGFibGUiLCJfYWxsS2V5cyIsImlzU2NyaXB0YWJsZSIsImlzSW5kZXhhYmxlIiwicmVhZEtleSIsInByZWZpeCIsIm5lZWRzU3ViUmVzb2x2ZXIiLCJfcmVzb2x2ZVNjcmlwdGFibGUiLCJfcmVzb2x2ZUFycmF5IiwiRXJyb3IiLCJqb2luIiwiZGVsZXRlIiwiY3JlYXRlU3ViUmVzb2x2ZXIiLCJhcnIiLCJmaWx0ZXIiLCJyZXNvbHZlciIsInJlc29sdmVGYWxsYmFjayIsImdldFNjb3BlIiwicGFyZW50IiwiYWRkU2NvcGVzIiwicGFyZW50U2NvcGVzIiwicGFyZW50RmFsbGJhY2siLCJhbGxTY29wZXMiLCJhZGRTY29wZXNGcm9tS2V5Iiwic3ViR2V0VGFyZ2V0IiwicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwiRVBTSUxPTiIsImdldFBvaW50IiwicG9pbnRzIiwic2tpcCIsImdldFZhbHVlQXhpcyIsInNwbGluZUN1cnZlIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsIm5leHQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwibW9ub3RvbmVBZGp1c3QiLCJkZWx0YUsiLCJtSyIsInBvaW50c0xlbiIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwibW9ub3RvbmVDb21wdXRlIiwidmFsdWVBeGlzIiwiZGVsdGEiLCJwb2ludEJlZm9yZSIsImlQaXhlbCIsInZQaXhlbCIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzbG9wZURlbHRhIiwiY2FwQ29udHJvbFBvaW50IiwicHQiLCJjYXBCZXppZXJQb2ludHMiLCJpbkFyZWEiLCJpbkFyZWFQcmV2IiwiaW5BcmVhTmV4dCIsIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwibG9vcCIsImNvbnRyb2xQb2ludHMiLCJzcGFuR2FwcyIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJwcmV2IiwidGVuc2lvbiIsIl9pc0RvbVN1cHBvcnRlZCIsImRvY3VtZW50IiwiX2dldFBhcmVudE5vZGUiLCJkb21Ob2RlIiwicGFyZW50Tm9kZSIsImhvc3QiLCJwYXJzZU1heFN0eWxlIiwic3R5bGVWYWx1ZSIsInBhcmVudFByb3BlcnR5IiwidmFsdWVJblBpeGVscyIsImdldENvbXB1dGVkU3R5bGUiLCJlbGVtZW50IiwiZ2V0U3R5bGUiLCJlbCIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbmVkU3R5bGUiLCJzdHlsZXMiLCJzdWZmaXgiLCJ1c2VPZmZzZXRQb3MiLCJzaGFkb3dSb290IiwiZ2V0Q2FudmFzUG9zaXRpb24iLCJldnQiLCJuYXRpdmUiLCJ0b3VjaGVzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJib3JkZXJCb3giLCJib3hTaXppbmciLCJwYWRkaW5ncyIsImJvcmRlcnMiLCJnZXRDb250YWluZXJTaXplIiwibWF4SGVpZ2h0IiwiY29udGFpbmVyIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjb250YWluZXJTdHlsZSIsImNvbnRhaW5lckJvcmRlciIsImNvbnRhaW5lclBhZGRpbmciLCJyb3VuZDEiLCJnZXRNYXhpbXVtU2l6ZSIsImJiV2lkdGgiLCJiYkhlaWdodCIsImFzcGVjdFJhdGlvIiwibWFyZ2lucyIsImNvbnRhaW5lclNpemUiLCJyZXRpbmFTY2FsZSIsImZvcmNlUmF0aW8iLCJmb3JjZVN0eWxlIiwicGl4ZWxSYXRpbyIsImRldmljZUhlaWdodCIsImRldmljZVdpZHRoIiwic2V0VHJhbnNmb3JtIiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmVTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkVXNlZFNpemUiLCJfcG9pbnRJbkxpbmUiLCJfc3RlcHBlZEludGVycG9sYXRpb24iLCJfYmV6aWVySW50ZXJwb2xhdGlvbiIsImNwMSIsImNwMiIsImludGxDYWNoZSIsIk1hcCIsImdldE51bWJlckZvcm1hdCIsImxvY2FsZSIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdHRlciIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJmb3JtYXQiLCJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCJyZWN0WCIsInNldFdpZHRoIiwieFBsdXMiLCJsZWZ0Rm9yTHRyIiwiaXRlbVdpZHRoIiwiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwiX2l0ZW1XaWR0aCIsImdldFJ0bEFkYXB0ZXIiLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJvcmlnaW5hbCIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJzZXRQcm9wZXJ0eSIsInByZXZUZXh0RGlyZWN0aW9uIiwicmVzdG9yZVRleHREaXJlY3Rpb24iLCJwcm9wZXJ0eUZuIiwiYmV0d2VlbiIsImNvbXBhcmUiLCJub3JtYWxpemUiLCJub3JtYWxpemVTZWdtZW50IiwiY291bnQiLCJnZXRTZWdtZW50Iiwic2VnbWVudCIsImJvdW5kcyIsInN0YXJ0Qm91bmQiLCJlbmRCb3VuZCIsIl9ib3VuZFNlZ21lbnQiLCJpbnNpZGUiLCJzdWJTdGFydCIsInByZXZWYWx1ZSIsInN0YXJ0SXNCZWZvcmUiLCJlbmRJc0JlZm9yZSIsInNob3VsZFN0YXJ0Iiwic2hvdWxkU3RvcCIsIl9ib3VuZFNlZ21lbnRzIiwic2VnbWVudHMiLCJzdWIiLCJmaW5kU3RhcnRBbmRFbmQiLCJzb2xpZFNlZ21lbnRzIiwibGFzdCIsImN1ciIsInN0b3AiLCJfY29tcHV0ZVNlZ21lbnRzIiwic2VnbWVudE9wdGlvbnMiLCJfbG9vcCIsInNwbGl0QnlTdHlsZXMiLCJjb21wbGV0ZUxvb3AiLCJfZnVsbExvb3AiLCJkb1NwbGl0QnlTdHlsZXMiLCJiYXNlU3R5bGUiLCJyZWFkU3R5bGUiLCJwcmV2U3R5bGUiLCJwMCIsInAwRGF0YUluZGV4IiwicDFEYXRhSW5kZXgiLCJfZGF0YXNldEluZGV4Iiwic3R5bGVDaGFuZ2VkIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsIkFuaW1hdG9yIiwiX3JlcXVlc3QiLCJfY2hhcnRzIiwiX3J1bm5pbmciLCJfbGFzdERhdGUiLCJfbm90aWZ5IiwiYW5pbXMiLCJkYXRlIiwiY2FsbGJhY2tzIiwibnVtU3RlcHMiLCJkdXJhdGlvbiIsImluaXRpYWwiLCJjdXJyZW50U3RlcCIsIl9yZWZyZXNoIiwiX3VwZGF0ZSIsIkRhdGUiLCJub3ciLCJyZW1haW5pbmciLCJydW5uaW5nIiwiZHJhdyIsIl9hY3RpdmUiLCJfdG90YWwiLCJ0aWNrIiwiX2dldEFuaW1zIiwiY2hhcnRzIiwiY29tcGxldGUiLCJwcm9ncmVzcyIsImxpc3RlbiIsImV2ZW50IiwiY2IiLCJyZWR1Y2UiLCJhY2MiLCJfZHVyYXRpb24iLCJjYW5jZWwiLCJyZW1vdmUiLCJhbmltYXRvciIsImludGVycG9sYXRvcnMiLCJib29sZWFuIiwidG8iLCJmYWN0b3IiLCJjMCIsIm51bWJlciIsIkFuaW1hdGlvbiIsImNmZyIsImN1cnJlbnRWYWx1ZSIsIl9mbiIsIl9lYXNpbmciLCJlYXNpbmciLCJfc3RhcnQiLCJfdGFyZ2V0IiwiX3Byb3AiLCJfZnJvbSIsIl90byIsIl9wcm9taXNlcyIsImFjdGl2ZSIsInVwZGF0ZSIsImVsYXBzZWQiLCJyZW1haW4iLCJ3YWl0IiwicHJvbWlzZXMiLCJQcm9taXNlIiwicmVqIiwicmVzb2x2ZWQiLCJudW1iZXJzIiwiY29sb3JzIiwiYW5pbWF0aW9uT3B0aW9ucyIsInByb3BlcnRpZXMiLCJyZXNpemUiLCJzaG93IiwiYW5pbWF0aW9ucyIsInZpc2libGUiLCJoaWRlIiwiQW5pbWF0aW9ucyIsImNvbmZpZyIsIl9jaGFydCIsIl9wcm9wZXJ0aWVzIiwiY29uZmlndXJlIiwiYW5pbWF0ZWRQcm9wcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvcHRpb24iLCJfYW5pbWF0ZU9wdGlvbnMiLCJuZXdPcHRpb25zIiwicmVzb2x2ZVRhcmdldE9wdGlvbnMiLCJfY3JlYXRlQW5pbWF0aW9ucyIsIiRzaGFyZWQiLCJhd2FpdEFsbCIsIiRhbmltYXRpb25zIiwidGhlbiIsImFuaW0iLCJhbGwiLCJzY2FsZUNsaXAiLCJhbGxvd2VkT3ZlcmZsb3ciLCJkZWZhdWx0Q2xpcCIsInhTY2FsZSIsInlTY2FsZSIsInRvQ2xpcCIsImRpc2FibGVkIiwiZ2V0U29ydGVkRGF0YXNldEluZGljZXMiLCJmaWx0ZXJWaXNpYmxlIiwibWV0YXNldHMiLCJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwiYXBwbHlTdGFjayIsInN0YWNrIiwiZHNJbmRleCIsInNpbmdsZU1vZGUiLCJvdGhlclZhbHVlIiwiY29udmVydE9iamVjdERhdGFUb0FycmF5IiwiYWRhdGEiLCJpc1N0YWNrZWQiLCJtZXRhIiwic3RhY2tlZCIsImdldFN0YWNrS2V5IiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJnZXRVc2VyQm91bmRzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJORUdBVElWRV9JTkZJTklUWSIsImdldE9yQ3JlYXRlU3RhY2siLCJzdGFja3MiLCJzdGFja0tleSIsImluZGV4VmFsdWUiLCJzdWJTdGFjayIsImdldExhc3RJbmRleEluU3RhY2siLCJ2U2NhbGUiLCJwb3NpdGl2ZSIsImdldE1hdGNoaW5nVmlzaWJsZU1ldGFzIiwidXBkYXRlU3RhY2tzIiwiY29udHJvbGxlciIsInBhcnNlZCIsIl9jYWNoZWRNZXRhIiwiX3N0YWNrcyIsImlTY2FsZSIsImlBeGlzIiwiYXhpcyIsInZBeGlzIiwiaXRlbVN0YWNrcyIsIl90b3AiLCJfYm90dG9tIiwiZ2V0Rmlyc3RTY2FsZUlkIiwic2hpZnQiLCJjcmVhdGVEYXRhc2V0Q29udGV4dCIsImRhdGFzZXQiLCJjcmVhdGVEYXRhQ29udGV4dCIsImRhdGFJbmRleCIsInJhdyIsImNsZWFyU3RhY2tzIiwiX3BhcnNlZCIsImlzRGlyZWN0VXBkYXRlTW9kZSIsImNsb25lSWZOb3RTaGFyZWQiLCJjYWNoZWQiLCJzaGFyZWQiLCJEYXRhc2V0Q29udHJvbGxlciIsIl9jdHgiLCJfY2FjaGVkRGF0YU9wdHMiLCJnZXRNZXRhIiwiX3R5cGUiLCJfcGFyc2luZyIsIl9kYXRhIiwiX29iamVjdERhdGEiLCJfc2hhcmVkT3B0aW9ucyIsIl9kcmF3U3RhcnQiLCJfZHJhd0NvdW50IiwiZW5hYmxlT3B0aW9uU2hhcmluZyIsIiRjb250ZXh0IiwiX3N5bmNMaXN0IiwiaW5pdGlhbGl6ZSIsImxpbmtTY2FsZXMiLCJfc3RhY2tlZCIsImFkZEVsZW1lbnRzIiwidXBkYXRlSW5kZXgiLCJnZXREYXRhc2V0IiwiY2hvb3NlSWQiLCJ4aWQiLCJ4QXhpc0lEIiwieWlkIiwieUF4aXNJRCIsInJpZCIsInJBeGlzSUQiLCJpaWQiLCJpQXhpc0lEIiwidmlkIiwidkF4aXNJRCIsImdldFNjYWxlRm9ySWQiLCJyU2NhbGUiLCJnZXREYXRhc2V0TWV0YSIsInNjYWxlSUQiLCJfZ2V0T3RoZXJTY2FsZSIsInJlc2V0IiwiX2Rlc3Ryb3kiLCJfZGF0YUNoZWNrIiwiaXNFeHRlbnNpYmxlIiwiZGF0YXNldEVsZW1lbnRUeXBlIiwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwicmVzZXROZXdFbGVtZW50cyIsInN0YWNrQ2hhbmdlZCIsIm9sZFN0YWNrZWQiLCJfcmVzeW5jRWxlbWVudHMiLCJzY29wZUtleXMiLCJkYXRhc2V0U2NvcGVLZXlzIiwiZ2V0T3B0aW9uU2NvcGVzIiwiY3JlYXRlUmVzb2x2ZXIiLCJwYXJzZSIsInNvcnRlZCIsIl9zb3J0ZWQiLCJwYXJzZUFycmF5RGF0YSIsInBhcnNlT2JqZWN0RGF0YSIsInBhcnNlUHJpbWl0aXZlRGF0YSIsImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwic2luZ2xlU2NhbGUiLCJ4QXhpc0tleSIsInlBeGlzS2V5IiwiZ2V0UGFyc2VkIiwiZ2V0RGF0YUVsZW1lbnQiLCJ1cGRhdGVSYW5nZUZyb21QYXJzZWQiLCJwYXJzZWRWYWx1ZSIsIk5hTiIsImdldE1pbk1heCIsImNhblN0YWNrIiwib3RoZXJTY2FsZSIsIm90aGVyTWluIiwib3RoZXJNYXgiLCJfc2tpcCIsImdldEFsbFBhcnNlZFZhbHVlcyIsImdldE1heE92ZXJmbG93IiwiZ2V0TGFiZWxBbmRWYWx1ZSIsImxhYmVsIiwiZ2V0TGFiZWxGb3JWYWx1ZSIsIl9jbGlwIiwiY2hhcnRBcmVhIiwiaGlkZGVuIiwicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZGF0YUVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGUiLCJzaGFyaW5nIiwiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCJyZXNvbHZlTmFtZWRPcHRpb25zIiwiZnJlZXplIiwiX3Jlc29sdmVBbmltYXRpb25zIiwidHJhbnNpdGlvbiIsImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCJnZXRTaGFyZWRPcHRpb25zIiwiaW5jbHVkZU9wdGlvbnMiLCJzaGFyZWRPcHRpb25zIiwiX2FuaW1hdGlvbnNEaXNhYmxlZCIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVTaGFyZWRPcHRpb25zIiwiX3NldFN0eWxlIiwicmVtb3ZlSG92ZXJTdHlsZSIsInNldEhvdmVyU3R5bGUiLCJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCJfc2V0RGF0YXNldEhvdmVyU3R5bGUiLCJhcmcxIiwiYXJnMiIsIm51bU1ldGEiLCJudW1EYXRhIiwiX2luc2VydEVsZW1lbnRzIiwiX3JlbW92ZUVsZW1lbnRzIiwibW92ZSIsInVwZGF0ZUVsZW1lbnRzIiwicmVtb3ZlZCIsIl9zeW5jIiwiX29uRGF0YVB1c2giLCJhcmd1bWVudHMiLCJfb25EYXRhUG9wIiwiX29uRGF0YVNoaWZ0IiwiX29uRGF0YVNwbGljZSIsIl9vbkRhdGFVbnNoaWZ0IiwiZ2V0QWxsU2NhbGVWYWx1ZXMiLCJfY2FjaGUiLCIkYmFyIiwibWV0YXMiLCJjb25jYXQiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsIl9sZW5ndGgiLCJjdXJyIiwidXBkYXRlTWluQW5kUHJldiIsImdldFBpeGVsRm9yVmFsdWUiLCJ0aWNrcyIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsInJ1bGVyIiwic3RhY2tDb3VudCIsInRoaWNrbmVzcyIsImJhclRoaWNrbmVzcyIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJjaHVuayIsInBpeGVscyIsImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCJwZXJjZW50IiwicGFyc2VGbG9hdEJhciIsImVudHJ5Iiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiYmFyU3RhcnQiLCJiYXJFbmQiLCJfY3VzdG9tIiwicGFyc2VWYWx1ZSIsInBhcnNlQXJyYXlPclByaW1pdGl2ZSIsImlzRmxvYXRCYXIiLCJjdXN0b20iLCJiYXJTaWduIiwiYWN0dWFsQmFzZSIsImlzSG9yaXpvbnRhbCIsImJvcmRlclByb3BzIiwiaG9yaXpvbnRhbCIsInNldEJvcmRlclNraXBwZWQiLCJlZGdlIiwiYm9yZGVyU2tpcHBlZCIsImVuYWJsZUJvcmRlclJhZGl1cyIsInBhcnNlRWRnZSIsInN3YXAiLCJzdGFydEVuZCIsIm9yaWciLCJ2MiIsIkJhckNvbnRyb2xsZXIiLCJpQXhpc0tleSIsInZBeGlzS2V5IiwiYmFycyIsImdldEJhc2VQaXhlbCIsIl9nZXRSdWxlciIsImZpcnN0T3B0cyIsInZwaXhlbHMiLCJoZWFkIiwiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImNlbnRlciIsIl9nZXRTdGFja3MiLCJncm91cGVkIiwiX2dldFN0YWNrQ291bnQiLCJfZ2V0U3RhY2tJbmRleCIsIl9zdGFydFBpeGVsIiwiX2VuZFBpeGVsIiwiYmFzZVZhbHVlIiwibWluQmFyTGVuZ3RoIiwiZmxvYXRpbmciLCJnZXREYXRhVmlzaWJpbGl0eSIsImhhbGZHcmlkIiwiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCJza2lwTnVsbCIsIm1heEJhclRoaWNrbmVzcyIsIkluZmluaXR5Iiwic3RhY2tJbmRleCIsInJlY3RzIiwiX2luZGV4XyIsIm9mZnNldCIsImdyaWQiLCJfdmFsdWVfIiwiYmVnaW5BdFplcm8iLCJCdWJibGVDb250cm9sbGVyIiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwidG9vbHRpcCIsInRpdGxlIiwiZ2V0UmF0aW9BbmRPZmZzZXQiLCJjaXJjdW1mZXJlbmNlIiwiY3V0b3V0IiwicmF0aW9YIiwicmF0aW9ZIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJjYWxjTWF4IiwiY2FsY01pbiIsIm1heFgiLCJtYXhZIiwibWluWCIsIm1pblkiLCJEb3VnaG51dENvbnRyb2xsZXIiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiX2dldFJvdGF0aW9uIiwiX2dldENpcmN1bWZlcmVuY2UiLCJfZ2V0Um90YXRpb25FeHRlbnRzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImFyY3MiLCJzcGFjaW5nIiwiZ2V0TWF4Qm9yZGVyV2lkdGgiLCJnZXRNYXhPZmZzZXQiLCJtYXhTaXplIiwiY2hhcnRXZWlnaHQiLCJfZ2V0UmluZ1dlaWdodCIsIm1heFJhZGl1cyIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwidG90YWwiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiX2NpcmN1bWZlcmVuY2UiLCJhbmltYXRlUm90YXRlIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImFuaW1hdGlvbk9wdHMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImFuaW1hdGVTY2FsZSIsIm1ldGFEYXRhIiwiYm9yZGVyQWxpZ24iLCJob3ZlckJvcmRlcldpZHRoIiwiaG92ZXJPZmZzZXQiLCJyaW5nV2VpZ2h0T2Zmc2V0IiwibGVnZW5kIiwiZ2VuZXJhdGVMYWJlbHMiLCJsZWdlbmRJdGVtIiwidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImZvcm1hdHRlZFZhbHVlIiwiTGluZUNvbnRyb2xsZXIiLCJfZGF0YXNldCIsImFuaW1hdGlvbnNEaXNhYmxlZCIsImdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJzY2FsZVJhbmdlc0NoYW5nZWQiLCJfZGVjaW1hdGVkIiwiYW5pbWF0ZWQiLCJtYXhHYXBMZW5ndGgiLCJkaXJlY3RVcGRhdGUiLCJwcmV2UGFyc2VkIiwibnVsbERhdGEiLCJib3JkZXIiLCJsYXN0UG9pbnQiLCJ1cGRhdGVDb250cm9sUG9pbnRzIiwicG9pbnRDb3VudCIsIl9zY2FsZVJhbmdlcyIsIm5ld1JhbmdlcyIsInhtaW4iLCJ4bWF4IiwieW1pbiIsInltYXgiLCJjaGFuZ2VkIiwiUG9sYXJBcmVhQ29udHJvbGxlciIsIl91cGRhdGVSYWRpdXMiLCJtaW5TaXplIiwiY3V0b3V0UGVyY2VudGFnZSIsImdldFZpc2libGVEYXRhc2V0Q291bnQiLCJ4Q2VudGVyIiwieUNlbnRlciIsImRhdGFzZXRTdGFydEFuZ2xlIiwiZ2V0SW5kZXhBbmdsZSIsImRlZmF1bHRBbmdsZSIsImNvdW50VmlzaWJsZUVsZW1lbnRzIiwiX2NvbXB1dGVBbmdsZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwiYW5nbGVMaW5lcyIsImRpc3BsYXkiLCJjaXJjdWxhciIsInBvaW50TGFiZWxzIiwiUGllQ29udHJvbGxlciIsIlJhZGFyQ29udHJvbGxlciIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJTY2F0dGVyQ29udHJvbGxlciIsImNvbnRyb2xsZXJzIiwiX19wcm90b19fIiwiYWJzdHJhY3QiLCJEYXRlQWRhcHRlciIsImZvcm1hdHMiLCJ0aW1lc3RhbXAiLCJhbW91bnQiLCJ1bml0IiwiZGlmZiIsInN0YXJ0T2YiLCJ3ZWVrZGF5IiwiZW5kT2YiLCJtZW1iZXJzIiwiYWRhcHRlcnMiLCJfZGF0ZSIsImdldFJlbGF0aXZlUG9zaXRpb24kMSIsImV2YWx1YXRlQWxsVmlzaWJsZUl0ZW1zIiwiaGFuZGxlciIsImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCJiaW5hcnlTZWFyY2giLCJtZXRhc2V0IiwibG9va3VwTWV0aG9kIiwiX3JldmVyc2VQaXhlbHMiLCJnZXRSYW5nZSIsIm9wdGltaXplZEV2YWx1YXRlSXRlbXMiLCJwb3NpdGlvbiIsImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsInVzZVgiLCJ1c2VZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJ1c2VGaW5hbFBvc2l0aW9uIiwiX21pblBhZGRpbmciLCJldmFsdWF0aW9uRnVuYyIsImluUmFuZ2UiLCJnZXROZWFyZXN0SXRlbXMiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiZ2V0Q2VudGVyUG9pbnQiLCJnZXRBeGlzSXRlbXMiLCJyYW5nZU1ldGhvZCIsImludGVyc2VjdHNJdGVtIiwiSW50ZXJhY3Rpb24iLCJtb2RlcyIsIm5lYXJlc3QiLCJTVEFUSUNfUE9TSVRJT05TIiwiZmlsdGVyQnlQb3NpdGlvbiIsImZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyIsInNvcnRCeVdlaWdodCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJzdGFja1dlaWdodCIsImJ1aWxkU3RhY2tzIiwibGF5b3V0cyIsIndyYXAiLCJwbGFjZWQiLCJzZXRMYXlvdXREaW1zIiwicGFyYW1zIiwidkJveE1heFdpZHRoIiwiaEJveE1heEhlaWdodCIsImxheW91dCIsImZ1bGxTaXplIiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJidWlsZExheW91dEJveGVzIiwiY2VudGVySG9yaXpvbnRhbCIsImNlbnRlclZlcnRpY2FsIiwibGVmdEFuZFRvcCIsInJpZ2h0QW5kQm90dG9tIiwidmVydGljYWwiLCJnZXRDb21iaW5lZE1heCIsIm1heFBhZGRpbmciLCJ1cGRhdGVNYXhQYWRkaW5nIiwiYm94UGFkZGluZyIsInVwZGF0ZURpbXMiLCJnZXRQYWRkaW5nIiwibmV3V2lkdGgiLCJvdXRlcldpZHRoIiwibmV3SGVpZ2h0Iiwib3V0ZXJIZWlnaHQiLCJ3aWR0aENoYW5nZWQiLCJoZWlnaHRDaGFuZ2VkIiwic2FtZSIsIm90aGVyIiwiaGFuZGxlTWF4UGFkZGluZyIsInVwZGF0ZVBvcyIsImNoYW5nZSIsImdldE1hcmdpbnMiLCJtYXJnaW5Gb3JQb3NpdGlvbnMiLCJmaXRCb3hlcyIsInJlZml0Qm94ZXMiLCJyZWZpdCIsInNldEJveERpbXMiLCJwbGFjZUJveGVzIiwidXNlclBhZGRpbmciLCJwYWRkaW5nIiwiYWRkQm94IiwiX2xheWVycyIsInoiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwibWluUGFkZGluZyIsInZlcnRpY2FsQm94ZXMiLCJob3Jpem9udGFsQm94ZXMiLCJiZWZvcmVMYXlvdXQiLCJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsIkJhc2VQbGF0Zm9ybSIsImFjcXVpcmVDb250ZXh0IiwicmVsZWFzZUNvbnRleHQiLCJpc0F0dGFjaGVkIiwiQmFzaWNQbGF0Zm9ybSIsIkVYUEFORE9fS0VZIiwiRVZFTlRfVFlQRVMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm91dCIsImlzTnVsbE9yRW1wdHkiLCJpbml0Q2FudmFzIiwicmVuZGVySGVpZ2h0IiwiZ2V0QXR0cmlidXRlIiwicmVuZGVyV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiZnJvbU5hdGl2ZUV2ZW50IiwiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiYWRkZWROb2RlcyIsImFkZGVkIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjcmVhdGVEZXRhY2hPYnNlcnZlciIsInJlbW92ZWROb2RlcyIsImRycExpc3RlbmluZ0NoYXJ0cyIsIm9sZERldmljZVBpeGVsUmF0aW8iLCJvbldpbmRvd1Jlc2l6ZSIsImRwciIsImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsImNyZWF0ZVJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJjb250ZW50UmVjdCIsInJlbGVhc2VPYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJjcmVhdGVQcm94eUFuZExpc3RlbiIsIkRvbVBsYXRmb3JtIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicHJveGllcyIsIiRwcm94aWVzIiwiaGFuZGxlcnMiLCJhdHRhY2giLCJkZXRhY2giLCJpc0Nvbm5lY3RlZCIsIl9kZXRlY3RQbGF0Zm9ybSIsIk9mZnNjcmVlbkNhbnZhcyIsIkVsZW1lbnQiLCJ0b29sdGlwUG9zaXRpb24iLCJnZXRQcm9wcyIsImhhc1ZhbHVlIiwiZmluYWwiLCJkZWZhdWx0Um91dGVzIiwiZm9ybWF0dGVycyIsIm51bWVyaWMiLCJ0aWNrVmFsdWUiLCJub3RhdGlvbiIsIm1heFRpY2siLCJjYWxjdWxhdGVEZWx0YSIsImxvZ0RlbHRhIiwibnVtRGVjaW1hbCIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImxvZ2FyaXRobWljIiwiVGlja3MiLCJkcmF3Qm9yZGVyIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja0xlbmd0aCIsInRpY2tXaWR0aCIsInRpY2tDb2xvciIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJtaXJyb3IiLCJ0ZXh0U3Ryb2tlV2lkdGgiLCJ0ZXh0U3Ryb2tlQ29sb3IiLCJhdXRvU2tpcCIsImF1dG9Ta2lwUGFkZGluZyIsImxhYmVsT2Zmc2V0IiwibWlub3IiLCJtYWpvciIsImNyb3NzQWxpZ24iLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wQ29sb3IiLCJiYWNrZHJvcFBhZGRpbmciLCJ0aWNrT3B0cyIsInRpY2tzTGltaXQiLCJtYXhUaWNrc0xpbWl0IiwiZGV0ZXJtaW5lTWF4VGlja3MiLCJtYWpvckluZGljZXMiLCJlbmFibGVkIiwiZ2V0TWFqb3JJbmRpY2VzIiwibnVtTWFqb3JJbmRpY2VzIiwiZmlyc3QiLCJuZXdUaWNrcyIsInNraXBNYWpvcnMiLCJjYWxjdWxhdGVTcGFjaW5nIiwiYXZnTWFqb3JTcGFjaW5nIiwiX3RpY2tTaXplIiwibWF4U2NhbGUiLCJtYXhDaGFydCIsIl9tYXhMZW5ndGgiLCJldmVuTWFqb3JTcGFjaW5nIiwiZ2V0RXZlblNwYWNpbmciLCJmYWN0b3JzIiwiY2VpbCIsIm1ham9yU3RhcnQiLCJtYWpvckVuZCIsInJldmVyc2VBbGlnbiIsIm9mZnNldEZyb21FZGdlIiwic2FtcGxlIiwibnVtSXRlbXMiLCJpbmNyZW1lbnQiLCJnZXRQaXhlbEZvckdyaWRMaW5lIiwib2Zmc2V0R3JpZExpbmVzIiwidmFsaWRJbmRleCIsImxpbmVWYWx1ZSIsImNhY2hlcyIsImdldFRpY2tNYXJrTGVuZ3RoIiwiZ2V0VGl0bGVIZWlnaHQiLCJjcmVhdGVTY2FsZUNvbnRleHQiLCJjcmVhdGVUaWNrQ29udGV4dCIsInRpdGxlQWxpZ24iLCJ0aXRsZUFyZ3MiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJwb3NpdGlvbkF4aXNJRCIsIlNjYWxlIiwiX21hcmdpbnMiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwibGFiZWxSb3RhdGlvbiIsIl9yYW5nZSIsIl9ncmlkTGluZUl0ZW1zIiwiX2xhYmVsSXRlbXMiLCJfbGFiZWxTaXplcyIsIl9sb25nZXN0VGV4dENhY2hlIiwiX3VzZXJNYXgiLCJfdXNlck1pbiIsIl9zdWdnZXN0ZWRNYXgiLCJfc3VnZ2VzdGVkTWluIiwiX3RpY2tzTGVuZ3RoIiwiX2JvcmRlclZhbHVlIiwiX2RhdGFMaW1pdHNDYWNoZWQiLCJpbml0Iiwic3VnZ2VzdGVkTWluIiwic3VnZ2VzdGVkTWF4IiwiZ2V0VGlja3MiLCJ4TGFiZWxzIiwieUxhYmVscyIsImJlZm9yZVVwZGF0ZSIsInNhbXBsZVNpemUiLCJiZWZvcmVTZXREaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsImFmdGVyU2V0RGltZW5zaW9ucyIsImJlZm9yZURhdGFMaW1pdHMiLCJkZXRlcm1pbmVEYXRhTGltaXRzIiwiYWZ0ZXJEYXRhTGltaXRzIiwiYmVmb3JlQnVpbGRUaWNrcyIsImJ1aWxkVGlja3MiLCJhZnRlckJ1aWxkVGlja3MiLCJzYW1wbGluZ0VuYWJsZWQiLCJfY29udmVydFRpY2tzVG9MYWJlbHMiLCJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwiY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImJlZm9yZUZpdCIsImZpdCIsImFmdGVyRml0IiwiYWZ0ZXJVcGRhdGUiLCJyZXZlcnNlUGl4ZWxzIiwic3RhcnRQaXhlbCIsImVuZFBpeGVsIiwiX2FsaWduVG9QaXhlbHMiLCJhbGlnblRvUGl4ZWxzIiwiX2NhbGxIb29rcyIsIm5vdGlmeVBsdWdpbnMiLCJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJnZW5lcmF0ZVRpY2tMYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsIm51bVRpY2tzIiwibWF4TGFiZWxEaWFnb25hbCIsIl9pc1Zpc2libGUiLCJsYWJlbFNpemVzIiwiX2dldExhYmVsU2l6ZXMiLCJtYXhMYWJlbFdpZHRoIiwid2lkZXN0IiwibWF4TGFiZWxIZWlnaHQiLCJoaWdoZXN0IiwiYXNpbiIsInRpdGxlT3B0cyIsImdyaWRPcHRzIiwidGl0bGVIZWlnaHQiLCJ0aWNrUGFkZGluZyIsImFuZ2xlUmFkaWFucyIsImxhYmVsSGVpZ2h0IiwibGFiZWxXaWR0aCIsIl9jYWxjdWxhdGVQYWRkaW5nIiwiX2hhbmRsZU1hcmdpbnMiLCJpc1JvdGF0ZWQiLCJsYWJlbHNCZWxvd1RpY2tzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaXNGdWxsU2l6ZSIsIl9jb21wdXRlTGFiZWxTaXplcyIsIndpZHRocyIsImhlaWdodHMiLCJ3aWRlc3RMYWJlbFNpemUiLCJoaWdoZXN0TGFiZWxTaXplIiwidGlja0ZvbnQiLCJuZXN0ZWRMYWJlbCIsIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwidmFsdWVBdCIsImdldFZhbHVlRm9yUGl4ZWwiLCJkZWNpbWFsIiwiZ2V0RGVjaW1hbEZvclBpeGVsIiwiZ2V0QmFzZVZhbHVlIiwib3B0aW9uVGlja3MiLCJyb3QiLCJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCJ0aWNrc0xlbmd0aCIsInRsIiwiYm9yZGVyT3B0cyIsImF4aXNXaWR0aCIsImF4aXNIYWxmV2lkdGgiLCJhbGlnbkJvcmRlclZhbHVlIiwiYm9yZGVyVmFsdWUiLCJhbGlnbmVkTGluZVZhbHVlIiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJsaW1pdCIsInN0ZXAiLCJvcHRzQXRJbmRleCIsImxpbmVDb2xvciIsInRpY2tCb3JkZXJEYXNoIiwidGlja0JvcmRlckRhc2hPZmZzZXQiLCJfY29tcHV0ZUxhYmVsSXRlbXMiLCJ0aWNrQW5kUGFkZGluZyIsImhUaWNrQW5kUGFkZGluZyIsImxpbmVDb3VudCIsInRleHRPZmZzZXQiLCJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwiaGFsZkNvdW50IiwiYmFja2Ryb3AiLCJsYWJlbFBhZGRpbmciLCJfY29tcHV0ZUxhYmVsQXJlYSIsImRyYXdCYWNrZ3JvdW5kIiwiZmlsbFJlY3QiLCJmaW5kSW5kZXgiLCJkcmF3R3JpZCIsImRyYXdMaW5lIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsImxhc3RMaW5lV2lkdGgiLCJkcmF3TGFiZWxzIiwiZHJhd1RpdGxlIiwidHoiLCJneiIsImF4aXNJRCIsIl9tYXhEaWdpdHMiLCJmb250U2l6ZSIsIlR5cGVkUmVnaXN0cnkiLCJpc0ZvclR5cGUiLCJpc1Byb3RvdHlwZU9mIiwicmVnaXN0ZXIiLCJwYXJlbnRTY29wZSIsImlzSUNoYXJ0Q29tcG9uZW50IiwicmVnaXN0ZXJEZWZhdWx0cyIsInVucmVnaXN0ZXIiLCJpdGVtRGVmYXVsdHMiLCJyb3V0ZURlZmF1bHRzIiwicm91dGVzIiwicHJvcGVydHlQYXJ0cyIsInNvdXJjZU5hbWUiLCJzb3VyY2VTY29wZSIsInBhcnRzIiwiUmVnaXN0cnkiLCJfdHlwZWRSZWdpc3RyaWVzIiwiX2VhY2giLCJhZGRDb250cm9sbGVycyIsImFkZFBsdWdpbnMiLCJhZGRTY2FsZXMiLCJnZXRDb250cm9sbGVyIiwiX2dldCIsImdldEVsZW1lbnQiLCJnZXRQbHVnaW4iLCJnZXRTY2FsZSIsInJlbW92ZUNvbnRyb2xsZXJzIiwicmVtb3ZlRWxlbWVudHMiLCJyZW1vdmVQbHVnaW5zIiwicmVtb3ZlU2NhbGVzIiwidHlwZWRSZWdpc3RyeSIsImFyZyIsInJlZyIsIl9nZXRSZWdpc3RyeUZvclR5cGUiLCJfZXhlYyIsIml0ZW1SZWciLCJyZWdpc3RyeSIsImNvbXBvbmVudCIsImNhbWVsTWV0aG9kIiwiUGx1Z2luU2VydmljZSIsIl9pbml0Iiwibm90aWZ5IiwiaG9vayIsIl9jcmVhdGVEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJwbHVnaW4iLCJjYW5jZWxhYmxlIiwiaW52YWxpZGF0ZSIsIl9vbGRDYWNoZSIsIl9ub3RpZnlTdGF0ZUNoYW5nZXMiLCJhbGxQbHVnaW5zIiwiY3JlYXRlRGVzY3JpcHRvcnMiLCJwcmV2aW91c0Rlc2NyaXB0b3JzIiwic29tZSIsImdldE9wdHMiLCJwbHVnaW5PcHRzIiwicGx1Z2luU2NvcGVLZXlzIiwiZ2V0SW5kZXhBeGlzIiwiZGF0YXNldERlZmF1bHRzIiwiZGF0YXNldE9wdGlvbnMiLCJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwiZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyIsImF4aXNGcm9tUG9zaXRpb24iLCJkZXRlcm1pbmVBeGlzIiwic2NhbGVPcHRpb25zIiwibWVyZ2VTY2FsZUNvbmZpZyIsImNoYXJ0RGVmYXVsdHMiLCJjb25maWdTY2FsZXMiLCJjaGFydEluZGV4QXhpcyIsImZpcnN0SURzIiwic2NhbGVDb25mIiwiZGVmYXVsdElkIiwiZGVmYXVsdFNjYWxlT3B0aW9ucyIsImRlZmF1bHRJRCIsImluaXRPcHRpb25zIiwiaW5pdERhdGEiLCJpbml0Q29uZmlnIiwia2V5Q2FjaGUiLCJrZXlzQ2FjaGVkIiwiY2FjaGVkS2V5cyIsImdlbmVyYXRlIiwiYWRkSWZGb3VuZCIsIkNvbmZpZyIsIl9jb25maWciLCJfc2NvcGVDYWNoZSIsIl9yZXNvbHZlckNhY2hlIiwiY2xlYXJDYWNoZSIsImNsZWFyIiwiZGF0YXNldFR5cGUiLCJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwiX2NhY2hlZFNjb3BlcyIsIm1haW5TY29wZSIsInJlc2V0Q2FjaGUiLCJrZXlMaXN0cyIsImNoYXJ0T3B0aW9uU2NvcGVzIiwic3ViUHJlZml4ZXMiLCJnZXRSZXNvbHZlciIsIm5lZWRDb250ZXh0Iiwic3ViUmVzb2x2ZXIiLCJyZXNvbHZlckNhY2hlIiwidmVyc2lvbiIsIktOT1dOX1BPU0lUSU9OUyIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29tcGFyZTJMZXZlbCIsImwxIiwibDIiLCJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsIm9uQ29tcGxldGUiLCJvbkFuaW1hdGlvblByb2dyZXNzIiwib25Qcm9ncmVzcyIsImdldENhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwiaW5zdGFuY2VzIiwiZ2V0Q2hhcnQiLCJDaGFydCIsInVzZXJDb25maWciLCJpbml0aWFsQ2FudmFzIiwiZXhpc3RpbmdDaGFydCIsIl9vcHRpb25zIiwiX2FzcGVjdFJhdGlvIiwiX21ldGFzZXRzIiwiX2xhc3RFdmVudCIsIl9saXN0ZW5lcnMiLCJfcmVzcG9uc2l2ZUxpc3RlbmVycyIsIl9zb3J0ZWRNZXRhc2V0cyIsIl9wbHVnaW5zIiwiX2hpZGRlbkluZGljZXMiLCJhdHRhY2hlZCIsIl9kb1Jlc2l6ZSIsInJlc2l6ZURlbGF5IiwiZXJyb3IiLCJfaW5pdGlhbGl6ZSIsImJpbmRFdmVudHMiLCJfcmVzaXplIiwiX3Jlc2l6ZUJlZm9yZURyYXciLCJuZXdTaXplIiwibmV3UmF0aW8iLCJvblJlc2l6ZSIsInJlbmRlciIsImVuc3VyZVNjYWxlc0hhdmVJRHMiLCJzY2FsZXNPcHRpb25zIiwiYXhpc09wdGlvbnMiLCJidWlsZE9yVXBkYXRlU2NhbGVzIiwic2NhbGVPcHRzIiwidXBkYXRlZCIsImlzUmFkaWFsIiwiZHBvc2l0aW9uIiwiZHR5cGUiLCJzY2FsZVR5cGUiLCJzY2FsZUNsYXNzIiwiaGFzVXBkYXRlZCIsIl91cGRhdGVNZXRhc2V0cyIsIl9kZXN0cm95RGF0YXNldE1ldGEiLCJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsIm9yZGVyIiwiQ29udHJvbGxlckNsYXNzIiwiX3Jlc2V0RWxlbWVudHMiLCJhbmltc0Rpc2FibGVkIiwiZXhpc3RpbmdFdmVudHMiLCJuZXdFdmVudHMiLCJ1bmJpbmRFdmVudHMiLCJfdXBkYXRlTGF5b3V0IiwiX3VwZGF0ZURhdGFzZXRzIiwiX2V2ZW50SGFuZGxlciIsIm5vQXJlYSIsIl9pZHgiLCJfdXBkYXRlRGF0YXNldCIsImxheWVycyIsIl9kcmF3RGF0YXNldHMiLCJfZHJhd0RhdGFzZXQiLCJ1c2VDbGlwIiwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsInNldERhdGFzZXRWaXNpYmlsaXR5IiwiX3VwZGF0ZVZpc2liaWxpdHkiLCJkZXN0cm95IiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsImJpbmRVc2VyRXZlbnRzIiwiYmluZFJlc3BvbnNpdmVFdmVudHMiLCJfYWRkIiwiX3JlbW92ZSIsImRldGFjaGVkIiwidXBkYXRlSG92ZXJTdHlsZSIsImdldEFjdGl2ZUVsZW1lbnRzIiwic2V0QWN0aXZlRWxlbWVudHMiLCJhY3RpdmVFbGVtZW50cyIsImxhc3RBY3RpdmUiLCJfdXBkYXRlSG92ZXJTdHlsZXMiLCJyZXBsYXkiLCJob3Zlck9wdGlvbnMiLCJkZWFjdGl2YXRlZCIsImFjdGl2YXRlZCIsImV2ZW50RmlsdGVyIiwiX2hhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwiaW52YWxpZGF0ZVBsdWdpbnMiLCJjbGlwQXJjIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsInRvUmFkaXVzQ29ybmVycyIsInBhcnNlQm9yZGVyUmFkaXVzJDEiLCJhbmdsZURlbHRhIiwibyIsImJvcmRlclJhZGl1cyIsImhhbGZUaGlja25lc3MiLCJpbm5lckxpbWl0IiwiY29tcHV0ZU91dGVyTGltaXQiLCJvdXRlckFyY0xpbWl0Iiwib3V0ZXJTdGFydCIsIm91dGVyRW5kIiwiaW5uZXJTdGFydCIsImlubmVyRW5kIiwiclRoZXRhVG9YWSIsInRoZXRhIiwicGF0aEFyYyIsImlubmVyUiIsInNwYWNpbmdPZmZzZXQiLCJub1NwYWNpbmdJbm5lclJhZGl1cyIsIm5vU3BhY2luZ091dGVyUmFkaXVzIiwiYXZOb2dTcGFjaW5nUmFkaXVzIiwiYWRqdXN0ZWRBbmdsZSIsImJldGEiLCJhbmdsZU9mZnNldCIsIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsInBDZW50ZXIiLCJwNCIsInA4IiwiZHJhd0FyYyIsImZ1bGxDaXJjbGVzIiwiZHJhd0Z1bGxDaXJjbGVCb3JkZXJzIiwiaW5uZXIiLCJsaW5lSm9pbiIsIkFyY0VsZW1lbnQiLCJjaGFydFgiLCJjaGFydFkiLCJyQWRqdXN0IiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJyYWRpdXNPZmZzZXQiLCJzZXRTdHlsZSIsImxpbmVDYXAiLCJnZXRMaW5lTWV0aG9kIiwic3RlcHBlZCIsInBhdGhWYXJzIiwicGFyYW1zU3RhcnQiLCJwYXJhbXNFbmQiLCJzZWdtZW50U3RhcnQiLCJzZWdtZW50RW5kIiwib3V0c2lkZSIsInBhdGhTZWdtZW50IiwibGluZU1ldGhvZCIsImZhc3RQYXRoU2VnbWVudCIsImF2Z1giLCJjb3VudFgiLCJwcmV2WCIsImxhc3RZIiwicG9pbnRJbmRleCIsImRyYXdYIiwidHJ1bmNYIiwiX2dldFNlZ21lbnRNZXRob2QiLCJ1c2VGYXN0UGF0aCIsIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwic3Ryb2tlUGF0aFdpdGhDYWNoZSIsInBhdGgiLCJfcGF0aCIsIlBhdGgyRCIsInN0cm9rZVBhdGhEaXJlY3QiLCJzZWdtZW50TWV0aG9kIiwidXNlUGF0aDJEIiwiTGluZUVsZW1lbnQiLCJfcG9pbnRzIiwiX3NlZ21lbnRzIiwiX3BvaW50c1VwZGF0ZWQiLCJpbnRlcnBvbGF0ZSIsIl9pbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImluUmFuZ2UkMSIsImhpdFJhZGl1cyIsIlBvaW50RWxlbWVudCIsIm1vdXNlWCIsIm1vdXNlWSIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJob3ZlclJhZGl1cyIsImdldEJhckJvdW5kcyIsImJhciIsImhhbGYiLCJza2lwT3JMaW1pdCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsInBhcnNlQm9yZGVyUmFkaXVzIiwibWF4UiIsImVuYWJsZUJvcmRlciIsImJvdW5kaW5nUmVjdHMiLCJvdXRlciIsInNraXBYIiwic2tpcFkiLCJza2lwQm90aCIsImhhc1JhZGl1cyIsImFkZE5vcm1hbFJlY3RQYXRoIiwiaW5mbGF0ZVJlY3QiLCJyZWZSZWN0IiwiQmFyRWxlbWVudCIsImFkZFJlY3RQYXRoIiwiaW5mbGF0ZUFtb3VudCIsImx0dGJEZWNpbWF0aW9uIiwic2FtcGxlcyIsImRlY2ltYXRlZCIsImJ1Y2tldFdpZHRoIiwic2FtcGxlZEluZGV4IiwiZW5kSW5kZXgiLCJtYXhBcmVhUG9pbnQiLCJtYXhBcmVhIiwibmV4dEEiLCJhdmdZIiwiYXZnUmFuZ2VTdGFydCIsImF2Z1JhbmdlRW5kIiwiYXZnUmFuZ2VMZW5ndGgiLCJyYW5nZU9mZnMiLCJyYW5nZVRvIiwicG9pbnRBeCIsInBvaW50QXkiLCJtaW5NYXhEZWNpbWF0aW9uIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInN0YXJ0SW5kZXgiLCJ4TWluIiwieE1heCIsImR4IiwibGFzdEluZGV4IiwiaW50ZXJtZWRpYXRlSW5kZXgxIiwiaW50ZXJtZWRpYXRlSW5kZXgyIiwiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwiY2xlYW5EZWNpbWF0ZWREYXRhIiwiZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQiLCJwbHVnaW5fZGVjaW1hdGlvbiIsImFsZ29yaXRobSIsImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwieEF4aXMiLCJ0aHJlc2hvbGQiLCJnZXRMaW5lQnlJbmRleCIsInBhcnNlRmlsbE9wdGlvbiIsImZpbGxPcHRpb24iLCJkZWNvZGVGaWxsIiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5Iiwic2ltcGxlQXJjIiwiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCJjb21wdXRlQm91bmRhcnkiLCJmaW5kU2VnbWVudEVuZCIsInBvaW50c0Zyb21TZWdtZW50cyIsImJvdW5kYXJ5IiwibGluZVBvaW50cyIsImJ1aWxkU3RhY2tMaW5lIiwic291cmNlUG9pbnRzIiwibGluZXNCZWxvdyIsImdldExpbmVzQmVsb3ciLCJjcmVhdGVCb3VuZGFyeUxpbmUiLCJhZGRQb2ludHNCZWxvdyIsImlzTGluZUFuZE5vdEluSGlkZUFuaW1hdGlvbiIsImJlbG93IiwidW5zaGlmdCIsInNvdXJjZVBvaW50IiwicG9zdHBvbmVkIiwiZmluZFBvaW50IiwicG9pbnRWYWx1ZSIsImZpcnN0VmFsdWUiLCJsYXN0VmFsdWUiLCJyZXNvbHZlVGFyZ2V0IiwicHJvcGFnYXRlIiwidmlzaXRlZCIsImNsaXBZIiwiZ2V0Qm91bmRzIiwiX2dldEVkZ2UiLCJ0cG9pbnRzIiwidGFyZ2V0U2VnbWVudHMiLCJ0Z3QiLCJzdWJCb3VuZHMiLCJmaWxsU291cmNlcyIsImZpbGxTb3VyY2UiLCJjbGlwQm91bmRzIiwiaW50ZXJwb2xhdGVkTGluZVRvIiwiaW50ZXJwb2xhdGVkUG9pbnQiLCJfZmlsbCIsInNyYyIsIm5vdFNoYXBlIiwibGluZUxvb3AiLCJ0YXJnZXRMb29wIiwiZG9GaWxsIiwiYWJvdmUiLCJkcmF3ZmlsbCIsImxpbmVPcHRzIiwicGx1Z2luX2ZpbGxlciIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCJfYXJncyIsIiRmaWxsZXIiLCJiZWZvcmVEcmF3IiwiZHJhd1RpbWUiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJiZWZvcmVEYXRhc2V0RHJhdyIsImdldEJveFNpemUiLCJsYWJlbE9wdHMiLCJib3hIZWlnaHQiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJpdGVtSGVpZ2h0IiwiaXRlbXNFcXVhbCIsIkxlZ2VuZCIsIl9hZGRlZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwibGVnZW5kSXRlbXMiLCJjb2x1bW5TaXplcyIsImxpbmVXaWR0aHMiLCJidWlsZExhYmVscyIsImxhYmVsRm9udCIsIl9jb21wdXRlVGl0bGVIZWlnaHQiLCJfZml0Um93cyIsIl9maXRDb2xzIiwiaGl0Ym94ZXMiLCJ0b3RhbEhlaWdodCIsInJvdyIsImhlaWdodExpbWl0IiwidG90YWxXaWR0aCIsImN1cnJlbnRDb2xXaWR0aCIsImN1cnJlbnRDb2xIZWlnaHQiLCJjb2wiLCJhZGp1c3RIaXRCb3hlcyIsInJ0bEhlbHBlciIsImhpdGJveCIsIl9kcmF3IiwiZGVmYXVsdENvbG9yIiwiZm9udENvbG9yIiwiaGFsZkZvbnRTaXplIiwiY3Vyc29yIiwiZHJhd0xlZ2VuZEJveCIsImxpbmVEYXNoIiwiZHJhd09wdGlvbnMiLCJTUVJUMiIsInlCb3hUb3AiLCJ4Qm94TGVmdCIsInRleHREaXJlY3Rpb24iLCJyZWFsWCIsInRpdGxlRm9udCIsInRpdGxlUGFkZGluZyIsInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaGFuZGxlRXZlbnQiLCJpc0xpc3RlbmVkIiwiaG92ZXJlZEl0ZW0iLCJzYW1lSXRlbSIsIm9uTGVhdmUiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJhZnRlckV2ZW50IiwiY2kiLCJUaXRsZSIsIl9wYWRkaW5nIiwidGV4dFNpemUiLCJfZHJhd0FyZ3MiLCJmb250T3B0cyIsImNyZWF0ZVRpdGxlIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIldlYWtNYXAiLCJwbHVnaW5fc3VidGl0bGUiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsInNwbGl0TmV3bGluZXMiLCJTdHJpbmciLCJjcmVhdGVUb29sdGlwSXRlbSIsImdldFRvb2x0aXBTaXplIiwiYm9keSIsImZvb3RlciIsImJvZHlGb250IiwiZm9vdGVyRm9udCIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50IiwiYm9keUxpbmVJdGVtQ291bnQiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlQm9keSIsImFmdGVyQm9keSIsInRpdGxlU3BhY2luZyIsInRpdGxlTWFyZ2luQm90dG9tIiwiYm9keUxpbmVIZWlnaHQiLCJkaXNwbGF5Q29sb3JzIiwiYm9keVNwYWNpbmciLCJmb290ZXJNYXJnaW5Ub3AiLCJmb290ZXJTcGFjaW5nIiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwiZGV0ZXJtaW5lWUFsaWduIiwiZG9lc05vdEZpdFdpdGhBbGlnbiIsInhBbGlnbiIsImNhcmV0IiwiY2FyZXRTaXplIiwiY2FyZXRQYWRkaW5nIiwiZGV0ZXJtaW5lWEFsaWduIiwieUFsaWduIiwiY2hhcnRXaWR0aCIsImRldGVybWluZUFsaWdubWVudCIsImFsaWduWCIsImFsaWduWSIsInBhZGRpbmdBbmRTaXplIiwiZ2V0QmFja2dyb3VuZFBvaW50IiwiYWxpZ25tZW50IiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJjcmVhdGVUb29sdGlwQ29udGV4dCIsInRvb2x0aXBJdGVtcyIsIm92ZXJyaWRlQ2FsbGJhY2tzIiwiVG9vbHRpcCIsIm9wYWNpdHkiLCJfZXZlbnRQb3NpdGlvbiIsIl9zaXplIiwiX2NhY2hlZEFuaW1hdGlvbnMiLCJfdG9vbHRpcEl0ZW1zIiwiZGF0YVBvaW50cyIsImNhcmV0WCIsImNhcmV0WSIsImxhYmVsQ29sb3JzIiwibGFiZWxQb2ludFN0eWxlcyIsImxhYmVsVGV4dENvbG9ycyIsImdldFRpdGxlIiwiYmVmb3JlVGl0bGUiLCJhZnRlclRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJzY29wZWQiLCJiZWZvcmVMYWJlbCIsImFmdGVyTGFiZWwiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJiZWZvcmVGb290ZXIiLCJhZnRlckZvb3RlciIsIl9jcmVhdGVJdGVtcyIsIml0ZW1Tb3J0IiwibGFiZWxDb2xvciIsImxhYmVsUG9pbnRTdHlsZSIsImxhYmVsVGV4dENvbG9yIiwicG9zaXRpb25BbmRTaXplIiwiYmFja2dyb3VuZFBvaW50IiwiZXh0ZXJuYWwiLCJkcmF3Q2FyZXQiLCJ0b29sdGlwUG9pbnQiLCJjYXJldFBvc2l0aW9uIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIngzIiwieTMiLCJwdFgiLCJwdFkiLCJ0aXRsZUNvbG9yIiwiX2RyYXdDb2xvckJveCIsImNvbG9yWCIsInJ0bENvbG9yWCIsInlPZmZTZXQiLCJjb2xvclkiLCJtdWx0aUtleUJhY2tncm91bmQiLCJvdXRlclgiLCJpbm5lclgiLCJzdHJva2VSZWN0IiwiZHJhd0JvZHkiLCJib2R5QWxpZ24iLCJ4TGluZVBhZGRpbmciLCJmaWxsTGluZU9mVGV4dCIsImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwidGV4dENvbG9yIiwiYm9keUNvbG9yIiwiZHJhd0Zvb3RlciIsImZvb3RlckFsaWduIiwiZm9vdGVyQ29sb3IiLCJ0b29sdGlwU2l6ZSIsInF1YWRyYXRpY0N1cnZlVG8iLCJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwiYW5pbVgiLCJhbmltWSIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJwb3NpdGlvbkNoYW5nZWQiLCJfcG9zaXRpb25DaGFuZ2VkIiwicGx1Z2luX3Rvb2x0aXAiLCJhZnRlckluaXQiLCJhZnRlckRyYXciLCJsYWJlbENvdW50IiwiRGVjaW1hdGlvbiIsIkZpbGxlciIsIlN1YlRpdGxlIiwiYWRkSWZTdHJpbmciLCJmaW5kT3JBZGRMYWJlbCIsImxhc3RJbmRleE9mIiwiQ2F0ZWdvcnlTY2FsZSIsIl9zdGFydFZhbHVlIiwiX3ZhbHVlUmFuZ2UiLCJnZW5lcmF0ZVRpY2tzJDEiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwicHJlY2lzaW9uIiwibWF4VGlja3MiLCJtYXhEaWdpdHMiLCJpbmNsdWRlQm91bmRzIiwibWF4U3BhY2VzIiwicm1pbiIsInJtYXgiLCJjb3VudERlZmluZWQiLCJtaW5TcGFjaW5nIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJkZWNpbWFsUGxhY2VzIiwicmVsYXRpdmVMYWJlbFNpemUiLCJMaW5lYXJTY2FsZUJhc2UiLCJfZW5kVmFsdWUiLCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwic2V0TWluIiwic2V0TWF4IiwibWluU2lnbiIsIm1heFNpZ24iLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsImdldFRpY2tMaW1pdCIsInN0ZXBTaXplIiwiY29tcHV0ZVRpY2tMaW1pdCIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiTGluZWFyU2NhbGUiLCJpc01ham9yIiwidGlja1ZhbCIsImdlbmVyYXRlVGlja3MiLCJlbmRFeHAiLCJlbmRTaWduaWZpY2FuZCIsImV4cCIsInNpZ25pZmljYW5kIiwibGFzdFRpY2siLCJMb2dhcml0aG1pY1NjYWxlIiwiX3plcm8iLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludExhYmVsQ29udGV4dCIsImdldFBvaW50UG9zaXRpb24iLCJkcmF3aW5nQXJlYSIsInBsRm9udCIsIl9wb2ludExhYmVscyIsImhMaW1pdHMiLCJ2TGltaXRzIiwiX3NldFJlZHVjdGlvbnMiLCJfcG9pbnRMYWJlbEl0ZW1zIiwiYnVpbGRQb2ludExhYmVsSXRlbXMiLCJ0aWNrQmFja2Ryb3BIZWlnaHQiLCJvdXRlckRpc3RhbmNlIiwiZXh0cmEiLCJwb2ludExhYmVsUG9zaXRpb24iLCJ5Rm9yQW5nbGUiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImxlZnRGb3JUZXh0QWxpZ24iLCJkcmF3UG9pbnRMYWJlbHMiLCJwYXRoUmFkaXVzTGluZSIsImRyYXdSYWRpdXNMaW5lIiwiZ3JpZExpbmVPcHRzIiwicGFyYW0iLCJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsIlJhZGlhbExpbmVhclNjYWxlIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsInNjYWxlZERpc3RhbmNlIiwicG9pbnRMYWJlbCIsImRpc3RhbmNlRnJvbUNlbnRlciIsImdldEJhc2VQb3NpdGlvbiIsImdldFBvaW50TGFiZWxQb3NpdGlvbiIsImFuaW1hdGUiLCJJTlRFUlZBTFMiLCJtaWxsaXNlY29uZCIsImNvbW1vbiIsInN0ZXBzIiwic2Vjb25kIiwibWludXRlIiwiaG91ciIsImRheSIsIndlZWsiLCJtb250aCIsInF1YXJ0ZXIiLCJ5ZWFyIiwiVU5JVFMiLCJzb3J0ZXIiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJpc29XZWVrZGF5IiwiX3BhcnNlT3B0cyIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwiYWRkVGljayIsInRpbWUiLCJ0aW1lc3RhbXBzIiwic2V0TWFqb3JUaWNrcyIsIm1ham9yVW5pdCIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJUaW1lU2NhbGUiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfb2Zmc2V0cyIsIl9ub3JtYWxpemVkIiwiZGlzcGxheUZvcm1hdHMiLCJub3JtYWxpemVkIiwiX2FwcGx5Qm91bmRzIiwiX2dldExhYmVsQm91bmRzIiwiZ2V0TGFiZWxUaW1lc3RhbXBzIiwidGltZU9wdHMiLCJfZ2VuZXJhdGUiLCJfZ2V0TGFiZWxDYXBhY2l0eSIsImluaXRPZmZzZXRzIiwiZ2V0RGVjaW1hbEZvclZhbHVlIiwiaGFzV2Vla2RheSIsImdldERhdGFUaW1lc3RhbXBzIiwidG9vbHRpcEZvcm1hdCIsImRhdGV0aW1lIiwiX3RpY2tGb3JtYXRGdW5jdGlvbiIsIm1pbm9yRm9ybWF0IiwibWFqb3JGb3JtYXQiLCJvZmZzZXRzIiwiX2dldExhYmVsU2l6ZSIsInRpY2tzT3B0cyIsInRpY2tMYWJlbFdpZHRoIiwiY29zUm90YXRpb24iLCJzaW5Sb3RhdGlvbiIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwicHJldlNvdXJjZSIsIm5leHRTb3VyY2UiLCJwcmV2VGFyZ2V0IiwibmV4dFRhcmdldCIsInNwYW4iLCJUaW1lU2VyaWVzU2NhbGUiLCJfdGFibGUiLCJfbWluUG9zIiwiX3RhYmxlUmFuZ2UiLCJfZ2V0VGltZXN0YW1wc0ZvclRhYmxlIiwiYnVpbGRMb29rdXBUYWJsZSIsInJlZ2lzdGVyYWJsZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLDBCQUFULENBQW9CQyxTQUFwQixFQUErQkMsU0FBL0IsRUFBMENDLFVBQTFDLEVBQXNEO0VBQ3BELE9BQU9ELFNBQVMsR0FBRyxHQUFaLEdBQWtCRCxTQUFsQixHQUE4QixLQUE5QixHQUFzQ0UsVUFBN0M7QUFDRDs7QUFDRCxNQUFNQyxnQkFBZ0IsR0FBSSxZQUFXO0VBQ25DLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztJQUNqQyxPQUFPLFVBQVNDLFFBQVQsRUFBbUI7TUFDeEIsT0FBT0EsUUFBUSxFQUFmO0lBQ0QsQ0FGRDtFQUdEOztFQUNELE9BQU9ELE1BQU0sQ0FBQ0UscUJBQWQ7QUFDRCxDQVB5QixFQUExQjs7QUFRQSxTQUFTQyxTQUFULENBQW1CQyxFQUFuQixFQUF1QkMsT0FBdkIsRUFBZ0NDLFFBQWhDLEVBQTBDO0VBQ3hDLE1BQU1DLFVBQVUsR0FBR0QsUUFBUSxLQUFNRSxJQUFELElBQVVDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCSixJQUEzQixDQUFmLENBQTNCOztFQUNBLElBQUlLLE9BQU8sR0FBRyxLQUFkO0VBQ0EsSUFBSUwsSUFBSSxHQUFHLEVBQVg7RUFDQSxPQUFPLFVBQVMsR0FBR00sSUFBWixFQUFrQjtJQUN2Qk4sSUFBSSxHQUFHRCxVQUFVLENBQUNPLElBQUQsQ0FB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QzYrQixhQUFhLEVBQUVBLHVCQUZ5QjtFQUd4Q2tDLFdBQVcsRUFBRUEscUJBSDJCO0VBSXhDUyxnQkFBZ0IsRUFBRUEsMEJBSnNCO0VBS3hDZ0MsaUJBQWlCLEVBQUVBLDJCQUxxQjtFQU14Q3VELFNBQVMsRUFBRUEsbUJBTjZCO0VBT3hDb0MsZUFBZSxFQUFFQTtBQVB1QixDQUFkLENBQTFCO0FBVUEsTUFBTU0sYUFBYSxHQUFHLENBQ3BCMXBDLFdBRG9CLEVBRXBCNzRCLGtCQUZvQixFQUdwQm1CLGlCQUhvQixFQUlwQkcsZ0JBSm9CLENBQXRCIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2My41LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5jb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnLCB1cGRhdGVGbikge1xuICBjb25zdCB1cGRhdGVBcmdzID0gdXBkYXRlRm4gfHwgKChhcmdzKSA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSk7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG4gIGxldCBhcmdzID0gW107XG4gIHJldHVybiBmdW5jdGlvbiguLi5yZXN0KSB7XG4gICAgYXJncyA9IHVwZGF0ZUFyZ3MocmVzdCk7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0oKSk7XG5mdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuY29uc3QgaXNOdW1iZXJGaW5pdGUgPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xuZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6IHZhbHVlIC8gZGltZW5zaW9uO1xuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuZnVuY3Rpb24gY2FsbGJhY2soZm4sIGFyZ3MsIHRoaXNBcmcpIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuICBsZXQgaSwgbGVuLCBrZXlzO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xuICBsZXQgaSwgaWxlbiwgdjAsIHYxO1xuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9uZSQxKHNvdXJjZSkge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUkMSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lJDEoc291cmNlW2tleXNba11dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VJZih0YXJnZXQsIHNvdXJjZSkge1xuICByZXR1cm4gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuZnVuY3Rpb24gX21lcmdlcklmKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG5cdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuY29uc3QgZW1wdHlTdHJpbmcgPSAnJztcbmNvbnN0IGRvdCA9ICcuJztcbmZ1bmN0aW9uIGluZGV4T2ZEb3RPckxlbmd0aChrZXksIHN0YXJ0KSB7XG4gIGNvbnN0IGlkeCA9IGtleS5pbmRleE9mKGRvdCwgc3RhcnQpO1xuICByZXR1cm4gaWR4ID09PSAtMSA/IGtleS5sZW5ndGggOiBpZHg7XG59XG5mdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KSB7XG4gIGlmIChrZXkgPT09IGVtcHR5U3RyaW5nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGlkeCA9IGluZGV4T2ZEb3RPckxlbmd0aChrZXksIHBvcyk7XG4gIHdoaWxlIChvYmogJiYgaWR4ID4gcG9zKSB7XG4gICAgb2JqID0gb2JqW2tleS5zdWJzdHIocG9zLCBpZHggLSBwb3MpXTtcbiAgICBwb3MgPSBpZHggKyAxO1xuICAgIGlkeCA9IGluZGV4T2ZEb3RPckxlbmd0aChrZXksIHBvcyk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBuaWNlTnVtKHJhbmdlKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cbmZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHgsIHksIGVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbmZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodCwgcywgcCkgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQsIHMsIHApID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogdCA9PiB0LFxuICBlYXNlSW5RdWFkOiB0ID0+IHQgKiB0LFxuICBlYXNlT3V0UXVhZDogdCA9PiAtdCAqICh0IC0gMiksXG4gIGVhc2VJbk91dFF1YWQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG4gIGVhc2VJbkN1YmljOiB0ID0+IHQgKiB0ICogdCxcbiAgZWFzZU91dEN1YmljOiB0ID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRDdWJpYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblF1YXJ0OiB0ID0+IHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWFydDogdCA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG4gIGVhc2VJbk91dFF1YXJ0OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcbiAgZWFzZUluUXVpbnQ6IHQgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWludDogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRRdWludDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuICBlYXNlSW5TaW5lOiB0ID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICBlYXNlT3V0U2luZTogdCA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG4gIGVhc2VJbk91dFNpbmU6IHQgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG4gIGVhc2VJbkV4cG86IHQgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG4gIGVhc2VPdXRFeHBvOiB0ID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuICBlYXNlSW5PdXRFeHBvOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcbiAgZWFzZUluQ2lyYzogdCA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG4gIGVhc2VPdXRDaXJjOiB0ID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcbiAgZWFzZUluT3V0Q2lyYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgZWFzZUluRWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlT3V0RWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZUluT3V0RWxhc3RpYyh0KSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcbiAgZWFzZUluQmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG4gIGVhc2VPdXRCYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuICBlYXNlSW5PdXRCYWNrKHQpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcbiAgZWFzZUluQm91bmNlOiB0ID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuICBlYXNlT3V0Qm91bmNlKHQpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiB0ID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn07XG5cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4xLjlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMCBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgbWFwID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gJzAxMjM0NTY3ODlBQkNERUYnO1xuY29uc3QgaDEgPSAoYikgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSAoYikgPT4gaGV4WyhiICYgMHhGMCkgPj4gNF0gKyBoZXhbYiAmIDB4Rl07XG5jb25zdCBlcSA9IChiKSA9PiAoKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKSk7XG5mdW5jdGlvbiBpc1Nob3J0KHYpIHtcblx0cmV0dXJuIGVxKHYucikgJiYgZXEodi5nKSAmJiBlcSh2LmIpICYmIGVxKHYuYSk7XG59XG5mdW5jdGlvbiBoZXhQYXJzZShzdHIpIHtcblx0dmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cdHZhciByZXQ7XG5cdGlmIChzdHJbMF0gPT09ICcjJykge1xuXHRcdGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XG5cdFx0XHRyZXQgPSB7XG5cdFx0XHRcdHI6IDI1NSAmIG1hcFtzdHJbMV1dICogMTcsXG5cdFx0XHRcdGc6IDI1NSAmIG1hcFtzdHJbMl1dICogMTcsXG5cdFx0XHRcdGI6IDI1NSAmIG1hcFtzdHJbM11dICogMTcsXG5cdFx0XHRcdGE6IGxlbiA9PT0gNSA/IG1hcFtzdHJbNF1dICogMTcgOiAyNTVcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG5cdFx0XHRyZXQgPSB7XG5cdFx0XHRcdHI6IG1hcFtzdHJbMV1dIDw8IDQgfCBtYXBbc3RyWzJdXSxcblx0XHRcdFx0ZzogbWFwW3N0clszXV0gPDwgNCB8IG1hcFtzdHJbNF1dLFxuXHRcdFx0XHRiOiBtYXBbc3RyWzVdXSA8PCA0IHwgbWFwW3N0cls2XV0sXG5cdFx0XHRcdGE6IGxlbiA9PT0gOSA/IChtYXBbc3RyWzddXSA8PCA0IHwgbWFwW3N0cls4XV0pIDogMjU1XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcblx0dmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcblx0cmV0dXJuIHZcblx0XHQ/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArICh2LmEgPCAyNTUgPyBmKHYuYSkgOiAnJylcblx0XHQ6IHY7XG59XG5mdW5jdGlvbiByb3VuZCh2KSB7XG5cdHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcblx0Y29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG5cdGxldCBhID0gMjU1O1xuXHRsZXQgciwgZywgYjtcblx0aWYgKCFtKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtWzddICE9PSByKSB7XG5cdFx0Y29uc3QgdiA9ICttWzddO1xuXHRcdGEgPSAyNTUgJiAobVs4XSA/IHAyYih2KSA6IHYgKiAyNTUpO1xuXHR9XG5cdHIgPSArbVsxXTtcblx0ZyA9ICttWzNdO1xuXHRiID0gK21bNV07XG5cdHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IHIpO1xuXHRnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBnKTtcblx0YiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogYik7XG5cdHJldHVybiB7XG5cdFx0cjogcixcblx0XHRnOiBnLFxuXHRcdGI6IGIsXG5cdFx0YTogYVxuXHR9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcblx0cmV0dXJuIHYgJiYgKFxuXHRcdHYuYSA8IDI1NVxuXHRcdFx0PyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG5cdFx0XHQ6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG5cdCk7XG59XG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuXHRjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcblx0Y29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuXHRyZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuXHRjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuXHRyZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuXHRjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuXHRsZXQgaTtcblx0aWYgKHcgKyBiID4gMSkge1xuXHRcdGkgPSAxIC8gKHcgKyBiKTtcblx0XHR3ICo9IGk7XG5cdFx0YiAqPSBpO1xuXHR9XG5cdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRyZ2JbaV0gKj0gMSAtIHcgLSBiO1xuXHRcdHJnYltpXSArPSB3O1xuXHR9XG5cdHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcblx0Y29uc3QgcmFuZ2UgPSAyNTU7XG5cdGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcblx0Y29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuXHRjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG5cdGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0Y29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcblx0bGV0IGgsIHMsIGQ7XG5cdGlmIChtYXggIT09IG1pbikge1xuXHRcdGQgPSBtYXggLSBtaW47XG5cdFx0cyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXHRcdGggPSBtYXggPT09IHJcblx0XHRcdD8gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0OiBtYXggPT09IGdcblx0XHRcdFx0PyAoYiAtIHIpIC8gZCArIDJcblx0XHRcdFx0OiAociAtIGcpIC8gZCArIDQ7XG5cdFx0aCA9IGggKiA2MCArIDAuNTtcblx0fVxuXHRyZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuXHRyZXR1cm4gKFxuXHRcdEFycmF5LmlzQXJyYXkoYSlcblx0XHRcdD8gZihhWzBdLCBhWzFdLCBhWzJdKVxuXHRcdFx0OiBmKGEsIGIsIGMpXG5cdCkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcblx0cmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuXHRyZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG5cdHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuXHRyZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG5cdGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuXHRsZXQgYSA9IDI1NTtcblx0bGV0IHY7XG5cdGlmICghbSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAobVs1XSAhPT0gdikge1xuXHRcdGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG5cdH1cblx0Y29uc3QgaCA9IGh1ZSgrbVsyXSk7XG5cdGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG5cdGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG5cdGlmIChtWzFdID09PSAnaHdiJykge1xuXHRcdHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG5cdH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcblx0XHR2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuXHR9IGVsc2Uge1xuXHRcdHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRyOiB2WzBdLFxuXHRcdGc6IHZbMV0sXG5cdFx0YjogdlsyXSxcblx0XHRhOiBhXG5cdH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG5cdHZhciBoID0gcmdiMmhzbCh2KTtcblx0aFswXSA9IGh1ZShoWzBdICsgZGVnKTtcblx0aCA9IGhzbDJyZ2IoaCk7XG5cdHYuciA9IGhbMF07XG5cdHYuZyA9IGhbMV07XG5cdHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuXHRpZiAoIXYpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3QgYSA9IHJnYjJoc2wodik7XG5cdGNvbnN0IGggPSBhWzBdO1xuXHRjb25zdCBzID0gbjJwKGFbMV0pO1xuXHRjb25zdCBsID0gbjJwKGFbMl0pO1xuXHRyZXR1cm4gdi5hIDwgMjU1XG5cdFx0PyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcblx0XHQ6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5jb25zdCBtYXAkMSA9IHtcblx0eDogJ2RhcmsnLFxuXHRaOiAnbGlnaHQnLFxuXHRZOiAncmUnLFxuXHRYOiAnYmx1Jyxcblx0VzogJ2dyJyxcblx0VjogJ21lZGl1bScsXG5cdFU6ICdzbGF0ZScsXG5cdEE6ICdlZScsXG5cdFQ6ICdvbCcsXG5cdFM6ICdvcicsXG5cdEI6ICdyYScsXG5cdEM6ICdsYXRlZycsXG5cdEQ6ICdpZ2h0cycsXG5cdFI6ICdpbicsXG5cdFE6ICd0dXJxdW9pcycsXG5cdEU6ICdoaScsXG5cdFA6ICdybycsXG5cdE86ICdhbCcsXG5cdE46ICdsZScsXG5cdE06ICdkZScsXG5cdEw6ICd5ZWxsbycsXG5cdEY6ICdlbicsXG5cdEs6ICdjaCcsXG5cdEc6ICdhcmtzJyxcblx0SDogJ2VhJyxcblx0STogJ2lnaHRnJyxcblx0SjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzID0ge1xuXHRPaWNlWGU6ICdmMGY4ZmYnLFxuXHRhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG5cdGFxdWE6ICdmZmZmJyxcblx0YXF1YW1hclJlOiAnN2ZmZmQ0Jyxcblx0YXp1WTogJ2YwZmZmZicsXG5cdGJlaWdlOiAnZjVmNWRjJyxcblx0YmlzcXVlOiAnZmZlNGM0Jyxcblx0YmxhY2s6ICcwJyxcblx0YmxhbktlZE9tb25kOiAnZmZlYmNkJyxcblx0WGU6ICdmZicsXG5cdFhldmlUZXQ6ICc4YTJiZTInLFxuXHRiUHduOiAnYTUyYTJhJyxcblx0YnVybHl3b29kOiAnZGViODg3Jyxcblx0Y2FNdFhlOiAnNWY5ZWEwJyxcblx0S2FydFl1c2U6ICc3ZmZmMDAnLFxuXHRLb2NUYXRlOiAnZDI2OTFlJyxcblx0Y1NPOiAnZmY3ZjUwJyxcblx0Y1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuXHRjU25zaWxrOiAnZmZmOGRjJyxcblx0Y3JpbXNvbjogJ2RjMTQzYycsXG5cdGN5YW46ICdmZmZmJyxcblx0eFhlOiAnOGInLFxuXHR4Y3lhbjogJzhiOGInLFxuXHR4Z1RNblBkOiAnYjg4NjBiJyxcblx0eFdheTogJ2E5YTlhOScsXG5cdHhnWUY6ICc2NDAwJyxcblx0eGdZeTogJ2E5YTlhOScsXG5cdHhraGFraTogJ2JkYjc2YicsXG5cdHhtYWdGdGE6ICc4YjAwOGInLFxuXHR4VGl2ZWdZRjogJzU1NmIyZicsXG5cdHhTYW5nZTogJ2ZmOGMwMCcsXG5cdHhTY0VkOiAnOTkzMmNjJyxcblx0eFlkOiAnOGIwMDAwJyxcblx0eHNPbW9uOiAnZTk5NjdhJyxcblx0eHNIZ1lGOiAnOGZiYzhmJyxcblx0eFVYZTogJzQ4M2Q4YicsXG5cdHhVV2F5OiAnMmY0ZjRmJyxcblx0eFVnWXk6ICcyZjRmNGYnLFxuXHR4UWU6ICdjZWQxJyxcblx0eHZpVGV0OiAnOTQwMGQzJyxcblx0ZEFwcFJrOiAnZmYxNDkzJyxcblx0ZEFwc2t5WGU6ICdiZmZmJyxcblx0ZGltV2F5OiAnNjk2OTY5Jyxcblx0ZGltZ1l5OiAnNjk2OTY5Jyxcblx0ZG9kZ2VyWGU6ICcxZTkwZmYnLFxuXHRmaVlicmljazogJ2IyMjIyMicsXG5cdGZsU093RXRlOiAnZmZmYWYwJyxcblx0Zm9Zc3RXQW46ICcyMjhiMjInLFxuXHRmdUtzaWE6ICdmZjAwZmYnLFxuXHRnYVJzYlNvOiAnZGNkY2RjJyxcblx0Z2hvc3R3RXRlOiAnZjhmOGZmJyxcblx0Z1RkOiAnZmZkNzAwJyxcblx0Z1RNblBkOiAnZGFhNTIwJyxcblx0V2F5OiAnODA4MDgwJyxcblx0Z1lGOiAnODAwMCcsXG5cdGdZRkx3OiAnYWRmZjJmJyxcblx0Z1l5OiAnODA4MDgwJyxcblx0aG9uZXlNdzogJ2YwZmZmMCcsXG5cdGhvdHBSazogJ2ZmNjliNCcsXG5cdFJkaWFuWWQ6ICdjZDVjNWMnLFxuXHRSZGlnbzogJzRiMDA4MicsXG5cdGl2U3k6ICdmZmZmZjAnLFxuXHRraGFraTogJ2YwZTY4YycsXG5cdGxhdkZNcjogJ2U2ZTZmYScsXG5cdGxhdkZNclhzaDogJ2ZmZjBmNScsXG5cdGxhd25nWUY6ICc3Y2ZjMDAnLFxuXHRObW9uY0VmZm9uOiAnZmZmYWNkJyxcblx0WlhlOiAnYWRkOGU2Jyxcblx0WmNTTzogJ2YwODA4MCcsXG5cdFpjeWFuOiAnZTBmZmZmJyxcblx0WmdUTW5QZEx3OiAnZmFmYWQyJyxcblx0WldheTogJ2QzZDNkMycsXG5cdFpnWUY6ICc5MGVlOTAnLFxuXHRaZ1l5OiAnZDNkM2QzJyxcblx0WnBSazogJ2ZmYjZjMScsXG5cdFpzT21vbjogJ2ZmYTA3YScsXG5cdFpzSGdZRjogJzIwYjJhYScsXG5cdFpza3lYZTogJzg3Y2VmYScsXG5cdFpVV2F5OiAnNzc4ODk5Jyxcblx0WlVnWXk6ICc3Nzg4OTknLFxuXHRac3RBbFhlOiAnYjBjNGRlJyxcblx0Wkx3OiAnZmZmZmUwJyxcblx0bGltZTogJ2ZmMDAnLFxuXHRsaW1lZ1lGOiAnMzJjZDMyJyxcblx0bFJGOiAnZmFmMGU2Jyxcblx0bWFnRnRhOiAnZmYwMGZmJyxcblx0bWFQb246ICc4MDAwMDAnLFxuXHRWYXF1YW1hclJlOiAnNjZjZGFhJyxcblx0VlhlOiAnY2QnLFxuXHRWU2NFZDogJ2JhNTVkMycsXG5cdFZwdXJwTjogJzkzNzBkYicsXG5cdFZzSGdZRjogJzNjYjM3MScsXG5cdFZVWGU6ICc3YjY4ZWUnLFxuXHRWc3ByUmdnWUY6ICdmYTlhJyxcblx0VlFlOiAnNDhkMWNjJyxcblx0VnZpVGV0WWQ6ICdjNzE1ODUnLFxuXHRtaWRuaWdodFhlOiAnMTkxOTcwJyxcblx0bVJ0Y1lhbTogJ2Y1ZmZmYScsXG5cdG1pc3R5UHNlOiAnZmZlNGUxJyxcblx0bW9jY2FzUjogJ2ZmZTRiNScsXG5cdG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuXHRuYXZ5OiAnODAnLFxuXHRUZGxhY2U6ICdmZGY1ZTYnLFxuXHRUaXZlOiAnODA4MDAwJyxcblx0VGl2ZWRCYjogJzZiOGUyMycsXG5cdFNhbmdlOiAnZmZhNTAwJyxcblx0U2FuZ2VZZDogJ2ZmNDUwMCcsXG5cdFNjRWQ6ICdkYTcwZDYnLFxuXHRwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuXHRwT2VnWUY6ICc5OGZiOTgnLFxuXHRwT2VRZTogJ2FmZWVlZScsXG5cdHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuXHRwYXBheWF3RXA6ICdmZmVmZDUnLFxuXHRwSEtwdWZmOiAnZmZkYWI5Jyxcblx0cGVydTogJ2NkODUzZicsXG5cdHBSazogJ2ZmYzBjYicsXG5cdHBsdW06ICdkZGEwZGQnLFxuXHRwb3dNclhlOiAnYjBlMGU2Jyxcblx0cHVycE46ICc4MDAwODAnLFxuXHRZYmVjY2FwdXJwTjogJzY2MzM5OScsXG5cdFlkOiAnZmYwMDAwJyxcblx0UHN5YnJvd246ICdiYzhmOGYnLFxuXHRQeU9YZTogJzQxNjllMScsXG5cdHNhZGROYlB3bjogJzhiNDUxMycsXG5cdHNPbW9uOiAnZmE4MDcyJyxcblx0c2FuZHliUHduOiAnZjRhNDYwJyxcblx0c0hnWUY6ICcyZThiNTcnLFxuXHRzSHNoZWxsOiAnZmZmNWVlJyxcblx0c2lGbmE6ICdhMDUyMmQnLFxuXHRzaWx2ZXI6ICdjMGMwYzAnLFxuXHRza3lYZTogJzg3Y2VlYicsXG5cdFVYZTogJzZhNWFjZCcsXG5cdFVXYXk6ICc3MDgwOTAnLFxuXHRVZ1l5OiAnNzA4MDkwJyxcblx0c25vdzogJ2ZmZmFmYScsXG5cdHNwclJnZ1lGOiAnZmY3ZicsXG5cdHN0QWxYZTogJzQ2ODJiNCcsXG5cdHRhbjogJ2QyYjQ4YycsXG5cdHRlTzogJzgwODAnLFxuXHR0RXN0TjogJ2Q4YmZkOCcsXG5cdHRvbWF0bzogJ2ZmNjM0NycsXG5cdFFlOiAnNDBlMGQwJyxcblx0dmlUZXQ6ICdlZTgyZWUnLFxuXHRKSHQ6ICdmNWRlYjMnLFxuXHR3RXRlOiAnZmZmZmZmJyxcblx0d0V0ZXNtb2tlOiAnZjVmNWY1Jyxcblx0THc6ICdmZmZmMDAnLFxuXHRMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG5cdGNvbnN0IHVucGFja2VkID0ge307XG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyk7XG5cdGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwJDEpO1xuXHRsZXQgaSwgaiwgaywgb2ssIG5rO1xuXHRmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdG9rID0gbmsgPSBrZXlzW2ldO1xuXHRcdGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuXHRcdFx0ayA9IHRrZXlzW2pdO1xuXHRcdFx0bmsgPSBuay5yZXBsYWNlKGssIG1hcCQxW2tdKTtcblx0XHR9XG5cdFx0ayA9IHBhcnNlSW50KG5hbWVzW29rXSwgMTYpO1xuXHRcdHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuXHR9XG5cdHJldHVybiB1bnBhY2tlZDtcbn1cbmxldCBuYW1lcyQxO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuXHRpZiAoIW5hbWVzJDEpIHtcblx0XHRuYW1lcyQxID0gdW5wYWNrKCk7XG5cdFx0bmFtZXMkMS50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcblx0fVxuXHRjb25zdCBhID0gbmFtZXMkMVtzdHIudG9Mb3dlckNhc2UoKV07XG5cdHJldHVybiBhICYmIHtcblx0XHRyOiBhWzBdLFxuXHRcdGc6IGFbMV0sXG5cdFx0YjogYVsyXSxcblx0XHRhOiBhLmxlbmd0aCA9PT0gNCA/IGFbM10gOiAyNTVcblx0fTtcbn1cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuXHRpZiAodikge1xuXHRcdGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuXHRcdHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuXHRcdHRtcCA9IGhzbDJyZ2IodG1wKTtcblx0XHR2LnIgPSB0bXBbMF07XG5cdFx0di5nID0gdG1wWzFdO1xuXHRcdHYuYiA9IHRtcFsyXTtcblx0fVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcblx0cmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG5cdHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuXHRcdFx0diA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0di5hID0gbjJiKGlucHV0WzNdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0diA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuXHRcdHYuYSA9IG4yYih2LmEpO1xuXHR9XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcblx0aWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuXHRcdHJldHVybiByZ2JQYXJzZShzdHIpO1xuXHR9XG5cdHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuXHRjb25zdHJ1Y3RvcihpbnB1dCkge1xuXHRcdGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXQ7XG5cdFx0fVxuXHRcdGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG5cdFx0bGV0IHY7XG5cdFx0aWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR2ID0gZnJvbU9iamVjdChpbnB1dCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0diA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuXHRcdH1cblx0XHR0aGlzLl9yZ2IgPSB2O1xuXHRcdHRoaXMuX3ZhbGlkID0gISF2O1xuXHR9XG5cdGdldCB2YWxpZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQ7XG5cdH1cblx0Z2V0IHJnYigpIHtcblx0XHR2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG5cdFx0aWYgKHYpIHtcblx0XHRcdHYuYSA9IGIybih2LmEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdjtcblx0fVxuXHRzZXQgcmdiKG9iaikge1xuXHRcdHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcblx0fVxuXHRyZ2JTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB0aGlzLl9yZ2I7XG5cdH1cblx0aGV4U3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdGhpcy5fcmdiO1xuXHR9XG5cdGhzbFN0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHRoaXMuX3JnYjtcblx0fVxuXHRtaXgoY29sb3IsIHdlaWdodCkge1xuXHRcdGNvbnN0IG1lID0gdGhpcztcblx0XHRpZiAoY29sb3IpIHtcblx0XHRcdGNvbnN0IGMxID0gbWUucmdiO1xuXHRcdFx0Y29uc3QgYzIgPSBjb2xvci5yZ2I7XG5cdFx0XHRsZXQgdzI7XG5cdFx0XHRjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcblx0XHRcdGNvbnN0IHcgPSAyICogcCAtIDE7XG5cdFx0XHRjb25zdCBhID0gYzEuYSAtIGMyLmE7XG5cdFx0XHRjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcblx0XHRcdHcyID0gMSAtIHcxO1xuXHRcdFx0YzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG5cdFx0XHRjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcblx0XHRcdGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuXHRcdFx0YzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG5cdFx0XHRtZS5yZ2IgPSBjMTtcblx0XHR9XG5cdFx0cmV0dXJuIG1lO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuXHR9XG5cdGFscGhhKGEpIHtcblx0XHR0aGlzLl9yZ2IuYSA9IG4yYihhKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGVhcmVyKHJhdGlvKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5fcmdiO1xuXHRcdHJnYi5hICo9IDEgLSByYXRpbztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRncmV5c2NhbGUoKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5fcmdiO1xuXHRcdGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcblx0XHRyZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0b3BhcXVlcihyYXRpbykge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcblx0XHRyZ2IuYSAqPSAxICsgcmF0aW87XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bmVnYXRlKCkge1xuXHRcdGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG5cdFx0di5yID0gMjU1IC0gdi5yO1xuXHRcdHYuZyA9IDI1NSAtIHYuZztcblx0XHR2LmIgPSAyNTUgLSB2LmI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bGlnaHRlbihyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkYXJrZW4ocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNhdHVyYXRlKHJhdGlvKSB7XG5cdFx0bW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRlc2F0dXJhdGUocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJvdGF0ZShkZWcpIHtcblx0XHRyb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcblx0cmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmNvbnN0IGlzUGF0dGVybk9yR3JhZGllbnQgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuO1xuZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBpbmRleF9lc20odmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmRleF9lc20odmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gIH1cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBkZXNjcmliZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCB0YXJnZXRTY29wZSk7XG4gICAgY29uc3QgcHJpdmF0ZU5hbWUgPSAnXycgKyBuYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxudmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9XG59KTtcblxuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5mdW5jdGlvbiBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9sb25nZXN0VGV4dChjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGksIGosIGpsZW4sIHRoaW5nLCBuZXN0ZWRUaGluZztcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBpc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdHgucmVzdG9yZSgpO1xuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCkge1xuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB4LCB5KSB7XG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXM7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgc3dpdGNoIChzdHlsZSkge1xuICBkZWZhdWx0OlxuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgIGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdCc6XG4gICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgIGN0eC5yZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAncmVjdFJvdCc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdjcm9zcyc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdzdGFyJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdsaW5lJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdkYXNoJzpcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICBicmVhaztcbiAgfVxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKHBvaW50LCBhcmVhLCBtYXJnaW4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTtcbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5mdW5jdGlvbiBjbGlwQXJlYShjdHgsIGFyZWEpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4KSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXAsIG1vZGUpIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gX2JlemllckN1cnZlVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gcmVuZGVyVGV4dChjdHgsIHRleHQsIHgsIHksIGZvbnQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGksIGxpbmU7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuICAgIHkgKz0gZm9udC5saW5lSGVpZ2h0O1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgLUhBTEZfUEksIFBJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuXG5jb25zdCBMSU5FX0hFSUdIVCA9IG5ldyBSZWdFeHAoL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuY29uc3QgRk9OVF9TVFlMRSA9IG5ldyBSZWdFeHAoL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC8pO1xuZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlLCBzaXplKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgY2FzZSAncHgnOlxuICAgIHJldHVybiB2YWx1ZTtcbiAgY2FzZSAnJSc6XG4gICAgdmFsdWUgLz0gMTAwO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5jb25zdCBudW1iZXJPclplcm8gPSB2ID0+ICt2IHx8IDA7XG5mdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgcHJvcHMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRvVFJCTCh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlKSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSk7XG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0ZvbnQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udDtcbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gJyc7XG4gIH1cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5mdW5jdGlvbiByZXNvbHZlKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heCwgZ3JhY2UpIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAtIE1hdGguYWJzKHRvRGltZW5zaW9uKGdyYWNlLCBtaW4pKSxcbiAgICBtYXg6IG1heCArIHRvRGltZW5zaW9uKGdyYWNlLCBtYXgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9sb29rdXAodGFibGUsIHZhbHVlLCBjbXApIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDtcbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG8sIGhpfTtcbn1cbmNvbnN0IF9sb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuY29uc3QgX3Jsb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcbiAgfVxuICBpZiAoc2V0LnNpemUgPT09IGlsZW4pIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbJyddLCByb290U2NvcGVzID0gc2NvcGVzLCBmYWxsYmFjaywgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdKSB7XG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3Blczogcm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgcm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgc3RvcmFnZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2F0dGFjaENvbnRleHQocHJveHksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHgpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKHByb3h5LCBkZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9KSB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuY29uc3QgcmVhZEtleSA9IChwcmVmaXgsIG5hbWUpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcCwgdmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnO1xuZnVuY3Rpb24gX2NhY2hlZCh0YXJnZXQsIHByb3AsIHJlc29sdmUpIHtcbiAgbGV0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSByZXNvbHZlKCk7XG4gIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICB2YWx1ZSA9IHZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBjcmVhdGVTdWJSZXNvbHZlcihfcHJveHkuX3Njb3BlcywgX3Byb3h5LCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBpc0luZGV4YWJsZSkge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgaWYgKGRlZmluZWQoX2NvbnRleHQuaW5kZXgpICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhmYWxsYmFjaywgcHJvcCwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5jb25zdCBnZXRTY29wZSA9IChrZXksIHBhcmVudCkgPT4ga2V5ID09PSB0cnVlID8gcGFyZW50XG4gIDogdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyByZXNvbHZlT2JqZWN0S2V5KHBhcmVudCwga2V5KSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGFkZFNjb3BlcyhzZXQsIHBhcmVudFNjb3Blcywga2V5LCBwYXJlbnRGYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHNjb3BlKTtcbiAgICAgIGlmIChkZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjayAhPT0ga2V5ICYmIGZhbGxiYWNrICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgZGVmaW5lZChwYXJlbnRGYWxsYmFjaykgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKHBhcmVudFNjb3BlcywgcmVzb2x2ZXIsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHJvb3RTY29wZXMgPSByZXNvbHZlci5fcm9vdFNjb3BlcztcbiAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2socmVzb2x2ZXIuX2ZhbGxiYWNrLCBwcm9wLCB2YWx1ZSk7XG4gIGNvbnN0IGFsbFNjb3BlcyA9IFsuLi5wYXJlbnRTY29wZXMsIC4uLnJvb3RTY29wZXNdO1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCk7XG4gIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZVJlc29sdmVyKEFycmF5LmZyb20oc2V0KSwgWycnXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssXG4gICAgKCkgPT4gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaykge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHByb3h5KSB7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlKHJlYWRLZXkocHJlZml4LCBwcm9wKSwgc2NvcGVzKTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5LCBzY29wZXMpIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50cywgaSkgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuZnVuY3Rpb24gc3BsaW5lQ3VydmUoZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuICBjb25zdCBmYSA9IHQgKiBzMDE7XG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSykge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSyA9IEFycmF5KHBvaW50c0xlbik7XG4gIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHBvaW50cywgb3B0aW9ucywgYXJlYSwgbG9vcCwgaW5kZXhBeGlzKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgY29udHJvbFBvaW50cztcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzRG9tU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHByb3BlcnR5KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cbmNvbnN0IHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzLCBzdHlsZSwgc3VmZml4KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4LCB5LCB0YXJnZXQpID0+ICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgIXRhcmdldC5zaGFkb3dSb290KTtcbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKGV2dCwgY2FudmFzKSB7XG4gIGNvbnN0IGUgPSBldnQubmF0aXZlIHx8IGV2dDtcbiAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2dCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5jb25zdCByb3VuZDEgPSB2ID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgY2hhcnQuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgY2hhcnQud2lkdGggPSBkZXZpY2VXaWR0aCAvIHBpeGVsUmF0aW87XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogKG4sIHMsIGUpID0+IG4gPj0gTWF0aC5taW4ocywgZSkgJiYgbiA8PSBNYXRoLm1heChlLCBzKSxcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCh7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4OiBsaW5lLl9kYXRhc2V0SW5kZXhcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCwgZW5kOiBpIC0gMSwgbG9vcDogc2VnbWVudC5sb29wLCBzdHlsZTogcHJldlN0eWxlfSk7XG4gICAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgICAgICBzdGFydCA9IGkgLSAxO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQsIGVuZDogaSAtIDEsIGxvb3A6IHNlZ21lbnQubG9vcCwgc3R5bGV9KTtcbiAgICAgIHN0YXJ0ID0gaSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICByZXR1cm4gcHJldlN0eWxlICYmIEpTT04uc3RyaW5naWZ5KHN0eWxlKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlKTtcbn1cblxuZXhwb3J0IHsgb3ZlcnJpZGVzIGFzICQsIHRvUGFkZGluZyBhcyBBLCBlYWNoIGFzIEIsIGdldE1heGltdW1TaXplIGFzIEMsIF9nZXRQYXJlbnROb2RlIGFzIEQsIHJlYWRVc2VkU2l6ZSBhcyBFLCB0aHJvdHRsZWQgYXMgRiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyBhcyBHLCBIQUxGX1BJIGFzIEgsIF9pc0RvbVN1cHBvcnRlZCBhcyBJLCBsb2cxMCBhcyBKLCBfZmFjdG9yaXplIGFzIEssIGZpbml0ZU9yRGVmYXVsdCBhcyBMLCBjYWxsYmFjayBhcyBNLCBfYWRkR3JhY2UgYXMgTiwgdG9EZWdyZWVzIGFzIE8sIFBJIGFzIFAsIF9tZWFzdXJlVGV4dCBhcyBRLCBfaW50MTZSYW5nZSBhcyBSLCBfYWxpZ25QaXhlbCBhcyBTLCBUQVUgYXMgVCwgY2xpcEFyZWEgYXMgVSwgcmVuZGVyVGV4dCBhcyBWLCB1bmNsaXBBcmVhIGFzIFcsIHRvRm9udCBhcyBYLCBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgWSwgX2FsaWduU3RhcnRFbmQgYXMgWiwgX2FycmF5VW5pcXVlIGFzIF8sIHJlc29sdmUgYXMgYSwgbWVyZ2UgYXMgYTAsIF9jYXBpdGFsaXplIGFzIGExLCBkZXNjcmlwdG9ycyBhcyBhMiwgaXNGdW5jdGlvbiBhcyBhMywgX2F0dGFjaENvbnRleHQgYXMgYTQsIF9jcmVhdGVSZXNvbHZlciBhcyBhNSwgX2Rlc2NyaXB0b3JzIGFzIGE2LCBtZXJnZUlmIGFzIGE3LCB1aWQgYXMgYTgsIGRlYm91bmNlIGFzIGE5LCBfc2V0TWluQW5kTWF4QnlLZXkgYXMgYUEsIG5pY2VOdW0gYXMgYUIsIGFsbW9zdFdob2xlIGFzIGFDLCBhbG1vc3RFcXVhbHMgYXMgYUQsIF9kZWNpbWFsUGxhY2VzIGFzIGFFLCBfbG9uZ2VzdFRleHQgYXMgYUYsIF9maWx0ZXJCZXR3ZWVuIGFzIGFHLCBfbG9va3VwIGFzIGFILCBnZXRIb3ZlckNvbG9yIGFzIGFJLCBjbG9uZSQxIGFzIGFKLCBfbWVyZ2VyIGFzIGFLLCBfbWVyZ2VySWYgYXMgYUwsIF9kZXByZWNhdGVkIGFzIGFNLCB0b0ZvbnRTdHJpbmcgYXMgYU4sIHNwbGluZUN1cnZlIGFzIGFPLCBzcGxpbmVDdXJ2ZU1vbm90b25lIGFzIGFQLCBnZXRTdHlsZSBhcyBhUSwgZm9udFN0cmluZyBhcyBhUiwgdG9MaW5lSGVpZ2h0IGFzIGFTLCBQSVRBVSBhcyBhVCwgSU5GSU5JVFkgYXMgYVUsIFJBRF9QRVJfREVHIGFzIGFWLCBRVUFSVEVSX1BJIGFzIGFXLCBUV09fVEhJUkRTX1BJIGFzIGFYLCBfYW5nbGVEaWZmIGFzIGFZLCByZXRpbmFTY2FsZSBhcyBhYSwgY2xlYXJDYW52YXMgYXMgYWIsIHNldHNFcXVhbCBhcyBhYywgX2VsZW1lbnRzRXF1YWwgYXMgYWQsIGdldEFuZ2xlRnJvbVBvaW50IGFzIGFlLCBfcmVhZFZhbHVlVG9Qcm9wcyBhcyBhZiwgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMgYXMgYWcsIF9jb21wdXRlU2VnbWVudHMgYXMgYWgsIF9ib3VuZFNlZ21lbnRzIGFzIGFpLCBfc3RlcHBlZEludGVycG9sYXRpb24gYXMgYWosIF9iZXppZXJJbnRlcnBvbGF0aW9uIGFzIGFrLCBfcG9pbnRJbkxpbmUgYXMgYWwsIF9zdGVwcGVkTGluZVRvIGFzIGFtLCBfYmV6aWVyQ3VydmVUbyBhcyBhbiwgZHJhd1BvaW50IGFzIGFvLCBhZGRSb3VuZGVkUmVjdFBhdGggYXMgYXAsIHRvVFJCTCBhcyBhcSwgdG9UUkJMQ29ybmVycyBhcyBhciwgX2JvdW5kU2VnbWVudCBhcyBhcywgX25vcm1hbGl6ZUFuZ2xlIGFzIGF0LCBnZXRSdGxBZGFwdGVyIGFzIGF1LCBvdmVycmlkZVRleHREaXJlY3Rpb24gYXMgYXYsIF90ZXh0WCBhcyBhdywgcmVzdG9yZVRleHREaXJlY3Rpb24gYXMgYXgsIG5vb3AgYXMgYXksIGRpc3RhbmNlQmV0d2VlblBvaW50cyBhcyBheiwgaXNBcnJheSBhcyBiLCBjb2xvciBhcyBjLCBkZWZhdWx0cyBhcyBkLCBlZmZlY3RzIGFzIGUsIHJlc29sdmVPYmplY3RLZXkgYXMgZiwgaXNOdW1iZXJGaW5pdGUgYXMgZywgZGVmaW5lZCBhcyBoLCBpc09iamVjdCBhcyBpLCBpc051bGxPclVuZGVmIGFzIGosIHRvUGVyY2VudGFnZSBhcyBrLCBsaXN0ZW5BcnJheUV2ZW50cyBhcyBsLCB0b0RpbWVuc2lvbiBhcyBtLCBmb3JtYXROdW1iZXIgYXMgbiwgX2FuZ2xlQmV0d2VlbiBhcyBvLCBpc051bWJlciBhcyBwLCBfbGltaXRWYWx1ZSBhcyBxLCByZXF1ZXN0QW5pbUZyYW1lIGFzIHIsIHNpZ24gYXMgcywgdG9SYWRpYW5zIGFzIHQsIHVubGlzdGVuQXJyYXlFdmVudHMgYXMgdSwgdmFsdWVPckRlZmF1bHQgYXMgdiwgX2xvb2t1cEJ5S2V5IGFzIHcsIGdldFJlbGF0aXZlUG9zaXRpb24gYXMgeCwgX2lzUG9pbnRJbkFyZWEgYXMgeSwgX3Jsb29rdXBCeUtleSBhcyB6IH07XG4iLCIvKiFcbiAqIENoYXJ0LmpzIHYzLjUuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIxIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBlIGFzIGVmZmVjdHMsIGMgYXMgY29sb3IsIGQgYXMgZGVmYXVsdHMsIGkgYXMgaXNPYmplY3QsIGIgYXMgaXNBcnJheSwgdiBhcyB2YWx1ZU9yRGVmYXVsdCwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGcgYXMgaXNOdW1iZXJGaW5pdGUsIGggYXMgZGVmaW5lZCwgcyBhcyBzaWduLCBqIGFzIGlzTnVsbE9yVW5kZWYsIF8gYXMgX2FycmF5VW5pcXVlLCB0IGFzIHRvUmFkaWFucywgayBhcyB0b1BlcmNlbnRhZ2UsIG0gYXMgdG9EaW1lbnNpb24sIFQgYXMgVEFVLCBuIGFzIGZvcm1hdE51bWJlciwgbyBhcyBfYW5nbGVCZXR3ZWVuLCBIIGFzIEhBTEZfUEksIFAgYXMgUEksIHAgYXMgaXNOdW1iZXIsIHEgYXMgX2xpbWl0VmFsdWUsIHcgYXMgX2xvb2t1cEJ5S2V5LCB4IGFzIGdldFJlbGF0aXZlUG9zaXRpb24kMSwgeSBhcyBfaXNQb2ludEluQXJlYSwgeiBhcyBfcmxvb2t1cEJ5S2V5LCBBIGFzIHRvUGFkZGluZywgQiBhcyBlYWNoLCBDIGFzIGdldE1heGltdW1TaXplLCBEIGFzIF9nZXRQYXJlbnROb2RlLCBFIGFzIHJlYWRVc2VkU2l6ZSwgRiBhcyB0aHJvdHRsZWQsIEcgYXMgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgSSBhcyBfaXNEb21TdXBwb3J0ZWQsIEogYXMgbG9nMTAsIEsgYXMgX2ZhY3Rvcml6ZSwgTCBhcyBmaW5pdGVPckRlZmF1bHQsIE0gYXMgY2FsbGJhY2ssIE4gYXMgX2FkZEdyYWNlLCBPIGFzIHRvRGVncmVlcywgUSBhcyBfbWVhc3VyZVRleHQsIFIgYXMgX2ludDE2UmFuZ2UsIFMgYXMgX2FsaWduUGl4ZWwsIFUgYXMgY2xpcEFyZWEsIFYgYXMgcmVuZGVyVGV4dCwgVyBhcyB1bmNsaXBBcmVhLCBYIGFzIHRvRm9udCwgWSBhcyBfdG9MZWZ0UmlnaHRDZW50ZXIsIFogYXMgX2FsaWduU3RhcnRFbmQsICQgYXMgb3ZlcnJpZGVzLCBhMCBhcyBtZXJnZSwgYTEgYXMgX2NhcGl0YWxpemUsIGEyIGFzIGRlc2NyaXB0b3JzLCBhMyBhcyBpc0Z1bmN0aW9uLCBhNCBhcyBfYXR0YWNoQ29udGV4dCwgYTUgYXMgX2NyZWF0ZVJlc29sdmVyLCBhNiBhcyBfZGVzY3JpcHRvcnMsIGE3IGFzIG1lcmdlSWYsIGE4IGFzIHVpZCwgYTkgYXMgZGVib3VuY2UsIGFhIGFzIHJldGluYVNjYWxlLCBhYiBhcyBjbGVhckNhbnZhcywgYWMgYXMgc2V0c0VxdWFsLCBhZCBhcyBfZWxlbWVudHNFcXVhbCwgYWUgYXMgZ2V0QW5nbGVGcm9tUG9pbnQsIGFmIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBhZyBhcyBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cywgYWggYXMgX2NvbXB1dGVTZWdtZW50cywgYWkgYXMgX2JvdW5kU2VnbWVudHMsIGFqIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYWsgYXMgX2JlemllckludGVycG9sYXRpb24sIGFsIGFzIF9wb2ludEluTGluZSwgYW0gYXMgX3N0ZXBwZWRMaW5lVG8sIGFuIGFzIF9iZXppZXJDdXJ2ZVRvLCBhbyBhcyBkcmF3UG9pbnQsIGFwIGFzIGFkZFJvdW5kZWRSZWN0UGF0aCwgYXEgYXMgdG9UUkJMLCBhciBhcyB0b1RSQkxDb3JuZXJzLCBhcyBhcyBfYm91bmRTZWdtZW50LCBhdCBhcyBfbm9ybWFsaXplQW5nbGUsIGF1IGFzIGdldFJ0bEFkYXB0ZXIsIGF2IGFzIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgYXcgYXMgX3RleHRYLCBheCBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYXkgYXMgbm9vcCwgYXogYXMgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBhQSBhcyBfc2V0TWluQW5kTWF4QnlLZXksIGFCIGFzIG5pY2VOdW0sIGFDIGFzIGFsbW9zdFdob2xlLCBhRCBhcyBhbG1vc3RFcXVhbHMsIGFFIGFzIF9kZWNpbWFsUGxhY2VzLCBhRiBhcyBfbG9uZ2VzdFRleHQsIGFHIGFzIF9maWx0ZXJCZXR3ZWVuLCBhSCBhcyBfbG9va3VwIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50LmpzJztcbmV4cG9ydCB7IGQgYXMgZGVmYXVsdHMgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuXG5jbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICBtZS5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIG1lLl91cGRhdGUoKTtcbiAgICAgIG1lLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGlmIChtZS5fcnVubmluZykge1xuICAgICAgICBtZS5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG4gICAgbWUuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIG1lLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgbWUuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIG1lLl9sYXN0RGF0ZSA9IGRhdGU7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgbWUuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cbnZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBjb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUuX2FjdGl2ZSkge1xuICAgICAgbWUuX25vdGlmeShmYWxzZSk7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBtZS5fdGFyZ2V0W21lLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gbWUuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gbWUuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIG1lLl9zdGFydCA9IGRhdGU7XG4gICAgICBtZS5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICBtZS5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIG1lLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIG1lLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIG1lLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUuX2FjdGl2ZSkge1xuICAgICAgbWUudGljayhEYXRlLm5vdygpKTtcbiAgICAgIG1lLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIG1lLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSBtZS5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSBtZS5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IG1lLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSBtZS5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gbWUuX2xvb3A7XG4gICAgY29uc3QgdG8gPSBtZS5fdG87XG4gICAgbGV0IGZhY3RvcjtcbiAgICBtZS5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuICAgIGlmICghbWUuX2FjdGl2ZSkge1xuICAgICAgbWUuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgbWUuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICBtZS5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gbWUuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgbWUuX3RhcmdldFtwcm9wXSA9IG1lLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gIGRlbGF5OiB1bmRlZmluZWQsXG4gIGR1cmF0aW9uOiAxMDAwLFxuICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICBmbjogdW5kZWZpbmVkLFxuICBmcm9tOiB1bmRlZmluZWQsXG4gIGxvb3A6IHVuZGVmaW5lZCxcbiAgdG86IHVuZGVmaW5lZCxcbiAgdHlwZTogdW5kZWZpbmVkLFxufSk7XG5jb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9pbmRleGFibGU6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnY29sb3InLFxuICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICB9LFxuICBudW1iZXJzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgcHJvcGVydGllczogbnVtYmVyc1xuICB9LFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgYWN0aXZlOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwXG4gICAgfVxuICB9LFxuICByZXNpemU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfVxuICB9LFxuICBzaG93OiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuICBoaWRlOiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGZuOiB2ID0+IHYgfCAwXG4gICAgICB9LFxuICAgIH1cbiAgfVxufSk7XG5jbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zKSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2JhcicpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudCksXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIG1lLmNvbmZpZ3VyZSgpO1xuICAgIG1lLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICBtZS5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IG1lLl9kYXRhO1xuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgbWUuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIG1lKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIG1lKTtcbiAgICAgIH1cbiAgICAgIG1lLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgbWUuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIG1lLl9kYXRhQ2hlY2soKTtcbiAgICBpZiAobWUuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgbWUuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG4gIGJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBzdGFja0NoYW5nZWQgPSBmYWxzZTtcbiAgICBtZS5fZGF0YUNoZWNrKCk7XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cbiAgICBtZS5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3MobWUsIG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY29uZmlnID0gbWUuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKG1lLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG1lLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICBtZS5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgbWUuZ2V0Q29udGV4dCgpKTtcbiAgICBtZS5fcGFyc2luZyA9IG1lLm9wdGlvbnMucGFyc2luZztcbiAgfVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSBtZTtcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgIGlmIChtZS5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICBtZXRhLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IG1lLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSBtZS5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IG1lLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyhtZSwgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXVxuICAgIH07XG4gICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7bW9kZX0pO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgIGlmIChzdGFjayAmJiB2YWx1ZXMpIHtcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4LCB7YWxsOiB0cnVlfSk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IG1lLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNhblN0YWNrICYmIG1ldGEuX3N0YWNrZWQgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKG1lLmNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHZhbHVlLCBwYXJzZWQsIG90aGVyVmFsdWU7XG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgICBvdGhlclZhbHVlID0gcGFyc2VkW290aGVyU2NhbGUuYXhpc107XG4gICAgICByZXR1cm4gIWlzTnVtYmVyRmluaXRlKHZhbHVlKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1lLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgZm9yIChpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWUudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbWUuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgbWUuY29uZmlndXJlKCk7XG4gICAgbWUuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgbWUudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KG1lLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCBtZS5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7fVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjdHggPSBtZS5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSBtZS5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSBtZS5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgbGV0IGk7XG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBtZS5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IG1lLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dCA9IGVsZW1lbnQuJGNvbnRleHQgfHxcbiAgICAgICAgKGVsZW1lbnQuJGNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dChtZS5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IG1lLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IG1lLiRjb250ZXh0IHx8XG4gICAgICAgIChtZS4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KG1lLmNoYXJ0LmdldENvbnRleHQoKSwgbWUuaW5kZXgpKTtcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcbiAgICB9XG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYWN0aXZlID0gbW9kZSA9PT0gJ2FjdGl2ZSc7XG4gICAgY29uc3QgY2FjaGUgPSBtZS5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSBtZS5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IG1lLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEVsZW1lbnRTY29wZUtleXMobWUuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG1lLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IG1lLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgdHJhbnNpdGlvbiwgYWN0aXZlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSBtZS5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgYW5pbWF0aW9uLSR7dHJhbnNpdGlvbn1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoY2hhcnQub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSBtZS5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhtZS5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG1lLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICAgIG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBtZS5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuICBpbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gIH1cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xuICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIHRydWUpO1xuICB9XG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YSA9IG1lLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWUuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIG1lLl9zeW5jTGlzdCkge1xuICAgICAgbWVbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgbWUuX3N5bmNMaXN0ID0gW107XG4gICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIG1lLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICBtZS5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIG1lLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyBtZS5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB9XG4gICAgaWYgKG1lLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIG1lLnBhcnNlKHN0YXJ0LCBjb3VudCk7XG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIG1lLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge31cbiAgX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgaWYgKG1lLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgfVxuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gIH1cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG4gIF9vbkRhdGFQb3AoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgc3RhcnQsIGNvdW50XSk7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMl0pO1xuICB9XG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbkRhdGFzZXRDb250cm9sbGVyLmRlZmF1bHRzID0ge307XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnYmFyJyk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKHNjYWxlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICByZXR1cm4gbWluO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbWUuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBtZS5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSBtZS5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIG1lLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSBtZTtcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSBtZS5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gbWUuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gbWUuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgbWUudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWUuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiBtZS5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gbWUuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIG1lLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhtZS5fdHlwZSk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3QgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcbiAgICBsZXQgaSwgaXRlbTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWl0ZW0uY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgdmFsID0gaXRlbS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpW1xuICAgICAgICAgIGl0ZW0uY29udHJvbGxlci5fY2FjaGVkTWV0YS52U2NhbGUuYXhpc1xuICAgICAgICBdO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKGl0ZW0uc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIGl0ZW0uc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goaXRlbS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gLTEpXG4gICAgICA/IHN0YWNrcy5sZW5ndGggLSAxXG4gICAgICA6IGluZGV4O1xuICB9XG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtZS5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShpU2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogbWUuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gbWU7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IG1lLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IG1lLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuICAgIGlmIChtZS5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cbiAgICBzaXplID0gaGVhZCAtIGJhc2U7XG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XG4gICAgfVxuICAgIGlmIChiYXNlID09PSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShhY3R1YWxCYXNlKSkge1xuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcbiAgICAgIGJhc2UgKz0gaGFsZkdyaWQ7XG4gICAgICBzaXplIC09IGhhbGZHcmlkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyBtZS5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG4gICAgICAgID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gbWUuX2dldFN0YWNrSW5kZXgobWUuaW5kZXgsIG1lLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1lLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgaWxlbiA9IHJlY3RzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChtZS5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcobWUuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XG5CYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiB0cnVlLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgfVxuICB9XG59O1xuQmFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbTtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGkpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGkpLFxuICAgICAgICBfY3VzdG9tOiBpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCB7ZGF0YSwgX3BhcnNlZH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSgpIC8gMiwgX3BhcnNlZFtpXS5fY3VzdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IG1lLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IG1ldGEubGFiZWwsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgcG9pbnRzID0gbWUuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBtZS51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IG1lLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IG1lLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIG1lLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gICAgbWUudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5CdWJibGVDb250cm9sbGVyLmlkID0gJ2J1YmJsZSc7XG5CdWJibGVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgfVxuICB9XG59O1xuQnViYmxlQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5jbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7fVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG1ldGEuX3BhcnNlZFtpXSA9ICtkYXRhW2ldO1xuICAgIH1cbiAgfVxuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChtZS5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBtZS5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY2hhcnQgPSBtZS5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSBtZS5nZXRNYXhCb3JkZXJXaWR0aCgpICsgbWUuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgbWUub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKG1lLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSBtZS5fZ2V0UmluZ1dlaWdodChtZS5pbmRleCk7XG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IG1lLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24obWUub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gbWUuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICBtZS5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIG1lLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG4gICAgbWV0YS50b3RhbCA9IG1lLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgbWUub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIG1lLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KG1lLmluZGV4KTtcbiAgICBtZS5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG1lLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuICAgIG1lLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IG1lLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSBtZS5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogbWUuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogbWUub3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IG1lLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IG1lLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gbWUuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gbWUuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IG1lLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgbWUub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIG1lLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgIG1lLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gICAgbWUudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuICAgIGlmICghYXJjcykge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gbWUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgIH0sXG4gIH0sXG4gIGN1dG91dDogJzUwJScsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6ICdyJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgbGV0IGRhdGFMYWJlbCA9IHRvb2x0aXBJdGVtLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFMYWJlbCkpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgKz0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhTGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gbWUuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICBtZS5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgbWUuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChzY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghbWUub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IG1lLm9wdGlvbnMuc2VnbWVudDtcbiAgICBtZS51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG4gICAgbWUudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkfSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IG1lLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSBtZS5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBtZS5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qgc3BhbkdhcHMgPSBtZS5vcHRpb25zLnNwYW5HYXBzO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IG1lLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIG1lLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZS5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyBtZS5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICBtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICAgIG1lLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZShtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZShtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuTGluZUNvbnRyb2xsZXIuaWQgPSAnbGluZSc7XG5MaW5lQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbn07XG5MaW5lQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICB9LFxuICB9XG59O1xuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcbiAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWluKS5sbyxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKSxcbiAgICAgIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoTWF0aC5tYXgoXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5mdW5jdGlvbiBzY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuXG5jbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY2hhcnQgPSBtZS5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgbWUub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiBtZS5pbmRleCk7XG4gICAgbWUuaW5uZXJSYWRpdXMgPSBtZS5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSBtZS5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gbWUuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gbWUuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIG1lLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2ldKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IG1lLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG4gICAgICBtZS51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG5Qb2xhckFyZWFDb250cm9sbGVyLmlkID0gJ3BvbGFyQXJlYSc7XG5Qb2xhckFyZWFDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICB9LFxuICB9LFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc3RhcnRBbmdsZTogMCxcbn07XG5Qb2xhckFyZWFDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNoYXJ0LmRhdGEubGFiZWxzW2NvbnRleHQuZGF0YUluZGV4XSArICc6ICcgKyBjb250ZXh0LmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb2ludExhYmVsczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xufVxuUGllQ29udHJvbGxlci5pZCA9ICdwaWUnO1xuUGllQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgY3V0b3V0OiAwLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJ1xufTtcblxuY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1lLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBtZS5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gbWUucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghbWUub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBtZS51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIG1lLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBzY2FsZSA9IG1lLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIGRhdGFzZXQuZGF0YVtpXSk7XG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuUmFkYXJDb250cm9sbGVyLmlkID0gJ3JhZGFyJztcblJhZGFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBlbGVtZW50czoge1xuICAgIGxpbmU6IHtcbiAgICAgIGZpbGw6ICdzdGFydCdcbiAgICB9XG4gIH0sXG59O1xuUmFkYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBMaW5lQ29udHJvbGxlciB7XG59XG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcblNjYXR0ZXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBzaG93TGluZTogZmFsc2UsXG4gIGZpbGw6IGZhbHNlXG59O1xuU2NhdHRlckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6ICdwb2ludCdcbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS5sYWJlbCArICcsICcgKyBpdGVtLmZvcm1hdHRlZFZhbHVlICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5Qb2xhckFyZWFDb250cm9sbGVyOiBQb2xhckFyZWFDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICBmb3JtYXRzKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHBhcnNlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBmb3JtYXQodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBhZGQodGltZXN0YW1wLCBhbW91bnQsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBkaWZmKGEsIGIsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBzdGFydE9mKHRpbWVzdGFtcCwgdW5pdCwgd2Vla2RheSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGVuZE9mKHRpbWVzdGFtcCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcbnZhciBhZGFwdGVycyA9IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyXG59O1xuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG4gIGlmICgnbmF0aXZlJyBpbiBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUueCxcbiAgICAgIHk6IGUueVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGdldFJlbGF0aXZlUG9zaXRpb24kMShlLCBjaGFydCk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUFsbFZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgbGV0IGluZGV4LCBkYXRhLCBlbGVtZW50O1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICh7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV0pO1xuICAgIGZvciAobGV0IGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgIGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuZnVuY3Rpb24gb3B0aW1pemVkRXZhbHVhdGVJdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGlmICghX2lzUG9pbnRJbkFyZWEocG9zaXRpb24sIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG4gIG9wdGltaXplZEV2YWx1YXRlSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgaWYgKCFfaXNQb2ludEluQXJlYShwb3NpdGlvbiwgY2hhcnQuY2hhcnRBcmVhLCBjaGFydC5fbWluUGFkZGluZykpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKCFfaXNQb2ludEluQXJlYShjZW50ZXIsIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG4gIG9wdGltaXplZEV2YWx1YXRlSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcbiAgZXZhbHVhdGVBbGxWaXNpYmxlSXRlbXMoY2hhcnQsIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG52YXIgSW50ZXJhY3Rpb24gPSB7XG4gIG1vZGVzOiB7XG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgb3B0aW9ucy5heGlzID0gJ3gnO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBvcHRpb25zLmF4aXMgPSAneSc7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfVxufSk7XG52YXIgbGF5b3V0cyA9IHtcbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgpO1xuICAgIH0pO1xuICB9XG59O1xuXG5jbGFzcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5jbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEoZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgY29uc3QgZWxlbWVudCA9IGNvbnRhaW5lciB8fCBjYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gX2dldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cnkuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhZGRlZCA9IGVudHJ5LmFkZGVkTm9kZXNbaV07XG4gICAgICAgIGlmIChhZGRlZCA9PT0gZWxlbWVudCB8fCBhZGRlZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbGlzdGVuZXIoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyeS5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVudHJ5LnJlbW92ZWROb2Rlc1tpXSA9PT0gY2FudmFzKSB7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQsIChhcmdzKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIHJldHVybiBbZXZlbnQsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICB9KTtcbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuICBnZXRQcm9wcyhwcm9wcywgZmluYWwpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICByZXR1cm4gbWU7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IG1lW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbkVsZW1lbnQuZGVmYXVsdHMgPSB7fTtcbkVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuICB9LFxuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcbiAgICBjb25zdCBudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKTtcbiAgICBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG52YXIgVGlja3MgPSB7Zm9ybWF0dGVyc307XG5cbmRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIG9mZnNldDogZmFsc2UsXG4gIHJldmVyc2U6IGZhbHNlLFxuICBiZWdpbkF0WmVybzogZmFsc2UsXG4gIGJvdW5kczogJ3RpY2tzJyxcbiAgZ3JhY2U6IDAsXG4gIGdyaWQ6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBkcmF3Qm9yZGVyOiB0cnVlLFxuICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgdGlja0xlbmd0aDogOCxcbiAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wLFxuICAgIGJvcmRlcldpZHRoOiAxXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgdGV4dDogJycsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiA0LFxuICAgICAgYm90dG9tOiA0XG4gICAgfVxuICB9LFxuICB0aWNrczoge1xuICAgIG1pblJvdGF0aW9uOiAwLFxuICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICBtaXJyb3I6IGZhbHNlLFxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgIHBhZGRpbmc6IDMsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgIG1pbm9yOiB7fSxcbiAgICBtYWpvcjoge30sXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGNyb3NzQWxpZ246ICduZWFyJyxcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgfVxufSk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2JvcmRlckNvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICBfZmFsbGJhY2s6ICdzY2FsZScsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG59KTtcblxuZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuICBuZXh0ID0gc3RhcnQ7XG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudCksIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudCksIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5jbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIG1lLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQobWUuZ2V0Q29udGV4dCgpKTtcbiAgICBtZS5heGlzID0gb3B0aW9ucy5heGlzO1xuICAgIG1lLl91c2VyTWluID0gbWUucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIG1lLl91c2VyTWF4ID0gbWUucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIG1lLl9zdWdnZXN0ZWRNaW4gPSBtZS5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1pbik7XG4gICAgbWUuX3N1Z2dlc3RlZE1heCA9IG1lLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfVxuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBtZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IG1lLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgobWUsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG4gIGdldFBhZGRpbmcoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBtZS5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiBtZS5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogbWUucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IG1lLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG4gICAgbWUuYmVmb3JlVXBkYXRlKCk7XG4gICAgbWUubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICBtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgbWUuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcbiAgICBtZS50aWNrcyA9IG51bGw7XG4gICAgbWUuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIG1lLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICBtZS5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgbWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIG1lLnNldERpbWVuc2lvbnMoKTtcbiAgICBtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcbiAgICBtZS5fbWF4TGVuZ3RoID0gbWUuaXNIb3Jpem9udGFsKClcbiAgICAgID8gbWUud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IG1lLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgaWYgKCFtZS5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgbWUuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgbWUuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgbWUuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICBtZS5fcmFuZ2UgPSBfYWRkR3JhY2UobWUsIG1lLm9wdGlvbnMuZ3JhY2UpO1xuICAgICAgbWUuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICBtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG4gICAgbWUudGlja3MgPSBtZS5idWlsZFRpY2tzKCkgfHwgW107XG4gICAgbWUuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IG1lLnRpY2tzLmxlbmd0aDtcbiAgICBtZS5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKG1lLnRpY2tzLCBzYW1wbGVTaXplKSA6IG1lLnRpY2tzKTtcbiAgICBtZS5jb25maWd1cmUoKTtcbiAgICBtZS5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgbWUuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIG1lLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIG1lLnRpY2tzID0gYXV0b1NraXAobWUsIG1lLnRpY2tzKTtcbiAgICAgIG1lLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgbWUuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKG1lLnRpY2tzKTtcbiAgICB9XG4gICAgbWUuYmVmb3JlRml0KCk7XG4gICAgbWUuZml0KCk7XG4gICAgbWUuYWZ0ZXJGaXQoKTtcbiAgICBtZS5hZnRlclVwZGF0ZSgpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSBtZS5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgIGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IG1lLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IG1lLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gbWUudG9wO1xuICAgICAgZW5kUGl4ZWwgPSBtZS5ib3R0b207XG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIG1lLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICBtZS5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICBtZS5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgbWUuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICBtZS5fYWxpZ25Ub1BpeGVscyA9IG1lLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG4gICAgICBtZS5sZWZ0ID0gMDtcbiAgICAgIG1lLnJpZ2h0ID0gbWUud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcbiAgICAgIG1lLnRvcCA9IDA7XG4gICAgICBtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG4gICAgfVxuICAgIG1lLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICBtZS5wYWRkaW5nVG9wID0gMDtcbiAgICBtZS5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBtZS5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIG1lLmdldENvbnRleHQoKSk7XG4gICAgY2FsbGJhY2sobWUub3B0aW9uc1tuYW1lXSwgW21lXSk7XG4gIH1cbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsYmFjayh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgbWUpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSBtZS50aWNrcy5sZW5ndGg7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG4gICAgaWYgKCFtZS5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhbWUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1lLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKG1lLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgbWUubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gbWUubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IG1lLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgbWUuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cbiAgICBtZS5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gbWU7XG4gICAgY29uc3QgZGlzcGxheSA9IG1lLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBtZS50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gbWUuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihtZS5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4obWUubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIG1lLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIG1lLl9oYW5kbGVNYXJnaW5zKCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgbWUud2lkdGggPSBtZS5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSBtZS5fbWFyZ2lucy5sZWZ0IC0gbWUuX21hcmdpbnMucmlnaHQ7XG4gICAgICBtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgbWUuaGVpZ2h0ID0gbWUuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIG1lLl9tYXJnaW5zLnRvcCAtIG1lLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSBtZS5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgbWUuYXhpcyA9PT0gJ3gnO1xuICAgIGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IG1lLmdldFBpeGVsRm9yVGljaygwKSAtIG1lLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKG1lLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogbWUud2lkdGggLyAobWUud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICBtZS5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuICAgICAgbWUucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgbWUucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLl9tYXJnaW5zKSB7XG4gICAgICBtZS5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgobWUucGFkZGluZ0xlZnQsIG1lLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgbWUuX21hcmdpbnMudG9wID0gTWF0aC5tYXgobWUucGFkZGluZ1RvcCwgbWUuX21hcmdpbnMudG9wKTtcbiAgICAgIG1lLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgobWUucGFkZGluZ1JpZ2h0LCBtZS5fbWFyZ2lucy5yaWdodCk7XG4gICAgICBtZS5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heChtZS5wYWRkaW5nQm90dG9tLCBtZS5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbWUuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgbWUuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSBtZS5fbGFiZWxTaXplcztcbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSBtZS5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSBtZS50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cbiAgICAgIG1lLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IG1lLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSBsYWJlbFtqXTtcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuICAgIGNvbnN0IHBpeGVsID0gbWUuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogbWUuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UobWUuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbChtZS5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gbWUudGlja3MgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KG1lLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lLiRjb250ZXh0IHx8XG5cdFx0XHQobWUuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQobWUuY2hhcnQuZ2V0Q29udGV4dCgpLCBtZSkpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcbiAgICBjb25zdCBsYWJlbFNpemVzID0gbWUuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuICAgIHJldHVybiBtZS5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYXhpcyA9IG1lLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSBtZS5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IG1lLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5ib3R0b20pO1xuICAgICAgdHkxID0gbWUuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSBtZS50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5yaWdodCk7XG4gICAgICB0eDEgPSBtZS5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gbWUubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KGkpKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IGdyaWQuYm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKG1lLCBpLCBvZmZzZXQpO1xuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZS5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICBtZS5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBheGlzID0gbWUuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gbWUudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSBtZS5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSBtZS5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gbWUudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gbWUuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IG1lLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gbWUuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gbWUuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gbWUuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gbWUuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IG1lLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gbWUuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQobWUuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IG1lLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IG1lLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgbGV0IGJhY2tkcm9wO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG4gICAgICAgIGxldCB0b3AgPSB5ICsgdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0geCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICBiYWNrZHJvcCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gbWUub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gbWUuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSBtZS5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbWUucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IG1lLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSBtZS5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBtZS5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gbWUucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSBtZS5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1lLm9wdGlvbnMucG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiBtZS5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IG1lLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogbWUudG9wLCBsZWZ0OiAwLCBib3R0b206IG1lLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBncmlkID0gbWUub3B0aW9ucy5ncmlkO1xuICAgIGlmICghbWUuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IG1lLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGdyaWQgPSBtZS5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gbWUuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gbWUuX2dyaWRMaW5lSXRlbXMgfHwgKG1lLl9ncmlkTGluZUl0ZW1zID0gbWUuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2dyaWR9fSA9IG1lO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQobWUuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBncmlkLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IG1lLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG4gICAgaWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIG1lLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgbWUuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzO1xuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSBtZS5jdHg7XG4gICAgY29uc3QgYXJlYSA9IG1lLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gbWUuX2xhYmVsSXRlbXMgfHwgKG1lLl9sYWJlbEl0ZW1zID0gbWUuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgaWYgKGl0ZW0uYmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGl0ZW0uYmFja2Ryb3AuY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpdGVtLmJhY2tkcm9wLmxlZnQsIGl0ZW0uYmFja2Ryb3AudG9wLCBpdGVtLmJhY2tkcm9wLndpZHRoLCBpdGVtLmJhY2tkcm9wLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBsZXQgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmICghbWUuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgbWUuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICBtZS5kcmF3Qm9yZGVyKCk7XG4gICAgbWUuZHJhd1RpdGxlKCk7XG4gICAgbWUuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGlmICghbWUuX2lzVmlzaWJsZSgpIHx8IG1lLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgbWUuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgIG1lLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIG1lLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIG1lLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGd6ICsgMSxcbiAgICAgIGRyYXcoKSB7XG4gICAgICAgIG1lLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgIG1lLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGFzID0gbWUuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IG1lLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSBtZS5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZm9udFNpemUgPSBtZS5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAobWUuaXNIb3Jpem9udGFsKCkgPyBtZS53aWR0aCA6IG1lLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuXG5jbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICBwYXJlbnRTY29wZSA9IG1lLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBtZS5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSBtZS5zY29wZSArICcuJyArIGlkO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKG1lLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IG1lLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSBtZS5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgbWUuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgbWUuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICBtZS5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG59XG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICBtZS5faW5pdCA9IG1lLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICBtZS5fbm90aWZ5KG1lLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyBtZS5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogbWUuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSBtZS5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG4gICAgaWYgKGhvb2sgPT09ICdkZXN0cm95Jykge1xuICAgICAgbWUuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICBtZS5fbm90aWZ5KG1lLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBsdWdpbnM7XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCBwbHVnaW4sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCBwbHVnaW4sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtzY3JpcHRhYmxlOiBmYWxzZSwgaW5kZXhhYmxlOiBmYWxzZSwgYWxsS2V5czogdHJ1ZX0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5Jykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICByZXR1cm4gc2NhbGVPcHRpb25zLmF4aXMgfHwgYXhpc0Zyb21Qb3NpdGlvbihzY2FsZU9wdGlvbnMucG9zaXRpb24pIHx8IGlkLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdElEcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgZmlyc3RJRHNbYXhpc10gPSBmaXJzdElEc1theGlzXSB8fCBpZDtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgZmlyc3RJRHNbYXhpc10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNjYWxlcztcbn1cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuICBpbml0T3B0aW9ucyhjb25maWcpO1xuICByZXR1cm4gY29uZmlnO1xufVxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5jbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgaWYgKChpc1NjcmlwdGFibGUocHJvcCkgJiYgaXNGdW5jdGlvbihwcm94eVtwcm9wXSkpXG4gICAgICB8fCAoaXNJbmRleGFibGUocHJvcCkgJiYgaXNBcnJheShwcm94eVtwcm9wXSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMy41LjFcIjtcblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcbmNsYXNzIENoYXJ0IHtcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIG1lLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICBjb25zdCBjb250ZXh0ID0gbWUucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHRoaXMudXBkYXRlKCdyZXNpemUnKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICBpbnN0YW5jZXNbbWUuaWRdID0gbWU7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0b3IubGlzdGVuKG1lLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKG1lLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICBtZS5faW5pdGlhbGl6ZSgpO1xuICAgIGlmIChtZS5hdHRhY2hlZCkge1xuICAgICAgbWUudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuICAgIGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIG1lLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZShtZSwgbWUub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgbWUuYmluZEV2ZW50cygpO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiBtZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gbWUuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG1lLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSBtZS5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBtZS5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgbWUud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIG1lLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIG1lLl9hc3BlY3RSYXRpbyA9IG1lLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUobWUsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuICAgIGNhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFttZSwgbmV3U2l6ZV0sIG1lKTtcbiAgICBpZiAobWUuYXR0YWNoZWQpIHtcbiAgICAgIGlmIChtZS5fZG9SZXNpemUoKSkge1xuICAgICAgICBtZS5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSBtZS5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IG1lLmN0eCxcbiAgICAgICAgICBjaGFydDogbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKG1lLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveChtZSwgc2NhbGUpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YXNldHMgPSBtZS5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgbWUuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIG1lLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSBtZTtcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgbWUuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbWUuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gbWUuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBtZS5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIG1lLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBtZS5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSBtZS5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWUuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBlYWNoKG1lLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIG1lKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IG1lLmNvbmZpZztcbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgbWUuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIG1lLmdldENvbnRleHQoKSk7XG4gICAgZWFjaChtZS5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3gobWUsIHNjYWxlKTtcbiAgICB9KTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gbWUuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFtZS5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICBtZS5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgbWUuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyhtZS5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChtZS5vcHRpb25zLmV2ZW50cyk7XG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIG1lLnVuYmluZEV2ZW50cygpO1xuICAgICAgbWUuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgICBtZS5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gbWUuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gbWUuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtZS5fbWluUGFkZGluZyA9IG1pblBhZGRpbmc7XG4gICAgbWUuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZS5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuICAgIG1lLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG4gICAgaWYgKG1lLl9sYXN0RXZlbnQpIHtcbiAgICAgIG1lLl9ldmVudEhhbmRsZXIobWUuX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIG1lLnJlbmRlcigpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5b3V0cy51cGRhdGUobWUsIG1lLndpZHRoLCBtZS5oZWlnaHQsIG1pblBhZGRpbmcpO1xuICAgIGNvbnN0IGFyZWEgPSBtZS5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgbWUuX2xheWVycyA9IFtdO1xuICAgIGVhY2gobWUuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICBtZS5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgbWUpO1xuICAgIG1lLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgaXNGdW5jdGlvbiA9IHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChtZS5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG1lLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24gPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuICAgIGlmIChtZS5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbmltYXRvci5oYXMobWUpKSB7XG4gICAgICBpZiAobWUuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcobWUpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KG1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWUuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiBtZX0pO1xuICAgIH1cbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBsZXQgaTtcbiAgICBpZiAobWUuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IG1lLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgbWUuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1lLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICB9XG4gICAgbWUuY2xlYXIoKTtcbiAgICBpZiAobWUud2lkdGggPD0gMCB8fCBtZS5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWUubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVycyA9IG1lLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyhtZS5jaGFydEFyZWEpO1xuICAgIH1cbiAgICBtZS5fZHJhd0RhdGFzZXRzKCk7XG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KG1lLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhc2V0cyA9IG1lLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSBtZS5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZS5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IG1lLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IG1lLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG4gICAgICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gbWUuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSBtZS5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgbWUudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIG1lLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9tZXRhc2V0cyAmJiBtZS5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIG1lLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gbWU7XG4gICAgbGV0IGksIGlsZW47XG4gICAgbWUuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZShtZSk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBtZS5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgICBtZS5jb25maWcuY2xlYXJDYWNoZSgpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIG1lLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgbWUucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIG1lLmNhbnZhcyA9IG51bGw7XG4gICAgICBtZS5jdHggPSBudWxsO1xuICAgIH1cbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdkZXN0cm95Jyk7XG4gICAgZGVsZXRlIGluc3RhbmNlc1ttZS5pZF07XG4gIH1cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gbWUucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGZ1bmN0aW9uKGUsIHgsIHkpIHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgbWUuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuICAgIGVhY2gobWUub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmICghbWUuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIG1lLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1lLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gbWUucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmIChtZS5jYW52YXMpIHtcbiAgICAgICAgbWUucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGRldGFjaGVkO1xuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgICAgbWUuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgbWUucmVzaXplKCk7XG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIG1lLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZChtZS5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGVhY2gobWUuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICBtZS5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgbWUuX2xpc3RlbmVycyA9IHt9O1xuICAgIGVhY2gobWUuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgbWUucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIG1lLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgbWUuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIG1lLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSBtZS5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgbWUudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIG1lLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGFyZ3MgPSB7ZXZlbnQ6IGUsIHJlcGxheSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUudHlwZSk7XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gbWUuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIG1lLnJlbmRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbWU7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IG1lO1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBsZXQgYWN0aXZlID0gW107XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgbGFzdEV2ZW50ID0gbnVsbDtcbiAgICBpZiAoZS50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgICBhY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgbGFzdEV2ZW50ID0gZS50eXBlID09PSAnY2xpY2snID8gbWUuX2xhc3RFdmVudCA6IGU7XG4gICAgfVxuICAgIG1lLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgIGlmIChfaXNQb2ludEluQXJlYShlLCBtZS5jaGFydEFyZWEsIG1lLl9taW5QYWRkaW5nKSkge1xuICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCBtZV0sIG1lKTtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgbWVdLCBtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIG1lLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBtZS5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cbiAgICBtZS5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG59XG5jb25zdCBpbnZhbGlkYXRlUGx1Z2lucyA9ICgpID0+IGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJ0LCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZGVmYXVsdHNcbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogaW5zdGFuY2VzXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiB2ZXJzaW9uXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzcGFjaW5nKSB7XG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICB9XG4gIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICB9XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcbiAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XG4gICAgICBpZiAoY2lyY3VtZmVyZW5jZSAlIFRBVSA9PT0gMCkge1xuICAgICAgICBlbmRBbmdsZSArPSBUQVU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCBmdWxsQ2lyY2xlc30gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gZWxlbWVudC5pbm5lclJhZGl1cyArIHBpeGVsTWFyZ2luO1xuICBsZXQgaTtcbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSArIFRBVSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSkge1xuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gIGlmICghb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuICB9XG4gIGlmIChlbGVtZW50LmZ1bGxDaXJjbGVzKSB7XG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpO1xuICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKGNoYXJ0WCwgY2hhcnRZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IChkaXN0YW5jZSA+PSBpbm5lclJhZGl1cyArIHJBZGp1c3QgJiYgZGlzdGFuY2UgPD0gb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZScsXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IG1lO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDI7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIG1lLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgbWUuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgbWUuaW5uZXJSYWRpdXMgPCAwIHx8IG1lLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGxldCByYWRpdXNPZmZzZXQgPSAwO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldCAvIDI7XG4gICAgICBjb25zdCBoYWxmQW5nbGUgPSAobWUuc3RhcnRBbmdsZSArIG1lLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQpO1xuICAgICAgaWYgKG1lLmNpcmN1bWZlcmVuY2UgPj0gUEkpIHtcbiAgICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IGRyYXdBcmMoY3R4LCBtZSwgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgbWUsIHJhZGl1c09mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbkFyY0VsZW1lbnQuaWQgPSAnYXJjJztcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdW5kZWZpbmVkLFxufTtcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xufTtcblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cbiAgcmV0dXJuIGxpbmVUbztcbn1cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcHJldiA9IHBvaW50O1xuICB9XG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuICByZXR1cm4gISFsb29wO1xufVxuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiBsaW5lLnNlZ21lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhbWUuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gbWUuX2xvb3AgOiBtZS5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhtZS5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICBtZS5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIG1lLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIG1lLl9zZWdtZW50cztcbiAgICBkZWxldGUgbWUuX3BhdGg7XG4gICAgbWUuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gbWUucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHMobWUsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gbWUuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKG1lKTtcbiAgICBsZXQgbG9vcCA9IG1lLl9sb29wO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8IChtZS5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgbWUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSBtZS5wb2ludHMgfHwgW107XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoIHx8ICFvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgZHJhdyhjdHgsIG1lLCBzdGFydCwgY291bnQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKG1lLmFuaW1hdGVkKSB7XG4gICAgICBtZS5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgbWUuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5MaW5lRWxlbWVudC5pZCA9ICdsaW5lJztcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gIGZpbGw6IGZhbHNlLFxuICBzcGFuR2FwczogZmFsc2UsXG4gIHN0ZXBwZWQ6IGZhbHNlLFxuICB0ZW5zaW9uOiAwLFxufTtcbkxpbmVFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuTGluZUVsZW1lbnQuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbn07XG5cbmZ1bmN0aW9uIGluUmFuZ2UkMShlbCwgcG9zLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgc2l6ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuICBkcmF3KGN0eCwgYXJlYSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBpZiAobWUuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEobWUsIGFyZWEsIG1lLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCBtZS54LCBtZS55KTtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG5Qb2ludEVsZW1lbnQuaWQgPSAncG9pbnQnO1xuUG9pbnRFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJXaWR0aDogMSxcbiAgaGl0UmFkaXVzOiAxLFxuICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICBob3ZlclJhZGl1czogNCxcbiAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn07XG5Qb2ludEVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgeCA+PSBib3VuZHMubGVmdCAmJiB4IDw9IGJvdW5kcy5yaWdodClcblx0XHQmJiAoc2tpcFkgfHwgeSA+PSBib3VuZHMudG9wICYmIHkgPD0gYm91bmRzLmJvdHRvbSk7XG59XG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5jbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuICAgIGNvbnN0IGluZmxhdGVBbW91bnQgPSAwLjMzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5CYXJFbGVtZW50LmlkID0gJ2Jhcic7XG5CYXJFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBlbmFibGVCb3JkZXJSYWRpdXM6IHRydWUsXG4gIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxufTtcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5MaW5lRWxlbWVudDogTGluZUVsZW1lbnQsXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcbkJhckVsZW1lbnQ6IEJhckVsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEudHlwZSAhPT0gJ2xpbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG4gIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgaWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcbiAgICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgbGV0IGhvcml6b250YWw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICB0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSkge1xuICAgIGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCBlbmQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIGxldCBpLCBjZW50ZXIsIHZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IGVuZDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgc2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KGNoYXJ0LCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChjcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cbmNvbnN0IGlzTGluZUFuZE5vdEluSGlkZUFuaW1hdGlvbiA9IChtZXRhKSA9PiBtZXRhLnR5cGUgPT09ICdsaW5lJyAmJiAhbWV0YS5oaWRkZW47XG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaXNMaW5lQW5kTm90SW5IaWRlQW5pbWF0aW9uKG1ldGEpKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKHBvaW50VmFsdWUgPj0gZmlyc3RWYWx1ZSAmJiBwb2ludFZhbHVlIDw9IGxhc3RWYWx1ZSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG4gIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9jbGlwKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHRhcmdldC5wYXRoKGN0eCk7XG4gIGN0eC5saW5lVG8odGFyZ2V0Lmxhc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBnZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBmaW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuICAgIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IGdldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9maWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBnZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG4gIGN0eC5zYXZlKCk7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIF9jbGlwKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgX2ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBfY2xpcChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICB9XG4gIF9maWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxudmFyIHBsdWdpbl9maWxsZXIgPSB7XG4gIGlkOiAnZmlsbGVyJyxcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBkZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGRyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBkcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG4gICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5jbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICBtZS5fbWFyZ2lucyA9IG1hcmdpbnM7XG4gICAgbWUuc2V0RGltZW5zaW9ucygpO1xuICAgIG1lLmJ1aWxkTGFiZWxzKCk7XG4gICAgbWUuZml0KCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuICAgICAgbWUubGVmdCA9IG1lLl9tYXJnaW5zLmxlZnQ7XG4gICAgICBtZS5yaWdodCA9IG1lLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG4gICAgICBtZS50b3AgPSBtZS5fbWFyZ2lucy50b3A7XG4gICAgICBtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG4gICAgfVxuICB9XG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgbWUuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgbWUuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobWUub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IG1lO1xuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBtZS53aWR0aCA9IG1lLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IG1lLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgaWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IG1lLm1heFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gbWUuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuICAgICAgd2lkdGggPSBtZS5fZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cbiAgICBtZS53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IG1lLm1heFdpZHRoKTtcbiAgICBtZS5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IG1lLm1heEhlaWdodCk7XG4gIH1cbiAgX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSBtZTtcbiAgICBjb25zdCBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgbWUubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IG1lO1xuICAgIGNvbnN0IGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IG1lLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcbiAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcbiAgICBtZS5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAoIW1lLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IG1lLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IG1lO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCBtZS5sZWZ0LCBtZS53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbWUubGVmdCArIHBhZGRpbmcsIG1lLnJpZ2h0IC0gbWUubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbWUubGVmdCArIHBhZGRpbmcsIG1lLnJpZ2h0IC0gbWUubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IG1lLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbWUudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCBtZS5ib3R0b20gLSBtZS5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbWUudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCBtZS5ib3R0b20gLSBtZS5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gbWUubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChtZS5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgbWUpO1xuICAgICAgbWUuX2RyYXcoKTtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgX2RyYXcoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IG1lO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCBtZS5sZWZ0LCBtZS53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7Y29sb3I6IGZvbnRDb2xvciwgcGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcbiAgICBtZS5kcmF3VGl0bGUoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLmxlZnQgKyBwYWRkaW5nLCBtZS5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiBtZS50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogbWUubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBtZS50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIG1lLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihtZS5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIG1lLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKG1lLndpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiBtZS5yaWdodCkge1xuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgeCA9IGN1cnNvci54ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLmxlZnQgKyBwYWRkaW5nLCBtZS5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IG1lLmJvdHRvbSkge1xuICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgbWUuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiBtZS5yaWdodCwgb3B0cy5ydGwpO1xuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKG1lLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgbWUubGVmdCwgbWUud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuICAgIGxldCBsZWZ0ID0gbWUubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSBtZS53aWR0aDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi5tZS5saW5lV2lkdGhzKTtcbiAgICAgIHkgPSBtZS50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCBtZS5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gbWUuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIG1lLnRvcCwgbWUuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIG1lLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgfVxuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgaWYgKHggPj0gbWUubGVmdCAmJiB4IDw9IG1lLnJpZ2h0ICYmIHkgPj0gbWUudG9wICYmIHkgPD0gbWUuYm90dG9tKSB7XG4gICAgICBsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuICAgICAgICBpZiAoeCA+PSBoaXRCb3gubGVmdCAmJiB4IDw9IGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoICYmIHkgPj0gaGl0Qm94LnRvcCAmJiB5IDw9IGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBtZS5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSBtZS5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIG1lXSwgbWUpO1xuICAgICAgfVxuICAgICAgbWUuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCBtZV0sIG1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgbWVdLCBtZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgaWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBwbHVnaW5fbGVnZW5kID0ge1xuICBpZDogJ2xlZ2VuZCcsXG4gIF9lbGVtZW50OiBMZWdlbmQsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGFmdGVyVXBkYXRlKGNoYXJ0KSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgd2VpZ2h0OiAxMDAwLFxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG5cbmNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBtZS5sZWZ0ID0gMDtcbiAgICBtZS50b3AgPSAwO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICBtZS53aWR0aCA9IG1lLmhlaWdodCA9IG1lLnJpZ2h0ID0gbWUuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWUud2lkdGggPSBtZS5yaWdodCA9IG1heFdpZHRoO1xuICAgIG1lLmhlaWdodCA9IG1lLmJvdHRvbSA9IG1heEhlaWdodDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICBtZS5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIG1lLl9wYWRkaW5nLmhlaWdodDtcbiAgICBpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1lLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgbWUuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IG1lLl9kcmF3QXJncyhvZmZzZXQpO1xuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gIGlkOiAndGl0bGUnLFxuICBfZWxlbWVudDogVGl0bGUsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMikgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG4gIHdpZHRoUGFkZGluZyA9IDA7XG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG4gIHJldHVybiB4QWxpZ247XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCByYWRpdXNBbmRQYWRkaW5nID0gY29ybmVyUmFkaXVzICsgY2FyZXRQYWRkaW5nO1xuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSByYWRpdXNBbmRQYWRkaW5nO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0XG4gICAgICA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50KSwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2NoYXJ0ID0gY29uZmlnLl9jaGFydDtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjYWNoZWQgPSBtZS5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IG1lLl9jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucy5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKG1lLl9jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgbWUuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICByZXR1cm4gbWUuJGNvbnRleHQgfHxcblx0XHRcdChtZS4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KG1lLl9jaGFydC5nZXRDb250ZXh0KCksIG1lLCBtZS5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkobWUsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBbY29udGV4dF0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhzY29wZWQuYmVmb3JlTGFiZWwuY2FsbChtZSwgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgc2NvcGVkLmxhYmVsLmNhbGwobWUsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhzY29wZWQuYWZ0ZXJMYWJlbC5jYWxsKG1lLCBjb250ZXh0KSkpO1xuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KG1lLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseShtZSwgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYWN0aXZlID0gbWUuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gbWUuX2NoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShtZS5fY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChzY29wZWQubGFiZWxDb2xvci5jYWxsKG1lLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goc2NvcGVkLmxhYmVsUG9pbnRTdHlsZS5jYWxsKG1lLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChzY29wZWQubGFiZWxUZXh0Q29sb3IuY2FsbChtZSwgY29udGV4dCkpO1xuICAgIH0pO1xuICAgIG1lLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgbWUubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgbWUubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIG1lLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zLnNldENvbnRleHQobWUuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSBtZS5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmIChtZS5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwobWUsIGFjdGl2ZSwgbWUuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gbWUuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuICAgICAgbWUudGl0bGUgPSBtZS5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgbWUuYmVmb3JlQm9keSA9IG1lLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIG1lLmJvZHkgPSBtZS5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBtZS5hZnRlckJvZHkgPSBtZS5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIG1lLmZvb3RlciA9IG1lLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2l6ZSA9IG1lLl9zaXplID0gZ2V0VG9vbHRpcFNpemUobWUsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KG1lLl9jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgbWUuX2NoYXJ0KTtcbiAgICAgIG1lLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICBtZS55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICBjYXJldFk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuICAgIG1lLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgbWUuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIG1lLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZShtZSwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbChtZSwge2NoYXJ0OiBtZS5fY2hhcnQsIHRvb2x0aXA6IG1lLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2Nvcm5lclJhZGl1cywgY2FyZXRTaXplfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBjb3JuZXJSYWRpdXMgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBjb3JuZXJSYWRpdXMgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGl0bGUgPSBtZS50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIG1lLngsIG1lLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWChtZSwgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nO1xuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IG1lLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IG1lLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGh9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWChtZSwgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGFiZWxDb2xvcnMuYm9yZGVyV2lkdGggfHwgMTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3JzLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvcnMuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvcnMuYm9yZGVyUmFkaXVzKTtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gbWUubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHl9ID0gbWU7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGh9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIG1lLngsIG1lLndpZHRoKTtcbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gICAgcHQueCA9IGdldEFsaWduZWRYKG1lLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2gobWUuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyAxKSA6IChib3hXaWR0aCArIDIpXG4gICAgICA6IDA7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSBtZS5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgbWUuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBlYWNoKG1lLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7XG4gIH1cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGZvb3RlciA9IG1lLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIG1lLngsIG1lLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWChtZSwgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5jb3JuZXJSYWRpdXM7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjaGFydCA9IG1lLl9jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IG1lLiRhbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgaWYgKGFuaW1YIHx8IGFuaW1ZKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwobWUsIG1lLl9hY3RpdmUsIG1lLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IG1lLl9zaXplID0gZ2V0VG9vbHRpcFNpemUobWUsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIG1lLl9zaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICBtZS54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICBtZS55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICBtZS53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIG1lLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICBtZS5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICBtZS5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICBtZS5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUobWUsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnMuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gbWUub3BhY2l0eTtcbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWUuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBtZS53aWR0aCxcbiAgICAgIGhlaWdodDogbWUuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwdCA9IHtcbiAgICAgIHg6IG1lLngsXG4gICAgICB5OiBtZS55XG4gICAgfTtcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gbWUudGl0bGUubGVuZ3RoIHx8IG1lLmJlZm9yZUJvZHkubGVuZ3RoIHx8IG1lLmJvZHkubGVuZ3RoIHx8IG1lLmFmdGVyQm9keS5sZW5ndGggfHwgbWUuZm9vdGVyLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgIG1lLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuICAgICAgbWUuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgbWUuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICBtZS5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IG1lLl9jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IG1lLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIG1lLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBtZS5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICBtZS51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUV2ZW50KGUsIHJlcGxheSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gbWUuX2FjdGl2ZSB8fCBbXTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICBpZiAoZS50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgICBhY3RpdmUgPSBtZS5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IG1lLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcbiAgICBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgbWUuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICBtZS5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG4gICAgICAgIG1lLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5Ub29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG52YXIgcGx1Z2luX3Rvb2x0aXAgPSB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe19jaGFydDogY2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICB0b29sdGlwXG4gICAgfTtcbiAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRvb2x0aXApIHtcbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuICAgIH1cbiAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgICAgIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJUaXRsZTogbm9vcCxcbiAgICAgIGJlZm9yZUJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgICB9LFxuICAgICAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFmdGVyTGFiZWw6IG5vb3AsXG4gICAgICBhZnRlckJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gICAgICBmb290ZXI6IG5vb3AsXG4gICAgICBhZnRlckZvb3Rlcjogbm9vcFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuXG52YXIgcGx1Z2lucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkRlY2ltYXRpb246IHBsdWdpbl9kZWNpbWF0aW9uLFxuRmlsbGVyOiBwbHVnaW5fZmlsbGVyLFxuTGVnZW5kOiBwbHVnaW5fbGVnZW5kLFxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcblRpdGxlOiBwbHVnaW5fdGl0bGUsXG5Ub29sdGlwOiBwbHVnaW5fdG9vbHRpcFxufSk7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCkgPT4gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZydcbiAgPyBsYWJlbHMucHVzaChyYXcpIC0gMVxuICA6IGlzTmFOKHJhdykgPyBudWxsIDogaW5kZXg7XG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcbmNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IG1lLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IG1lLmdldE1pbk1heCh0cnVlKTtcbiAgICBpZiAobWUub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IG1lLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIG1lLm1pbiA9IG1pbjtcbiAgICBtZS5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWluID0gbWUubWluO1xuICAgIGNvbnN0IG1heCA9IG1lLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG4gICAgbWUuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgbWUuX3N0YXJ0VmFsdWUgPSBtZS5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG4gICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKCFtZS5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWUuX3JldmVyc2VQaXhlbHMgPSAhbWUuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gbWUucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IG1lLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG1lLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1lLl9zdGFydFZhbHVlICsgbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIG1lLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG5DYXRlZ29yeVNjYWxlLmlkID0gJ2NhdGVnb3J5JztcbkNhdGVnb3J5U2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IENhdGVnb3J5U2NhbGUucHJvdG90eXBlLmdldExhYmVsRm9yVmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yfSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICBpZiAoYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5jbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiArcmF3O1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IG1lLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IG1lO1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICAgIGlmIChtYXggPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbWluIDw9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuICAgICAgfVxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZS5taW4gPSBtaW47XG4gICAgbWUubWF4ID0gbWF4O1xuICB9XG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwobWUubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcihtZS5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IG1lLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGxldCBtYXhUaWNrcyA9IG1lLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiBtZS5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiBtZS5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IG1lLl9yYW5nZSB8fCBtZTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MkMShudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgbWUsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICBtZS5zdGFydCA9IG1lLm1heDtcbiAgICAgIG1lLmVuZCA9IG1lLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWUuc3RhcnQgPSBtZS5taW47XG4gICAgICBtZS5lbmQgPSBtZS5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gbWUudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gbWUubWluO1xuICAgIGxldCBlbmQgPSBtZS5tYXg7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKG1lLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIG1lLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgbWUuX2VuZFZhbHVlID0gZW5kO1xuICAgIG1lLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICB9XG59XG5cbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IG1lLmdldE1pbk1heCh0cnVlKTtcbiAgICBtZS5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICBtZS5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gbWF4IDogMTtcbiAgICBtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyhtZS5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IG1lLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbkxpbmVhclNjYWxlLmlkID0gJ2xpbmVhcic7XG5MaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IGVuZEV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuICBjb25zdCBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBsZXQgdGlja1ZhbCA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuICBsZXQgZXhwID0gTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSk7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBkbyB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWwsIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gICAgKytzaWduaWZpY2FuZDtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IDE7XG4gICAgICArK2V4cDtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gIHJldHVybiB0aWNrcztcbn1cbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IG1lLmdldE1pbk1heCh0cnVlKTtcbiAgICBtZS5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgbWUubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuICAgIGlmIChtZS5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICBtZS5femVybyA9IHRydWU7XG4gICAgfVxuICAgIG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBtZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IG1lLm1pbjtcbiAgICBsZXQgbWF4ID0gbWUubWF4O1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgY29uc3QgZXhwID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHYpKSArIG0pO1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoZXhwKG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oZXhwKG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG4gICAgICBzZXRNYXgoZXhwKG1pbiwgKzEpKTtcbiAgICB9XG4gICAgaWYgKG1lLl96ZXJvICYmIG1lLm1pbiAhPT0gbWUuX3N1Z2dlc3RlZE1pbiAmJiBtaW4gPT09IGV4cChtZS5taW4sIDApKSB7XG4gICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICB9XG4gICAgbWUubWluID0gbWluO1xuICAgIG1lLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogbWUuX3VzZXJNaW4sXG4gICAgICBtYXg6IG1lLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIG1lKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgbWUsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICBtZS5zdGFydCA9IG1lLm1heDtcbiAgICAgIG1lLmVuZCA9IG1lLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWUuc3RhcnQgPSBtZS5taW47XG4gICAgICBtZS5lbmQgPSBtZS5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnMCcgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQgPSBtZS5taW47XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgbWUuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgbWUuX3ZhbHVlUmFuZ2UgPSBsb2cxMChtZS5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gbWUubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSBtZS5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZGVjaW1hbCA9IG1lLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCBtZS5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiBtZS5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbkxvZ2FyaXRobWljU2NhbGUuaWQgPSAnbG9nYXJpdGhtaWMnO1xuTG9nYXJpdGhtaWNTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuICBjb25zdCBmdXJ0aGVzdExpbWl0cyA9IHtcbiAgICBsOiAwLFxuICAgIHI6IHNjYWxlLndpZHRoLFxuICAgIHQ6IDAsXG4gICAgYjogc2NhbGUuaGVpZ2h0IC0gc2NhbGUucGFkZGluZ1RvcFxuICB9O1xuICBjb25zdCBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgaWYgKGhMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy5sKSB7XG4gICAgICBmdXJ0aGVzdExpbWl0cy5sID0gaExpbWl0cy5zdGFydDtcbiAgICAgIGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XG4gICAgfVxuICAgIGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcbiAgICAgIGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcbiAgICAgIGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG4gICAgfVxuICAgIGlmICh2TGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMudCkge1xuICAgICAgZnVydGhlc3RMaW1pdHMudCA9IHZMaW1pdHMuc3RhcnQ7XG4gICAgICBmdXJ0aGVzdEFuZ2xlcy50ID0gYW5nbGVSYWRpYW5zO1xuICAgIH1cbiAgICBpZiAodkxpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5iKSB7XG4gICAgICBmdXJ0aGVzdExpbWl0cy5iID0gdkxpbWl0cy5lbmQ7XG4gICAgICBmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xuICAgIH1cbiAgfVxuICBzY2FsZS5fc2V0UmVkdWN0aW9ucyhzY2FsZS5kcmF3aW5nQXJlYSwgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKTtcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCB0aWNrQmFja2Ryb3BIZWlnaHQgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cyk7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IGV4dHJhID0gKGkgPT09IDAgPyB0aWNrQmFja2Ryb3BIZWlnaHQgLyAyIDogMCk7XG4gICAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nW2ldKTtcbiAgICBjb25zdCBhbmdsZSA9IHRvRGVncmVlcyhzY2FsZS5nZXRJbmRleEFuZ2xlKGkpKTtcbiAgICBjb25zdCBzaXplID0gbGFiZWxTaXplc1tpXTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICBpdGVtcy5wdXNoKHtcbiAgICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgICAgeSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIGxlZnQsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgIGJvdHRvbTogeSArIHNpemUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbiwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0IC0gcGFkZGluZy5sZWZ0LCB0b3AgLSBwYWRkaW5nLnRvcCwgcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aCwgYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQpO1xuICAgIH1cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuICByZXR1cm4gaXNOdW1iZXIocGFyYW0pID8gcGFyYW0gOiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG4gICAgbWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuICAgIG1lLnBhZGRpbmdUb3AgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQobWUub3B0aW9ucykgLyAyO1xuICAgIG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKG1lLndpZHRoIC8gMik7XG4gICAgbWUueUNlbnRlciA9IE1hdGguZmxvb3IoKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApIC8gMik7XG4gICAgbWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wLCBtZS53aWR0aCkgLyAyO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSBtZS5nZXRNaW5NYXgoZmFsc2UpO1xuICAgIG1lLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIG1lLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuICAgIG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbChtZSwgdGlja3MpO1xuICAgIG1lLl9wb2ludExhYmVscyA9IG1lLmdldExhYmVscygpLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGNhbGxiYWNrKG1lLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCBtZSk7XG4gICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgIH0pO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyhtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuICBfc2V0UmVkdWN0aW9ucyhsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBsZXQgcmFkaXVzUmVkdWN0aW9uTGVmdCA9IGZ1cnRoZXN0TGltaXRzLmwgLyBNYXRoLnNpbihmdXJ0aGVzdEFuZ2xlcy5sKTtcbiAgICBsZXQgcmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBNYXRoLm1heChmdXJ0aGVzdExpbWl0cy5yIC0gbWUud2lkdGgsIDApIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMucik7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IC1NYXRoLm1heChmdXJ0aGVzdExpbWl0cy5iIC0gKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApLCAwKSAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLmIpO1xuICAgIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG4gICAgcmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuICAgIHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuICAgIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuICAgIG1lLmRyYXdpbmdBcmVhID0gTWF0aC5tYXgobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC8gMiwgTWF0aC5taW4oXG4gICAgICBNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25MZWZ0ICsgcmFkaXVzUmVkdWN0aW9uUmlnaHQpIC8gMiksXG4gICAgICBNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25Ub3AgKyByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pIC8gMikpKTtcbiAgICBtZS5zZXRDZW50ZXJQb2ludChyYWRpdXNSZWR1Y3Rpb25MZWZ0LCByYWRpdXNSZWR1Y3Rpb25SaWdodCwgcmFkaXVzUmVkdWN0aW9uVG9wLCByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuICB9XG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1heFJpZ2h0ID0gbWUud2lkdGggLSByaWdodE1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG4gICAgY29uc3QgbWF4TGVmdCA9IGxlZnRNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xuICAgIGNvbnN0IG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG4gICAgY29uc3QgbWF4Qm90dG9tID0gKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApIC0gYm90dG9tTW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcbiAgICBtZS54Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuICAgIG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XG4gIH1cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvIHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IG1lLmRyYXdpbmdBcmVhIC8gKG1lLm1heCAtIG1lLm1pbik7XG4gICAgaWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIChtZS5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gbWUubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKG1lLmRyYXdpbmdBcmVhIC8gKG1lLm1heCAtIG1lLm1pbikpO1xuICAgIHJldHVybiBtZS5vcHRpb25zLnJldmVyc2UgPyBtZS5tYXggLSBzY2FsZWREaXN0YW5jZSA6IG1lLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gbWUuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KG1lLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIG1lLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gbWUub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSBtZS5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUobWUsIG1lLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG1lLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCBtZS5nZXRMYWJlbHMoKS5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY3R4ID0gbWUuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IG1lLmdldExhYmVscygpLmxlbmd0aDtcbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHMobWUsIGxhYmVsQ291bnQpO1xuICAgIH1cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBtZS50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KGluZGV4IC0gMSkpO1xuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKG1lLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBmb3IgKGkgPSBtZS5nZXRMYWJlbHMoKS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dChtZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBtZS5taW4gOiBtZS5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IG1lLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge31cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY3R4ID0gbWUuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IG1lLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBtZS50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdUaXRsZSgpIHt9XG59XG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIGFuaW1hdGU6IHRydWUsXG4gIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICB9LFxuICBncmlkOiB7XG4gICAgY2lyY3VsYXI6IGZhbHNlXG4gIH0sXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHRpY2tzOiB7XG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHBhZGRpbmc6IDVcbiAgfVxufTtcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRSb3V0ZXMgPSB7XG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xufTtcblJhZGlhbExpbmVhclNjYWxlLmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgfVxufTtcblxuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG4gIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMpIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gbWUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICBfYXBwbHlCb3VuZHMobWUuX2dldExhYmVsQm91bmRzKCkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHMobWUuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG4gICAgbWUubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICBtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gbWUuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiBtZS5fZ2VuZXJhdGUoKTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIG1lLm1pbiA9IG1lLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICBtZS5tYXggPSBtZS5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IG1lLm1pbjtcbiAgICBjb25zdCBtYXggPSBtZS5tYXg7XG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG4gICAgbWUuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1lLm1pbiwgbWUubWF4LCBtZS5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhtZSwgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCkpO1xuICAgIG1lLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCBtZS5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdChtZS5fdW5pdCk7XG4gICAgbWUuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyhtZSwgdGlja3MsIG1lLl9tYWpvclVuaXQpO1xuICB9XG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG4gICAgaWYgKG1lLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IG1lLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKG1lLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gbWUuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gbWUuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICBtZS5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gbWUubWluO1xuICAgIGNvbnN0IG1heCA9IG1lLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgbWUuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCh0aW1lT3B0cy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIG1lLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSBtZS5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSBtZS5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcbiAgICBjb25zdCBsYWJlbCA9IG1lLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG4gICAgcmV0dXJuIGZvcm1hdHRlciA/IGNhbGxiYWNrKGZvcm1hdHRlciwgW2xhYmVsLCBpbmRleCwgdGlja3NdLCBtZSkgOiBsYWJlbDtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIG1lLm1pbikgLyAobWUubWF4IC0gbWUubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSBtZS5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IG1lLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IG1lLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBtZS5taW4gKyBwb3MgKiAobWUubWF4IC0gbWUubWluKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSBtZS5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKG1lLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSBtZS5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSBtZS5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCBbZXhhbXBsZVRpbWVdLCBtZS5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gbWUuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcihtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIC8gc2l6ZS53IDogbWUuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBtZS5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IG1lLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKG1lLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIChtZS5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKG1lKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gKG1lLl9jYWNoZS5kYXRhID0gbWUubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBtZS5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UobWUsIGxhYmVsc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gKG1lLl9jYWNoZS5sYWJlbHMgPSBtZS5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiBtZS5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG5UaW1lU2NhbGUuaWQgPSAndGltZSc7XG5UaW1lU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGJvdW5kczogJ2RhdGEnLFxuICBhZGFwdGVyczoge30sXG4gIHRpbWU6IHtcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHVuaXQ6IGZhbHNlLFxuICAgIHJvdW5kOiBmYWxzZSxcbiAgICBpc29XZWVrZGF5OiBmYWxzZSxcbiAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICB9LFxuICB0aWNrczoge1xuICAgIHNvdXJjZTogJ2F1dG8nLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG1lLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IG1lLl90YWJsZSA9IG1lLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgbWUuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCBtZS5taW4pO1xuICAgIG1lLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIG1lLm1heCkgLSBtZS5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBsZXQgdGltZXN0YW1wcyA9IG1lLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG1lLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSBtZS5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzID0gbWUubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IG1lLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IG1lLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUobWUuX3RhYmxlLCBkZWNpbWFsICogbWUuX3RhYmxlUmFuZ2UgKyBtZS5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuVGltZVNlcmllc1NjYWxlLmlkID0gJ3RpbWVzZXJpZXMnO1xuVGltZVNlcmllc1NjYWxlLmRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG52YXIgc2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQ2F0ZWdvcnlTY2FsZTogQ2F0ZWdvcnlTY2FsZSxcbkxpbmVhclNjYWxlOiBMaW5lYXJTY2FsZSxcbkxvZ2FyaXRobWljU2NhbGU6IExvZ2FyaXRobWljU2NhbGUsXG5SYWRpYWxMaW5lYXJTY2FsZTogUmFkaWFsTGluZWFyU2NhbGUsXG5UaW1lU2NhbGU6IFRpbWVTY2FsZSxcblRpbWVTZXJpZXNTY2FsZTogVGltZVNlcmllc1NjYWxlXG59KTtcblxuY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuXG5leHBvcnQgeyBBbmltYXRpb24sIEFuaW1hdGlvbnMsIEFyY0VsZW1lbnQsIEJhckNvbnRyb2xsZXIsIEJhckVsZW1lbnQsIEJhc2VQbGF0Zm9ybSwgQmFzaWNQbGF0Zm9ybSwgQnViYmxlQ29udHJvbGxlciwgQ2F0ZWdvcnlTY2FsZSwgQ2hhcnQsIERhdGFzZXRDb250cm9sbGVyLCBwbHVnaW5fZGVjaW1hdGlvbiBhcyBEZWNpbWF0aW9uLCBEb21QbGF0Zm9ybSwgRG91Z2hudXRDb250cm9sbGVyLCBFbGVtZW50LCBwbHVnaW5fZmlsbGVyIGFzIEZpbGxlciwgSW50ZXJhY3Rpb24sIHBsdWdpbl9sZWdlbmQgYXMgTGVnZW5kLCBMaW5lQ29udHJvbGxlciwgTGluZUVsZW1lbnQsIExpbmVhclNjYWxlLCBMb2dhcml0aG1pY1NjYWxlLCBQaWVDb250cm9sbGVyLCBQb2ludEVsZW1lbnQsIFBvbGFyQXJlYUNvbnRyb2xsZXIsIFJhZGFyQ29udHJvbGxlciwgUmFkaWFsTGluZWFyU2NhbGUsIFNjYWxlLCBTY2F0dGVyQ29udHJvbGxlciwgcGx1Z2luX3N1YnRpdGxlIGFzIFN1YlRpdGxlLCBUaWNrcywgVGltZVNjYWxlLCBUaW1lU2VyaWVzU2NhbGUsIHBsdWdpbl90aXRsZSBhcyBUaXRsZSwgcGx1Z2luX3Rvb2x0aXAgYXMgVG9vbHRpcCwgYWRhcHRlcnMgYXMgX2FkYXB0ZXJzLCBfZGV0ZWN0UGxhdGZvcm0sIGFuaW1hdG9yLCBjb250cm9sbGVycywgZWxlbWVudHMsIGxheW91dHMsIHBsdWdpbnMsIHJlZ2lzdGVyYWJsZXMsIHJlZ2lzdHJ5LCBzY2FsZXMgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},173:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(174);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(4).default\nvar update = add(\"52f15586\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzP2U1ZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBOEM7QUFDcEU7QUFDQSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQWdEO0FBQ2xFLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjE3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI1MmYxNTU4NlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xlYWZsZXQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///173\n")},174:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(26);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(175);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(176);\nvar ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(177);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\n// Module\nexports.push([module.i, "/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\"stretching\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg,\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: pan-x pan-y;\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t-ms-touch-action: pinch-zoom;\\r\\n\\t/* Fallback for FF which doesn\'t support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: none;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-tile {\\r\\n\\twill-change: opacity;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\t-webkit-transition: opacity 0.2s linear;\\r\\n\\t   -moz-transition: opacity 0.2s linear;\\r\\n\\t        transition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t    -ms-transform-origin: 0 0;\\r\\n\\t        transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\t-webkit-transition: none;\\r\\n\\t   -moz-transition: none;\\r\\n\\t        transition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:    -moz-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:    -moz-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline: 0;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-active {\\r\\n\\toutline: 2px solid orange;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont: 12px/1.5 \\"Helvetica Neue\\", Arial, Helvetica, sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px \'Lucida Console\', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.7);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-control-attribution,\\r\\n.leaflet-container .leaflet-control-scale {\\r\\n\\tfont-size: 11px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\tfont-size: 11px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 19px;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 18px 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\r\\n\\t-webkit-transform: rotate(45deg);\\r\\n\\t   -moz-transform: rotate(45deg);\\r\\n\\t    -ms-transform: rotate(45deg);\\r\\n\\t        transform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tpadding: 4px 4px 0 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 18px;\\r\\n\\theight: 14px;\\r\\n\\tfont: 16px/14px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #c3c3c3;\\r\\n\\ttext-decoration: none;\\r\\n\\tfont-weight: bold;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover {\\r\\n\\tcolor: #999;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\tzoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip-container {\\r\\n\\tmargin-top: -1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-clickable {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\"\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzRmODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRixzQ0FBc0MsbUJBQU8sQ0FBQyxFQUF5QztBQUN2RixvQ0FBb0MsbUJBQU8sQ0FBQyxHQUFxQjtBQUNqRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUF3QjtBQUNwRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFTLHNRQUFzUSx5QkFBeUIsY0FBYyxhQUFhLE9BQU8sd0JBQXdCLHVCQUF1QixPQUFPLHVFQUF1RSxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsT0FBTyxxRkFBcUYsOEJBQThCLEtBQUssMkhBQTJILGlEQUFpRCxPQUFPLHlIQUF5SCxvQkFBb0IscUJBQXFCLG9DQUFvQyxPQUFPLHFEQUFxRCxxQkFBcUIsT0FBTyxtZEFBbWQsaUNBQWlDLGtDQUFrQyxPQUFPLCtDQUErQyxvQ0FBb0MsZ0NBQWdDLE9BQU8sMkNBQTJDLG1DQUFtQyxxRkFBcUYsK0JBQStCLEtBQUssOERBQThELDZCQUE2Qix5QkFBeUIsS0FBSyx3QkFBd0IsK0NBQStDLEtBQUssMEJBQTBCLDJEQUEyRCxLQUFLLG1CQUFtQixzQkFBc0IseUJBQXlCLE9BQU8sMEJBQTBCLDBCQUEwQixPQUFPLHVCQUF1QixlQUFlLGdCQUFnQixrQ0FBa0Msa0NBQWtDLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTywrQkFBK0IsY0FBYyxFQUFFLCtCQUErQixjQUFjLEVBQUUsMkJBQTJCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLDJCQUEyQixjQUFjLEVBQUUsNkJBQTZCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsOEJBQThCLGNBQWMsRUFBRSw0QkFBNEIsaUJB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Z0NBQWdDLE9BQU8sMkJBQTJCLHdCQUF3QixLQUFLLDRCQUE0Qix1QkFBdUIsS0FBSyxvRUFBb0UsZUFBZSx1QkFBdUIsT0FBTyxrQ0FBa0MsZUFBZSwwQkFBMEIsOEJBQThCLE9BQU8sbUNBQW1DLGNBQWMseUJBQXlCLCtCQUErQixPQUFPO0FBQzVwZjtBQUNBIiwiZmlsZSI6IjE3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gcmVxdWlyZShcIi4vaW1hZ2VzL2xheWVycy5wbmdcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSByZXF1aXJlKFwiLi9pbWFnZXMvbGF5ZXJzLTJ4LnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyA9IHJlcXVpcmUoXCIuL2ltYWdlcy9tYXJrZXItaWNvbi5wbmdcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogcmVxdWlyZWQgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSxcXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyxcXHJcXG4ubGVhZmxldC1wYW5lID4gY2FudmFzLFxcclxcbi5sZWFmbGV0LXpvb20tYm94LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgIC13ZWJraXQtdXNlci1kcmFnOiBub25lO1xcclxcblxcdH1cXHJcXG4vKiBQcmV2ZW50cyBJRTExIGZyb20gaGlnaGxpZ2h0aW5nIHRpbGVzIGluIGJsdWUgKi9cXHJcXG4ubGVhZmxldC10aWxlOjpzZWxlY3Rpb24ge1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4vKiBTYWZhcmkgcmVuZGVycyBub24tcmV0aW5hIHRpbGUgb24gcmV0aW5hIGJldHRlciB3aXRoIHRoaXMsIGJ1dCBDaHJvbWUgaXMgd29yc2UgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0aW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LW9wdGltaXplLWNvbnRyYXN0O1xcclxcblxcdH1cXHJcXG4vKiBoYWNrIHRoYXQgcHJldmVudHMgaHcgbGF5ZXJzIFxcXCJzdHJldGNoaW5nXFxcIiB3aGVuIGxvYWRpbmcgbmV3IHRpbGVzICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogMTYwMHB4O1xcclxcblxcdGhlaWdodDogMTYwMHB4O1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIHN2ZzogcmVzZXQgc3ZnIG1heC13aWR0aCBkZWNsZXJhdGlvbiBzaGlwcGVkIGluIEpvb21sYSEgKGpvb21sYS5vcmcpIDMueCAqL1xcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBpbWc6IG1hcCBpcyBicm9rZW4gaW4gRkYgaWYgeW91IGhhdmUgbWF4LXdpZHRoOiAxMDAlIG9uIHRpbGVzICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtc2hhZG93LXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBpbWcubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0bWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0bWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwYW4teCBwYW4teTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwaW5jaC16b29tO1xcclxcblxcdC8qIEZhbGxiYWNrIGZvciBGRiB3aGljaCBkb2Vzbid0IHN1cHBvcnQgcGluY2gtem9vbSAqL1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYSB7XFxyXFxuXFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDUxLCAxODEsIDIyOSwgMC40KTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0ZmlsdGVyOiBpbmhlcml0O1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZS1sb2FkZWQge1xcclxcblxcdHZpc2liaWxpdHk6IGluaGVyaXQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHR3aWR0aDogMDtcXHJcXG5cXHRoZWlnaHQ6IDA7XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0fVxcclxcbi8qIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4ODMxOSAqL1xcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcge1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXBhbmUgICAgICAgICB7IHotaW5kZXg6IDQwMDsgfVxcclxcblxcclxcbi5sZWFmbGV0LXRpbGUtcGFuZSAgICB7IHotaW5kZXg6IDIwMDsgfVxcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSB7IHotaW5kZXg6IDQwMDsgfVxcclxcbi5sZWFmbGV0LXNoYWRvdy1wYW5lICB7IHotaW5kZXg6IDUwMDsgfVxcclxcbi5sZWFmbGV0LW1hcmtlci1wYW5lICB7IHotaW5kZXg6IDYwMDsgfVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcGFuZSAgIHsgei1pbmRleDogNjUwOyB9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSAgIHsgei1pbmRleDogNzAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgY2FudmFzIHsgei1pbmRleDogMTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgc3ZnICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdm1sLXNoYXBlIHtcXHJcXG5cXHR3aWR0aDogMXB4O1xcclxcblxcdGhlaWdodDogMXB4O1xcclxcblxcdH1cXHJcXG4ubHZtbCB7XFxyXFxuXFx0YmVoYXZpb3I6IHVybCgjZGVmYXVsdCNWTUwpO1xcclxcblxcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGNvbnRyb2wgcG9zaXRpb25pbmcgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0ei1pbmRleDogODAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3AsXFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ei1pbmRleDogMTAwMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiBsZWZ0O1xcclxcblxcdGNsZWFyOiBib3RoO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRmbG9hdDogcmlnaHQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiB6b29tIGFuZCBmYWRlIGFuaW1hdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LW1hcC1wYW5lIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246ICAgIC1tb3otdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246ICAgICAgICAgdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtcGFuLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWhpZGUge1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY3Vyc29ycyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWdyYWIge1xcclxcblxcdGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIsXFxyXFxuLmxlYWZsZXQtY3Jvc3NoYWlyIC5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IGNyb3NzaGFpcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSxcXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRjdXJzb3I6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LWdyYWIsXFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiAubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlIHtcXHJcXG5cXHRjdXJzb3I6IG1vdmU7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiYmluZztcXHJcXG5cXHRjdXJzb3I6ICAgICAgICAgZ3JhYmJpbmc7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIG1hcmtlciAmIG92ZXJsYXlzIGludGVyYWN0aXZpdHkgKi9cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aCxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lciB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG5zdmcubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlIHBhdGgge1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB2aXN1YWwgdHdlYWtzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZGRkO1xcclxcblxcdG91dGxpbmU6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHRjb2xvcjogIzAwNzhBODtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1hY3RpdmUge1xcclxcblxcdG91dGxpbmU6IDJweCBzb2xpZCBvcmFuZ2U7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHRib3JkZXI6IDJweCBkb3R0ZWQgIzM4ZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGdlbmVyYWwgdHlwb2dyYXBoeSAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0Zm9udDogMTJweC8xLjUgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0b29sYmFyIHN0eWxlcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC42NSk7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYSxcXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYztcXHJcXG5cXHR3aWR0aDogMjZweDtcXHJcXG5cXHRoZWlnaHQ6IDI2cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDI2cHg7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRjb2xvcjogYmxhY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDUwJTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYS5sZWFmbGV0LWRpc2FibGVkIHtcXHJcXG5cXHRjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHRjb2xvcjogI2JiYjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGEge1xcclxcblxcdHdpZHRoOiAzMHB4O1xcclxcblxcdGhlaWdodDogMzBweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMzBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogem9vbSBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLWluLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQge1xcclxcblxcdGZvbnQ6IGJvbGQgMThweCAnTHVjaWRhIENvbnNvbGUnLCBNb25hY28sIG1vbm9zcGFjZTtcXHJcXG5cXHR0ZXh0LWluZGVudDogMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLXpvb20taW4sIC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQgIHtcXHJcXG5cXHRmb250LXNpemU6IDIycHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGxheWVycyBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMge1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDVweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKTtcXHJcXG5cXHR3aWR0aDogMzZweDtcXHJcXG5cXHRoZWlnaHQ6IDM2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIik7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiAyNnB4IDI2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0d2lkdGg6IDQ0cHg7XFxyXFxuXFx0aGVpZ2h0OiA0NHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0LFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0ZGlzcGxheTogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCB7XFxyXFxuXFx0cGFkZGluZzogNnB4IDEwcHggNnB4IDZweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXIge1xcclxcblxcdG92ZXJmbG93LXk6IHNjcm9sbDtcXHJcXG5cXHRvdmVyZmxvdy14OiBoaWRkZW47XFxyXFxuXFx0cGFkZGluZy1yaWdodDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogMnB4O1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR0b3A6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWwge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3Ige1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRtYXJnaW46IDVweCAtMTBweCA1cHggLTZweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGVmYXVsdCBpY29uIFVSTHMgKi9cXHJcXG4ubGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyArIFwiKTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogYXR0cmlidXRpb24gYW5kIHNjYWxlIGNvbnRyb2xzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcclxcblxcdG1hcmdpbjogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdHBhZGRpbmc6IDAgNXB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGEge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmhvdmVyIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdGZvbnQtc2l6ZTogMTFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLXRvcDogbm9uZTtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS4xO1xcclxcblxcdHBhZGRpbmc6IDJweCA1cHggMXB4O1xcclxcblxcdGZvbnQtc2l6ZTogMTFweDtcXHJcXG5cXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXHJcXG5cXHRib3JkZXItdG9wOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdG1hcmdpbi10b3A6IC0ycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpIHtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAycHggc29saWQgIzc3NztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJveC1zaGFkb3c6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgcmdiYSgwLDAsMCwwLjIpO1xcclxcblxcdGJhY2tncm91bmQtY2xpcDogcGFkZGluZy1ib3g7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHBvcHVwICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyIHtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAxMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50IHtcXHJcXG5cXHRtYXJnaW46IDEzcHggMTlweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS40O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50IHAge1xcclxcblxcdG1hcmdpbjogMThweCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogNDBweDtcXHJcXG5cXHRoZWlnaHQ6IDIwcHg7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTIwcHg7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMTdweDtcXHJcXG5cXHRoZWlnaHQ6IDE3cHg7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcclxcblxcdG1hcmdpbjogLTEwcHggYXV0byAwO1xcclxcblxcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB3aGl0ZTtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRib3gtc2hhZG93OiAwIDNweCAxNHB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b24ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0cGFkZGluZzogNHB4IDRweCAwIDA7XFxyXFxuXFx0Ym9yZGVyOiBub25lO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHR3aWR0aDogMThweDtcXHJcXG5cXHRoZWlnaHQ6IDE0cHg7XFxyXFxuXFx0Zm9udDogMTZweC8xNHB4IFRhaG9tYSwgVmVyZGFuYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHRjb2xvcjogI2MzYzNjMztcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmhvdmVyIHtcXHJcXG5cXHRjb2xvcjogIzk5OTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtc2Nyb2xsZWQge1xcclxcblxcdG92ZXJmbG93OiBhdXRvO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHpvb206IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDI0cHg7XFxyXFxuXFx0bWFyZ2luOiAwIGF1dG87XFxyXFxuXFxyXFxuXFx0LW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KVxcXCI7XFxyXFxuXFx0ZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdG1hcmdpbi10b3A6IC0xcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtem9vbSxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBkaXYgaWNvbiAqL1xcclxcblxcclxcbi5sZWFmbGV0LWRpdi1pY29uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM2NjY7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIFRvb2x0aXAgKi9cXHJcXG4vKiBCYXNlIHN0eWxlcyBmb3IgdGhlIGVsZW1lbnQgdGhhdCBoYXMgYSB0b29sdGlwICovXFxyXFxuLmxlYWZsZXQtdG9vbHRpcCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBhZGRpbmc6IDZweDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogM3B4O1xcclxcblxcdGNvbG9yOiAjMjIyO1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJvcmRlcjogNnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdGNvbnRlbnQ6IFxcXCJcXFwiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEaXJlY3Rpb25zICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b20ge1xcclxcblxcdG1hcmdpbi10b3A6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3Age1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXRvcC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTEycHg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0dG9wOiA1MCU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItbGVmdC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1yaWdodC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///174\n')},175:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers.png?416d91365b44e4b4f4777663e6f009f3");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nP2YwYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsZ0RBQWdEIiwiZmlsZSI6IjE3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMucG5nPzQxNmQ5MTM2NWI0NGU0YjRmNDc3NzY2M2U2ZjAwOWYzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///175\n')},176:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers-2x.png?8f2c4d11474275fbc1614b9098334eae");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nP2UxMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsbURBQW1EIiwiZmlsZSI6IjE3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMtMngucG5nPzhmMmM0ZDExNDc0Mjc1ZmJjMTYxNGI5MDk4MzM0ZWFlXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n')},177:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "marker-icon.png?2b3e1faf89f94a4835397e7a43b4f77d");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmc/NWM4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLG9GQUF1QixxREFBcUQiLCJmaWxlIjoiMTc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIm1hcmtlci1pY29uLnBuZz8yYjNlMWZhZjg5Zjk0YTQ4MzUzOTdlN2E0M2I0Zjc3ZFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///177\n')},197:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);\n/*!\n  * chartjs-adapter-moment v1.0.0\n  * https://www.chartjs.org\n  * (c) 2021 chartjs-adapter-moment Contributors\n  * Released under the MIT license\n  */\n\n\nconst FORMATS = {\n  datetime: 'MMM D, YYYY, h:mm:ss a',\n  millisecond: 'h:mm:ss.SSS a',\n  second: 'h:mm:ss a',\n  minute: 'h:mm a',\n  hour: 'hA',\n  day: 'MMM D',\n  week: 'll',\n  month: 'MMM YYYY',\n  quarter: '[Q]Q - YYYY',\n  year: 'YYYY'\n};\n\nchart_js__WEBPACK_IMPORTED_MODULE_1__[/* _adapters */ \"b\"]._date.override(typeof moment__WEBPACK_IMPORTED_MODULE_0___default.a === 'function' ? {\n  _id: 'moment',\n  // DEBUG ONLY\n  formats: function () {\n    return FORMATS;\n  },\n  parse: function (value, format) {\n    if (typeof value === 'string' && typeof format === 'string') {\n      value = moment__WEBPACK_IMPORTED_MODULE_0___default()(value, format);\n    } else if (!(value instanceof moment__WEBPACK_IMPORTED_MODULE_0___default.a)) {\n      value = moment__WEBPACK_IMPORTED_MODULE_0___default()(value);\n    }\n\n    return value.isValid() ? value.valueOf() : null;\n  },\n  format: function (time, format) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(time).format(format);\n  },\n  add: function (time, amount, unit) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(time).add(amount, unit).valueOf();\n  },\n  diff: function (max, min, unit) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(max).diff(moment__WEBPACK_IMPORTED_MODULE_0___default()(min), unit);\n  },\n  startOf: function (time, unit, weekday) {\n    time = moment__WEBPACK_IMPORTED_MODULE_0___default()(time);\n\n    if (unit === 'isoWeek') {\n      weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));\n      return time.isoWeekday(weekday).startOf('day').valueOf();\n    }\n\n    return time.startOf(unit).valueOf();\n  },\n  endOf: function (time, unit) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(time).endOf(unit).valueOf();\n  }\n} : {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1hZGFwdGVyLW1vbWVudC9kaXN0L2NoYXJ0anMtYWRhcHRlci1tb21lbnQuZXNtLmpzPzFjODYiXSwibmFtZXMiOlsiRk9STUFUUyIsImRhdGV0aW1lIiwibWlsbGlzZWNvbmQiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5Iiwid2VlayIsIm1vbnRoIiwicXVhcnRlciIsInllYXIiLCJfYWRhcHRlcnMiLCJfZGF0ZSIsIm92ZXJyaWRlIiwibW9tZW50IiwiX2lkIiwiZm9ybWF0cyIsInBhcnNlIiwidmFsdWUiLCJmb3JtYXQiLCJpc1ZhbGlkIiwidmFsdWVPZiIsInRpbWUiLCJhZGQiLCJhbW91bnQiLCJ1bml0IiwiZGlmZiIsIm1heCIsIm1pbiIsInN0YXJ0T2YiLCJ3ZWVrZGF5IiwiTWF0aCIsInRydW5jIiwiaXNvV2Vla2RheSIsImVuZE9mIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTUEsT0FBTyxHQUFHO0VBQ2RDLFFBQVEsRUFBRSx3QkFESTtFQUVkQyxXQUFXLEVBQUUsZUFGQztFQUdkQyxNQUFNLEVBQUUsV0FITTtFQUlkQyxNQUFNLEVBQUUsUUFKTTtFQUtkQyxJQUFJLEVBQUUsSUFMUTtFQU1kQyxHQUFHLEVBQUUsT0FOUztFQU9kQyxJQUFJLEVBQUUsSUFQUTtFQVFkQyxLQUFLLEVBQUUsVUFSTztFQVNkQyxPQUFPLEVBQUUsYUFUSztFQVVkQyxJQUFJLEVBQUU7QUFWUSxDQUFoQjs7QUFhQUMsMERBQVMsQ0FBQ0MsS0FBVixDQUFnQkMsUUFBaEIsQ0FBeUIsT0FBT0MsNkNBQVAsS0FBa0IsVUFBbEIsR0FBK0I7RUFDdERDLEdBQUcsRUFBRSxRQURpRDtFQUN2QztFQUVmQyxPQUFPLEVBQUUsWUFBVztJQUNsQixPQUFPaEIsT0FBUDtFQUNELENBTHFEO0VBT3REaUIsS0FBSyxFQUFFLFVBQVNDLEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCO0lBQzdCLElBQUksT0FBT0QsS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPQyxNQUFQLEtBQWtCLFFBQW5ELEVBQTZEO01BQzNERCxLQUFLLEdBQUdKLDZDQUFNLENBQUNJLEtBQUQsRUFBUUMsTUFBUixDQUFkO0lBQ0QsQ0FGRCxNQUVPLElBQUksRUFBRUQsS0FBSyxZQUFZSiw2Q0FBbkIsQ0FBSixFQUFnQztNQUNyQ0ksS0FBSyxHQUFHSiw2Q0FBTSxDQUFDSSxLQUFELENBQWQ7SUFDRDs7SUFDRCxPQUFPQSxLQUFLLENBQUNFLE9BQU4sS0FBa0JGLEtBQUssQ0FBQ0csT0FBTixFQUFsQixHQUFvQyxJQUEzQztFQUNELENBZHFEO0VBZ0J0REYsTUFBTSxFQUFFLFVBQVNHLElBQVQsRUFBZUgsTUFBZixFQUF1QjtJQUM3QixPQUFPTCw2Q0FBTSxDQUFDUSxJQUFELENBQU4sQ0FBYUgsTUFBYixDQUFvQkEsTUFBcEIsQ0FBUDtFQUNELENBbEJxRDtFQW9CdERJLEdBQUcsRUFBRSxVQUFTRCxJQUFULEVBQWVFLE1BQWYsRUFBdUJDLElBQXZCLEVBQTZCO0lBQ2hDLE9BQU9YLDZDQUFNLENBQUNRLElBQUQsQ0FBTixDQUFhQyxHQUFiLENBQWlCQyxNQUFqQixFQUF5QkMsSUFBekIsRUFBK0JKLE9BQS9CLEVBQVA7RUFDRCxDQXRCcUQ7RUF3QnRESyxJQUFJLEVBQUUsVUFBU0MsR0FBVCxFQUFjQyxHQUFkLEVBQW1CSCxJQUFuQixFQUF5QjtJQUM3QixPQUFPWCw2Q0FBTSxDQUFDYSxHQUFELENBQU4sQ0FBWUQsSUFBWixDQUFpQlosNkNBQU0sQ0FBQ2MsR0FBRCxDQUF2QixFQUE4QkgsSUFBOUIsQ0FBUDtFQUNELENBMUJxRDtFQTRCdERJLE9BQU8sRUFBRSxVQUFTUCxJQUFULEVBQWVHLElBQWYsRUFBcUJLLE9BQXJCLEVBQThCO0lBQ3JDUixJQUFJLEdBQUdSLDZDQUFNLENBQUNRLElBQUQsQ0FBYjs7SUFDQSxJQUFJRyxJQUFJLEtBQUssU0FBYixFQUF3QjtNQUN0QkssT0FBTyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDSCxHQUFMLENBQVNHLElBQUksQ0FBQ0osR0FBTCxDQUFTLENBQVQsRUFBWUcsT0FBWixDQUFULEVBQStCLENBQS9CLENBQVgsQ0FBVjtNQUNBLE9BQU9SLElBQUksQ0FBQ1csVUFBTCxDQUFnQkgsT0FBaEIsRUFBeUJELE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDUixPQUF4QyxFQUFQO0lBQ0Q7O0lBQ0QsT0FBT0MsSUFBSSxDQUFDTyxPQUFMLENBQWFKLElBQWIsRUFBbUJKLE9BQW5CLEVBQVA7RUFDRCxDQW5DcUQ7RUFxQ3REYSxLQUFLLEVBQUUsVUFBU1osSUFBVCxFQUFlRyxJQUFmLEVBQXFCO0lBQzFCLE9BQU9YLDZDQUFNLENBQUNRLElBQUQsQ0FBTixDQUFhWSxLQUFiLENBQW1CVCxJQUFuQixFQUF5QkosT0FBekIsRUFBUDtFQUNEO0FBdkNxRCxDQUEvQixHQXdDckIsRUF4Q0oiLCJmaWxlIjoiMTk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogY2hhcnRqcy1hZGFwdGVyLW1vbWVudCB2MS4wLjBcbiAgKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICAqIChjKSAyMDIxIGNoYXJ0anMtYWRhcHRlci1tb21lbnQgQ29udHJpYnV0b3JzXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gICovXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBfYWRhcHRlcnMgfSBmcm9tICdjaGFydC5qcyc7XG5cbmNvbnN0IEZPUk1BVFMgPSB7XG4gIGRhdGV0aW1lOiAnTU1NIEQsIFlZWVksIGg6bW06c3MgYScsXG4gIG1pbGxpc2Vjb25kOiAnaDptbTpzcy5TU1MgYScsXG4gIHNlY29uZDogJ2g6bW06c3MgYScsXG4gIG1pbnV0ZTogJ2g6bW0gYScsXG4gIGhvdXI6ICdoQScsXG4gIGRheTogJ01NTSBEJyxcbiAgd2VlazogJ2xsJyxcbiAgbW9udGg6ICdNTU0gWVlZWScsXG4gIHF1YXJ0ZXI6ICdbUV1RIC0gWVlZWScsXG4gIHllYXI6ICdZWVlZJ1xufTtcblxuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XG4gIF9pZDogJ21vbWVudCcsIC8vIERFQlVHIE9OTFlcblxuICBmb3JtYXRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRk9STUFUUztcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcbiAgICB9IGVsc2UgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG4gICAgICB2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5pc1ZhbGlkKCkgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuICAgIHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xuICB9LFxuXG4gIGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbWVudChtYXgpLmRpZmYobW9tZW50KG1pbiksIHVuaXQpO1xuICB9LFxuXG4gIHN0YXJ0T2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICB0aW1lID0gbW9tZW50KHRpbWUpO1xuICAgIGlmICh1bml0ID09PSAnaXNvV2VlaycpIHtcbiAgICAgIHdlZWtkYXkgPSBNYXRoLnRydW5jKE1hdGgubWluKE1hdGgubWF4KDAsIHdlZWtkYXkpLCA2KSk7XG4gICAgICByZXR1cm4gdGltZS5pc29XZWVrZGF5KHdlZWtkYXkpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWUuc3RhcnRPZih1bml0KS52YWx1ZU9mKCk7XG4gIH0sXG5cbiAgZW5kT2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tZW50KHRpbWUpLmVuZE9mKHVuaXQpLnZhbHVlT2YoKTtcbiAgfVxufSA6IHt9KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///197\n")},2:function(module,exports,__webpack_require__){eval("/* @preserve\n * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com\n * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n(function (global, factory) {\n   true ? factory(exports) : undefined;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.6.0\";\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  var freeze = Object.freeze;\n\n  Object.freeze = function (obj) {\n    return obj;\n  }; // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n\n\n  function extend(dest) {\n    var i, j, len, src;\n\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n\n    return dest;\n  } // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n\n  var create = Object.create || function () {\n    function F() {}\n\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }(); // @function bind(fn: Function, ): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n\n\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  } // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n\n\n  var lastId = 0; // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  function stamp(obj) {\n    /*eslint-disable */\n    obj._leaflet_id = obj._leaflet_id || ++lastId;\n    return obj._leaflet_id;\n    /* eslint-enable */\n  } // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n\n\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n\n    return wrapperFn;\n  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n\n\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n        min = range[0],\n        d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  } // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n\n\n  function falseFn() {\n    return false;\n  } // @function formatNum(num: Number, digits?: Number): Number\n  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.\n\n\n  function formatNum(num, digits) {\n    var pow = Math.pow(10, digits === undefined ? 6 : digits);\n    return Math.round(num * pow) / pow;\n  } // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n\n\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  } // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n\n\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  } // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n\n\n  function setOptions(obj, options) {\n    if (!obj.hasOwnProperty('options')) {\n      obj.options = obj.options ? create(obj.options) : {};\n    }\n\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n\n    return obj.options;\n  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  var templateRe = /\\{ *([\\w_-]+) *\\}/g; // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values  they will be evaluated passing `data` as an argument.\n\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return value;\n    });\n  } // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }; // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n\n\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n\n  var lastTime = 0; // fallback for IE 7-8\n\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n        timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n\n\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  } // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n\n\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n\n  var Util = (Object.freeze || Object)({\n    freeze: freeze,\n    extend: extend,\n    create: create,\n    bind: bind,\n    lastId: lastId,\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  }); // @class Class\n  // @aka L.Class\n  // @section\n  // @uninheritable\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      } // call all constructor hooks\n\n\n      this.callInitHooks();\n    };\n\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto; // inherit parent's statics\n\n    for (var i in this) {\n      if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    } // mix static properties into the class\n\n\n    if (props.statics) {\n      extend(NewClass, props.statics);\n      delete props.statics;\n    } // mix includes into the prototype\n\n\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n      delete props.includes;\n    } // merge options\n\n\n    if (proto.options) {\n      props.options = extend(create(proto.options), props.options);\n    } // mix given properties into the prototype\n\n\n    extend(proto, props);\n    proto._initHooks = []; // add method for calling all hooks\n\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n\n      this._initHooksCalled = true;\n\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n\n    return NewClass;\n  }; // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n\n\n  Class.include = function (props) {\n    extend(this.prototype, props);\n    return this;\n  }; // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n\n\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  }; // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n\n\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n\n    this.prototype._initHooks.push(init);\n\n    return this;\n  };\n\n  function checkDeprecatedMixinEvents(includes) {\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n\n    includes = isArray(includes) ? includes : [includes];\n\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!types) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._off(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context) {\n      this._events = this._events || {};\n      /* get/init listeners for type */\n\n      var typeListeners = this._events[type];\n\n      if (!typeListeners) {\n        typeListeners = [];\n        this._events[type] = typeListeners;\n      }\n\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n\n      var newListener = {\n        fn: fn,\n        ctx: context\n      },\n          listeners = typeListeners; // check if fn already there\n\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return;\n        }\n      }\n\n      listeners.push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n\n      if (!this._events) {\n        return;\n      }\n\n      listeners = this._events[type];\n\n      if (!listeners) {\n        return;\n      }\n\n      if (!fn) {\n        // Set all removed listeners to noop so they are not called if remove happens in fire\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].fn = falseFn;\n        } // clear all listeners for a type if function isn't specified\n\n\n        delete this._events[type];\n        return;\n      }\n\n      if (context === this) {\n        context = undefined;\n      }\n\n      if (listeners) {\n        // find fn and remove it\n        for (i = 0, len = listeners.length; i < len; i++) {\n          var l = listeners[i];\n\n          if (l.ctx !== context) {\n            continue;\n          }\n\n          if (l.fn === fn) {\n            // set the removed listener to noop so that's not called if remove happens in fire\n            l.fn = falseFn;\n\n            if (this._firingCount) {\n              /* copy array in case events are being fired */\n              this._events[type] = listeners = listeners.slice();\n            }\n\n            listeners.splice(i, 1);\n            return;\n          }\n        }\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide an data\n    // object  the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n\n      if (this._events) {\n        var listeners = this._events[type];\n\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            l.fn.call(l.ctx || this, event);\n          }\n\n          this._firingCount--;\n        }\n      }\n\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n\n      return this;\n    },\n    // @method listens(type: String): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    listens: function (type, propagate) {\n      var listeners = this._events && this._events[type];\n\n      if (listeners && listeners.length) {\n        return true;\n      }\n\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, propagate)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    // @method once(): this\n    // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      if (typeof types === 'object') {\n        for (var type in types) {\n          this.once(type, types[type], fn);\n        }\n\n        return this;\n      }\n\n      var handler = bind(function () {\n        this.off(types, fn, context).off(types, handler, context);\n      }, this); // add a listener that's executed once and removed after that\n\n      return this.on(types, fn, context).on(types, handler, context);\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  }; // aliases; we should ditch those eventually\n  // @method addEventListener(): this\n  // Alias to [`on()`](#evented-on)\n\n  Events.addEventListener = Events.on; // @method removeEventListener(): this\n  // Alias to [`off()`](#evented-off)\n  // @method clearAllEventListeners(): this\n  // Alias to [`off()`](#evented-off)\n\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(): this\n  // Alias to [`once()`](#evented-once)\n\n  Events.addOneTimeEventListener = Events.once; // @method fireEvent(): this\n  // Alias to [`fire()`](#evented-fire)\n\n  Events.fireEvent = Events.fire; // @method hasEventListeners(): Boolean\n  // Alias to [`listens()`](#evented-listens)\n\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n    this.y = round ? Math.round(y) : y;\n  }\n\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n          y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  }; // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n\n    if (x === undefined || x === null) {\n      return x;\n    }\n\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n\n    return new Point(x, y, round);\n  }\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n\n    var points = b ? [a, b] : a;\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n    extend: function (point) {\n      // (Point)\n      point = toPoint(point); // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n\n      if (!this.min && !this.max) {\n        this.min = point.clone();\n        this.max = point.clone();\n      } else {\n        this.min.x = Math.min(point.x, this.min.x);\n        this.max.x = Math.max(point.x, this.max.x);\n        this.min.y = Math.min(point.y, this.min.y);\n        this.max.y = Math.max(point.y, this.max.y);\n      }\n\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return new Point(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return new Point(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xIntersects = max2.x >= min.x && min2.x <= max.x,\n          yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xOverlaps = max2.x > min.x && min2.x < max.x,\n          yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    isValid: function () {\n      return !!(this.min && this.max);\n    }\n  }; // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n\n    return new Bounds(a, b);\n  }\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  }; // TODO International date line?\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n\n    return new LatLngBounds(a, b);\n  }\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    } // @property lat: Number\n    // Latitude in degrees\n\n\n    this.lat = +lat; // @property lng: Number\n    // Longitude in degrees\n\n    this.lng = +lng; // @property alt: Number\n    // Altitude in meters (optional)\n\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n\n      return null;\n    }\n\n    if (a === undefined || a === null) {\n      return a;\n    }\n\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n\n    if (b === undefined) {\n      return null;\n    }\n\n    return new LatLng(a, b, c);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leafet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n          scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n          untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n\n      var b = this.projection.bounds,\n          s = this.scale(zoom),\n          min = this.transformation.transform(b.min, s),\n          max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n          alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n          newCenter = this.wrapLatLng(center),\n          latShift = center.lat - newCenter.lat,\n          lngShift = center.lng - newCenter.lng;\n\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n\n      var sw = bounds.getSouthWest(),\n          ne = bounds.getNorthEast(),\n          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see http://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection  the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          max = this.MAX_LATITUDE,\n          lat = Math.max(Math.min(max, latlng.lat), -max),\n          sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  }); // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  } // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n\n\n  function pointsToPath(rings, closed) {\n    var str = '',\n        i,\n        j,\n        len,\n        len2,\n        points,\n        p;\n\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      } // closes the ring for polygons; \"x\" is VML syntax\n\n\n      str += closed ? svg ? 'z' : 'x' : '';\n    } // SVG complains about empty path strings\n\n\n    return str || 'M0 0';\n  }\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n\n  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n\n  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n\n  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.\n\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n\n  var webkit = userAgentContains('webkit'); // @property android: Boolean\n  // `true` for any browser running on an Android platform.\n\n  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.\n\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)\n\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser\n\n  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.\n\n  var chrome = userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.\n\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom'); // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n\n  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform\n\n  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n\n  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n\n  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n\n  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n\n  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n\n  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n\n  var pointer = !webkit && !!(window.PointerEvent || msPointer); // @property touch: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // This does not necessarily mean that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n\n  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n\n  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n\n  var mobileGecko = mobile && gecko; // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {// Errors can safely be ignored since this is only a browser support test.\n    }\n\n    return supportsPassiveOption;\n  }; // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n\n\n  var canvas = function () {\n    return !!document.createElement('canvas').getContext;\n  }(); // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n\n\n  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n\n  var vml = !svg && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n\n  var Browser = (Object.freeze || Object)({\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas,\n    svg: svg,\n    vml: vml\n  });\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];\n  var _pointers = {};\n  var _pointerDocListener = false; // DomEvent.DoubleTap needs to know about this\n\n  var _pointersCount = 0; // Provides a touch events wrapper for (ms)pointer events.\n  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler, id) {\n    if (type === 'touchstart') {\n      _addPointerStart(obj, handler, id);\n    } else if (type === 'touchmove') {\n      _addPointerMove(obj, handler, id);\n    } else if (type === 'touchend') {\n      _addPointerEnd(obj, handler, id);\n    }\n\n    return this;\n  }\n\n  function removePointerListener(obj, type, id) {\n    var handler = obj['_leaflet_' + type + id];\n\n    if (type === 'touchstart') {\n      obj.removeEventListener(POINTER_DOWN, handler, false);\n    } else if (type === 'touchmove') {\n      obj.removeEventListener(POINTER_MOVE, handler, false);\n    } else if (type === 'touchend') {\n      obj.removeEventListener(POINTER_UP, handler, false);\n      obj.removeEventListener(POINTER_CANCEL, handler, false);\n    }\n\n    return this;\n  }\n\n  function _addPointerStart(obj, handler, id) {\n    var onDown = bind(function (e) {\n      if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n        // In IE11, some touch events needs to fire for form controls, or\n        // the controls will stop working. We keep a whitelist of tag names that\n        // need these events. For other target tags, we prevent default on the event.\n        if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {\n          preventDefault(e);\n        } else {\n          return;\n        }\n      }\n\n      _handlePointer(e, handler);\n    });\n    obj['_leaflet_touchstart' + id] = onDown;\n    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation\n\n    if (!_pointerDocListener) {\n      // we listen documentElement as any drags that end by moving the touch off the screen get fired there\n      document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n    _pointersCount++;\n  }\n\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n    _pointersCount--;\n  }\n\n  function _handlePointer(e, handler) {\n    e.touches = [];\n\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n\n    e.changedTouches = [e];\n    handler(e);\n  }\n\n  function _addPointerMove(obj, handler, id) {\n    var onMove = function (e) {\n      // don't fire touch moves when mouse isn't down\n      if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {\n        return;\n      }\n\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchmove' + id] = onMove;\n    obj.addEventListener(POINTER_MOVE, onMove, false);\n  }\n\n  function _addPointerEnd(obj, handler, id) {\n    var onUp = function (e) {\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchend' + id] = onUp;\n    obj.addEventListener(POINTER_UP, onUp, false);\n    obj.addEventListener(POINTER_CANCEL, onUp, false);\n  }\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   */\n\n\n  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';\n\n  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';\n\n  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs\n\n  function addDoubleTapListener(obj, handler, id) {\n    var last,\n        touch$$1,\n        doubleTap = false,\n        delay = 250;\n\n    function onTouchStart(e) {\n      var count;\n\n      if (pointer) {\n        if (!edge || e.pointerType === 'mouse') {\n          return;\n        }\n\n        count = _pointersCount;\n      } else {\n        count = e.touches.length;\n      }\n\n      if (count > 1) {\n        return;\n      }\n\n      var now = Date.now(),\n          delta = now - (last || now);\n      touch$$1 = e.touches ? e.touches[0] : e;\n      doubleTap = delta > 0 && delta <= delay;\n      last = now;\n    }\n\n    function onTouchEnd(e) {\n      if (doubleTap && !touch$$1.cancelBubble) {\n        if (pointer) {\n          if (!edge || e.pointerType === 'mouse') {\n            return;\n          } // work around .type being readonly with MSPointer* events\n\n\n          var newTouch = {},\n              prop,\n              i;\n\n          for (i in touch$$1) {\n            prop = touch$$1[i];\n            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;\n          }\n\n          touch$$1 = newTouch;\n        }\n\n        touch$$1.type = 'dblclick';\n        touch$$1.button = 0;\n        handler(touch$$1);\n        last = null;\n      }\n    }\n\n    obj[_pre + _touchstart + id] = onTouchStart;\n    obj[_pre + _touchend + id] = onTouchEnd;\n    obj[_pre + 'dblclick' + id] = handler;\n    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {\n      passive: false\n    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),\n    // the browser doesn't fire touchend/pointerup events but does fire\n    // native dblclicks. See #4127.\n    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.\n\n    obj.addEventListener('dblclick', handler, false);\n    return this;\n  }\n\n  function removeDoubleTapListener(obj, id) {\n    var touchstart = obj[_pre + _touchstart + id],\n        touchend = obj[_pre + _touchend + id],\n        dblclick = obj[_pre + 'dblclick' + id];\n    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.removeEventListener(_touchend, touchend, passiveEvents ? {\n      passive: false\n    } : false);\n\n    if (!edge) {\n      obj.removeEventListener('dblclick', dblclick, false);\n    }\n\n    return this;\n  }\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n\n\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  } // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n\n\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n\n    return value === 'auto' ? null : value;\n  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n\n\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n\n    if (container) {\n      container.appendChild(el);\n    }\n\n    return el;\n  } // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n\n\n  function remove(el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n      parent.removeChild(el);\n    }\n  } // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n\n\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  } // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n\n\n  function toFront(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  } // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n\n\n  function toBack(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  } // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n\n\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  } // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n\n\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  } // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n\n\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  } // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n\n\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  } // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n\n\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  } // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n\n\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n\n  function _setOpacityIE(el, value) {\n    var filter = false,\n        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist\n\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n\n    value = Math.round(value * 100);\n\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  } // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n\n\n  function testProp(props) {\n    var style = document.documentElement.style;\n\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n\n    return false;\n  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n\n\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  } // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n\n\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  } // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n\n\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n    return el._leaflet_pos || new Point(0, 0);\n  } // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n\n\n  var disableTextSelection;\n  var enableTextSelection;\n\n  var _userSelect;\n\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  } // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n\n\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  } // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n\n\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n\n  var _outlineElement;\n\n  var _outlineStyle; // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n\n\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n\n    if (!element.style) {\n      return;\n    }\n\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outline;\n    element.style.outline = 'none';\n    on(window, 'keydown', restoreOutline);\n  } // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n\n\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n\n    _outlineElement.style.outline = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  } // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n\n\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n\n    return element;\n  } // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n\n\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n\n  var DomUtil = (Object.freeze || Object)({\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    disableTextSelection: disableTextSelection,\n    enableTextSelection: enableTextSelection,\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  });\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function on(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n\n    return this;\n  }\n\n  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function off(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else if (types) {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        removeOne(obj, types[i], fn, context);\n      }\n    } else {\n      for (var j in obj[eventsKey]) {\n        removeOne(obj, j, obj[eventsKey][j]);\n      }\n\n      delete obj[eventsKey];\n    }\n\n    return this;\n  }\n\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n\n    var originalHandler = handler;\n\n    if (pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      addPointerListener(obj, type, handler, id);\n    } else if (touch && type === 'dblclick' && addDoubleTapListener && !(pointer && chrome)) {\n      // Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener\n      // See #5180\n      addDoubleTapListener(obj, handler, id);\n    } else if ('addEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n\n        obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\n      } else {\n        if (type === 'click' && android) {\n          handler = function (e) {\n            filterClick(e, originalHandler);\n          };\n        }\n\n        obj.addEventListener(type, handler, false);\n      }\n    } else if ('attachEvent' in obj) {\n      obj.attachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n\n  function removeOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),\n        handler = obj[eventsKey] && obj[eventsKey][id];\n\n    if (!handler) {\n      return this;\n    }\n\n    if (pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, id);\n    } else if (touch && type === 'dblclick' && removeDoubleTapListener && !(pointer && chrome)) {\n      removeDoubleTapListener(obj, id);\n    } else if ('removeEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else {\n        obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);\n      }\n    } else if ('detachEvent' in obj) {\n      obj.detachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey][id] = null;\n  } // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n\n    skipped(e);\n    return this;\n  } // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).\n\n\n  function disableScrollPropagation(el) {\n    addOne(el, 'mousewheel', stopPropagation);\n    return this;\n  } // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n\n\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick', stopPropagation);\n    addOne(el, 'click', fakeStop);\n    return this;\n  } // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n\n\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n\n    return this;\n  } // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n\n\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n\n\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n\n    var scale = getScale(container),\n        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point( // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),\n  // and Firefox scrolls device pixels, not CSS pixels\n\n\n  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a mousewheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n\n  function getWheelDelta(e) {\n    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages\n    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\n    0;\n  }\n\n  var skipEvents = {};\n\n  function fakeStop(e) {\n    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)\n    skipEvents[e.type] = true;\n  }\n\n  function skipped(e) {\n    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map\n\n    skipEvents[e.type] = false;\n    return events;\n  } // check if element really left/entered the event target (for mouseenter/mouseleave)\n\n\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n\n    if (!related) {\n      return true;\n    }\n\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n\n    return related !== el;\n  }\n\n  var lastClick; // this is a horrible workaround for a bug in Android where a single touch triggers two click events\n\n  function filterClick(e, handler) {\n    var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,\n        elapsed = lastClick && timeStamp - lastClick; // are they closer together than 500ms yet more than 100ms?\n    // Android typically triggers them ~300ms apart while multiple listeners\n    // on the same event should be triggered far faster;\n    // or check if click is simulated on the element, and if it is, reject any non-simulated events\n\n    if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {\n      stop(e);\n      return;\n    }\n\n    lastClick = timeStamp;\n    handler(e);\n  }\n\n  var DomEvent = (Object.freeze || Object)({\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    fakeStop: fakeStop,\n    skipped: skipped,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  });\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var fx = new L.PosAnimation();\n   * fx.run(el, [300, 500], 0.5);\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date(); // @event start: Event\n      // Fired when the animation starts\n\n      this.fire('start');\n\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n\n      this._step(true);\n\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n          duration = this._duration * 1000;\n\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n\n      if (round) {\n        pos._round();\n      }\n\n      setPosition(this._el, pos); // @event step: Event\n      // Fired continuously during the animation.\n\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false; // @event end: Event\n      // Fired when the animation ends.\n\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API  it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n\n      this._initContainer(id);\n\n      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980\n\n\n      this._onResize = bind(this._onResize, this);\n\n      this._initEvents();\n\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n\n      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\n      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n\n      this._stop();\n\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        } // try animating pan or zoom\n\n\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      } // animation didn't start, just reset the map view\n\n\n      this._resetView(center, zoom);\n\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n          viewHalf = this.getSize().divideBy(2),\n          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n          swPoint = this.project(bounds.getSouthWest(), zoom),\n          nePoint = this.project(bounds.getNorthEast(), zoom),\n          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      } // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\n        return this;\n      }\n\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      } // don't fire movestart if animating inertia\n\n\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      } // animate pan unless animate: false specified\n\n\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n\n        var newPos = this._getMapPanePos().subtract(offset).round();\n\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n\n        this.fire('move').fire('moveend');\n      }\n\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n\n      if (options.animate === false || !any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n\n      this._stop();\n\n      var from = this.project(this.getCenter()),\n          to = this.project(targetCenter),\n          size = this.getSize(),\n          startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n          w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n          u1 = to.distanceTo(from) || 1,\n          rho = 1.42,\n          rho2 = rho * rho;\n\n      function r(i) {\n        var s1 = i ? -1 : 1,\n            s2 = i ? w1 : w0,\n            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n            b1 = 2 * s2 * rho2 * u1,\n            b = t1 / b1,\n            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n\n      var r0 = r(0);\n\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n\n      var start = Date.now(),\n          S = (r(1) - r0) / rho,\n          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n      function frame() {\n        var t = (Date.now() - start) / duration,\n            s = easeOut(t) * S;\n\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n\n      this._moveStart(true, options.noMoveStart);\n\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: Bounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this.off('moveend', this._panInsideMaxBounds);\n      } else if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n\n      this.options.maxBounds = bounds;\n\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n\n      var center = this.getCenter(),\n          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit\n    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          center = this.getCenter(),\n          pixelCenter = this.project(center),\n          pixelPoint = this.project(latlng),\n          pixelBounds = this.getPixelBounds(),\n          halfPixelBounds = pixelBounds.getSize().divideBy(2),\n          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);\n\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var diff = pixelCenter.subtract(pixelPoint),\n            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);\n\n        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {\n          newCenter.x = pixelCenter.x - diff.x;\n\n          if (diff.x > 0) {\n            newCenter.x += halfPixelBounds.x - paddingTL.x;\n          } else {\n            newCenter.x -= halfPixelBounds.x - paddingBR.x;\n          }\n        }\n\n        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {\n          newCenter.y = pixelCenter.y - diff.y;\n\n          if (diff.y > 0) {\n            newCenter.y += halfPixelBounds.y - paddingTL.y;\n          } else {\n            newCenter.y -= halfPixelBounds.y - paddingBR.y;\n          }\n        }\n\n        this.panTo(this.unproject(newCenter), options);\n        this._enforcingBounds = false;\n      }\n\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so \n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so \n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n          oldCenter = oldSize.divideBy(2).round(),\n          newCenter = newSize.divideBy(2).round(),\n          offset = oldCenter.subtract(newCenter);\n\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n\n        this.fire('move');\n\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      } // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n\n\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n\n      }, options);\n\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n\n        return this;\n      }\n\n      var onResponse = bind(this._handleGeolocationResponse, this),\n          onError = bind(this._handleGeolocationError, this);\n\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      var c = error.code,\n          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      } // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n\n\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      var lat = pos.coords.latitude,\n          lng = pos.coords.longitude,\n          latlng = new LatLng(lat, lng),\n          bounds = latlng.toBounds(pos.coords.accuracy * 2),\n          options = this._locateOptions;\n\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      } // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n\n\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n\n      var handler = this[name] = new HandlerClass(this);\n\n      this._handlers.push(handler);\n\n      if (this.options[name]) {\n        handler.enable();\n      }\n\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n\n        this._containerId = undefined;\n      }\n\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n\n      this._stop();\n\n      remove(this._mapPane);\n\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n\n      this._clearHandlers();\n\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n\n      var i;\n\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n          pane = create$1('div', className, container || this._mapPane);\n\n      if (name) {\n        this._panes[name] = pane;\n      }\n\n      return pane;\n    },\n    // @section Methods for Getting Map State\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter;\n      }\n\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n          sw = this.unproject(bounds.getBottomLeft()),\n          ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n          min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          nw = bounds.getNorthWest(),\n          se = bounds.getSouthEast(),\n          size = this.getSize().subtract(padding),\n          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n          snap = any3d ? this.options.zoomSnap : 1,\n          scalex = size.x / boundsSize.x,\n          scaley = size.y / boundsSize.y,\n          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && any3d;\n      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n        container.style.position = 'relative';\n      }\n\n      this._initPanes();\n\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {}; // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n\n      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n\n      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n\n      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n\n      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n\n      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n\n      this.createPane('popupPane');\n\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n    // @section Map state change events\n    _resetView: function (center, zoom) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n\n      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n\n\n      this.fire('viewreset'); // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n\n      return this;\n    },\n    _move: function (center, zoom, data) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event\n      // Fired repeatedly during any change in zoom level, including zoom\n      // and fly animations.\n\n      if (zoomChanged || data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      } // @event move: Event\n      // Fired repeatedly during any movement of the map, including pan and\n      // fly animations.\n\n\n      return this.fire('move', data);\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map has changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      } // @event moveend: Event\n      // Fired when the center of the map stops changing (e.g. user stopped\n      // dragging the map).\n\n\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n    // @section Interaction events\n    _initEvents: function (remove$$1) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove$$1 ? off : on; // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n\n      if (any3d && this.options.transform3DLimit) {\n        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n          target,\n          isHover = type === 'mouseout' || type === 'mouseover',\n          src = e.target || e.srcElement,\n          dragging = false;\n\n      while (src) {\n        target = this._targets[stamp(src)];\n\n        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n\n          targets.push(target);\n\n          if (isHover) {\n            break;\n          }\n        }\n\n        if (src === this._container) {\n          break;\n        }\n\n        src = src.parentNode;\n      }\n\n      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {\n        targets = [this];\n      }\n\n      return targets;\n    },\n    _handleDOMEvent: function (e) {\n      if (!this._loaded || skipped(e)) {\n        return;\n      }\n\n      var type = e.type;\n\n      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(e.target || e.srcElement);\n      }\n\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, targets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n\n        this._fireDOMEvent(synth, synth.type, targets);\n      }\n\n      if (e._stopped) {\n        return;\n      } // Find the layer the event is propagating from and its parents.\n\n\n      targets = (targets || []).concat(this._findEventTargets(e, type));\n\n      if (!targets.length) {\n        return;\n      }\n\n      var target = targets[0];\n\n      if (type === 'contextmenu' && target.listens(type, true)) {\n        preventDefault(e);\n      }\n\n      var data = {\n        originalEvent: e\n      };\n\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n\n      for (var i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n\n      return this;\n    },\n    // private methods for getting map state\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n\n      var centerPoint = this.project(center, zoom),\n          viewHalf = this.getSize().divideBy(2),\n          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n\n\n      if (offset.round().equals([0, 0])) {\n        return center;\n      }\n\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n\n      var viewBounds = this.getPixelBounds(),\n          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n          dx = this._rebound(minOffset.x, -maxOffset.x),\n          dy = this._rebound(minOffset.y, -maxOffset.y);\n\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          snap = any3d ? this.options.zoomSnap : 1;\n\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options\n\n\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n\n      this._panes.mapPane.appendChild(proxy);\n\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n            transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired\n\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n          z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n\n      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large\n\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      } // offset is the pixel coords of the zoom origin relative to the current center\n\n\n      var scale = this.getZoomScale(zoom),\n          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      requestAnimFrame(function () {\n        this._moveStart(true, false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n\n      if (startAnim) {\n        this._animatingZoom = true; // remember what center/zoom to set after animation\n\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      } // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n\n\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      this._animatingZoom = false;\n\n      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\n\n      requestAnimFrame(function () {\n        this._moveEnd(true);\n      }, this);\n    }\n  }); // @section\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n\n      if (map) {\n        map.removeControl(this);\n      }\n\n      this.options.position = position;\n\n      if (map) {\n        map.addControl(this);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n          pos = this.getPosition(),\n          corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n\n      this._map.on('unload', this.remove, this);\n\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n\n      remove(this._container);\n\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n\n      this._map.off('unload', this.remove, this);\n\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n\n  var control = function (options) {\n    return new Control(options);\n  };\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n\n\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n          l = 'leaflet-',\n          container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n\n      this._update();\n\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n\n      var obj = this._getLayer(stamp(layer));\n\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n\n      this._checkDisabledLayers();\n\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n          container = this._container = create$1('div', className),\n          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n\n        if (!android) {\n          on(container, {\n            mouseenter: this.expand,\n            mouseleave: this.collapse\n          }, this);\n        }\n      }\n\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n\n      if (touch) {\n        on(link, 'click', stop);\n        on(link, 'click', this.expand, this);\n      } else {\n        on(link, 'focus', this.expand, this);\n      }\n\n      if (!collapsed) {\n        this.expand();\n      }\n\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n          overlaysPresent,\n          i,\n          obj,\n          baseLayersCount = 0;\n\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n\n        this._addItem(obj);\n\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      } // Hide base layers section if there's only one layer.\n\n\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n\n      var obj = this._getLayer(stamp(e.target)); // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layer control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layer control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layer control](#control-layers).\n      // @namespace Control.Layers\n\n\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n          checked = this._map.hasLayer(obj.layer),\n          input;\n\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n\n      this._layerControlInputs.push(input);\n\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n\n      var holder = document.createElement('div');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n\n      this._checkDisabledLayers();\n\n      return label;\n    },\n    _onInputClick: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer;\n      var addedLayers = [],\n          removedLayers = [];\n      this._handlingClick = true;\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      } // Bugfix issue 2318: Should remove all old layers before readding new ones\n\n\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n\n      this._handlingClick = false;\n\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer,\n          zoom = this._map.getZoom();\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n\n      return this;\n    },\n    _expand: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.expand();\n    },\n    _collapse: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.collapse();\n    }\n  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '+'\n      // The text set on the 'zoom in' button.\n      zoomInText: '+',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '&#x2212;'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '&#x2212;',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n          container = create$1('div', zoomName + ' leaflet-bar'),\n          options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n\n      this._updateDisabled();\n\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n          className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n      }\n\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n      }\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  }); // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n          container = create$1('div', className),\n          options = this.options;\n\n      this._addScales(options, className + '-line', container);\n\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n          y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n          maxMiles,\n          miles,\n          feet;\n\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n          d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  }); // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container); // TODO ugly, refactor\n\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n\n      this._update();\n\n      return this._container;\n    },\n    // @method setPrefix(prefix: String): this\n    // Sets the text before the attributions.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n\n      this._update();\n\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n\n      this._attributions[text]++;\n\n      this._update();\n\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n\n        this._update();\n      }\n\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var attribs = [];\n\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n\n      var prefixAndAttribs = [];\n\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n\n      this._container.innerHTML = prefixAndAttribs.join(' | ');\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  }); // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    } // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n\n  }); // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n\n  var Mixin = {\n    Events: Events\n  };\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = touch ? 'touchstart mousedown' : 'mousedown';\n  var END = {\n    mousedown: 'mouseup',\n    touchstart: 'touchend',\n    pointerdown: 'touchend',\n    MSPointerDown: 'touchend'\n  };\n  var MOVE = {\n    mousedown: 'mousemove',\n    touchstart: 'touchmove',\n    pointerdown: 'touchmove',\n    MSPointerDown: 'touchmove'\n  };\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline$$1, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline$$1;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      } // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n\n\n      if (Draggable._dragging === this) {\n        this.finishDrag();\n      }\n\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this._moved = false;\n\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n\n      disableImageDrag();\n      disableTextSelection();\n\n      if (this._moving) {\n        return;\n      } // @event down: Event\n      // Fired when a drag is about to start.\n\n\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n          sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n\n      this._parentScale = getScale(sizedParent);\n      on(document, MOVE[e.type], this._onMove, this);\n      on(document, END[e.type], this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n\n      if (!offset.x && !offset.y) {\n        return;\n      }\n\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n\n\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        this._startPos = getPosition(this._element).subtract(offset);\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n\n        if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      cancelAnimFrame(this._animRequest);\n      this._lastEvent = e;\n      this._animRequest = requestAnimFrame(this._updatePosition, this, true);\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      }; // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos); // @event drag: Event\n      // Fired continuously during dragging.\n\n      this.fire('drag', e);\n    },\n    _onUp: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this.finishDrag();\n    },\n    finishDrag: function () {\n      removeClass(document.body, 'leaflet-dragging');\n\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n\n      for (var i in MOVE) {\n        off(document, MOVE[i], this._onMove, this);\n        off(document, END[i], this._onUp, this);\n      }\n\n      enableImageDrag();\n      enableTextSelection();\n\n      if (this._moved && this._moving) {\n        // ensure drag is not fired after dragend\n        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n\n        this.fire('dragend', {\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n\n      this._moving = false;\n      Draggable._dragging = false;\n    }\n  });\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).\n\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n\n    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction\n\n    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification\n\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n\n\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n\n\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\n\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n        markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n    var i,\n        newPoints = [];\n\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n\n    return newPoints;\n  }\n\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n        index,\n        i,\n        sqDist;\n\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  } // reduce points that are too close to each other to a single point\n\n\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n\n    return reducedPoints;\n  }\n\n  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n\n\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n        codeB = _getBitCode(b, bounds),\n        codeOut,\n        p,\n        newCode; // save 2nd code to avoid calculating it on the next segment\n\n\n    _lastCode = codeB;\n\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      } // if a,b is outside the clip window (trivial reject)\n\n\n      if (codeA & codeB) {\n        return false;\n      } // other cases\n\n\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n        dy = b.y - a.y,\n        min = bounds.min,\n        max = bounds.max,\n        x,\n        y;\n\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n\n    return new Point(x, y, round);\n  }\n\n  function _getBitCode(p, bounds) {\n    var code = 0;\n\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n\n    return code;\n  } // square distance (to avoid unnecessary Math.sqrt calls)\n\n\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n        dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  } // return closest point on segment or distance to that point\n\n\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  } // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n\n\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  var LineUtil = (Object.freeze || Object)({\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat\n  });\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n        edges = [1, 4, 2, 8],\n        i,\n        j,\n        k,\n        a,\n        b,\n        len,\n        edge,\n        p;\n\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    } // for each edge (left, bottom, right, top)\n\n\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j]; // if a is inside the clip window\n\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n\n          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n\n      points = clippedPoints;\n    }\n\n    return points;\n  }\n\n  var PolyUtil = (Object.freeze || Object)({\n    clipPolygon: clipPolygon\n  });\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection  the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          r = this.R,\n          y = latlng.lat * d,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n          r = this.R,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          ts = Math.exp(-point.y / r),\n          phi = Math.PI / 2 - 2 * Math.atan(ts);\n\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n  /*\n   * @class Projection\n  \n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).\n  \n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n  \n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n  \n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n  \n   * Note that the projection instances do not inherit from Leafet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n  \n   */\n\n  var index = (Object.freeze || Object)({\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n          dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \" OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target; // check in case layer gets added and then removed before the map is ready\n\n      if (!map.hasLayer(this)) {\n        return;\n      }\n\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n\n      this.onAdd(map);\n\n      if (this.getAttribution && map.attributionControl) {\n        map.attributionControl.addAttribution(this.getAttribution());\n      }\n\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n\n      var id = stamp(layer);\n\n      if (this._layers[id]) {\n        return this;\n      }\n\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n\n      if (!this._layers[id]) {\n        return this;\n      }\n\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n\n      if (layer.getAttribution && this.attributionControl) {\n        this.attributionControl.removeAttribution(layer.getAttribution());\n      }\n\n      delete this._layers[id];\n\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return !!layer && stamp(layer) in this._layers;\n    },\n\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n          maxZoom = -Infinity,\n          oldZoomSpan = this._getZoomSpan();\n\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, ): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          i,\n          layer;\n\n      for (i in this._layers) {\n        layer = this._layers[i];\n\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n\n      return bounds;\n    }\n  }); // @factory L.featureGroup(layers: Layer[])\n  // Create a feature group, optionally given an initial set of layers.\n\n  var featureGroup = function (layers) {\n    return new FeatureGroup(layers);\n  };\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0]\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n\n        return null;\n      }\n\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n\n      this._setIconStyles(img, name);\n\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n\n      var size = toPoint(sizeOption),\n          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  }); // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n\n  function icon(options) {\n    return new Icon(options);\n  }\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (!IconDefault.imagePath) {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      } // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n\n\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n\n      if (path === null || path.indexOf('url') !== 0) {\n        path = '';\n      } else {\n        path = path.replace(/^url\\([\"']?/, '').replace(/marker-icon\\.png[\"']?\\)$/, '');\n      }\n\n      return path;\n    }\n  });\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n          map = marker._map,\n          speed = this._marker.options.autoPanSpeed,\n          padding = this._marker.options.autoPanPadding,\n          iconPos = getPosition(marker._icon),\n          bounds = map.getPixelBounds(),\n          origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n\n        this._draggable._newPos._add(movement);\n\n        this._draggable._startPos._add(movement);\n\n        setPosition(marker._icon, this._draggable._newPos);\n\n        this._onDrag(e);\n\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n      this._oldLatLng = this._marker.getLatLng();\n\n      this._marker.closePopup().fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n          shadow = marker._shadow,\n          iconPos = getPosition(marker._icon),\n          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position\n\n\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng; // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n      cancelAnimFrame(this._panRequest); // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n\n      delete this._oldLatLng;\n\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      title: '',\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the icon image (useful for accessibility).\n      alt: '',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option pane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n\n      this._initIcon();\n\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n\n      delete this.dragging;\n\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n\n      this._removeIcon();\n\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n\n      if (this._map) {\n        this._initIcon();\n\n        this.update();\n      }\n\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n\n        this._setPos(pos);\n      }\n\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n          addIcon = false; // if we're not reusing the icon, remove the old one and init new one\n\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n\n        addIcon = true;\n\n        if (options.title) {\n          icon.title = options.title;\n        }\n\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n\n      addClass(icon, classToAdd);\n\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n      }\n\n      this._icon = icon;\n\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      var newShadow = options.icon.createShadow(this._shadow),\n          addShadow = false;\n\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n\n        addShadow = true;\n      }\n\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n\n      this._shadow = newShadow;\n\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n\n      this._initInteraction();\n\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n\n      this._zIndex = pos.y + this.options.zIndexOffset;\n\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n\n        this.dragging = new MarkerDrag(this);\n\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._map) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  }); // factory L.marker(latlng: LatLng, options? : Marker options)\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n\n      this._reset();\n\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n\n        if (this.options.stroke && style && style.hasOwnProperty('weight')) {\n          this._updateBounds();\n        }\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;\n    }\n  });\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n          r2 = this._radiusY || r,\n          w = this._clickTolerance(),\n          p = [r + w, r2 + w];\n\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      } // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n\n\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n          lat = this._latlng.lat,\n          map = this._map,\n          crs = map.options.crs;\n\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n            latR = this._mRadius / Earth.R / d,\n            top = map.project([lat + latR, lng]),\n            bottom = map.project([lat - latR, lng]),\n            p = top.add(bottom).divideBy(2),\n            lat2 = map.unproject(p).lat,\n            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n\n      this._updateBounds();\n    }\n  }); // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n          minPoint = null,\n          closest = _sqClosestPointOnSegment,\n          p1,\n          p2;\n\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          halfDist,\n          segDist,\n          dist,\n          p1,\n          p2,\n          ratio,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polyline centroid algorithm; only uses the first ring if there are multiple\n\n\n      for (i = 0, halfDist = 0; i < len - 1; i++) {\n        halfDist += points[i].distanceTo(points[i + 1]) / 2;\n      } // The line is so small in the current view that all points are on the same pixel.\n\n\n      if (halfDist === 0) {\n        return this._map.layerPointToLatLng(points[0]);\n      }\n\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);\n        }\n      }\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n\n      this._bounds.extend(latlng);\n\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n          flat = isFlat(latlngs);\n\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n          p = new Point(w, w);\n\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n          len = latlngs.length,\n          i,\n          ring;\n\n      if (flat) {\n        ring = [];\n\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      var parts = this._parts,\n          i,\n          j,\n          k,\n          len,\n          len2,\n          segment,\n          points;\n\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n          if (!segment) {\n            continue;\n          }\n\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part\n\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n          tolerance = this.options.smoothFactor;\n\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._clipPoints();\n\n      this._simplifyPoints();\n\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n          j,\n          k,\n          len,\n          len2,\n          part,\n          w = this._clickTolerance();\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // hit detection for polylines\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n\n\n  Polyline._flat = _flat;\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          j,\n          p1,\n          p2,\n          f,\n          area,\n          x,\n          y,\n          center,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polygon centroid algorithm; only uses the first ring if there are multiple\n\n\n      area = x = y = 0;\n\n      for (i = 0, j = len - 1; i < len; j = i++) {\n        p1 = points[i];\n        p2 = points[j];\n        f = p1.y * p2.x - p2.y * p1.x;\n        x += (p1.x + p2.x) * f;\n        y += (p1.y + p2.y) * f;\n        area += f * 3;\n      }\n\n      if (area === 0) {\n        // Polygon is so small that all points are on same pixel.\n        center = points[0];\n      } else {\n        center = [x / area, y / area];\n      }\n\n      return this._map.layerPointToLatLng(center);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n          len = result.length; // remove last point if it equals first one\n\n\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n      var bounds = this._renderer._bounds,\n          w = this.options.weight,\n          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges\n\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n          part,\n          p1,\n          p2,\n          i,\n          j,\n          k,\n          len,\n          len2;\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // ray casting algorithm for detecting if point is in polygon\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      } // also check if it's on polygon stroke\n\n\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n          i,\n          len,\n          feature;\n\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n\n        return this;\n      }\n\n      var options = this.options;\n\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n\n      var layer = geometryToLayer(geojson, options);\n\n      if (!layer) {\n        return this;\n      }\n\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      } // reset any custom styles\n\n\n      layer.options = extend({}, layer.defaultOptions);\n\n      this._setLayerStyle(layer, this.options.style);\n\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n\n        layer.setStyle(style);\n      }\n    }\n  }); // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n        coords = geometry ? geometry.coordinates : null,\n        layers = [],\n        pointToLayer = options && options.pointToLayer,\n        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n        latlng,\n        latlngs,\n        i,\n        len;\n\n    if (!coords && !geometry) {\n      return null;\n    }\n\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n\n        return new FeatureGroup(layers);\n\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var layer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n\n          if (layer) {\n            layers.push(layer);\n          }\n        }\n\n        return new FeatureGroup(layers);\n\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  } // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n\n\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n\n\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n\n    return latlngs;\n  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n\n\n  function latLngToCoords(latlng, precision) {\n    precision = typeof precision === 'number' ? precision : 6;\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n\n\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n\n    if (!levelsDeep && closed) {\n      coords.push(coords[0]);\n    }\n\n    return coords;\n  }\n\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  } // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n\n\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  }; // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n\n  Marker.include(PointToGeoJSON); // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON); // @namespace Polyline\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  }); // @namespace Polygon\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n          multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n\n      if (!holes) {\n        coords = [coords];\n      }\n\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  }); // @namespace LayerGroup\n\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number): Object\n    // `precision` is the number of decimal places for coordinates.\n    // The default value is 6 places.\n    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n\n      var isGeometryCollection = type === 'GeometryCollection',\n          jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json); // Squash nested feature collections\n\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  }); // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  } // Backward compatibility.\n\n\n  var geoJson = geoJSON;\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n\n      this.getPane().appendChild(this._image);\n\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._image) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n\n      if (this._image) {\n        this._image.src = url;\n      }\n\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n\n      if (this._map) {\n        this._reset();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn; // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n          size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    }\n  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n      keepAspectRatio: true\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn; // @event load: Event\n      // Fired when the video has finished loading the first frame\n\n      vid.onloadeddata = bind(this.fire, this, 'load');\n\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n\n      if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    } // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n\n  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    } // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n\n  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.\r\n   */\n  // @namespace DivOverlay\n\n\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position. Useful to control the anchor\n      // of the popup when opening it on some overlays.\n      offset: [0, 7],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: '',\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane'\n    },\n    initialize: function (options, source) {\n      setOptions(this, options);\n      this._source = source;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (!this._container) {\n        this._initLayout();\n      }\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n\n      this.bringToFront();\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n    },\n    // @namespace Popup\n    // @method getLatLng: LatLng\n    // Returns the geographical point of popup.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the popup will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n\n      if (this._map) {\n        this._updatePosition();\n\n        this._adjustPan();\n      }\n\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the popup.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Alias for [getContent()](#popup-getcontent)\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._container.style.visibility = 'hidden';\n\n      this._updateContent();\n\n      this._updateLayout();\n\n      this._updatePosition();\n\n      this._container.style.visibility = '';\n\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the popup is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this popup in front of other popups (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this popup to the back of other popups (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n\n      return this;\n    },\n    _prepareOpen: function (parent, layer, latlng) {\n      if (!(layer instanceof Layer)) {\n        latlng = layer;\n        layer = parent;\n      }\n\n      if (layer instanceof FeatureGroup) {\n        for (var id in parent._layers) {\n          layer = parent._layers[id];\n          break;\n        }\n      }\n\n      if (!latlng) {\n        if (layer.getCenter) {\n          latlng = layer.getCenter();\n        } else if (layer.getLatLng) {\n          latlng = layer.getLatLng();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      } // set overlay source to this layer\n\n\n      this._source = layer; // update the overlay (content, layout, ect...)\n\n      this.update();\n      return latlng;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n\n        node.appendChild(content);\n      }\n\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n\n      var bottom = this._containerBottom = -offset.y,\n          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)\n\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   * Here's a more complicated way to open a popup on a map:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n  // @namespace Popup\n\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.\n    openOn: function (map) {\n      map.openPopup(this);\n      return this;\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n\n      map.fire('popupopen', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true); // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n\n\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n\n      map.fire('popupclose', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this._close;\n      }\n\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closePopup(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(wrapper);\n      disableScrollPropagation(this._contentNode);\n      on(wrapper, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.href = '#close';\n        closeButton.innerHTML = '&#215;';\n        on(closeButton, 'click', this._onCloseButtonClick, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n          style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n          maxHeight = this.options.maxHeight,\n          scrolledClass = 'leaflet-popup-scrolled';\n\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n          anchor = this._getAnchor();\n\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      var map = this._map,\n          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n          containerHeight = this._container.offsetHeight + marginBottom,\n          containerWidth = this._containerWidth,\n          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n      layerPos._add(getPosition(this._container));\n\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n          padding = toPoint(this.options.autoPanPadding),\n          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n          size = map.getSize(),\n          dx = 0,\n          dy = 0;\n\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      } // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n\n\n      if (dx || dy) {\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _onCloseButtonClick: function (e) {\n      this._close();\n\n      stop(e);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  }); // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n\n\n  Map.mergeOptions({\n    closePopupOnClick: true\n  }); // @namespace Map\n  // @section Methods for Layers and Controls\n\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      if (!(popup instanceof Popup)) {\n        popup = new Popup(options).setContent(popup);\n      }\n\n      if (latlng) {\n        popup.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(popup)) {\n        return this;\n      }\n\n      if (this._popup && this._popup.options.autoClose) {\n        this.closePopup();\n      }\n\n      this._popup = popup;\n      return this.addLayer(popup);\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      if (!popup || popup === this._popup) {\n        popup = this._popup;\n        this._popup = null;\n      }\n\n      if (popup) {\n        this.removeLayer(popup);\n      }\n\n      return this;\n    }\n  });\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n  // @section Popup methods\n\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      if (content instanceof Popup) {\n        setOptions(content, options);\n        this._popup = content;\n        content._source = this;\n      } else {\n        if (!this._popup || options) {\n          this._popup = new Popup(options, this);\n        }\n\n        this._popup.setContent(content);\n      }\n\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (layer, latlng) {\n      if (this._popup && this._map) {\n        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map\n\n        this._map.openPopup(this._popup, latlng);\n      }\n\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup._close();\n      }\n\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function (target) {\n      if (this._popup) {\n        if (this._popup._map) {\n          this.closePopup();\n        } else {\n          this.openPopup(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._popup) {\n        return;\n      }\n\n      if (!this._map) {\n        return;\n      } // prevent map click\n\n\n      stop(e); // if this inherits from Path its a vector and we can just\n      // open the popup at the new location\n\n      if (layer instanceof Path) {\n        this.openPopup(e.layer || e.target, e.latlng);\n        return;\n      } // otherwise treat it like a marker and figure out\n      // if we should toggle it open/closed\n\n\n      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n        this.closePopup();\n      } else {\n        this.openPopup(layer, e.latlng);\n      }\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n  // @namespace Tooltip\n\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option interactive: Boolean = false\n      // If true, the tooltip will listen to the feature events.\n      interactive: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (touch && !this.options.permanent) {\n        events.preclick = this._close;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closeTooltip(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var map = this._map,\n          container = this._container,\n          centerPoint = map.latLngToContainerPoint(map.getCenter()),\n          tooltipPoint = map.layerPointToContainerPoint(pos),\n          direction = this.options.direction,\n          tooltipWidth = container.offsetWidth,\n          tooltipHeight = container.offsetHeight,\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (direction === 'top') {\n        pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));\n      } else if (direction === 'bottom') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));\n      } else if (direction === 'center') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));\n      } else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));\n      } else {\n        direction = 'left';\n        pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));\n      }\n\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  }); // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  }; // @namespace Map\n  // @section Methods for Layers and Controls\n\n\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      if (!(tooltip instanceof Tooltip)) {\n        tooltip = new Tooltip(options).setContent(tooltip);\n      }\n\n      if (latlng) {\n        tooltip.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(tooltip)) {\n        return this;\n      }\n\n      return this.addLayer(tooltip);\n    },\n    // @method closeTooltip(tooltip?: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      if (tooltip) {\n        this.removeLayer(tooltip);\n      }\n\n      return this;\n    }\n  });\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n  // @section Tooltip methods\n\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (content instanceof Tooltip) {\n        setOptions(content, options);\n        this._tooltip = content;\n        content._source = this;\n      } else {\n        if (!this._tooltip || options) {\n          this._tooltip = new Tooltip(options, this);\n        }\n\n        this._tooltip.setContent(content);\n      }\n\n      this._initTooltipInteractions();\n\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n\n      return this;\n    },\n    _initTooltipInteractions: function (remove$$1) {\n      if (!remove$$1 && this._tooltipHandlersAdded) {\n        return;\n      }\n\n      var onOff = remove$$1 ? 'off' : 'on',\n          events = {\n        remove: this.closeTooltip,\n        move: this._moveTooltip\n      };\n\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n\n        if (this._tooltip.options.sticky) {\n          events.mousemove = this._moveTooltip;\n        }\n\n        if (touch) {\n          events.click = this._openTooltip;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove$$1;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (layer, latlng) {\n      if (this._tooltip && this._map) {\n        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map\n\n        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never\n        // opened.\n\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          addClass(this._tooltip._container, 'leaflet-clickable');\n          this.addInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip._close();\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          removeClass(this._tooltip._container, 'leaflet-clickable');\n          this.removeInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function (target) {\n      if (this._tooltip) {\n        if (this._tooltip._map) {\n          this.closeTooltip();\n        } else {\n          this.openTooltip(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _openTooltip: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n          containerPoint,\n          layerPoint;\n\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n          options = this.options;\n\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n\n      this._setIconStyles(div, 'icon');\n\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  }); // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n\n      this._levels = {};\n      this._tiles = {};\n\n      this._resetView();\n\n      this._update();\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n\n      remove(this._container);\n\n      map._removeZoomLimit(this);\n\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n\n        this._setAutoZIndex(Math.max);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n\n        this._setAutoZIndex(Math.min);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      this._updateOpacity();\n\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n\n        this._update();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n\n        events.move = this._onMove;\n      }\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n      var layers = this.getPane().children,\n          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\n\n      if (ielt9) {\n        return;\n      }\n\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n          nextFrame = false,\n          willPrune = false;\n\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n\n          tile.active = true;\n        }\n      }\n\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n\n      this._updateZIndex();\n\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom;\n\n      if (zoom === undefined) {\n        return undefined;\n      }\n\n      for (var z in this._levels) {\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n\n          this._removeTilesAtZoom(z);\n\n          this._onRemoveLevel(z);\n\n          delete this._levels[z];\n        }\n      }\n\n      var level = this._levels[zoom],\n          map = this._map;\n\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n\n        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition\n\n\n        falseFn(level.el.offsetWidth);\n\n        this._onCreateLevel(level);\n      }\n\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var key, tile;\n\n      var zoom = this._map.getZoom();\n\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n\n        return;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n\n        this._onRemoveLevel(z);\n\n        delete this._levels[z];\n      }\n\n      this._removeAllTiles();\n\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n          y2 = Math.floor(y / 2),\n          z2 = z - 1,\n          coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n\n      var key = this._tileCoordsToKey(coords2),\n          tile = this._tiles[key];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n\n          var key = this._tileCoordsToKey(coords),\n              tile = this._tiles[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = this._clampZoom(Math.round(zoom));\n\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      }\n\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n\n        this._updateLevels();\n\n        this._resetGrid();\n\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n\n        if (!noPrune) {\n          this._pruneTiles();\n        } // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n\n\n        this._noPrune = !!noPrune;\n      }\n\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n      if (any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n          crs = map.options.crs,\n          tileSize = this._tileSize = this.getTileSize(),\n          tileZoom = this._tileZoom;\n\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n          scale = map.getZoomScale(mapZoom, this._tileZoom),\n          pixelCenter = map.project(center, this._tileZoom).floor(),\n          halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n\n      if (!map) {\n        return;\n      }\n\n      var zoom = this._clampZoom(map.getZoom());\n\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n          tileRange = this._pxBoundsToTileRange(pixelBounds),\n          tileCenter = tileRange.getCenter(),\n          queue = [],\n          margin = this.options.keepBuffer,\n          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.\n\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      } // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n\n\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n\n        return;\n      } // create a queue of coordinates to load tiles from\n\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      } // sort tile queue to load tiles in order of their distance to center\n\n\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true; // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n\n          this.fire('loading');\n        } // create DOM fragment to append tiles in one batch\n\n\n        var fragment = document.createDocumentFragment();\n\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n\n      if (!this.options.bounds) {\n        return true;\n      } // don't load tile if it doesn't intersect the bounds in options\n\n\n      var tileBounds = this._tileCoordsToBounds(coords);\n\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n          tileSize = this.getTileSize(),\n          nwPoint = coords.scaleBy(tileSize),\n          sePoint = nwPoint.add(tileSize),\n          nw = map.unproject(nwPoint, coords.z),\n          se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n          bounds = new LatLngBounds(bp[0], bp[1]);\n\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n          coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      remove(tile.el);\n      delete this._tiles[key]; // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems\n\n      if (ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      } // without this hack, tiles disappear after zoom on Chrome for Android\n      // https://github.com/Leaflet/Leaflet/issues/2078\n\n\n      if (android && !android23) {\n        tile.style.WebkitBackfaceVisibility = 'hidden';\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n          key = this._tileCoordsToKey(coords);\n\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n      this._initTile(tile); // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n\n\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n\n      setPosition(tile, tilePos); // save tile in cache\n\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile); // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n\n      var key = this._tileCoordsToKey(coords);\n\n      tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      tile.loaded = +new Date();\n\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n\n        this._pruneTiles();\n      }\n\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent\n        // Fired when a tile loads.\n\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n\n      if (this._noTilesToLoad()) {\n        this._loading = false; // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n\n        this.fire('load');\n\n        if (ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }); // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>'}).addTo(map);\r\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels\n\n      if (options.detectRetina && retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom--;\n        } else {\n          options.zoomOffset--;\n          options.minZoom++;\n        }\n\n        options.minZoom = Math.max(0, options.minZoom);\n      }\n\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      } // for https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!android) {\n        this.on('tileunload', this._onTileRemove);\n      }\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n\n      this._url = url;\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      /*\r\n       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n       http://www.w3.org/TR/WCAG20-TECHS/H67\r\n      */\n\n\n      tile.alt = '';\n      /*\r\n       Set role=\"presentation\" to force screen readers to ignore this\r\n       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n      */\n\n      tile.setAttribute('role', 'presentation');\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n\n        data['-y'] = invertedY;\n      }\n\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom,\n          zoomReverse = this.options.zoomReverse,\n          zoomOffset = this.options.zoomOffset;\n\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            remove(tile);\n            delete this._tiles[i];\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      } // Cancels any pending http requests associated with the tile\n      // unless we're on Android's stock browser,\n      // see https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!androidStock) {\n        tile.el.setAttribute('src', emptyImageUrl);\n      }\n\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data  2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params\n\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n          crs = this._crs,\n          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n          min = bounds.min,\n          max = bounds.max,\n          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n          url = TileLayer.prototype.getTileUrl.call(this, coords);\n\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    }\n  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1,\n      // @option tolerance: Number = 0\n      // How much to extend click tolerance round a path/object on the map\n      tolerance: 0\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n\n        if (this._zoomAnimated) {\n          addClass(this._container, 'leaflet-zoom-animated');\n        }\n      }\n\n      this.getPane().appendChild(this._container);\n\n      this._update();\n\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n          position = getPosition(this._container),\n          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n          currentCenterPoint = this._map.project(this._center, zoom),\n          destCenterPoint = this._map.project(center, zoom),\n          centerOffset = destCenterPoint.subtract(currentCenterPoint),\n          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n      if (any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n\n      this._updateTransform(this._center, this._zoom);\n\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n          size = this._map.getSize(),\n          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n\n      var layer;\n      this._redrawBounds = null;\n\n      for (var id in this._layers) {\n        layer = this._layers[id];\n\n        layer._update();\n      }\n\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          container = this._container,\n          size = b.getSize(),\n          m = retina ? 2 : 1;\n      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina\n\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n\n      if (retina) {\n        this._ctx.scale(2, 2);\n      } // translate so we use the same path coordinates after canvas element moves\n\n\n      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves\n\n\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n\n      layer._project();\n\n      layer._update(); // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n\n\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n            dashArray = [],\n            dashValue,\n            i;\n\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths\n\n          if (isNaN(dashValue)) {\n            return;\n          }\n\n          dashArray.push(dashValue);\n        }\n\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n\n      this._extendRedrawBounds(layer);\n\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n\n        this._redrawBounds.max._ceil();\n      }\n\n      this._clear(); // clear layers in redraw bounds\n\n\n      this._draw(); // draw layers\n\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n      }\n    },\n    _draw: function () {\n      var layer,\n          bounds = this._redrawBounds;\n\n      this._ctx.save();\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.beginPath();\n\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n\n        this._ctx.clip();\n      }\n\n      this._drawing = true;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n\n      this._drawing = false;\n\n      this._ctx.restore(); // Restore state before clipping.\n\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n\n      var i,\n          j,\n          len2,\n          p,\n          parts = layer._parts,\n          len = parts.length,\n          ctx = this._ctx;\n\n      if (!len) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n\n      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n\n      var p = layer._point,\n          ctx = this._ctx,\n          r = Math.max(Math.round(layer._radius), 1),\n          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n      if (s !== 1) {\n        ctx.restore();\n      }\n\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n          layer,\n          clickedLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {\n          clickedLayer = layer;\n        }\n      }\n\n      if (clickedLayer) {\n        fakeStop(e);\n\n        this._fireEvent([clickedLayer], e);\n      }\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n\n      var point = this._map.mouseEventToLayerPoint(e);\n\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n\n        this._fireEvent([layer], e, 'mouseout');\n\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n\n      var layer, candidateHoveredLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n\n      if (this._hoveredLayer) {\n        this._fireEvent([this._hoveredLayer], e);\n      }\n\n      this._mouseHoverThrottled = true;\n      setTimeout(L.bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n\n      this._requestRedraw(layer);\n    }\n  }); // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n\n  function canvas$1(options) {\n    return canvas ? new Canvas(options) : null;\n  }\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      return function (name) {\n        return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n      };\n    }\n  }();\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n\n\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n\n      this._container.appendChild(container);\n\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n          fill = layer._fill,\n          options = layer.options,\n          container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n          r = Math.round(layer._radius),\n          r2 = Math.round(layer._radiusY || r);\n\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create$2 = vml ? vmlCreate : svgCreate;\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.zoomstart = this._onZoomStart;\n      return events;\n    },\n    _initContainer: function () {\n      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths\n\n      this._container.setAttribute('pointer-events', 'none');\n\n      this._rootGroup = create$2('g');\n\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _onZoomStart: function () {\n      // Drag-then-pinch interactions might mess up the center and zoom.\n      // In this case, the easiest way to prevent this is re-do the renderer\n      //   bounds and padding when the zooming starts.\n      this._update();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          size = b.getSize(),\n          container = this._container; // set size of svg-container if changed\n\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      } // movement: update container viewBox so that we don't have to change coordinates of individual layers\n\n\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n    _initPath: function (layer) {\n      var path = layer._path = create$2('path'); // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n\n      this._rootGroup.appendChild(layer._path);\n\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n          options = layer.options;\n\n      if (!path) {\n        return;\n      }\n\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n          r = Math.max(Math.round(layer._radius), 1),\n          r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs\n\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n\n  if (vml) {\n    SVG.include(vmlMixin);\n  } // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n\n\n  function svg$1(options) {\n    return svg || vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n\n      var renderer = this._paneRenderers[name];\n\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas$1(options) || svg$1(options);\n    }\n  });\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create$2;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      } // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n\n\n      this._clearDeferredResetState();\n\n      this._resetState();\n\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n\n        this._map.fire('boxzoomstart');\n      }\n\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n          size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n\n      this._finish();\n\n      if (!this._moved) {\n        return;\n      } // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n\n\n      this._clearDeferredResetState();\n\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n      }\n    }\n  }); // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n          oldZoom = map.getZoom(),\n          delta = map.options.zoomDelta,\n          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  }); // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map be draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default unless running on old Android devices.\n    inertia: !android23,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second.\n    inertiaDeceleration: 3400,\n    // px/s^2\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n\n      this._draggable.enable();\n\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n\n      map._stop();\n\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n\n      map.fire('movestart').fire('dragstart');\n\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n        this._positions.push(pos);\n\n        this._times.push(time);\n\n        this._prunePositions(time);\n      }\n\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n      var limit = this._offsetLimit;\n\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n          halfWidth = Math.round(worldWidth / 2),\n          dx = this._initialWorldOffset,\n          x = this._draggable._newPos.x,\n          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n          options = map.options,\n          noInertia = !options.inertia || this._times.length < 2;\n      map.fire('dragend', e);\n\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n\n        var direction = this._lastPos.subtract(this._positions[0]),\n            duration = (this._lastTime - this._times[0]) / 1000,\n            ease = options.easeLinearity,\n            speedVector = direction.multiplyBy(ease / duration),\n            speed = speedVector.distanceTo([0, 0]),\n            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  }); // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n\n  Map.addInitHook('addHandler', 'dragging', Drag);\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Keyboard Navigation Options\n\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n\n      this._setPanDelta(map.options.keyboardPanDelta);\n\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container; // make the container focusable by tabbing\n\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n\n      var body = document.body,\n          docEl = document.documentElement,\n          top = body.scrollTop || docEl.scrollTop,\n          left = body.scrollLeft || docEl.scrollLeft;\n\n      this._map._container.focus();\n\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      var key = e.keyCode,\n          map = this._map,\n          offset;\n\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n\n          map.panBy(offset);\n\n          if (map.options.maxBounds) {\n            map.panInsideBounds(map.options.maxBounds);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n\n      stop(e);\n    }\n  }); // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Mousewheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'mousewheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n          zoom = map.getZoom(),\n          snap = this._map.options.zoomSnap || 0;\n\n      map._stop(); // stop panning and fly animations if any\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n\n\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n\n      if (!delta) {\n        return;\n      }\n\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  }); // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n  /*\n   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tap: Boolean = true\n    // Enables mobile hacks for supporting instant taps (fixing 200ms click\n    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).\n    tap: true,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var Tap = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      if (!e.touches) {\n        return;\n      }\n\n      preventDefault(e);\n      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch\n\n      if (e.touches.length > 1) {\n        this._fireClick = false;\n        clearTimeout(this._holdTimeout);\n        return;\n      }\n\n      var first = e.touches[0],\n          el = first.target;\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it\n\n      if (el.tagName && el.tagName.toLowerCase() === 'a') {\n        addClass(el, 'leaflet-active');\n      } // simulate long hold but setting a timeout\n\n\n      this._holdTimeout = setTimeout(bind(function () {\n        if (this._isTapValid()) {\n          this._fireClick = false;\n\n          this._onUp();\n\n          this._simulateEvent('contextmenu', first);\n        }\n      }, this), 1000);\n\n      this._simulateEvent('mousedown', first);\n\n      on(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n    },\n    _onUp: function (e) {\n      clearTimeout(this._holdTimeout);\n      off(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n\n      if (this._fireClick && e && e.changedTouches) {\n        var first = e.changedTouches[0],\n            el = first.target;\n\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n          removeClass(el, 'leaflet-active');\n        }\n\n        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much\n\n\n        if (this._isTapValid()) {\n          this._simulateEvent('click', first);\n        }\n      }\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n\n      this._simulateEvent('mousemove', first);\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = document.createEvent('MouseEvents');\n      simulatedEvent._simulated = true;\n      e.target._simulatedClick = true;\n      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  }); // @section Handlers\n  // @property tap: Handler\n  // Mobile touch hacks (quick tap and touch hold) handler.\n\n  if (touch && !pointer) {\n    Map.addInitHook('addHandler', 'tap', Tap);\n  }\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers except for old Androids.\n    touchZoom: touch && !android23,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n\n      map._stop();\n\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n\n      var map = this._map,\n          p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]),\n          scale = p1.distanceTo(p2) / this._startDist;\n\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n\n      if (!this._moved) {\n        map._moveStart(true, false);\n\n        this._moved = true;\n      }\n\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      });\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'touchend', this._onTouchEnd); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  }); // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.Tap = Tap;\n  Map.TouchZoom = TouchZoom;\n  Object.freeze = freeze;\n  exports.version = version;\n  exports.Control = Control;\n  exports.control = control;\n  exports.Browser = Browser;\n  exports.Evented = Evented;\n  exports.Mixin = Mixin;\n  exports.Util = Util;\n  exports.Class = Class;\n  exports.Handler = Handler;\n  exports.extend = extend;\n  exports.bind = bind;\n  exports.stamp = stamp;\n  exports.setOptions = setOptions;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.PosAnimation = PosAnimation;\n  exports.Draggable = Draggable;\n  exports.LineUtil = LineUtil;\n  exports.PolyUtil = PolyUtil;\n  exports.Point = Point;\n  exports.point = toPoint;\n  exports.Bounds = Bounds;\n  exports.bounds = toBounds;\n  exports.Transformation = Transformation;\n  exports.transformation = toTransformation;\n  exports.Projection = index;\n  exports.LatLng = LatLng;\n  exports.latLng = toLatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.latLngBounds = toLatLngBounds;\n  exports.CRS = CRS;\n  exports.GeoJSON = GeoJSON;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.layerGroup = layerGroup;\n  exports.FeatureGroup = FeatureGroup;\n  exports.featureGroup = featureGroup;\n  exports.ImageOverlay = ImageOverlay;\n  exports.imageOverlay = imageOverlay;\n  exports.VideoOverlay = VideoOverlay;\n  exports.videoOverlay = videoOverlay;\n  exports.SVGOverlay = SVGOverlay;\n  exports.svgOverlay = svgOverlay;\n  exports.DivOverlay = DivOverlay;\n  exports.Popup = Popup;\n  exports.popup = popup;\n  exports.Tooltip = Tooltip;\n  exports.tooltip = tooltip;\n  exports.Icon = Icon;\n  exports.icon = icon;\n  exports.DivIcon = DivIcon;\n  exports.divIcon = divIcon;\n  exports.Marker = Marker;\n  exports.marker = marker;\n  exports.TileLayer = TileLayer;\n  exports.tileLayer = tileLayer;\n  exports.GridLayer = GridLayer;\n  exports.gridLayer = gridLayer;\n  exports.SVG = SVG;\n  exports.svg = svg$1;\n  exports.Renderer = Renderer;\n  exports.Canvas = Canvas;\n  exports.canvas = canvas$1;\n  exports.Path = Path;\n  exports.CircleMarker = CircleMarker;\n  exports.circleMarker = circleMarker;\n  exports.Circle = Circle;\n  exports.circle = circle;\n  exports.Polyline = Polyline;\n  exports.polyline = polyline;\n  exports.Polygon = Polygon;\n  exports.polygon = polygon;\n  exports.Rectangle = Rectangle;\n  exports.rectangle = rectangle;\n  exports.Map = Map;\n  exports.map = createMap;\n  var oldL = window.L;\n\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  }; // Always export us to window global (see #2364)\n\n\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvVXRpbC5qcz8yZTY0Iiwid2VicGFjazovLy8uLi9zcmMvY29yZS9DbGFzcy5qcz8wMWFjIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9FdmVudHMuanM/MTM2ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzPzE1NDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanM/MWM3OSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmdCb3VuZHMuanM/YjU3YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmcuanM/NWI2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLmpzP2IyY2QiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcz8xMDE5Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcz8xZTVlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanM/YzI1MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzP2YyMmUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanM/OTBjMSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvQnJvd3Nlci5qcz83ZGUzIiwid2VicGFjazovLy8uLi9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanM/ODY0NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanM/ZTc2ZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21VdGlsLmpzPzdjOTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kb20vRG9tRXZlbnQuanM/MWVhYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanM/YjZiMSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9NYXAuanM/NzNlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5qcz81MjkxIiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcz82NGQ0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanM/MTU1MCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcz84YzY0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzPzJjZDciLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb250cm9sL2luZGV4LmpzPzBjYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL0hhbmRsZXIuanM/NGU1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW5kZXguanM/ZTBlMCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9EcmFnZ2FibGUuanM/Y2NlYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L0xpbmVVdGlsLmpzPzE4N2EiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcz9kNTdlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanM/OWQ4NSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanM/YjJiYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzP2ZkYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcz8wYzNiIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanM/ZDk4MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcz85YmU4Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9pbmRleC5qcz82NmQ5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvTGF5ZXIuanM/NjcwMyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanM/N2Y2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcz8yNDRhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanM/MDU4OCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanM/MjdlNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcz8yZmI1Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcz8zZGQyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanM/MjQ4ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanM/OWQxYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcz85YzM3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanM/MjcyNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0dlb0pTT04uanM/YWFlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcz8wMTg5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzPzAzZTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9TVkdPdmVybGF5LmpzPzNjZjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzPzAwMjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9Qb3B1cC5qcz84ZTExIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVG9vbHRpcC5qcz8wZGIyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanM/ZTBkZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9pbmRleC5qcz84ZjM4Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanM/Mzg4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzPzI2MjAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanM/ZjllNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvaW5kZXguanM/NDI4YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcz8xMGVlIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcz9iOWViIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanM/YzkzNCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanM/Zjg0YiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcz81ZmE3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcz8wZDdhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzPzFlMTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9pbmRleC5qcz8xMjIyIiwid2VicGFjazovLy8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanM/ZTljYyIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanM/MDJkNSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzP2JjZDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanM/M2YzYiIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanM/MWYxNCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanM/OTFiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9pbmRleC5qcz8yMDUyIiwid2VicGFjazovLy8uLi9zcmMvTGVhZmxldC5qcz82YzExIl0sIm5hbWVzIjpbIlV0aWwuY3JlYXRlIiwiVXRpbC5leHRlbmQiLCJVdGlsLmlzQXJyYXkiLCJVdGlsLnNwbGl0V29yZHMiLCJVdGlsLmZhbHNlRm4iLCJVdGlsLmJpbmQiLCJVdGlsLnN0YW1wIiwiVXRpbC5mb3JtYXROdW0iLCJVdGlsLndyYXBOdW0iLCJCcm93c2VyLnN2ZyIsInN0eWxlIiwiQnJvd3Nlci5tc1BvaW50ZXIiLCJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsIkJyb3dzZXIucG9pbnRlciIsInRvdWNoIiwiQnJvd3Nlci5lZGdlIiwiQnJvd3Nlci5wYXNzaXZlRXZlbnRzIiwiY3JlYXRlIiwiVXRpbC50cmltIiwiQnJvd3Nlci5pZTNkIiwiQnJvd3Nlci5hbnkzZCIsIkRvbUV2ZW50Lm9uIiwiRG9tRXZlbnQub2ZmIiwiQnJvd3Nlci50b3VjaCIsIkJyb3dzZXIuY2hyb21lIiwiQnJvd3Nlci5hbmRyb2lkIiwiQnJvd3Nlci53aW4iLCJCcm93c2VyLmdlY2tvIiwiRG9tVXRpbC5nZXRQb3NpdGlvbiIsIlV0aWwucmVxdWVzdEFuaW1GcmFtZSIsIkRvbVV0aWwuc2V0UG9zaXRpb24iLCJVdGlsLmNhbmNlbEFuaW1GcmFtZSIsIlV0aWwuc2V0T3B0aW9ucyIsIkRvbVV0aWwuVFJBTlNJVElPTiIsIkJyb3dzZXIubW9iaWxlT3BlcmEiLCJEb21VdGlsLlRSQU5TSVRJT05fRU5EIiwiRG9tVXRpbC5hZGRDbGFzcyIsIkRvbVV0aWwucmVtb3ZlIiwiRG9tVXRpbC5jcmVhdGUiLCJEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uIiwiRG9tVXRpbC5nZXQiLCJCcm93c2VyLnJldGluYSIsIkJyb3dzZXIuaWVsdDkiLCJCcm93c2VyLnNhZmFyaSIsIkRvbVV0aWwuZ2V0U3R5bGUiLCJyZW1vdmUiLCJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwiRG9tRXZlbnQuc2tpcHBlZCIsIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCJVdGlsLmluZGV4T2YiLCJEb21VdGlsLnJlbW92ZUNsYXNzIiwiRG9tVXRpbC5UUkFOU0ZPUk0iLCJEb21VdGlsLnNldFRyYW5zZm9ybSIsIkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwiRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiRG9tRXZlbnQuc3RvcCIsIkRvbVV0aWwuZW1wdHkiLCJwcmV2ZW50T3V0bGluZSIsIkRvbVV0aWwuaGFzQ2xhc3MiLCJEb21VdGlsLmRpc2FibGVJbWFnZURyYWciLCJEb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uIiwiRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUiLCJEb21VdGlsLmdldFNjYWxlIiwiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCJEb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24iLCJMaW5lVXRpbC5fZ2V0Qml0Q29kZSIsIkxpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9pbnQiLCJsYXRMbmciLCJEb21VdGlsLnNldE9wYWNpdHkiLCJMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJMaW5lVXRpbC5pc0ZsYXQiLCJMaW5lVXRpbC5jbGlwU2VnbWVudCIsIkxpbmVVdGlsLnNpbXBsaWZ5IiwiTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIkxpbmVVdGlsLl9mbGF0IiwiUG9seVV0aWwuY2xpcFBvbHlnb24iLCJEb21VdGlsLnRvRnJvbnQiLCJEb21VdGlsLnRvQmFjayIsIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsIkJyb3dzZXIubW9iaWxlIiwiVXRpbC50aHJvdHRsZSIsImxhdExuZ0JvdW5kcyIsIkJyb3dzZXIuYW5kcm9pZDIzIiwiVXRpbC50ZW1wbGF0ZSIsIlV0aWwuZW1wdHlJbWFnZVVybCIsIkJyb3dzZXIuYW5kcm9pZFN0b2NrIiwiRG9tRXZlbnQuZmFrZVN0b3AiLCJjYW52YXMiLCJCcm93c2VyLmNhbnZhcyIsIkJyb3dzZXIudm1sIiwic3ZnIiwiRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFQUFBOzs7Ozs7RUFNTyxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBcEI7O0VBQ1AsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsVUFBVSxHQUFWLEVBQWU7SUFBRSxPQUFPLEdBQVA7RUFBYSxDQUE5QyxDOzs7O0VBSU8sU0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXNCO0lBQzVCLElBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLEVBQWUsR0FBZjs7SUFFQSxLQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxHQUFHLFNBQVMsQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsR0FBeEMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFrRDtNQUNqRCxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUQsQ0FBZjs7TUFDQSxLQUFLLENBQUwsSUFBVSxHQUFWLEVBQWU7UUFDZCxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsR0FBRyxDQUFDLENBQUQsQ0FBYjtNQUNBO0lBQ0Q7O0lBQ0QsT0FBTyxJQUFQO0VBQ0EsQzs7OztFQUlNLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFQLElBQWtCLFlBQVk7SUFDakQsU0FBUyxDQUFULEdBQWEsQ0FBRTs7SUFDZixPQUFPLFVBQVUsS0FBVixFQUFpQjtNQUN2QixDQUFDLENBQUMsU0FBRixHQUFjLEtBQWQ7TUFDQSxPQUFPLElBQUksQ0FBSixFQUFQO0lBQ0EsQ0FIRDtFQUlBLENBTm9DLEVBQTlCLEM7Ozs7O0VBV0EsU0FBUyxJQUFULENBQWMsRUFBZCxFQUFrQixHQUFsQixF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QUFlLFFBQWY7RUFFQSxHQUFHLENBQUMsZUFBSixHQUFzQixlQUF0QjtFQUVBLEdBQUcsQ0FBQyxHQUFKLEdBQVUsR0FBVjtFQUVBLEdBQUcsQ0FBQyxTQUFKLEdBQWdCLFNBQWhCO0VDWUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsTUFBaEIiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XHJcbk9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG5cdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZXN0O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbmV4cG9ydCB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbi8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdGlmIChmbi5iaW5kKSB7XHJcblx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHR9XHJcblxyXG5cdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHR9O1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuZXhwb3J0IHZhciBsYXN0SWQgPSAwO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5leHBvcnQgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK2xhc3RJZDtcclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbi8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbi8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4vLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHdyYXBwZXJGbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4vLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbi8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIGRpZ2l0cz86IE51bWJlcik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNiBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgZGlnaXRzKSB7XHJcblx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCAoZGlnaXRzID09PSB1bmRlZmluZWQgPyA2IDogZGlnaXRzKSk7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG5cdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0fVxyXG5cdHJldHVybiBvYmoub3B0aW9ucztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbi8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0fVxyXG5cdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG59XHJcblxyXG52YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3Xy1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbmV4cG9ydCB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdFV0aWwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKFV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBVdGlsLmlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuIiwiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG52YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG5cdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG5cdH0sXHJcblxyXG5cdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5leHBvcnQgdmFyIEVhcnRoID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG4iLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuaW1wb3J0IHtzdmdDcmVhdGV9IGZyb20gJy4uL2xheWVyL3ZlY3Rvci9TVkcuVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbmV4cG9ydCB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG5leHBvcnQgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4vLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4vLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuZXhwb3J0IHZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuZXhwb3J0IHZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47IGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbmV4cG9ydCB2YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG5leHBvcnQgdmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBjaHJvbWUgPSB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5leHBvcnQgdmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG5leHBvcnQgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuZXhwb3J0IHZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbmV4cG9ydCB2YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbmV4cG9ydCB2YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG5leHBvcnQgdmFyIHBvaW50ZXIgPSAhd2Via2l0ICYmICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxuZXhwb3J0IHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbmV4cG9ydCB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuLy8gQHByb3BlcnR5IHBhc3NpdmVFdmVudHM6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbmV4cG9ydCB2YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuXHR9XHJcblx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxufSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbmV4cG9ydCB2YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG5leHBvcnQgdmFyIHN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBzdmdDcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbmV4cG9ydCB2YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5cbnZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG52YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xudmFyIFRBR19XSElURV9MSVNUID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnT1BUSU9OJ107XG5cbnZhciBfcG9pbnRlcnMgPSB7fTtcbnZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbi8vIERvbUV2ZW50LkRvdWJsZVRhcCBuZWVkcyB0byBrbm93IGFib3V0IHRoaXNcbmV4cG9ydCB2YXIgX3BvaW50ZXJzQ291bnQgPSAwO1xuXG4vLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4vLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpIHtcblx0dmFyIGhhbmRsZXIgPSBvYmpbJ19sZWFmbGV0XycgKyB0eXBlICsgaWRdO1xuXG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbkRvd24gPSBVdGlsLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLk1TUE9JTlRFUl9UWVBFX01PVVNFICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdC8vIEluIElFMTEsIHNvbWUgdG91Y2ggZXZlbnRzIG5lZWRzIHRvIGZpcmUgZm9yIGZvcm0gY29udHJvbHMsIG9yXG5cdFx0XHQvLyB0aGUgY29udHJvbHMgd2lsbCBzdG9wIHdvcmtpbmcuIFdlIGtlZXAgYSB3aGl0ZWxpc3Qgb2YgdGFnIG5hbWVzIHRoYXRcblx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRpZiAoVEFHX1dISVRFX0xJU1QuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lKSA8IDApIHtcblx0XHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH0pO1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgb25Eb3duLCBmYWxzZSk7XG5cblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0X3BvaW50ZXJzQ291bnQrKztcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG5cdF9wb2ludGVyc0NvdW50LS07XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpIHtcblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBvbk1vdmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25VcCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG59XG5cbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtfcG9pbnRlcnNDb3VudH0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG52YXIgX3RvdWNoc3RhcnQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCc7XHJcbnZhciBfdG91Y2hlbmQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBCcm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCc7XHJcbnZhciBfcHJlID0gJ19sZWFmbGV0Xyc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdHZhciBsYXN0LCB0b3VjaCxcclxuXHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0aWYgKCghQnJvd3Nlci5lZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRjb3VudCA9IF9wb2ludGVyc0NvdW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHQgICAgZGVsdGEgPSBub3cgLSAobGFzdCB8fCBub3cpO1xyXG5cclxuXHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRpZiAoKCFCcm93c2VyLmVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG5cdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdHByb3AgPSB0b3VjaFtpXTtcclxuXHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG91Y2ggPSBuZXdUb3VjaDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0dG91Y2guYnV0dG9uID0gMDtcclxuXHRcdFx0aGFuZGxlcih0b3VjaCk7XHJcblx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblx0b2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdID0gaGFuZGxlcjtcclxuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdC8vIE9uIHNvbWUgcGxhdGZvcm1zIChub3RhYmx5LCBjaHJvbWU8NTUgb24gd2luMTAgKyB0b3VjaHNjcmVlbiArIG1vdXNlKSxcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdC8vIEVkZ2UgMTQgYWxzbyBmaXJlcyBuYXRpdmUgZGJsY2xpY2tzLCBidXQgb25seSBmb3IgcG9pbnRlclR5cGUgbW91c2UsIHNlZSAjNTE4MC5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCkge1xyXG5cdHZhciB0b3VjaHN0YXJ0ID0gb2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSxcclxuXHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcclxuXHQgICAgZGJsY2xpY2sgPSBvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0aWYgKCFCcm93c2VyLmVkZ2UpIHtcclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbmV4cG9ydCB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcblx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcblx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldChpZCkge1xyXG5cdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcblx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQpIHtcclxuXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdH1cclxuXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBVdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIFV0aWwudHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG5cdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWR0VsZW1lbnRJbnN0YW5jZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nRWxlbWVudCBpbnN0ZWFkXHJcblx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG5cdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG5cdFx0ZWwgPSBlbC5jb3JyZXNwb25kaW5nRWxlbWVudDtcclxuXHR9XHJcblx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbi8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4vLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG5cdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG5cdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdHRyeSB7XHJcblx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdH1cclxuXHJcblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0aWYgKGZpbHRlcikge1xyXG5cdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4vLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbi8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbi8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4vLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4vLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbi8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG5cdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG5cdFx0KEJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4vLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4vLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4vLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcblx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4vLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG5leHBvcnQgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBfdXNlclNlbGVjdDtcclxuaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG5cdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4vLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxudmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4vLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcblx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0cmVzdG9yZU91dGxpbmUoKTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XHJcblx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG5cdGRvIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcblx0cmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbi8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG5cdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcblx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcblx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3RcclxuXHR9O1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7YWRkUG9pbnRlckxpc3RlbmVyLCByZW1vdmVQb2ludGVyTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcbmltcG9ydCB7YWRkRG91YmxlVGFwTGlzdGVuZXIsIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LkRvdWJsZVRhcCc7XHJcbmltcG9ydCB7Z2V0U2NhbGV9IGZyb20gJy4vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiBhZGREb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHQvLyBDaHJvbWUgPjU1IGRvZXMgbm90IG5lZWQgdGhlIHN5bnRoZXRpYyBkYmxjbGlja3MgZnJvbSBhZGREb3VibGVUYXBMaXN0ZW5lclxyXG5cdFx0Ly8gU2VlICM1MTgwXHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIgJiZcclxuXHQgICAgICAgICAgICEoQnJvd3Nlci5wb2ludGVyICYmIEJyb3dzZXIuY2hyb21lKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOlxyXG5cdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHRza2lwcGVkKGUpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ21vdXNld2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICdtb3VzZXdoZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGUpIHtcclxuXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcblx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG5cdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcblx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuXHQpO1xyXG59XHJcblxyXG4vLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4vLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci53aW4gJiYgQnJvd3Nlci5jaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbnZhciBza2lwRXZlbnRzID0ge307XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBza2lwcGVkKGUpIHtcclxuXHR2YXIgZXZlbnRzID0gc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0cmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbnZhciBsYXN0Q2xpY2s7XHJcblxyXG4vLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcbmZ1bmN0aW9uIGZpbHRlckNsaWNrKGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdCAgICBlbGFwc2VkID0gbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBsYXN0Q2xpY2spO1xyXG5cclxuXHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdC8vIG9uIHRoZSBzYW1lIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZmFyIGZhc3RlcjtcclxuXHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRzdG9wKGUpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRsYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdGhhbmRsZXIoZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuZXhwb3J0IHZhciBQb3NBbmltYXRpb24gPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb3NBbmltYXRpb259IGZyb20gJy4uL2RvbS9Qb3NBbmltYXRpb24nO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcCA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBFUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgaGlnaGVzdCBvZiB0aGVpciBgbWF4Wm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuXHRcdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdG8gYXNzaWduIGludGVybmFsIGZsYWdzIGF0IHRoZSBiZWdpbm5pbmcsXHJcblx0XHQvLyB0byBhdm9pZCBpbmNvbnNpc3RlbnQgc3RhdGUgaW4gc29tZSBlZGdlIGNhc2VzLlxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBVdGlsLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBEb21VdGlsLlRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHREb21FdmVudC5vbih0aGlzLl9wcm94eSwgRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG5cdC8vIGBwYWRkaW5nYCwgYHBhZGRpbmdUb3BMZWZ0YCBhbmQgYHBhZGRpbmdUb3BSaWdodGAgb3B0aW9ucyB0byBmaXRcclxuXHQvLyB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLCBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QoY2VudGVyKSxcclxuXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgaGFsZlBpeGVsQm91bmRzID0gcGl4ZWxCb3VuZHMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHBhZGRlZEJvdW5kcyA9IHRvQm91bmRzKFtwaXhlbEJvdW5kcy5taW4uYWRkKHBhZGRpbmdUTCksIHBpeGVsQm91bmRzLm1heC5zdWJ0cmFjdChwYWRkaW5nQlIpXSk7XHJcblxyXG5cdFx0aWYgKCFwYWRkZWRCb3VuZHMuY29udGFpbnMocGl4ZWxQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGRpZmYgPSBwaXhlbENlbnRlci5zdWJ0cmFjdChwaXhlbFBvaW50KSxcclxuXHRcdFx0ICAgIG5ld0NlbnRlciA9IHRvUG9pbnQocGl4ZWxQb2ludC54ICsgZGlmZi54LCBwaXhlbFBvaW50LnkgKyBkaWZmLnkpO1xyXG5cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueCA8IHBhZGRlZEJvdW5kcy5taW4ueCB8fCBwaXhlbFBvaW50LnggPiBwYWRkZWRCb3VuZHMubWF4LngpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueCA9IHBpeGVsQ2VudGVyLnggLSBkaWZmLng7XHJcblx0XHRcdFx0aWYgKGRpZmYueCA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci54ICs9IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci54IC09IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ0JSLng7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwaXhlbFBvaW50LnkgPCBwYWRkZWRCb3VuZHMubWluLnkgfHwgcGl4ZWxQb2ludC55ID4gcGFkZGVkQm91bmRzLm1heC55KSB7XHJcblx0XHRcdFx0bmV3Q2VudGVyLnkgPSBwaXhlbENlbnRlci55IC0gZGlmZi55O1xyXG5cdFx0XHRcdGlmIChkaWZmLnkgPiAwKSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueSArPSBoYWxmUGl4ZWxCb3VuZHMueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueSAtPSBoYWxmUGl4ZWxCb3VuZHMueSAtIHBhZGRpbmdCUi55O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KG5ld0NlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX3BhbmVzID0gW107XHJcblx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcblx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG5cdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBVdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSlcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuXHRcdC8vIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuXHRcdC8vIGZseSBhbmltYXRpb25zLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RvcHBlZFxyXG5cdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IERvbUV2ZW50Lm9mZiA6IERvbUV2ZW50Lm9uO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHQvLyBAZXZlbnQga2V5ZG93bjogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG5cdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcblx0XHQvLyB0aGF0IGRvIG5vdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBEb21FdmVudC5za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnIHx8IHR5cGUgPT09ICdrZXl1cCcgfHwgdHlwZSA9PT0gJ2tleWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIHRhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBVdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgVXRpbC5pbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG5cdFx0XSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHR2YXIgcHJvcCA9IERvbVV0aWwuVFJBTlNGT1JNLFxyXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xyXG5cdH0sXHJcblxyXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XHJcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tKTtcclxuXHJcblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0NsYXNzfSBmcm9tICcuLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIERvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIgb3IgdG91Y2guXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcblx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcblx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcblx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG5cdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG5cdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG5cdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gRG9tVXRpbC5jcmVhdGUoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzXycgKyBVdGlsLnN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnJiN4MjIxMjsnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcbiIsImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFNUQVJUID0gQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxudmFyIEVORCA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxufTtcclxudmFyIE1PVkUgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxufTtcclxuXHJcblxyXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuXHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChEb21VdGlsLmhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBNT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIHBhcmVudCBjb250YWluZXIncyBwb3NpdGlvbiwgYm9yZGVyIGFuZCBzY2FsZSBkbyBub3QgY2hhbmdlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRyYWcuXHJcblx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXHJcblx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcblx0XHRvZmZzZXQueCAvPSB0aGlzLl9wYXJlbnRTY2FsZS54O1xyXG5cdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcclxuXHJcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKCh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSAmJiAodGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59KTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlsaW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG4vLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbi8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4vLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4vLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4vLyBbRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4vLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbi8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcbi8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxufVxyXG5cclxuLy8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi9MaW5lVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxuXG4gKi9cblxuZXhwb3J0IHtMb25MYXR9IGZyb20gJy4vUHJvamVjdGlvbi5Mb25MYXQnO1xuZXhwb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcbmV4cG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVQU0czMzk1ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqXHJcbiAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0c0MzI2ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5leHBvcnQgdmFyIFNpbXBsZSA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGUuZy4gXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLiBJdCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEgYW5kIGlzIG9mdGVuIGEgbGVnYWwgb2JsaWdhdGlvbiB0b3dhcmRzIGNvcHlyaWdodCBob2xkZXJzIGFuZCB0aWxlIHByb3ZpZGVycy5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoVXRpbC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuLi8uLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtzZXRPcHRpb25zfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtyZXRpbmF9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHRvb2x0aXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG5cdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBwb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBwb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIHJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG5cdFx0aWYgKHBhdGggPT09IG51bGwgfHwgcGF0aC5pbmRleE9mKCd1cmwnKSAhPT0gMCkge1xuXHRcdFx0cGF0aCA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9edXJsXFwoW1wiJ10/LywgJycpLnJlcGxhY2UoL21hcmtlci1pY29uXFwucG5nW1wiJ10/XFwpJC8sICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fVxufSk7XG4iLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmNsb3NlUG9wdXAoKVxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xyXG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMFxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0SWNvbjogSWNvblxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fSxcclxuXHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5leHBvcnQgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgc3R5bGUuaGFzT3duUHJvcGVydHkoJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgdGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2U7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRWFydGgnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuXHQvLyBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGBwYCBvbiB0aGUgUG9seWxpbmUuXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG5cdFx0ICAgIGNsb3Nlc3QgPSBMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IExpbmVVdGlsLmlzRmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHMoW1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuXHRcdF0pO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdGlmIChMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IExpbmVVdGlsLl9mbGF0O1xuIiwiaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCAqIGFzIFBvbHlVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvbHlVdGlsJztcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFBvbHlnb24gPSBQb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXIsXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbal07XG5cblx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcblx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG5cdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhID09PSAwKSB7XG5cdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBQb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge01hcmtlcn0gZnJvbSAnLi9tYXJrZXIvTWFya2VyJztcclxuaW1wb3J0IHtDaXJjbGV9IGZyb20gJy4vdmVjdG9yL0NpcmNsZSc7XHJcbmltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGVNYXJrZXInO1xyXG5pbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL3ZlY3Rvci9Qb2x5bGluZSc7XHJcbmltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi92ZWN0b3IvUG9seWdvbic7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcblx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcblx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQpIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29vcmRzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG5leHBvcnQgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcblx0Ly8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcblx0Ly8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuZXhwb3J0IHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnSU1HJztcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCdpbWcnKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdGltZy5vbmxvYWQgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cdFx0aW1nLm9uZXJyb3IgPSBVdGlsLmJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQGV2ZW50IGVycm9yOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcblx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuXHRcdGxvb3A6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG5cdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gQnJvd3NlciBjb21wYXRpYmlsaXR5LSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdFxyXG5cdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgdmlkLnN0eWxlLmhhc093blByb3BlcnR5KCdvYmplY3RGaXQnKSkgeyB2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnOyB9XHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblx0fVxuXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbi8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuZXhwb3J0IGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERpdk92ZXJsYXlcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gcG9wdXAgbGlrZSBwbHVnaW5zLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5leHBvcnQgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKERvbVV0aWwucmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHBvcHVwLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cC5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIHBvcHVwLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIHBvcHVwLlxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIEFsaWFzIGZvciBbZ2V0Q29udGVudCgpXSgjcG9wdXAtZ2V0Y29udGVudClcclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgcG9wdXAgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgcG9wdXAgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIHBvcHVwIGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCBpbiBmcm9udCBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKHBhcmVudCwgbGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcclxuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XHJcblx0XHRcdGxheWVyID0gcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiBwYXJlbnQuX2xheWVycykge1xyXG5cdFx0XHRcdGxheWVyID0gcGFyZW50Ll9sYXllcnNbaWRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0aWYgKGxheWVyLmdldENlbnRlcikge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsYXRsbmc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQYXRofSBmcm9tICcuL3ZlY3Rvci9QYXRoJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuZXhwb3J0IHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0RG9tRXZlbnQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IERvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KERvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFBvcHVwKSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3BvcHVwLl9wcmVwYXJlT3Blbih0aGlzLCBsYXllciwgbGF0bG5nKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG4iLCJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuZXhwb3J0IHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgZXZlbnRzLlxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmIChCcm93c2VyLnRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludCgtdG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCAtdG9vbHRpcEhlaWdodCArIG9mZnNldC55ICsgYW5jaG9yLnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludChvZmZzZXQueCArIGFuY2hvci54LCBhbmNob3IueSAtIHRvb2x0aXBIZWlnaHQgLyAyICsgb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoICsgYW5jaG9yLnggLSBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSAtIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUb29sdGlwKSB7XG5cdFx0XHRVdGlsLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcblx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl9tYXApIHtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IFV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BhcXVlVGlsZTogVXRpbC5mYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbShNYXRoLnJvdW5kKHpvb20pKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIGxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuXHRcdHJldHVybiBbbncsIHNlXTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChCcm93c2VyLmFuZHJvaWQgJiYgIUJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICdNYXAgZGF0YSAmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL1wiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycywgPGEgaHJlZj1cImh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8yLjAvXCI+Q0MtQlktU0E8L2E+J30pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIFV0aWwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0LypcclxuXHRcdCBTZXQgcm9sZT1cInByZXNlbnRhdGlvblwiIHRvIGZvcmNlIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGlzXHJcblx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcblx0XHQqL1xyXG5cdFx0dGlsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIFV0aWwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuXHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbSxcclxuXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG5cdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdGlmICh6b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHpvb20gKyB6b29tT2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IFV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQ2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxyXG5cdFx0Ly8gdW5sZXNzIHdlJ3JlIG9uIEFuZHJvaWQncyBzdG9jayBicm93c2VyLFxyXG5cdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWRTdG9jaykge1xyXG5cdFx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiZXhwb3J0IHtHcmlkTGF5ZXIsIGdyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNU30gZnJvbSAnLi9UaWxlTGF5ZXIuV01TJztcblRpbGVMYXllci5XTVMgPSBUaWxlTGF5ZXJXTVM7XG50aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuZXhwb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn07XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMSxcblxuXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIGNsaWNrIHRvbGVyYW5jZSByb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXBcblx0XHR0b2xlcmFuY2UgOiAwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0VXRpbC5zdGFtcCh0aGlzKTtcblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGRhc2hWYWx1ZSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG5cdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG5cdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaWNrZWRMYXllcikgIHtcblx0XHRcdERvbUV2ZW50LmZha2VTdG9wKGUpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZUhvdmVyZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgIT09IHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cblx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9LCB0aGlzKSwgMzIpO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxuZXhwb3J0IHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5leHBvcnQgdmFyIHZtbE1peGluID0ge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0RG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBVdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7c3RhbXB9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3N2Z0NyZWF0ZSwgcG9pbnRzVG9QYXRofSBmcm9tICcuL1NWRy5VdGlsJztcbmV4cG9ydCB7cG9pbnRzVG9QYXRofTtcbmltcG9ydCB7dm1sTWl4aW4sIHZtbENyZWF0ZX0gZnJvbSAnLi9TVkcuVk1MJztcblxuZXhwb3J0IHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uLy4uL21hcC9NYXAnO1xuaW1wb3J0IHtjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7c3ZnfSBmcm9tICcuL1NWRyc7XG5cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG5cdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6IG5hbWV9KTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9jcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKG9wdGlvbnMpKSB8fCBzdmcob3B0aW9ucyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuIiwiZXhwb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5leHBvcnQge0xheWVyR3JvdXAsIGxheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XG5leHBvcnQge0ZlYXR1cmVHcm91cCwgZmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5pbXBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb24sIGdlb21ldHJ5VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIGNvb3Jkc1RvTGF0TG5ncywgbGF0TG5nVG9Db29yZHMsIGxhdExuZ3NUb0Nvb3JkcywgZ2V0RmVhdHVyZSwgYXNGZWF0dXJlfSBmcm9tICcuL0dlb0pTT04nO1xuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbkdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3Jkcztcbkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbkdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuZXhwb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29ufTtcblxuZXhwb3J0IHtJbWFnZU92ZXJsYXksIGltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuZXhwb3J0IHtWaWRlb092ZXJsYXksIHZpZGVvT3ZlcmxheX0gZnJvbSAnLi9WaWRlb092ZXJsYXknO1xuZXhwb3J0IHtTVkdPdmVybGF5LCBzdmdPdmVybGF5fSBmcm9tICcuL1NWR092ZXJsYXknO1xuXG5leHBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5leHBvcnQge1BvcHVwLCBwb3B1cH0gZnJvbSAnLi9Qb3B1cCc7XG5leHBvcnQge1Rvb2x0aXAsIHRvb2x0aXB9IGZyb20gJy4vVG9vbHRpcCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vbWFya2VyL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdGlsZS9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3ZlY3Rvci9pbmRleCc7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmUpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcblx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcblx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG5cdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgRG91YmxlQ2xpY2tab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy9cbi8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gYGBganNcbi8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuLy8gYGBgXG4vL1xuLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuLy8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGJlIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0IHVubGVzcyBydW5uaW5nIG9uIG9sZCBBbmRyb2lkIGRldmljZXMuXG5cdGluZXJ0aWE6ICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbmV4cG9ydCB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSBsYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG5cdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRtYXBcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcblx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucyh0aW1lKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9wcnVuZVBvc2l0aW9uczogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR3aGlsZSAodGhpcy5fcG9zaXRpb25zLmxlbmd0aCA+IDEgJiYgdGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtvbiwgb2ZmLCBzdG9wfSBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5leHBvcnQgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRvbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBNb3VzZXdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IERvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcDogQm9vbGVhbiA9IHRydWVcblx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcblx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHR0YXA6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuZXhwb3J0IHZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKEJyb3dzZXIudG91Y2ggJiYgIUJyb3dzZXIucG9pbnRlcikge1xuXHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwJywgVGFwKTtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IHtCb3hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkJveFpvb20nO1xuTWFwLkJveFpvb20gPSBCb3hab29tO1xuaW1wb3J0IHtEb3VibGVDbGlja1pvb219IGZyb20gJy4vaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tJztcbk1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG5pbXBvcnQge0RyYWd9IGZyb20gJy4vaGFuZGxlci9NYXAuRHJhZyc7XG5NYXAuRHJhZyA9IERyYWc7XG5pbXBvcnQge0tleWJvYXJkfSBmcm9tICcuL2hhbmRsZXIvTWFwLktleWJvYXJkJztcbk1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuaW1wb3J0IHtTY3JvbGxXaGVlbFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tJztcbk1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG5pbXBvcnQge1RhcH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXAnO1xuTWFwLlRhcCA9IFRhcDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIiwiXHJcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcclxuZXhwb3J0IHt2ZXJzaW9ufTtcclxuXHJcbi8vIGNvbnRyb2xcclxuZXhwb3J0ICogZnJvbSAnLi9jb250cm9sL2luZGV4JztcclxuXHJcbi8vIGNvcmVcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4JztcclxuXHJcbi8vIGRvbVxyXG5leHBvcnQgKiBmcm9tICcuL2RvbS9pbmRleCc7XHJcblxyXG4vLyBnZW9tZXRyeVxyXG5leHBvcnQgKiBmcm9tICcuL2dlb21ldHJ5L2luZGV4JztcclxuXHJcbi8vIGdlb1xyXG5leHBvcnQgKiBmcm9tICcuL2dlby9pbmRleCc7XHJcblxyXG4vLyBsYXllclxyXG5leHBvcnQgKiBmcm9tICcuL2xheWVyL2luZGV4JztcclxuXHJcbi8vIG1hcFxyXG5leHBvcnQgKiBmcm9tICcuL21hcC9pbmRleCc7XHJcblxyXG5pbXBvcnQge2ZyZWV6ZX0gZnJvbSAnLi9jb3JlL1V0aWwnO1xyXG5PYmplY3QuZnJlZXplID0gZnJlZXplO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},26:function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzFkZTUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVybCIsIm9wdGlvbnMiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInRlc3QiLCJzbGljZSIsImhhc2giLCJuZWVkUXVvdGVzIiwiY29uY2F0IiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7RUFDdkMsSUFBSSxDQUFDQSxPQUFMLEVBQWM7SUFDWjtJQUNBQSxPQUFPLEdBQUcsRUFBVjtFQUNELENBSnNDLENBSXJDOzs7RUFHRkQsR0FBRyxHQUFHQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0UsVUFBWCxHQUF3QkYsR0FBRyxDQUFDRyxPQUE1QixHQUFzQ0gsR0FBNUM7O0VBRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7SUFDM0IsT0FBT0EsR0FBUDtFQUNELENBWHNDLENBV3JDOzs7RUFHRixJQUFJLGVBQWVJLElBQWYsQ0FBb0JKLEdBQXBCLENBQUosRUFBOEI7SUFDNUI7SUFDQUEsR0FBRyxHQUFHQSxHQUFHLENBQUNLLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLENBQU47RUFDRDs7RUFFRCxJQUFJSixPQUFPLENBQUNLLElBQVosRUFBa0I7SUFDaEI7SUFDQU4sR0FBRyxJQUFJQyxPQUFPLENBQUNLLElBQWY7RUFDRCxDQXRCc0MsQ0FzQnJDO0VBQ0Y7OztFQUdBLElBQUksY0FBY0YsSUFBZCxDQUFtQkosR0FBbkIsS0FBMkJDLE9BQU8sQ0FBQ00sVUFBdkMsRUFBbUQ7SUFDakQsT0FBTyxLQUFLQyxNQUFMLENBQVlSLEdBQUcsQ0FBQ1MsT0FBSixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUJBLE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLENBQVosRUFBNEQsSUFBNUQsQ0FBUDtFQUNEOztFQUVELE9BQU9ULEdBQVA7QUFDRCxDQS9CRCIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIHVybCA9IHVybCAmJiB1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},3:function(module,exports,__webpack_require__){"use strict";eval('\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sIm1hcHBpbmdzIjoiQUFBYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVVDLFlBQVYsRUFBd0I7RUFDdkMsSUFBSUMsSUFBSSxHQUFHLEVBQVgsQ0FEdUMsQ0FDeEI7O0VBRWZBLElBQUksQ0FBQ0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0lBQ2xDLE9BQU8sS0FBS0MsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7TUFDOUIsSUFBSUMsT0FBTyxHQUFHQyxzQkFBc0IsQ0FBQ0YsSUFBRCxFQUFPSixZQUFQLENBQXBDOztNQUVBLElBQUlJLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtRQUNYLE9BQU8sVUFBVUcsTUFBVixDQUFpQkgsSUFBSSxDQUFDLENBQUQsQ0FBckIsRUFBMEIsSUFBMUIsRUFBZ0NHLE1BQWhDLENBQXVDRixPQUF2QyxFQUFnRCxHQUFoRCxDQUFQO01BQ0Q7O01BRUQsT0FBT0EsT0FBUDtJQUNELENBUk0sRUFRSkcsSUFSSSxDQVFDLEVBUkQsQ0FBUDtFQVNELENBVkQsQ0FIdUMsQ0FhcEM7RUFDSDs7O0VBR0FQLElBQUksQ0FBQ1EsQ0FBTCxHQUFTLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxNQUEvQixFQUF1QztJQUM5QyxJQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7TUFDL0I7TUFDQUEsT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWO0lBQ0Q7O0lBRUQsSUFBSUcsc0JBQXNCLEdBQUcsRUFBN0I7O0lBRUEsSUFBSUQsTUFBSixFQUFZO01BQ1YsS0FBSyxJQUFJSCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtLLE1BQXpCLEVBQWlDTCxDQUFDLEVBQWxDLEVBQXNDO1FBQ3BDO1FBQ0EsSUFBSU0sRUFBRSxHQUFHLEtBQUtOLENBQUwsRUFBUSxDQUFSLENBQVQ7O1FBRUEsSUFBSU0sRUFBRSxJQUFJLElBQVYsRUFBZ0I7VUFDZEYsc0JBQXNCLENBQUNFLEVBQUQsQ0FBdEIsR0FBNkIsSUFBN0I7UUFDRDtNQUNGO0lBQ0Y7O0lBRUQsS0FBSyxJQUFJQyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHTixPQUFPLENBQUNJLE1BQTlCLEVBQXNDRSxFQUFFLEVBQXhDLEVBQTRDO01BQzFDLElBQUlaLElBQUksR0FBRyxHQUFHRyxNQUFILENBQVVHLE9BQU8sQ0FBQ00sRUFBRCxDQUFqQixDQUFYOztNQUVBLElBQUlKLE1BQU0sSUFBSUMsc0JBQXNCLENBQUNULElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7UUFDN0M7UUFDQTtNQUNEOztNQUVELElBQUlPLFVBQUosRUFBZ0I7UUFDZCxJQUFJLENBQUNQLElBQUksQ0FBQyxDQUFELENBQVQsRUFBYztVQUNaQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVVPLFVBQVY7UUFDRCxDQUZELE1BRU87VUFDTFAsSUFBSSxDQUFDLENBQUQsQ0FBSixHQUFVLEdBQUdHLE1BQUgsQ0FBVUksVUFBVixFQUFzQixPQUF0QixFQUErQkosTUFBL0IsQ0FBc0NILElBQUksQ0FBQyxDQUFELENBQTFDLENBQVY7UUFDRDtNQUNGOztNQUVESCxJQUFJLENBQUNnQixJQUFMLENBQVViLElBQVY7SUFDRDtFQUNGLENBckNEOztFQXVDQSxPQUFPSCxJQUFQO0FBQ0QsQ0F6REQ7O0FBMkRBLFNBQVNLLHNCQUFULENBQWdDRixJQUFoQyxFQUFzQ0osWUFBdEMsRUFBb0Q7RUFDbEQsSUFBSUssT0FBTyxHQUFHRCxJQUFJLENBQUMsQ0FBRCxDQUFKLElBQVcsRUFBekIsQ0FEa0QsQ0FDckI7O0VBRTdCLElBQUljLFVBQVUsR0FBR2QsSUFBSSxDQUFDLENBQUQsQ0FBckI7O0VBRUEsSUFBSSxDQUFDYyxVQUFMLEVBQWlCO0lBQ2YsT0FBT2IsT0FBUDtFQUNEOztFQUVELElBQUlMLFlBQVksSUFBSSxPQUFPbUIsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtJQUM5QyxJQUFJQyxhQUFhLEdBQUdDLFNBQVMsQ0FBQ0gsVUFBRCxDQUE3QjtJQUNBLElBQUlJLFVBQVUsR0FBR0osVUFBVSxDQUFDSyxPQUFYLENBQW1CcEIsR0FBbkIsQ0FBdUIsVUFBVXFCLE1BQVYsRUFBa0I7TUFDeEQsT0FBTyxpQkFBaUJqQixNQUFqQixDQUF3QlcsVUFBVSxDQUFDTyxVQUFYLElBQXlCLEVBQWpELEVBQXFEbEIsTUFBckQsQ0FBNERpQixNQUE1RCxFQUFvRSxLQUFwRSxDQUFQO0lBQ0QsQ0FGZ0IsQ0FBakI7SUFHQSxPQUFPLENBQUNuQixPQUFELEVBQVVFLE1BQVYsQ0FBaUJlLFVBQWpCLEVBQTZCZixNQUE3QixDQUFvQyxDQUFDYSxhQUFELENBQXBDLEVBQXFEWixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0VBQ0Q7O0VBRUQsT0FBTyxDQUFDSCxPQUFELEVBQVVHLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDRCxDLENBQUM7OztBQUdGLFNBQVNhLFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0VBQzVCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlTCxTQUFmLENBQUQsQ0FBbkIsQ0FBVCxDQUFqQjtFQUNBLElBQUlNLElBQUksR0FBRywrREFBK0R6QixNQUEvRCxDQUFzRW9CLE1BQXRFLENBQVg7RUFDQSxPQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')}}]);