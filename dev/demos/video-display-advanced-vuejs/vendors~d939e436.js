(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{173:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(174);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(4).default\nvar update = add(\"52f15586\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzP2U1ZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBOEM7QUFDcEU7QUFDQSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQWdEO0FBQ2xFLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjE3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI1MmYxNTU4NlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xlYWZsZXQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///173\n")},174:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(25);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(175);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(176);\nvar ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(177);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\n// Module\nexports.push([module.i, "/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\"stretching\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg,\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: pan-x pan-y;\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t-ms-touch-action: pinch-zoom;\\r\\n\\t/* Fallback for FF which doesn\'t support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: none;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-tile {\\r\\n\\twill-change: opacity;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\t-webkit-transition: opacity 0.2s linear;\\r\\n\\t   -moz-transition: opacity 0.2s linear;\\r\\n\\t        transition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t    -ms-transform-origin: 0 0;\\r\\n\\t        transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\t-webkit-transition: none;\\r\\n\\t   -moz-transition: none;\\r\\n\\t        transition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:    -moz-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:    -moz-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline: 0;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-active {\\r\\n\\toutline: 2px solid orange;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont: 12px/1.5 \\"Helvetica Neue\\", Arial, Helvetica, sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px \'Lucida Console\', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.7);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-control-attribution,\\r\\n.leaflet-container .leaflet-control-scale {\\r\\n\\tfont-size: 11px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\tfont-size: 11px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 19px;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 18px 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\r\\n\\t-webkit-transform: rotate(45deg);\\r\\n\\t   -moz-transform: rotate(45deg);\\r\\n\\t    -ms-transform: rotate(45deg);\\r\\n\\t        transform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tpadding: 4px 4px 0 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 18px;\\r\\n\\theight: 14px;\\r\\n\\tfont: 16px/14px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #c3c3c3;\\r\\n\\ttext-decoration: none;\\r\\n\\tfont-weight: bold;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover {\\r\\n\\tcolor: #999;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\tzoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip-container {\\r\\n\\tmargin-top: -1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-clickable {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\"\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzRmODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRixzQ0FBc0MsbUJBQU8sQ0FBQyxFQUF5QztBQUN2RixvQ0FBb0MsbUJBQU8sQ0FBQyxHQUFxQjtBQUNqRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUF3QjtBQUNwRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFTLHNRQUFzUSx5QkFBeUIsY0FBYyxhQUFhLE9BQU8sd0JBQXdCLHVCQUF1QixPQUFPLHVFQUF1RSxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsT0FBTyxxRkFBcUYsOEJBQThCLEtBQUssMkhBQTJILGlEQUFpRCxPQUFPLHlIQUF5SCxvQkFBb0IscUJBQXFCLG9DQUFvQyxPQUFPLHFEQUFxRCxxQkFBcUIsT0FBTyxtZEFBbWQsaUNBQWlDLGtDQUFrQyxPQUFPLCtDQUErQyxvQ0FBb0MsZ0NBQWdDLE9BQU8sMkNBQTJDLG1DQUFtQyxxRkFBcUYsK0JBQStCLEtBQUssOERBQThELDZCQUE2Qix5QkFBeUIsS0FBSyx3QkFBd0IsK0NBQStDLEtBQUssMEJBQTBCLDJEQUEyRCxLQUFLLG1CQUFtQixzQkFBc0IseUJBQXlCLE9BQU8sMEJBQTBCLDBCQUEwQixPQUFPLHVCQUF1QixlQUFlLGdCQUFnQixrQ0FBa0Msa0NBQWtDLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTywrQkFBK0IsY0FBYyxFQUFFLCtCQUErQixjQUFjLEVBQUUsMkJBQTJCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLDJCQUEyQixjQUFjLEVBQUUsNkJBQTZCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsOEJBQThCLGNBQWMsRUFBRSw0QkFBNEIsaUJB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Z0NBQWdDLE9BQU8sMkJBQTJCLHdCQUF3QixLQUFLLDRCQUE0Qix1QkFBdUIsS0FBSyxvRUFBb0UsZUFBZSx1QkFBdUIsT0FBTyxrQ0FBa0MsZUFBZSwwQkFBMEIsOEJBQThCLE9BQU8sbUNBQW1DLGNBQWMseUJBQXlCLCtCQUErQixPQUFPO0FBQzVwZjtBQUNBIiwiZmlsZSI6IjE3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gcmVxdWlyZShcIi4vaW1hZ2VzL2xheWVycy5wbmdcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSByZXF1aXJlKFwiLi9pbWFnZXMvbGF5ZXJzLTJ4LnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyA9IHJlcXVpcmUoXCIuL2ltYWdlcy9tYXJrZXItaWNvbi5wbmdcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogcmVxdWlyZWQgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSxcXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyxcXHJcXG4ubGVhZmxldC1wYW5lID4gY2FudmFzLFxcclxcbi5sZWFmbGV0LXpvb20tYm94LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgIC13ZWJraXQtdXNlci1kcmFnOiBub25lO1xcclxcblxcdH1cXHJcXG4vKiBQcmV2ZW50cyBJRTExIGZyb20gaGlnaGxpZ2h0aW5nIHRpbGVzIGluIGJsdWUgKi9cXHJcXG4ubGVhZmxldC10aWxlOjpzZWxlY3Rpb24ge1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4vKiBTYWZhcmkgcmVuZGVycyBub24tcmV0aW5hIHRpbGUgb24gcmV0aW5hIGJldHRlciB3aXRoIHRoaXMsIGJ1dCBDaHJvbWUgaXMgd29yc2UgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0aW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LW9wdGltaXplLWNvbnRyYXN0O1xcclxcblxcdH1cXHJcXG4vKiBoYWNrIHRoYXQgcHJldmVudHMgaHcgbGF5ZXJzIFxcXCJzdHJldGNoaW5nXFxcIiB3aGVuIGxvYWRpbmcgbmV3IHRpbGVzICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogMTYwMHB4O1xcclxcblxcdGhlaWdodDogMTYwMHB4O1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIHN2ZzogcmVzZXQgc3ZnIG1heC13aWR0aCBkZWNsZXJhdGlvbiBzaGlwcGVkIGluIEpvb21sYSEgKGpvb21sYS5vcmcpIDMueCAqL1xcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBpbWc6IG1hcCBpcyBicm9rZW4gaW4gRkYgaWYgeW91IGhhdmUgbWF4LXdpZHRoOiAxMDAlIG9uIHRpbGVzICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtc2hhZG93LXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBpbWcubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0bWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0bWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwYW4teCBwYW4teTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwaW5jaC16b29tO1xcclxcblxcdC8qIEZhbGxiYWNrIGZvciBGRiB3aGljaCBkb2Vzbid0IHN1cHBvcnQgcGluY2gtem9vbSAqL1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYSB7XFxyXFxuXFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDUxLCAxODEsIDIyOSwgMC40KTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0ZmlsdGVyOiBpbmhlcml0O1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZS1sb2FkZWQge1xcclxcblxcdHZpc2liaWxpdHk6IGluaGVyaXQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHR3aWR0aDogMDtcXHJcXG5cXHRoZWlnaHQ6IDA7XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0fVxcclxcbi8qIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4ODMxOSAqL1xcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcge1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXBhbmUgICAgICAgICB7IHotaW5kZXg6IDQwMDsgfVxcclxcblxcclxcbi5sZWFmbGV0LXRpbGUtcGFuZSAgICB7IHotaW5kZXg6IDIwMDsgfVxcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSB7IHotaW5kZXg6IDQwMDsgfVxcclxcbi5sZWFmbGV0LXNoYWRvdy1wYW5lICB7IHotaW5kZXg6IDUwMDsgfVxcclxcbi5sZWFmbGV0LW1hcmtlci1wYW5lICB7IHotaW5kZXg6IDYwMDsgfVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcGFuZSAgIHsgei1pbmRleDogNjUwOyB9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSAgIHsgei1pbmRleDogNzAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgY2FudmFzIHsgei1pbmRleDogMTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgc3ZnICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdm1sLXNoYXBlIHtcXHJcXG5cXHR3aWR0aDogMXB4O1xcclxcblxcdGhlaWdodDogMXB4O1xcclxcblxcdH1cXHJcXG4ubHZtbCB7XFxyXFxuXFx0YmVoYXZpb3I6IHVybCgjZGVmYXVsdCNWTUwpO1xcclxcblxcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGNvbnRyb2wgcG9zaXRpb25pbmcgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0ei1pbmRleDogODAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3AsXFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ei1pbmRleDogMTAwMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiBsZWZ0O1xcclxcblxcdGNsZWFyOiBib3RoO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRmbG9hdDogcmlnaHQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiB6b29tIGFuZCBmYWRlIGFuaW1hdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LW1hcC1wYW5lIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246ICAgIC1tb3otdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246ICAgICAgICAgdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtcGFuLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWhpZGUge1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY3Vyc29ycyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWdyYWIge1xcclxcblxcdGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIsXFxyXFxuLmxlYWZsZXQtY3Jvc3NoYWlyIC5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IGNyb3NzaGFpcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSxcXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRjdXJzb3I6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LWdyYWIsXFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiAubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlIHtcXHJcXG5cXHRjdXJzb3I6IG1vdmU7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiYmluZztcXHJcXG5cXHRjdXJzb3I6ICAgICAgICAgZ3JhYmJpbmc7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIG1hcmtlciAmIG92ZXJsYXlzIGludGVyYWN0aXZpdHkgKi9cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aCxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lciB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG5zdmcubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlIHBhdGgge1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB2aXN1YWwgdHdlYWtzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZGRkO1xcclxcblxcdG91dGxpbmU6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHRjb2xvcjogIzAwNzhBODtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1hY3RpdmUge1xcclxcblxcdG91dGxpbmU6IDJweCBzb2xpZCBvcmFuZ2U7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHRib3JkZXI6IDJweCBkb3R0ZWQgIzM4ZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGdlbmVyYWwgdHlwb2dyYXBoeSAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0Zm9udDogMTJweC8xLjUgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0b29sYmFyIHN0eWxlcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC42NSk7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYSxcXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYztcXHJcXG5cXHR3aWR0aDogMjZweDtcXHJcXG5cXHRoZWlnaHQ6IDI2cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDI2cHg7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRjb2xvcjogYmxhY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDUwJTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYS5sZWFmbGV0LWRpc2FibGVkIHtcXHJcXG5cXHRjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHRjb2xvcjogI2JiYjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGEge1xcclxcblxcdHdpZHRoOiAzMHB4O1xcclxcblxcdGhlaWdodDogMzBweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMzBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogem9vbSBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLWluLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQge1xcclxcblxcdGZvbnQ6IGJvbGQgMThweCAnTHVjaWRhIENvbnNvbGUnLCBNb25hY28sIG1vbm9zcGFjZTtcXHJcXG5cXHR0ZXh0LWluZGVudDogMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLXpvb20taW4sIC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQgIHtcXHJcXG5cXHRmb250LXNpemU6IDIycHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGxheWVycyBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMge1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDVweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKTtcXHJcXG5cXHR3aWR0aDogMzZweDtcXHJcXG5cXHRoZWlnaHQ6IDM2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIik7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiAyNnB4IDI2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0d2lkdGg6IDQ0cHg7XFxyXFxuXFx0aGVpZ2h0OiA0NHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0LFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0ZGlzcGxheTogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCB7XFxyXFxuXFx0cGFkZGluZzogNnB4IDEwcHggNnB4IDZweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXIge1xcclxcblxcdG92ZXJmbG93LXk6IHNjcm9sbDtcXHJcXG5cXHRvdmVyZmxvdy14OiBoaWRkZW47XFxyXFxuXFx0cGFkZGluZy1yaWdodDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogMnB4O1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR0b3A6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWwge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3Ige1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRtYXJnaW46IDVweCAtMTBweCA1cHggLTZweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGVmYXVsdCBpY29uIFVSTHMgKi9cXHJcXG4ubGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyArIFwiKTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogYXR0cmlidXRpb24gYW5kIHNjYWxlIGNvbnRyb2xzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcclxcblxcdG1hcmdpbjogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdHBhZGRpbmc6IDAgNXB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGEge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmhvdmVyIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdGZvbnQtc2l6ZTogMTFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLXRvcDogbm9uZTtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS4xO1xcclxcblxcdHBhZGRpbmc6IDJweCA1cHggMXB4O1xcclxcblxcdGZvbnQtc2l6ZTogMTFweDtcXHJcXG5cXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXHJcXG5cXHRib3JkZXItdG9wOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdG1hcmdpbi10b3A6IC0ycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpIHtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAycHggc29saWQgIzc3NztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJveC1zaGFkb3c6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgcmdiYSgwLDAsMCwwLjIpO1xcclxcblxcdGJhY2tncm91bmQtY2xpcDogcGFkZGluZy1ib3g7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHBvcHVwICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyIHtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAxMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50IHtcXHJcXG5cXHRtYXJnaW46IDEzcHggMTlweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS40O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50IHAge1xcclxcblxcdG1hcmdpbjogMThweCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogNDBweDtcXHJcXG5cXHRoZWlnaHQ6IDIwcHg7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTIwcHg7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMTdweDtcXHJcXG5cXHRoZWlnaHQ6IDE3cHg7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcclxcblxcdG1hcmdpbjogLTEwcHggYXV0byAwO1xcclxcblxcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB3aGl0ZTtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRib3gtc2hhZG93OiAwIDNweCAxNHB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b24ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0cGFkZGluZzogNHB4IDRweCAwIDA7XFxyXFxuXFx0Ym9yZGVyOiBub25lO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHR3aWR0aDogMThweDtcXHJcXG5cXHRoZWlnaHQ6IDE0cHg7XFxyXFxuXFx0Zm9udDogMTZweC8xNHB4IFRhaG9tYSwgVmVyZGFuYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHRjb2xvcjogI2MzYzNjMztcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmhvdmVyIHtcXHJcXG5cXHRjb2xvcjogIzk5OTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtc2Nyb2xsZWQge1xcclxcblxcdG92ZXJmbG93OiBhdXRvO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHpvb206IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDI0cHg7XFxyXFxuXFx0bWFyZ2luOiAwIGF1dG87XFxyXFxuXFxyXFxuXFx0LW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KVxcXCI7XFxyXFxuXFx0ZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdG1hcmdpbi10b3A6IC0xcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtem9vbSxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBkaXYgaWNvbiAqL1xcclxcblxcclxcbi5sZWFmbGV0LWRpdi1pY29uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM2NjY7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIFRvb2x0aXAgKi9cXHJcXG4vKiBCYXNlIHN0eWxlcyBmb3IgdGhlIGVsZW1lbnQgdGhhdCBoYXMgYSB0b29sdGlwICovXFxyXFxuLmxlYWZsZXQtdG9vbHRpcCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBhZGRpbmc6IDZweDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogM3B4O1xcclxcblxcdGNvbG9yOiAjMjIyO1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJvcmRlcjogNnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdGNvbnRlbnQ6IFxcXCJcXFwiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEaXJlY3Rpb25zICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b20ge1xcclxcblxcdG1hcmdpbi10b3A6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3Age1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXRvcC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTEycHg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0dG9wOiA1MCU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItbGVmdC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1yaWdodC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///174\n')},175:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers.png?416d91365b44e4b4f4777663e6f009f3");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nP2YwYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsZ0RBQWdEIiwiZmlsZSI6IjE3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMucG5nPzQxNmQ5MTM2NWI0NGU0YjRmNDc3NzY2M2U2ZjAwOWYzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///175\n')},176:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers-2x.png?8f2c4d11474275fbc1614b9098334eae");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nP2UxMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsbURBQW1EIiwiZmlsZSI6IjE3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMtMngucG5nPzhmMmM0ZDExNDc0Mjc1ZmJjMTYxNGI5MDk4MzM0ZWFlXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n')},177:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "marker-icon.png?2b3e1faf89f94a4835397e7a43b4f77d");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmc/NWM4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLG9GQUF1QixxREFBcUQiLCJmaWxlIjoiMTc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIm1hcmtlci1pY29uLnBuZz8yYjNlMWZhZjg5Zjk0YTQ4MzUzOTdlN2E0M2I0Zjc3ZFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///177\n')},197:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n/*!\n  * chartjs-adapter-moment v1.0.0\n  * https://www.chartjs.org\n  * (c) 2021 chartjs-adapter-moment Contributors\n  * Released under the MIT license\n  */\n\n\nconst FORMATS = {\n  datetime: 'MMM D, YYYY, h:mm:ss a',\n  millisecond: 'h:mm:ss.SSS a',\n  second: 'h:mm:ss a',\n  minute: 'h:mm a',\n  hour: 'hA',\n  day: 'MMM D',\n  week: 'll',\n  month: 'MMM YYYY',\n  quarter: '[Q]Q - YYYY',\n  year: 'YYYY'\n};\n\nchart_js__WEBPACK_IMPORTED_MODULE_1__[/* _adapters */ \"b\"]._date.override(typeof moment__WEBPACK_IMPORTED_MODULE_0___default.a === 'function' ? {\n  _id: 'moment',\n  // DEBUG ONLY\n  formats: function () {\n    return FORMATS;\n  },\n  parse: function (value, format) {\n    if (typeof value === 'string' && typeof format === 'string') {\n      value = moment__WEBPACK_IMPORTED_MODULE_0___default()(value, format);\n    } else if (!(value instanceof moment__WEBPACK_IMPORTED_MODULE_0___default.a)) {\n      value = moment__WEBPACK_IMPORTED_MODULE_0___default()(value);\n    }\n\n    return value.isValid() ? value.valueOf() : null;\n  },\n  format: function (time, format) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(time).format(format);\n  },\n  add: function (time, amount, unit) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(time).add(amount, unit).valueOf();\n  },\n  diff: function (max, min, unit) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(max).diff(moment__WEBPACK_IMPORTED_MODULE_0___default()(min), unit);\n  },\n  startOf: function (time, unit, weekday) {\n    time = moment__WEBPACK_IMPORTED_MODULE_0___default()(time);\n\n    if (unit === 'isoWeek') {\n      weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));\n      return time.isoWeekday(weekday).startOf('day').valueOf();\n    }\n\n    return time.startOf(unit).valueOf();\n  },\n  endOf: function (time, unit) {\n    return moment__WEBPACK_IMPORTED_MODULE_0___default()(time).endOf(unit).valueOf();\n  }\n} : {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1hZGFwdGVyLW1vbWVudC9kaXN0L2NoYXJ0anMtYWRhcHRlci1tb21lbnQuZXNtLmpzPzFjODYiXSwibmFtZXMiOlsiRk9STUFUUyIsImRhdGV0aW1lIiwibWlsbGlzZWNvbmQiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5Iiwid2VlayIsIm1vbnRoIiwicXVhcnRlciIsInllYXIiLCJfYWRhcHRlcnMiLCJfZGF0ZSIsIm92ZXJyaWRlIiwibW9tZW50IiwiX2lkIiwiZm9ybWF0cyIsInBhcnNlIiwidmFsdWUiLCJmb3JtYXQiLCJpc1ZhbGlkIiwidmFsdWVPZiIsInRpbWUiLCJhZGQiLCJhbW91bnQiLCJ1bml0IiwiZGlmZiIsIm1heCIsIm1pbiIsInN0YXJ0T2YiLCJ3ZWVrZGF5IiwiTWF0aCIsInRydW5jIiwiaXNvV2Vla2RheSIsImVuZE9mIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTUEsT0FBTyxHQUFHO0FBQ2RDLFVBQVEsRUFBRSx3QkFESTtBQUVkQyxhQUFXLEVBQUUsZUFGQztBQUdkQyxRQUFNLEVBQUUsV0FITTtBQUlkQyxRQUFNLEVBQUUsUUFKTTtBQUtkQyxNQUFJLEVBQUUsSUFMUTtBQU1kQyxLQUFHLEVBQUUsT0FOUztBQU9kQyxNQUFJLEVBQUUsSUFQUTtBQVFkQyxPQUFLLEVBQUUsVUFSTztBQVNkQyxTQUFPLEVBQUUsYUFUSztBQVVkQyxNQUFJLEVBQUU7QUFWUSxDQUFoQjs7QUFhQUMsMERBQVMsQ0FBQ0MsS0FBVixDQUFnQkMsUUFBaEIsQ0FBeUIsT0FBT0MsNkNBQVAsS0FBa0IsVUFBbEIsR0FBK0I7QUFDdERDLEtBQUcsRUFBRSxRQURpRDtBQUN2QztBQUVmQyxTQUFPLEVBQUUsWUFBVztBQUNsQixXQUFPaEIsT0FBUDtBQUNELEdBTHFEO0FBT3REaUIsT0FBSyxFQUFFLFVBQVNDLEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCO0FBQzdCLFFBQUksT0FBT0QsS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPQyxNQUFQLEtBQWtCLFFBQW5ELEVBQTZEO0FBQzNERCxXQUFLLEdBQUdKLDZDQUFNLENBQUNJLEtBQUQsRUFBUUMsTUFBUixDQUFkO0FBQ0QsS0FGRCxNQUVPLElBQUksRUFBRUQsS0FBSyxZQUFZSiw2Q0FBbkIsQ0FBSixFQUFnQztBQUNyQ0ksV0FBSyxHQUFHSiw2Q0FBTSxDQUFDSSxLQUFELENBQWQ7QUFDRDs7QUFDRCxXQUFPQSxLQUFLLENBQUNFLE9BQU4sS0FBa0JGLEtBQUssQ0FBQ0csT0FBTixFQUFsQixHQUFvQyxJQUEzQztBQUNELEdBZHFEO0FBZ0J0REYsUUFBTSxFQUFFLFVBQVNHLElBQVQsRUFBZUgsTUFBZixFQUF1QjtBQUM3QixXQUFPTCw2Q0FBTSxDQUFDUSxJQUFELENBQU4sQ0FBYUgsTUFBYixDQUFvQkEsTUFBcEIsQ0FBUDtBQUNELEdBbEJxRDtBQW9CdERJLEtBQUcsRUFBRSxVQUFTRCxJQUFULEVBQWVFLE1BQWYsRUFBdUJDLElBQXZCLEVBQTZCO0FBQ2hDLFdBQU9YLDZDQUFNLENBQUNRLElBQUQsQ0FBTixDQUFhQyxHQUFiLENBQWlCQyxNQUFqQixFQUF5QkMsSUFBekIsRUFBK0JKLE9BQS9CLEVBQVA7QUFDRCxHQXRCcUQ7QUF3QnRESyxNQUFJLEVBQUUsVUFBU0MsR0FBVCxFQUFjQyxHQUFkLEVBQW1CSCxJQUFuQixFQUF5QjtBQUM3QixXQUFPWCw2Q0FBTSxDQUFDYSxHQUFELENBQU4sQ0FBWUQsSUFBWixDQUFpQlosNkNBQU0sQ0FBQ2MsR0FBRCxDQUF2QixFQUE4QkgsSUFBOUIsQ0FBUDtBQUNELEdBMUJxRDtBQTRCdERJLFNBQU8sRUFBRSxVQUFTUCxJQUFULEVBQWVHLElBQWYsRUFBcUJLLE9BQXJCLEVBQThCO0FBQ3JDUixRQUFJLEdBQUdSLDZDQUFNLENBQUNRLElBQUQsQ0FBYjs7QUFDQSxRQUFJRyxJQUFJLEtBQUssU0FBYixFQUF3QjtBQUN0QkssYUFBTyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDSCxHQUFMLENBQVNHLElBQUksQ0FBQ0osR0FBTCxDQUFTLENBQVQsRUFBWUcsT0FBWixDQUFULEVBQStCLENBQS9CLENBQVgsQ0FBVjtBQUNBLGFBQU9SLElBQUksQ0FBQ1csVUFBTCxDQUFnQkgsT0FBaEIsRUFBeUJELE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDUixPQUF4QyxFQUFQO0FBQ0Q7O0FBQ0QsV0FBT0MsSUFBSSxDQUFDTyxPQUFMLENBQWFKLElBQWIsRUFBbUJKLE9BQW5CLEVBQVA7QUFDRCxHQW5DcUQ7QUFxQ3REYSxPQUFLLEVBQUUsVUFBU1osSUFBVCxFQUFlRyxJQUFmLEVBQXFCO0FBQzFCLFdBQU9YLDZDQUFNLENBQUNRLElBQUQsQ0FBTixDQUFhWSxLQUFiLENBQW1CVCxJQUFuQixFQUF5QkosT0FBekIsRUFBUDtBQUNEO0FBdkNxRCxDQUEvQixHQXdDckIsRUF4Q0oiLCJmaWxlIjoiMTk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogY2hhcnRqcy1hZGFwdGVyLW1vbWVudCB2MS4wLjBcbiAgKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICAqIChjKSAyMDIxIGNoYXJ0anMtYWRhcHRlci1tb21lbnQgQ29udHJpYnV0b3JzXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gICovXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBfYWRhcHRlcnMgfSBmcm9tICdjaGFydC5qcyc7XG5cbmNvbnN0IEZPUk1BVFMgPSB7XG4gIGRhdGV0aW1lOiAnTU1NIEQsIFlZWVksIGg6bW06c3MgYScsXG4gIG1pbGxpc2Vjb25kOiAnaDptbTpzcy5TU1MgYScsXG4gIHNlY29uZDogJ2g6bW06c3MgYScsXG4gIG1pbnV0ZTogJ2g6bW0gYScsXG4gIGhvdXI6ICdoQScsXG4gIGRheTogJ01NTSBEJyxcbiAgd2VlazogJ2xsJyxcbiAgbW9udGg6ICdNTU0gWVlZWScsXG4gIHF1YXJ0ZXI6ICdbUV1RIC0gWVlZWScsXG4gIHllYXI6ICdZWVlZJ1xufTtcblxuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XG4gIF9pZDogJ21vbWVudCcsIC8vIERFQlVHIE9OTFlcblxuICBmb3JtYXRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRk9STUFUUztcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcbiAgICB9IGVsc2UgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG4gICAgICB2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5pc1ZhbGlkKCkgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuICAgIHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xuICB9LFxuXG4gIGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbWVudChtYXgpLmRpZmYobW9tZW50KG1pbiksIHVuaXQpO1xuICB9LFxuXG4gIHN0YXJ0T2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICB0aW1lID0gbW9tZW50KHRpbWUpO1xuICAgIGlmICh1bml0ID09PSAnaXNvV2VlaycpIHtcbiAgICAgIHdlZWtkYXkgPSBNYXRoLnRydW5jKE1hdGgubWluKE1hdGgubWF4KDAsIHdlZWtkYXkpLCA2KSk7XG4gICAgICByZXR1cm4gdGltZS5pc29XZWVrZGF5KHdlZWtkYXkpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWUuc3RhcnRPZih1bml0KS52YWx1ZU9mKCk7XG4gIH0sXG5cbiAgZW5kT2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tZW50KHRpbWUpLmVuZE9mKHVuaXQpLnZhbHVlT2YoKTtcbiAgfVxufSA6IHt9KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///197\n")},2:function(module,exports,__webpack_require__){eval("/* @preserve\n * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com\n * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n(function (global, factory) {\n   true ? factory(exports) : undefined;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.6.0\";\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  var freeze = Object.freeze;\n\n  Object.freeze = function (obj) {\n    return obj;\n  }; // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n\n\n  function extend(dest) {\n    var i, j, len, src;\n\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n\n    return dest;\n  } // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n\n  var create = Object.create || function () {\n    function F() {}\n\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }(); // @function bind(fn: Function, ): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n\n\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  } // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n\n\n  var lastId = 0; // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  function stamp(obj) {\n    /*eslint-disable */\n    obj._leaflet_id = obj._leaflet_id || ++lastId;\n    return obj._leaflet_id;\n    /* eslint-enable */\n  } // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n\n\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n\n    return wrapperFn;\n  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n\n\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n        min = range[0],\n        d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  } // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n\n\n  function falseFn() {\n    return false;\n  } // @function formatNum(num: Number, digits?: Number): Number\n  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.\n\n\n  function formatNum(num, digits) {\n    var pow = Math.pow(10, digits === undefined ? 6 : digits);\n    return Math.round(num * pow) / pow;\n  } // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n\n\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  } // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n\n\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  } // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n\n\n  function setOptions(obj, options) {\n    if (!obj.hasOwnProperty('options')) {\n      obj.options = obj.options ? create(obj.options) : {};\n    }\n\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n\n    return obj.options;\n  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  var templateRe = /\\{ *([\\w_-]+) *\\}/g; // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values  they will be evaluated passing `data` as an argument.\n\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return value;\n    });\n  } // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }; // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n\n\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n\n  var lastTime = 0; // fallback for IE 7-8\n\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n        timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n\n\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  } // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n\n\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n\n  var Util = (Object.freeze || Object)({\n    freeze: freeze,\n    extend: extend,\n    create: create,\n    bind: bind,\n    lastId: lastId,\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  }); // @class Class\n  // @aka L.Class\n  // @section\n  // @uninheritable\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      } // call all constructor hooks\n\n\n      this.callInitHooks();\n    };\n\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto; // inherit parent's statics\n\n    for (var i in this) {\n      if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    } // mix static properties into the class\n\n\n    if (props.statics) {\n      extend(NewClass, props.statics);\n      delete props.statics;\n    } // mix includes into the prototype\n\n\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n      delete props.includes;\n    } // merge options\n\n\n    if (proto.options) {\n      props.options = extend(create(proto.options), props.options);\n    } // mix given properties into the prototype\n\n\n    extend(proto, props);\n    proto._initHooks = []; // add method for calling all hooks\n\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n\n      this._initHooksCalled = true;\n\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n\n    return NewClass;\n  }; // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n\n\n  Class.include = function (props) {\n    extend(this.prototype, props);\n    return this;\n  }; // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n\n\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  }; // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n\n\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n\n    this.prototype._initHooks.push(init);\n\n    return this;\n  };\n\n  function checkDeprecatedMixinEvents(includes) {\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n\n    includes = isArray(includes) ? includes : [includes];\n\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!types) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._off(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context) {\n      this._events = this._events || {};\n      /* get/init listeners for type */\n\n      var typeListeners = this._events[type];\n\n      if (!typeListeners) {\n        typeListeners = [];\n        this._events[type] = typeListeners;\n      }\n\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n\n      var newListener = {\n        fn: fn,\n        ctx: context\n      },\n          listeners = typeListeners; // check if fn already there\n\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return;\n        }\n      }\n\n      listeners.push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n\n      if (!this._events) {\n        return;\n      }\n\n      listeners = this._events[type];\n\n      if (!listeners) {\n        return;\n      }\n\n      if (!fn) {\n        // Set all removed listeners to noop so they are not called if remove happens in fire\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].fn = falseFn;\n        } // clear all listeners for a type if function isn't specified\n\n\n        delete this._events[type];\n        return;\n      }\n\n      if (context === this) {\n        context = undefined;\n      }\n\n      if (listeners) {\n        // find fn and remove it\n        for (i = 0, len = listeners.length; i < len; i++) {\n          var l = listeners[i];\n\n          if (l.ctx !== context) {\n            continue;\n          }\n\n          if (l.fn === fn) {\n            // set the removed listener to noop so that's not called if remove happens in fire\n            l.fn = falseFn;\n\n            if (this._firingCount) {\n              /* copy array in case events are being fired */\n              this._events[type] = listeners = listeners.slice();\n            }\n\n            listeners.splice(i, 1);\n            return;\n          }\n        }\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide an data\n    // object  the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n\n      if (this._events) {\n        var listeners = this._events[type];\n\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            l.fn.call(l.ctx || this, event);\n          }\n\n          this._firingCount--;\n        }\n      }\n\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n\n      return this;\n    },\n    // @method listens(type: String): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    listens: function (type, propagate) {\n      var listeners = this._events && this._events[type];\n\n      if (listeners && listeners.length) {\n        return true;\n      }\n\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, propagate)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    // @method once(): this\n    // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      if (typeof types === 'object') {\n        for (var type in types) {\n          this.once(type, types[type], fn);\n        }\n\n        return this;\n      }\n\n      var handler = bind(function () {\n        this.off(types, fn, context).off(types, handler, context);\n      }, this); // add a listener that's executed once and removed after that\n\n      return this.on(types, fn, context).on(types, handler, context);\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  }; // aliases; we should ditch those eventually\n  // @method addEventListener(): this\n  // Alias to [`on()`](#evented-on)\n\n  Events.addEventListener = Events.on; // @method removeEventListener(): this\n  // Alias to [`off()`](#evented-off)\n  // @method clearAllEventListeners(): this\n  // Alias to [`off()`](#evented-off)\n\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(): this\n  // Alias to [`once()`](#evented-once)\n\n  Events.addOneTimeEventListener = Events.once; // @method fireEvent(): this\n  // Alias to [`fire()`](#evented-fire)\n\n  Events.fireEvent = Events.fire; // @method hasEventListeners(): Boolean\n  // Alias to [`listens()`](#evented-listens)\n\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n    this.y = round ? Math.round(y) : y;\n  }\n\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n          y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  }; // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n\n    if (x === undefined || x === null) {\n      return x;\n    }\n\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n\n    return new Point(x, y, round);\n  }\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n\n    var points = b ? [a, b] : a;\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n    extend: function (point) {\n      // (Point)\n      point = toPoint(point); // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n\n      if (!this.min && !this.max) {\n        this.min = point.clone();\n        this.max = point.clone();\n      } else {\n        this.min.x = Math.min(point.x, this.min.x);\n        this.max.x = Math.max(point.x, this.max.x);\n        this.min.y = Math.min(point.y, this.min.y);\n        this.max.y = Math.max(point.y, this.max.y);\n      }\n\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return new Point(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return new Point(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xIntersects = max2.x >= min.x && min2.x <= max.x,\n          yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xOverlaps = max2.x > min.x && min2.x < max.x,\n          yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    isValid: function () {\n      return !!(this.min && this.max);\n    }\n  }; // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n\n    return new Bounds(a, b);\n  }\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  }; // TODO International date line?\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n\n    return new LatLngBounds(a, b);\n  }\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    } // @property lat: Number\n    // Latitude in degrees\n\n\n    this.lat = +lat; // @property lng: Number\n    // Longitude in degrees\n\n    this.lng = +lng; // @property alt: Number\n    // Altitude in meters (optional)\n\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n\n      return null;\n    }\n\n    if (a === undefined || a === null) {\n      return a;\n    }\n\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n\n    if (b === undefined) {\n      return null;\n    }\n\n    return new LatLng(a, b, c);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leafet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n          scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n          untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n\n      var b = this.projection.bounds,\n          s = this.scale(zoom),\n          min = this.transformation.transform(b.min, s),\n          max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n          alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n          newCenter = this.wrapLatLng(center),\n          latShift = center.lat - newCenter.lat,\n          lngShift = center.lng - newCenter.lng;\n\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n\n      var sw = bounds.getSouthWest(),\n          ne = bounds.getNorthEast(),\n          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see http://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection  the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          max = this.MAX_LATITUDE,\n          lat = Math.max(Math.min(max, latlng.lat), -max),\n          sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  }); // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  } // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n\n\n  function pointsToPath(rings, closed) {\n    var str = '',\n        i,\n        j,\n        len,\n        len2,\n        points,\n        p;\n\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      } // closes the ring for polygons; \"x\" is VML syntax\n\n\n      str += closed ? svg ? 'z' : 'x' : '';\n    } // SVG complains about empty path strings\n\n\n    return str || 'M0 0';\n  }\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n\n  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n\n  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n\n  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.\n\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n\n  var webkit = userAgentContains('webkit'); // @property android: Boolean\n  // `true` for any browser running on an Android platform.\n\n  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.\n\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)\n\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser\n\n  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.\n\n  var chrome = userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.\n\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom'); // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n\n  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform\n\n  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n\n  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n\n  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n\n  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n\n  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n\n  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n\n  var pointer = !webkit && !!(window.PointerEvent || msPointer); // @property touch: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // This does not necessarily mean that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n\n  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n\n  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n\n  var mobileGecko = mobile && gecko; // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {// Errors can safely be ignored since this is only a browser support test.\n    }\n\n    return supportsPassiveOption;\n  }; // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n\n\n  var canvas = function () {\n    return !!document.createElement('canvas').getContext;\n  }(); // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n\n\n  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n\n  var vml = !svg && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n\n  var Browser = (Object.freeze || Object)({\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas,\n    svg: svg,\n    vml: vml\n  });\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];\n  var _pointers = {};\n  var _pointerDocListener = false; // DomEvent.DoubleTap needs to know about this\n\n  var _pointersCount = 0; // Provides a touch events wrapper for (ms)pointer events.\n  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler, id) {\n    if (type === 'touchstart') {\n      _addPointerStart(obj, handler, id);\n    } else if (type === 'touchmove') {\n      _addPointerMove(obj, handler, id);\n    } else if (type === 'touchend') {\n      _addPointerEnd(obj, handler, id);\n    }\n\n    return this;\n  }\n\n  function removePointerListener(obj, type, id) {\n    var handler = obj['_leaflet_' + type + id];\n\n    if (type === 'touchstart') {\n      obj.removeEventListener(POINTER_DOWN, handler, false);\n    } else if (type === 'touchmove') {\n      obj.removeEventListener(POINTER_MOVE, handler, false);\n    } else if (type === 'touchend') {\n      obj.removeEventListener(POINTER_UP, handler, false);\n      obj.removeEventListener(POINTER_CANCEL, handler, false);\n    }\n\n    return this;\n  }\n\n  function _addPointerStart(obj, handler, id) {\n    var onDown = bind(function (e) {\n      if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n        // In IE11, some touch events needs to fire for form controls, or\n        // the controls will stop working. We keep a whitelist of tag names that\n        // need these events. For other target tags, we prevent default on the event.\n        if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {\n          preventDefault(e);\n        } else {\n          return;\n        }\n      }\n\n      _handlePointer(e, handler);\n    });\n    obj['_leaflet_touchstart' + id] = onDown;\n    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation\n\n    if (!_pointerDocListener) {\n      // we listen documentElement as any drags that end by moving the touch off the screen get fired there\n      document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n    _pointersCount++;\n  }\n\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n    _pointersCount--;\n  }\n\n  function _handlePointer(e, handler) {\n    e.touches = [];\n\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n\n    e.changedTouches = [e];\n    handler(e);\n  }\n\n  function _addPointerMove(obj, handler, id) {\n    var onMove = function (e) {\n      // don't fire touch moves when mouse isn't down\n      if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {\n        return;\n      }\n\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchmove' + id] = onMove;\n    obj.addEventListener(POINTER_MOVE, onMove, false);\n  }\n\n  function _addPointerEnd(obj, handler, id) {\n    var onUp = function (e) {\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchend' + id] = onUp;\n    obj.addEventListener(POINTER_UP, onUp, false);\n    obj.addEventListener(POINTER_CANCEL, onUp, false);\n  }\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   */\n\n\n  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';\n\n  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';\n\n  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs\n\n  function addDoubleTapListener(obj, handler, id) {\n    var last,\n        touch$$1,\n        doubleTap = false,\n        delay = 250;\n\n    function onTouchStart(e) {\n      var count;\n\n      if (pointer) {\n        if (!edge || e.pointerType === 'mouse') {\n          return;\n        }\n\n        count = _pointersCount;\n      } else {\n        count = e.touches.length;\n      }\n\n      if (count > 1) {\n        return;\n      }\n\n      var now = Date.now(),\n          delta = now - (last || now);\n      touch$$1 = e.touches ? e.touches[0] : e;\n      doubleTap = delta > 0 && delta <= delay;\n      last = now;\n    }\n\n    function onTouchEnd(e) {\n      if (doubleTap && !touch$$1.cancelBubble) {\n        if (pointer) {\n          if (!edge || e.pointerType === 'mouse') {\n            return;\n          } // work around .type being readonly with MSPointer* events\n\n\n          var newTouch = {},\n              prop,\n              i;\n\n          for (i in touch$$1) {\n            prop = touch$$1[i];\n            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;\n          }\n\n          touch$$1 = newTouch;\n        }\n\n        touch$$1.type = 'dblclick';\n        touch$$1.button = 0;\n        handler(touch$$1);\n        last = null;\n      }\n    }\n\n    obj[_pre + _touchstart + id] = onTouchStart;\n    obj[_pre + _touchend + id] = onTouchEnd;\n    obj[_pre + 'dblclick' + id] = handler;\n    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {\n      passive: false\n    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),\n    // the browser doesn't fire touchend/pointerup events but does fire\n    // native dblclicks. See #4127.\n    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.\n\n    obj.addEventListener('dblclick', handler, false);\n    return this;\n  }\n\n  function removeDoubleTapListener(obj, id) {\n    var touchstart = obj[_pre + _touchstart + id],\n        touchend = obj[_pre + _touchend + id],\n        dblclick = obj[_pre + 'dblclick' + id];\n    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.removeEventListener(_touchend, touchend, passiveEvents ? {\n      passive: false\n    } : false);\n\n    if (!edge) {\n      obj.removeEventListener('dblclick', dblclick, false);\n    }\n\n    return this;\n  }\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n\n\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  } // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n\n\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n\n    return value === 'auto' ? null : value;\n  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n\n\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n\n    if (container) {\n      container.appendChild(el);\n    }\n\n    return el;\n  } // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n\n\n  function remove(el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n      parent.removeChild(el);\n    }\n  } // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n\n\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  } // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n\n\n  function toFront(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  } // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n\n\n  function toBack(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  } // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n\n\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  } // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n\n\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  } // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n\n\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  } // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n\n\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  } // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n\n\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  } // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n\n\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n\n  function _setOpacityIE(el, value) {\n    var filter = false,\n        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist\n\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n\n    value = Math.round(value * 100);\n\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  } // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n\n\n  function testProp(props) {\n    var style = document.documentElement.style;\n\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n\n    return false;\n  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n\n\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  } // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n\n\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  } // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n\n\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n    return el._leaflet_pos || new Point(0, 0);\n  } // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n\n\n  var disableTextSelection;\n  var enableTextSelection;\n\n  var _userSelect;\n\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  } // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n\n\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  } // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n\n\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n\n  var _outlineElement;\n\n  var _outlineStyle; // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n\n\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n\n    if (!element.style) {\n      return;\n    }\n\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outline;\n    element.style.outline = 'none';\n    on(window, 'keydown', restoreOutline);\n  } // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n\n\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n\n    _outlineElement.style.outline = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  } // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n\n\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n\n    return element;\n  } // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n\n\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n\n  var DomUtil = (Object.freeze || Object)({\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    disableTextSelection: disableTextSelection,\n    enableTextSelection: enableTextSelection,\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  });\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function on(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n\n    return this;\n  }\n\n  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function off(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else if (types) {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        removeOne(obj, types[i], fn, context);\n      }\n    } else {\n      for (var j in obj[eventsKey]) {\n        removeOne(obj, j, obj[eventsKey][j]);\n      }\n\n      delete obj[eventsKey];\n    }\n\n    return this;\n  }\n\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n\n    var originalHandler = handler;\n\n    if (pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      addPointerListener(obj, type, handler, id);\n    } else if (touch && type === 'dblclick' && addDoubleTapListener && !(pointer && chrome)) {\n      // Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener\n      // See #5180\n      addDoubleTapListener(obj, handler, id);\n    } else if ('addEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n\n        obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\n      } else {\n        if (type === 'click' && android) {\n          handler = function (e) {\n            filterClick(e, originalHandler);\n          };\n        }\n\n        obj.addEventListener(type, handler, false);\n      }\n    } else if ('attachEvent' in obj) {\n      obj.attachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n\n  function removeOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),\n        handler = obj[eventsKey] && obj[eventsKey][id];\n\n    if (!handler) {\n      return this;\n    }\n\n    if (pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, id);\n    } else if (touch && type === 'dblclick' && removeDoubleTapListener && !(pointer && chrome)) {\n      removeDoubleTapListener(obj, id);\n    } else if ('removeEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else {\n        obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);\n      }\n    } else if ('detachEvent' in obj) {\n      obj.detachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey][id] = null;\n  } // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n\n    skipped(e);\n    return this;\n  } // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).\n\n\n  function disableScrollPropagation(el) {\n    addOne(el, 'mousewheel', stopPropagation);\n    return this;\n  } // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n\n\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick', stopPropagation);\n    addOne(el, 'click', fakeStop);\n    return this;\n  } // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n\n\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n\n    return this;\n  } // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n\n\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n\n\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n\n    var scale = getScale(container),\n        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point( // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),\n  // and Firefox scrolls device pixels, not CSS pixels\n\n\n  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a mousewheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n\n  function getWheelDelta(e) {\n    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages\n    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\n    0;\n  }\n\n  var skipEvents = {};\n\n  function fakeStop(e) {\n    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)\n    skipEvents[e.type] = true;\n  }\n\n  function skipped(e) {\n    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map\n\n    skipEvents[e.type] = false;\n    return events;\n  } // check if element really left/entered the event target (for mouseenter/mouseleave)\n\n\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n\n    if (!related) {\n      return true;\n    }\n\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n\n    return related !== el;\n  }\n\n  var lastClick; // this is a horrible workaround for a bug in Android where a single touch triggers two click events\n\n  function filterClick(e, handler) {\n    var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,\n        elapsed = lastClick && timeStamp - lastClick; // are they closer together than 500ms yet more than 100ms?\n    // Android typically triggers them ~300ms apart while multiple listeners\n    // on the same event should be triggered far faster;\n    // or check if click is simulated on the element, and if it is, reject any non-simulated events\n\n    if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {\n      stop(e);\n      return;\n    }\n\n    lastClick = timeStamp;\n    handler(e);\n  }\n\n  var DomEvent = (Object.freeze || Object)({\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    fakeStop: fakeStop,\n    skipped: skipped,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  });\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var fx = new L.PosAnimation();\n   * fx.run(el, [300, 500], 0.5);\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date(); // @event start: Event\n      // Fired when the animation starts\n\n      this.fire('start');\n\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n\n      this._step(true);\n\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n          duration = this._duration * 1000;\n\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n\n      if (round) {\n        pos._round();\n      }\n\n      setPosition(this._el, pos); // @event step: Event\n      // Fired continuously during the animation.\n\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false; // @event end: Event\n      // Fired when the animation ends.\n\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API  it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n\n      this._initContainer(id);\n\n      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980\n\n\n      this._onResize = bind(this._onResize, this);\n\n      this._initEvents();\n\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n\n      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\n      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n\n      this._stop();\n\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        } // try animating pan or zoom\n\n\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      } // animation didn't start, just reset the map view\n\n\n      this._resetView(center, zoom);\n\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n          viewHalf = this.getSize().divideBy(2),\n          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n          swPoint = this.project(bounds.getSouthWest(), zoom),\n          nePoint = this.project(bounds.getNorthEast(), zoom),\n          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      } // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\n        return this;\n      }\n\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      } // don't fire movestart if animating inertia\n\n\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      } // animate pan unless animate: false specified\n\n\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n\n        var newPos = this._getMapPanePos().subtract(offset).round();\n\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n\n        this.fire('move').fire('moveend');\n      }\n\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n\n      if (options.animate === false || !any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n\n      this._stop();\n\n      var from = this.project(this.getCenter()),\n          to = this.project(targetCenter),\n          size = this.getSize(),\n          startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n          w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n          u1 = to.distanceTo(from) || 1,\n          rho = 1.42,\n          rho2 = rho * rho;\n\n      function r(i) {\n        var s1 = i ? -1 : 1,\n            s2 = i ? w1 : w0,\n            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n            b1 = 2 * s2 * rho2 * u1,\n            b = t1 / b1,\n            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n\n      var r0 = r(0);\n\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n\n      var start = Date.now(),\n          S = (r(1) - r0) / rho,\n          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n      function frame() {\n        var t = (Date.now() - start) / duration,\n            s = easeOut(t) * S;\n\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n\n      this._moveStart(true, options.noMoveStart);\n\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: Bounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this.off('moveend', this._panInsideMaxBounds);\n      } else if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n\n      this.options.maxBounds = bounds;\n\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n\n      var center = this.getCenter(),\n          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit\n    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          center = this.getCenter(),\n          pixelCenter = this.project(center),\n          pixelPoint = this.project(latlng),\n          pixelBounds = this.getPixelBounds(),\n          halfPixelBounds = pixelBounds.getSize().divideBy(2),\n          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);\n\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var diff = pixelCenter.subtract(pixelPoint),\n            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);\n\n        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {\n          newCenter.x = pixelCenter.x - diff.x;\n\n          if (diff.x > 0) {\n            newCenter.x += halfPixelBounds.x - paddingTL.x;\n          } else {\n            newCenter.x -= halfPixelBounds.x - paddingBR.x;\n          }\n        }\n\n        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {\n          newCenter.y = pixelCenter.y - diff.y;\n\n          if (diff.y > 0) {\n            newCenter.y += halfPixelBounds.y - paddingTL.y;\n          } else {\n            newCenter.y -= halfPixelBounds.y - paddingBR.y;\n          }\n        }\n\n        this.panTo(this.unproject(newCenter), options);\n        this._enforcingBounds = false;\n      }\n\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so \n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so \n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n          oldCenter = oldSize.divideBy(2).round(),\n          newCenter = newSize.divideBy(2).round(),\n          offset = oldCenter.subtract(newCenter);\n\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n\n        this.fire('move');\n\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      } // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n\n\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n\n      }, options);\n\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n\n        return this;\n      }\n\n      var onResponse = bind(this._handleGeolocationResponse, this),\n          onError = bind(this._handleGeolocationError, this);\n\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      var c = error.code,\n          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      } // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n\n\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      var lat = pos.coords.latitude,\n          lng = pos.coords.longitude,\n          latlng = new LatLng(lat, lng),\n          bounds = latlng.toBounds(pos.coords.accuracy * 2),\n          options = this._locateOptions;\n\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      } // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n\n\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n\n      var handler = this[name] = new HandlerClass(this);\n\n      this._handlers.push(handler);\n\n      if (this.options[name]) {\n        handler.enable();\n      }\n\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n\n        this._containerId = undefined;\n      }\n\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n\n      this._stop();\n\n      remove(this._mapPane);\n\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n\n      this._clearHandlers();\n\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n\n      var i;\n\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n          pane = create$1('div', className, container || this._mapPane);\n\n      if (name) {\n        this._panes[name] = pane;\n      }\n\n      return pane;\n    },\n    // @section Methods for Getting Map State\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter;\n      }\n\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n          sw = this.unproject(bounds.getBottomLeft()),\n          ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n          min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          nw = bounds.getNorthWest(),\n          se = bounds.getSouthEast(),\n          size = this.getSize().subtract(padding),\n          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n          snap = any3d ? this.options.zoomSnap : 1,\n          scalex = size.x / boundsSize.x,\n          scaley = size.y / boundsSize.y,\n          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && any3d;\n      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n        container.style.position = 'relative';\n      }\n\n      this._initPanes();\n\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {}; // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n\n      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n\n      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n\n      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n\n      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n\n      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n\n      this.createPane('popupPane');\n\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n    // @section Map state change events\n    _resetView: function (center, zoom) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n\n      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n\n\n      this.fire('viewreset'); // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n\n      return this;\n    },\n    _move: function (center, zoom, data) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event\n      // Fired repeatedly during any change in zoom level, including zoom\n      // and fly animations.\n\n      if (zoomChanged || data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      } // @event move: Event\n      // Fired repeatedly during any movement of the map, including pan and\n      // fly animations.\n\n\n      return this.fire('move', data);\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map has changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      } // @event moveend: Event\n      // Fired when the center of the map stops changing (e.g. user stopped\n      // dragging the map).\n\n\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n    // @section Interaction events\n    _initEvents: function (remove$$1) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove$$1 ? off : on; // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n\n      if (any3d && this.options.transform3DLimit) {\n        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n          target,\n          isHover = type === 'mouseout' || type === 'mouseover',\n          src = e.target || e.srcElement,\n          dragging = false;\n\n      while (src) {\n        target = this._targets[stamp(src)];\n\n        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n\n          targets.push(target);\n\n          if (isHover) {\n            break;\n          }\n        }\n\n        if (src === this._container) {\n          break;\n        }\n\n        src = src.parentNode;\n      }\n\n      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {\n        targets = [this];\n      }\n\n      return targets;\n    },\n    _handleDOMEvent: function (e) {\n      if (!this._loaded || skipped(e)) {\n        return;\n      }\n\n      var type = e.type;\n\n      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(e.target || e.srcElement);\n      }\n\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, targets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n\n        this._fireDOMEvent(synth, synth.type, targets);\n      }\n\n      if (e._stopped) {\n        return;\n      } // Find the layer the event is propagating from and its parents.\n\n\n      targets = (targets || []).concat(this._findEventTargets(e, type));\n\n      if (!targets.length) {\n        return;\n      }\n\n      var target = targets[0];\n\n      if (type === 'contextmenu' && target.listens(type, true)) {\n        preventDefault(e);\n      }\n\n      var data = {\n        originalEvent: e\n      };\n\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n\n      for (var i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n\n      return this;\n    },\n    // private methods for getting map state\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n\n      var centerPoint = this.project(center, zoom),\n          viewHalf = this.getSize().divideBy(2),\n          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n\n\n      if (offset.round().equals([0, 0])) {\n        return center;\n      }\n\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n\n      var viewBounds = this.getPixelBounds(),\n          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n          dx = this._rebound(minOffset.x, -maxOffset.x),\n          dy = this._rebound(minOffset.y, -maxOffset.y);\n\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          snap = any3d ? this.options.zoomSnap : 1;\n\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options\n\n\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n\n      this._panes.mapPane.appendChild(proxy);\n\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n            transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired\n\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n          z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n\n      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large\n\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      } // offset is the pixel coords of the zoom origin relative to the current center\n\n\n      var scale = this.getZoomScale(zoom),\n          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      requestAnimFrame(function () {\n        this._moveStart(true, false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n\n      if (startAnim) {\n        this._animatingZoom = true; // remember what center/zoom to set after animation\n\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      } // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n\n\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      this._animatingZoom = false;\n\n      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\n\n      requestAnimFrame(function () {\n        this._moveEnd(true);\n      }, this);\n    }\n  }); // @section\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n\n      if (map) {\n        map.removeControl(this);\n      }\n\n      this.options.position = position;\n\n      if (map) {\n        map.addControl(this);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n          pos = this.getPosition(),\n          corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n\n      this._map.on('unload', this.remove, this);\n\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n\n      remove(this._container);\n\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n\n      this._map.off('unload', this.remove, this);\n\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n\n  var control = function (options) {\n    return new Control(options);\n  };\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n\n\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n          l = 'leaflet-',\n          container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n\n      this._update();\n\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n\n      var obj = this._getLayer(stamp(layer));\n\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n\n      this._checkDisabledLayers();\n\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n          container = this._container = create$1('div', className),\n          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n\n        if (!android) {\n          on(container, {\n            mouseenter: this.expand,\n            mouseleave: this.collapse\n          }, this);\n        }\n      }\n\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n\n      if (touch) {\n        on(link, 'click', stop);\n        on(link, 'click', this.expand, this);\n      } else {\n        on(link, 'focus', this.expand, this);\n      }\n\n      if (!collapsed) {\n        this.expand();\n      }\n\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n          overlaysPresent,\n          i,\n          obj,\n          baseLayersCount = 0;\n\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n\n        this._addItem(obj);\n\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      } // Hide base layers section if there's only one layer.\n\n\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n\n      var obj = this._getLayer(stamp(e.target)); // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layer control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layer control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layer control](#control-layers).\n      // @namespace Control.Layers\n\n\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n          checked = this._map.hasLayer(obj.layer),\n          input;\n\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n\n      this._layerControlInputs.push(input);\n\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n\n      var holder = document.createElement('div');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n\n      this._checkDisabledLayers();\n\n      return label;\n    },\n    _onInputClick: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer;\n      var addedLayers = [],\n          removedLayers = [];\n      this._handlingClick = true;\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      } // Bugfix issue 2318: Should remove all old layers before readding new ones\n\n\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n\n      this._handlingClick = false;\n\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer,\n          zoom = this._map.getZoom();\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n\n      return this;\n    },\n    _expand: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.expand();\n    },\n    _collapse: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.collapse();\n    }\n  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '+'\n      // The text set on the 'zoom in' button.\n      zoomInText: '+',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '&#x2212;'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '&#x2212;',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n          container = create$1('div', zoomName + ' leaflet-bar'),\n          options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n\n      this._updateDisabled();\n\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n          className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n      }\n\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n      }\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  }); // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n          container = create$1('div', className),\n          options = this.options;\n\n      this._addScales(options, className + '-line', container);\n\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n          y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n          maxMiles,\n          miles,\n          feet;\n\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n          d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  }); // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container); // TODO ugly, refactor\n\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n\n      this._update();\n\n      return this._container;\n    },\n    // @method setPrefix(prefix: String): this\n    // Sets the text before the attributions.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n\n      this._update();\n\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n\n      this._attributions[text]++;\n\n      this._update();\n\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n\n        this._update();\n      }\n\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var attribs = [];\n\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n\n      var prefixAndAttribs = [];\n\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n\n      this._container.innerHTML = prefixAndAttribs.join(' | ');\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  }); // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    } // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n\n  }); // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n\n  var Mixin = {\n    Events: Events\n  };\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = touch ? 'touchstart mousedown' : 'mousedown';\n  var END = {\n    mousedown: 'mouseup',\n    touchstart: 'touchend',\n    pointerdown: 'touchend',\n    MSPointerDown: 'touchend'\n  };\n  var MOVE = {\n    mousedown: 'mousemove',\n    touchstart: 'touchmove',\n    pointerdown: 'touchmove',\n    MSPointerDown: 'touchmove'\n  };\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline$$1, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline$$1;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      } // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n\n\n      if (Draggable._dragging === this) {\n        this.finishDrag();\n      }\n\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this._moved = false;\n\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n\n      disableImageDrag();\n      disableTextSelection();\n\n      if (this._moving) {\n        return;\n      } // @event down: Event\n      // Fired when a drag is about to start.\n\n\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n          sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n\n      this._parentScale = getScale(sizedParent);\n      on(document, MOVE[e.type], this._onMove, this);\n      on(document, END[e.type], this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n\n      if (!offset.x && !offset.y) {\n        return;\n      }\n\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n\n\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        this._startPos = getPosition(this._element).subtract(offset);\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n\n        if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      cancelAnimFrame(this._animRequest);\n      this._lastEvent = e;\n      this._animRequest = requestAnimFrame(this._updatePosition, this, true);\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      }; // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos); // @event drag: Event\n      // Fired continuously during dragging.\n\n      this.fire('drag', e);\n    },\n    _onUp: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this.finishDrag();\n    },\n    finishDrag: function () {\n      removeClass(document.body, 'leaflet-dragging');\n\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n\n      for (var i in MOVE) {\n        off(document, MOVE[i], this._onMove, this);\n        off(document, END[i], this._onUp, this);\n      }\n\n      enableImageDrag();\n      enableTextSelection();\n\n      if (this._moved && this._moving) {\n        // ensure drag is not fired after dragend\n        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n\n        this.fire('dragend', {\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n\n      this._moving = false;\n      Draggable._dragging = false;\n    }\n  });\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).\n\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n\n    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction\n\n    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification\n\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n\n\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n\n\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\n\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n        markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n    var i,\n        newPoints = [];\n\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n\n    return newPoints;\n  }\n\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n        index,\n        i,\n        sqDist;\n\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  } // reduce points that are too close to each other to a single point\n\n\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n\n    return reducedPoints;\n  }\n\n  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n\n\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n        codeB = _getBitCode(b, bounds),\n        codeOut,\n        p,\n        newCode; // save 2nd code to avoid calculating it on the next segment\n\n\n    _lastCode = codeB;\n\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      } // if a,b is outside the clip window (trivial reject)\n\n\n      if (codeA & codeB) {\n        return false;\n      } // other cases\n\n\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n        dy = b.y - a.y,\n        min = bounds.min,\n        max = bounds.max,\n        x,\n        y;\n\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n\n    return new Point(x, y, round);\n  }\n\n  function _getBitCode(p, bounds) {\n    var code = 0;\n\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n\n    return code;\n  } // square distance (to avoid unnecessary Math.sqrt calls)\n\n\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n        dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  } // return closest point on segment or distance to that point\n\n\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  } // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n\n\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  var LineUtil = (Object.freeze || Object)({\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat\n  });\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n        edges = [1, 4, 2, 8],\n        i,\n        j,\n        k,\n        a,\n        b,\n        len,\n        edge,\n        p;\n\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    } // for each edge (left, bottom, right, top)\n\n\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j]; // if a is inside the clip window\n\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n\n          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n\n      points = clippedPoints;\n    }\n\n    return points;\n  }\n\n  var PolyUtil = (Object.freeze || Object)({\n    clipPolygon: clipPolygon\n  });\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection  the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          r = this.R,\n          y = latlng.lat * d,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n          r = this.R,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          ts = Math.exp(-point.y / r),\n          phi = Math.PI / 2 - 2 * Math.atan(ts);\n\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n  /*\n   * @class Projection\n  \n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).\n  \n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n  \n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n  \n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n  \n   * Note that the projection instances do not inherit from Leafet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n  \n   */\n\n  var index = (Object.freeze || Object)({\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n          dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \" OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target; // check in case layer gets added and then removed before the map is ready\n\n      if (!map.hasLayer(this)) {\n        return;\n      }\n\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n\n      this.onAdd(map);\n\n      if (this.getAttribution && map.attributionControl) {\n        map.attributionControl.addAttribution(this.getAttribution());\n      }\n\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n\n      var id = stamp(layer);\n\n      if (this._layers[id]) {\n        return this;\n      }\n\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n\n      if (!this._layers[id]) {\n        return this;\n      }\n\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n\n      if (layer.getAttribution && this.attributionControl) {\n        this.attributionControl.removeAttribution(layer.getAttribution());\n      }\n\n      delete this._layers[id];\n\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return !!layer && stamp(layer) in this._layers;\n    },\n\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n          maxZoom = -Infinity,\n          oldZoomSpan = this._getZoomSpan();\n\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, ): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          i,\n          layer;\n\n      for (i in this._layers) {\n        layer = this._layers[i];\n\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n\n      return bounds;\n    }\n  }); // @factory L.featureGroup(layers: Layer[])\n  // Create a feature group, optionally given an initial set of layers.\n\n  var featureGroup = function (layers) {\n    return new FeatureGroup(layers);\n  };\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0]\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n\n        return null;\n      }\n\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n\n      this._setIconStyles(img, name);\n\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n\n      var size = toPoint(sizeOption),\n          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  }); // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n\n  function icon(options) {\n    return new Icon(options);\n  }\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (!IconDefault.imagePath) {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      } // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n\n\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n\n      if (path === null || path.indexOf('url') !== 0) {\n        path = '';\n      } else {\n        path = path.replace(/^url\\([\"']?/, '').replace(/marker-icon\\.png[\"']?\\)$/, '');\n      }\n\n      return path;\n    }\n  });\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n          map = marker._map,\n          speed = this._marker.options.autoPanSpeed,\n          padding = this._marker.options.autoPanPadding,\n          iconPos = getPosition(marker._icon),\n          bounds = map.getPixelBounds(),\n          origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n\n        this._draggable._newPos._add(movement);\n\n        this._draggable._startPos._add(movement);\n\n        setPosition(marker._icon, this._draggable._newPos);\n\n        this._onDrag(e);\n\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n      this._oldLatLng = this._marker.getLatLng();\n\n      this._marker.closePopup().fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n          shadow = marker._shadow,\n          iconPos = getPosition(marker._icon),\n          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position\n\n\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng; // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n      cancelAnimFrame(this._panRequest); // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n\n      delete this._oldLatLng;\n\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      title: '',\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the icon image (useful for accessibility).\n      alt: '',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option pane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n\n      this._initIcon();\n\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n\n      delete this.dragging;\n\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n\n      this._removeIcon();\n\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n\n      if (this._map) {\n        this._initIcon();\n\n        this.update();\n      }\n\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n\n        this._setPos(pos);\n      }\n\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n          addIcon = false; // if we're not reusing the icon, remove the old one and init new one\n\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n\n        addIcon = true;\n\n        if (options.title) {\n          icon.title = options.title;\n        }\n\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n\n      addClass(icon, classToAdd);\n\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n      }\n\n      this._icon = icon;\n\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      var newShadow = options.icon.createShadow(this._shadow),\n          addShadow = false;\n\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n\n        addShadow = true;\n      }\n\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n\n      this._shadow = newShadow;\n\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n\n      this._initInteraction();\n\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n\n      this._zIndex = pos.y + this.options.zIndexOffset;\n\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n\n        this.dragging = new MarkerDrag(this);\n\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._map) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  }); // factory L.marker(latlng: LatLng, options? : Marker options)\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n\n      this._reset();\n\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n\n        if (this.options.stroke && style && style.hasOwnProperty('weight')) {\n          this._updateBounds();\n        }\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;\n    }\n  });\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n          r2 = this._radiusY || r,\n          w = this._clickTolerance(),\n          p = [r + w, r2 + w];\n\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      } // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n\n\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n          lat = this._latlng.lat,\n          map = this._map,\n          crs = map.options.crs;\n\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n            latR = this._mRadius / Earth.R / d,\n            top = map.project([lat + latR, lng]),\n            bottom = map.project([lat - latR, lng]),\n            p = top.add(bottom).divideBy(2),\n            lat2 = map.unproject(p).lat,\n            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n\n      this._updateBounds();\n    }\n  }); // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n          minPoint = null,\n          closest = _sqClosestPointOnSegment,\n          p1,\n          p2;\n\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          halfDist,\n          segDist,\n          dist,\n          p1,\n          p2,\n          ratio,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polyline centroid algorithm; only uses the first ring if there are multiple\n\n\n      for (i = 0, halfDist = 0; i < len - 1; i++) {\n        halfDist += points[i].distanceTo(points[i + 1]) / 2;\n      } // The line is so small in the current view that all points are on the same pixel.\n\n\n      if (halfDist === 0) {\n        return this._map.layerPointToLatLng(points[0]);\n      }\n\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);\n        }\n      }\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n\n      this._bounds.extend(latlng);\n\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n          flat = isFlat(latlngs);\n\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n          p = new Point(w, w);\n\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n          len = latlngs.length,\n          i,\n          ring;\n\n      if (flat) {\n        ring = [];\n\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      var parts = this._parts,\n          i,\n          j,\n          k,\n          len,\n          len2,\n          segment,\n          points;\n\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n          if (!segment) {\n            continue;\n          }\n\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part\n\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n          tolerance = this.options.smoothFactor;\n\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._clipPoints();\n\n      this._simplifyPoints();\n\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n          j,\n          k,\n          len,\n          len2,\n          part,\n          w = this._clickTolerance();\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // hit detection for polylines\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n\n\n  Polyline._flat = _flat;\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          j,\n          p1,\n          p2,\n          f,\n          area,\n          x,\n          y,\n          center,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polygon centroid algorithm; only uses the first ring if there are multiple\n\n\n      area = x = y = 0;\n\n      for (i = 0, j = len - 1; i < len; j = i++) {\n        p1 = points[i];\n        p2 = points[j];\n        f = p1.y * p2.x - p2.y * p1.x;\n        x += (p1.x + p2.x) * f;\n        y += (p1.y + p2.y) * f;\n        area += f * 3;\n      }\n\n      if (area === 0) {\n        // Polygon is so small that all points are on same pixel.\n        center = points[0];\n      } else {\n        center = [x / area, y / area];\n      }\n\n      return this._map.layerPointToLatLng(center);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n          len = result.length; // remove last point if it equals first one\n\n\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n      var bounds = this._renderer._bounds,\n          w = this.options.weight,\n          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges\n\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n          part,\n          p1,\n          p2,\n          i,\n          j,\n          k,\n          len,\n          len2;\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // ray casting algorithm for detecting if point is in polygon\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      } // also check if it's on polygon stroke\n\n\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n          i,\n          len,\n          feature;\n\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n\n        return this;\n      }\n\n      var options = this.options;\n\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n\n      var layer = geometryToLayer(geojson, options);\n\n      if (!layer) {\n        return this;\n      }\n\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      } // reset any custom styles\n\n\n      layer.options = extend({}, layer.defaultOptions);\n\n      this._setLayerStyle(layer, this.options.style);\n\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n\n        layer.setStyle(style);\n      }\n    }\n  }); // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n        coords = geometry ? geometry.coordinates : null,\n        layers = [],\n        pointToLayer = options && options.pointToLayer,\n        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n        latlng,\n        latlngs,\n        i,\n        len;\n\n    if (!coords && !geometry) {\n      return null;\n    }\n\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n\n        return new FeatureGroup(layers);\n\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var layer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n\n          if (layer) {\n            layers.push(layer);\n          }\n        }\n\n        return new FeatureGroup(layers);\n\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  } // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n\n\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n\n\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n\n    return latlngs;\n  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n\n\n  function latLngToCoords(latlng, precision) {\n    precision = typeof precision === 'number' ? precision : 6;\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n\n\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n\n    if (!levelsDeep && closed) {\n      coords.push(coords[0]);\n    }\n\n    return coords;\n  }\n\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  } // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n\n\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  }; // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n\n  Marker.include(PointToGeoJSON); // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON); // @namespace Polyline\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  }); // @namespace Polygon\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n          multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n\n      if (!holes) {\n        coords = [coords];\n      }\n\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  }); // @namespace LayerGroup\n\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number): Object\n    // `precision` is the number of decimal places for coordinates.\n    // The default value is 6 places.\n    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n\n      var isGeometryCollection = type === 'GeometryCollection',\n          jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json); // Squash nested feature collections\n\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  }); // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  } // Backward compatibility.\n\n\n  var geoJson = geoJSON;\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n\n      this.getPane().appendChild(this._image);\n\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._image) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n\n      if (this._image) {\n        this._image.src = url;\n      }\n\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n\n      if (this._map) {\n        this._reset();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn; // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n          size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    }\n  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n      keepAspectRatio: true\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn; // @event load: Event\n      // Fired when the video has finished loading the first frame\n\n      vid.onloadeddata = bind(this.fire, this, 'load');\n\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n\n      if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    } // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n\n  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    } // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n\n  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.\r\n   */\n  // @namespace DivOverlay\n\n\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position. Useful to control the anchor\n      // of the popup when opening it on some overlays.\n      offset: [0, 7],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: '',\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane'\n    },\n    initialize: function (options, source) {\n      setOptions(this, options);\n      this._source = source;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (!this._container) {\n        this._initLayout();\n      }\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n\n      this.bringToFront();\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n    },\n    // @namespace Popup\n    // @method getLatLng: LatLng\n    // Returns the geographical point of popup.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the popup will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n\n      if (this._map) {\n        this._updatePosition();\n\n        this._adjustPan();\n      }\n\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the popup.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Alias for [getContent()](#popup-getcontent)\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._container.style.visibility = 'hidden';\n\n      this._updateContent();\n\n      this._updateLayout();\n\n      this._updatePosition();\n\n      this._container.style.visibility = '';\n\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the popup is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this popup in front of other popups (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this popup to the back of other popups (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n\n      return this;\n    },\n    _prepareOpen: function (parent, layer, latlng) {\n      if (!(layer instanceof Layer)) {\n        latlng = layer;\n        layer = parent;\n      }\n\n      if (layer instanceof FeatureGroup) {\n        for (var id in parent._layers) {\n          layer = parent._layers[id];\n          break;\n        }\n      }\n\n      if (!latlng) {\n        if (layer.getCenter) {\n          latlng = layer.getCenter();\n        } else if (layer.getLatLng) {\n          latlng = layer.getLatLng();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      } // set overlay source to this layer\n\n\n      this._source = layer; // update the overlay (content, layout, ect...)\n\n      this.update();\n      return latlng;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n\n        node.appendChild(content);\n      }\n\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n\n      var bottom = this._containerBottom = -offset.y,\n          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)\n\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   * Here's a more complicated way to open a popup on a map:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n  // @namespace Popup\n\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.\n    openOn: function (map) {\n      map.openPopup(this);\n      return this;\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n\n      map.fire('popupopen', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true); // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n\n\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n\n      map.fire('popupclose', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this._close;\n      }\n\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closePopup(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(wrapper);\n      disableScrollPropagation(this._contentNode);\n      on(wrapper, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.href = '#close';\n        closeButton.innerHTML = '&#215;';\n        on(closeButton, 'click', this._onCloseButtonClick, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n          style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n          maxHeight = this.options.maxHeight,\n          scrolledClass = 'leaflet-popup-scrolled';\n\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n          anchor = this._getAnchor();\n\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      var map = this._map,\n          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n          containerHeight = this._container.offsetHeight + marginBottom,\n          containerWidth = this._containerWidth,\n          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n      layerPos._add(getPosition(this._container));\n\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n          padding = toPoint(this.options.autoPanPadding),\n          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n          size = map.getSize(),\n          dx = 0,\n          dy = 0;\n\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      } // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n\n\n      if (dx || dy) {\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _onCloseButtonClick: function (e) {\n      this._close();\n\n      stop(e);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  }); // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n\n\n  Map.mergeOptions({\n    closePopupOnClick: true\n  }); // @namespace Map\n  // @section Methods for Layers and Controls\n\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      if (!(popup instanceof Popup)) {\n        popup = new Popup(options).setContent(popup);\n      }\n\n      if (latlng) {\n        popup.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(popup)) {\n        return this;\n      }\n\n      if (this._popup && this._popup.options.autoClose) {\n        this.closePopup();\n      }\n\n      this._popup = popup;\n      return this.addLayer(popup);\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      if (!popup || popup === this._popup) {\n        popup = this._popup;\n        this._popup = null;\n      }\n\n      if (popup) {\n        this.removeLayer(popup);\n      }\n\n      return this;\n    }\n  });\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n  // @section Popup methods\n\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      if (content instanceof Popup) {\n        setOptions(content, options);\n        this._popup = content;\n        content._source = this;\n      } else {\n        if (!this._popup || options) {\n          this._popup = new Popup(options, this);\n        }\n\n        this._popup.setContent(content);\n      }\n\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (layer, latlng) {\n      if (this._popup && this._map) {\n        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map\n\n        this._map.openPopup(this._popup, latlng);\n      }\n\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup._close();\n      }\n\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function (target) {\n      if (this._popup) {\n        if (this._popup._map) {\n          this.closePopup();\n        } else {\n          this.openPopup(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._popup) {\n        return;\n      }\n\n      if (!this._map) {\n        return;\n      } // prevent map click\n\n\n      stop(e); // if this inherits from Path its a vector and we can just\n      // open the popup at the new location\n\n      if (layer instanceof Path) {\n        this.openPopup(e.layer || e.target, e.latlng);\n        return;\n      } // otherwise treat it like a marker and figure out\n      // if we should toggle it open/closed\n\n\n      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n        this.closePopup();\n      } else {\n        this.openPopup(layer, e.latlng);\n      }\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n  // @namespace Tooltip\n\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option interactive: Boolean = false\n      // If true, the tooltip will listen to the feature events.\n      interactive: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (touch && !this.options.permanent) {\n        events.preclick = this._close;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closeTooltip(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var map = this._map,\n          container = this._container,\n          centerPoint = map.latLngToContainerPoint(map.getCenter()),\n          tooltipPoint = map.layerPointToContainerPoint(pos),\n          direction = this.options.direction,\n          tooltipWidth = container.offsetWidth,\n          tooltipHeight = container.offsetHeight,\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (direction === 'top') {\n        pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));\n      } else if (direction === 'bottom') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));\n      } else if (direction === 'center') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));\n      } else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));\n      } else {\n        direction = 'left';\n        pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));\n      }\n\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  }); // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  }; // @namespace Map\n  // @section Methods for Layers and Controls\n\n\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      if (!(tooltip instanceof Tooltip)) {\n        tooltip = new Tooltip(options).setContent(tooltip);\n      }\n\n      if (latlng) {\n        tooltip.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(tooltip)) {\n        return this;\n      }\n\n      return this.addLayer(tooltip);\n    },\n    // @method closeTooltip(tooltip?: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      if (tooltip) {\n        this.removeLayer(tooltip);\n      }\n\n      return this;\n    }\n  });\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n  // @section Tooltip methods\n\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (content instanceof Tooltip) {\n        setOptions(content, options);\n        this._tooltip = content;\n        content._source = this;\n      } else {\n        if (!this._tooltip || options) {\n          this._tooltip = new Tooltip(options, this);\n        }\n\n        this._tooltip.setContent(content);\n      }\n\n      this._initTooltipInteractions();\n\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n\n      return this;\n    },\n    _initTooltipInteractions: function (remove$$1) {\n      if (!remove$$1 && this._tooltipHandlersAdded) {\n        return;\n      }\n\n      var onOff = remove$$1 ? 'off' : 'on',\n          events = {\n        remove: this.closeTooltip,\n        move: this._moveTooltip\n      };\n\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n\n        if (this._tooltip.options.sticky) {\n          events.mousemove = this._moveTooltip;\n        }\n\n        if (touch) {\n          events.click = this._openTooltip;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove$$1;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (layer, latlng) {\n      if (this._tooltip && this._map) {\n        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map\n\n        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never\n        // opened.\n\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          addClass(this._tooltip._container, 'leaflet-clickable');\n          this.addInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip._close();\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          removeClass(this._tooltip._container, 'leaflet-clickable');\n          this.removeInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function (target) {\n      if (this._tooltip) {\n        if (this._tooltip._map) {\n          this.closeTooltip();\n        } else {\n          this.openTooltip(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _openTooltip: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n          containerPoint,\n          layerPoint;\n\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n          options = this.options;\n\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n\n      this._setIconStyles(div, 'icon');\n\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  }); // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n\n      this._levels = {};\n      this._tiles = {};\n\n      this._resetView();\n\n      this._update();\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n\n      remove(this._container);\n\n      map._removeZoomLimit(this);\n\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n\n        this._setAutoZIndex(Math.max);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n\n        this._setAutoZIndex(Math.min);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      this._updateOpacity();\n\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n\n        this._update();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n\n        events.move = this._onMove;\n      }\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n      var layers = this.getPane().children,\n          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\n\n      if (ielt9) {\n        return;\n      }\n\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n          nextFrame = false,\n          willPrune = false;\n\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n\n          tile.active = true;\n        }\n      }\n\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n\n      this._updateZIndex();\n\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom;\n\n      if (zoom === undefined) {\n        return undefined;\n      }\n\n      for (var z in this._levels) {\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n\n          this._removeTilesAtZoom(z);\n\n          this._onRemoveLevel(z);\n\n          delete this._levels[z];\n        }\n      }\n\n      var level = this._levels[zoom],\n          map = this._map;\n\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n\n        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition\n\n\n        falseFn(level.el.offsetWidth);\n\n        this._onCreateLevel(level);\n      }\n\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var key, tile;\n\n      var zoom = this._map.getZoom();\n\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n\n        return;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n\n        this._onRemoveLevel(z);\n\n        delete this._levels[z];\n      }\n\n      this._removeAllTiles();\n\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n          y2 = Math.floor(y / 2),\n          z2 = z - 1,\n          coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n\n      var key = this._tileCoordsToKey(coords2),\n          tile = this._tiles[key];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n\n          var key = this._tileCoordsToKey(coords),\n              tile = this._tiles[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = this._clampZoom(Math.round(zoom));\n\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      }\n\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n\n        this._updateLevels();\n\n        this._resetGrid();\n\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n\n        if (!noPrune) {\n          this._pruneTiles();\n        } // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n\n\n        this._noPrune = !!noPrune;\n      }\n\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n      if (any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n          crs = map.options.crs,\n          tileSize = this._tileSize = this.getTileSize(),\n          tileZoom = this._tileZoom;\n\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n          scale = map.getZoomScale(mapZoom, this._tileZoom),\n          pixelCenter = map.project(center, this._tileZoom).floor(),\n          halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n\n      if (!map) {\n        return;\n      }\n\n      var zoom = this._clampZoom(map.getZoom());\n\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n          tileRange = this._pxBoundsToTileRange(pixelBounds),\n          tileCenter = tileRange.getCenter(),\n          queue = [],\n          margin = this.options.keepBuffer,\n          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.\n\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      } // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n\n\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n\n        return;\n      } // create a queue of coordinates to load tiles from\n\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      } // sort tile queue to load tiles in order of their distance to center\n\n\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true; // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n\n          this.fire('loading');\n        } // create DOM fragment to append tiles in one batch\n\n\n        var fragment = document.createDocumentFragment();\n\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n\n      if (!this.options.bounds) {\n        return true;\n      } // don't load tile if it doesn't intersect the bounds in options\n\n\n      var tileBounds = this._tileCoordsToBounds(coords);\n\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n          tileSize = this.getTileSize(),\n          nwPoint = coords.scaleBy(tileSize),\n          sePoint = nwPoint.add(tileSize),\n          nw = map.unproject(nwPoint, coords.z),\n          se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n          bounds = new LatLngBounds(bp[0], bp[1]);\n\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n          coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      remove(tile.el);\n      delete this._tiles[key]; // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems\n\n      if (ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      } // without this hack, tiles disappear after zoom on Chrome for Android\n      // https://github.com/Leaflet/Leaflet/issues/2078\n\n\n      if (android && !android23) {\n        tile.style.WebkitBackfaceVisibility = 'hidden';\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n          key = this._tileCoordsToKey(coords);\n\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n      this._initTile(tile); // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n\n\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n\n      setPosition(tile, tilePos); // save tile in cache\n\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile); // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n\n      var key = this._tileCoordsToKey(coords);\n\n      tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      tile.loaded = +new Date();\n\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n\n        this._pruneTiles();\n      }\n\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent\n        // Fired when a tile loads.\n\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n\n      if (this._noTilesToLoad()) {\n        this._loading = false; // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n\n        this.fire('load');\n\n        if (ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }); // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>'}).addTo(map);\r\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels\n\n      if (options.detectRetina && retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom--;\n        } else {\n          options.zoomOffset--;\n          options.minZoom++;\n        }\n\n        options.minZoom = Math.max(0, options.minZoom);\n      }\n\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      } // for https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!android) {\n        this.on('tileunload', this._onTileRemove);\n      }\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n\n      this._url = url;\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      /*\r\n       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n       http://www.w3.org/TR/WCAG20-TECHS/H67\r\n      */\n\n\n      tile.alt = '';\n      /*\r\n       Set role=\"presentation\" to force screen readers to ignore this\r\n       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n      */\n\n      tile.setAttribute('role', 'presentation');\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n\n        data['-y'] = invertedY;\n      }\n\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom,\n          zoomReverse = this.options.zoomReverse,\n          zoomOffset = this.options.zoomOffset;\n\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            remove(tile);\n            delete this._tiles[i];\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      } // Cancels any pending http requests associated with the tile\n      // unless we're on Android's stock browser,\n      // see https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!androidStock) {\n        tile.el.setAttribute('src', emptyImageUrl);\n      }\n\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data  2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params\n\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n          crs = this._crs,\n          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n          min = bounds.min,\n          max = bounds.max,\n          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n          url = TileLayer.prototype.getTileUrl.call(this, coords);\n\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    }\n  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1,\n      // @option tolerance: Number = 0\n      // How much to extend click tolerance round a path/object on the map\n      tolerance: 0\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n\n        if (this._zoomAnimated) {\n          addClass(this._container, 'leaflet-zoom-animated');\n        }\n      }\n\n      this.getPane().appendChild(this._container);\n\n      this._update();\n\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n          position = getPosition(this._container),\n          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n          currentCenterPoint = this._map.project(this._center, zoom),\n          destCenterPoint = this._map.project(center, zoom),\n          centerOffset = destCenterPoint.subtract(currentCenterPoint),\n          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n      if (any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n\n      this._updateTransform(this._center, this._zoom);\n\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n          size = this._map.getSize(),\n          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n\n      var layer;\n      this._redrawBounds = null;\n\n      for (var id in this._layers) {\n        layer = this._layers[id];\n\n        layer._update();\n      }\n\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          container = this._container,\n          size = b.getSize(),\n          m = retina ? 2 : 1;\n      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina\n\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n\n      if (retina) {\n        this._ctx.scale(2, 2);\n      } // translate so we use the same path coordinates after canvas element moves\n\n\n      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves\n\n\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n\n      layer._project();\n\n      layer._update(); // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n\n\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n            dashArray = [],\n            dashValue,\n            i;\n\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths\n\n          if (isNaN(dashValue)) {\n            return;\n          }\n\n          dashArray.push(dashValue);\n        }\n\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n\n      this._extendRedrawBounds(layer);\n\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n\n        this._redrawBounds.max._ceil();\n      }\n\n      this._clear(); // clear layers in redraw bounds\n\n\n      this._draw(); // draw layers\n\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n      }\n    },\n    _draw: function () {\n      var layer,\n          bounds = this._redrawBounds;\n\n      this._ctx.save();\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.beginPath();\n\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n\n        this._ctx.clip();\n      }\n\n      this._drawing = true;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n\n      this._drawing = false;\n\n      this._ctx.restore(); // Restore state before clipping.\n\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n\n      var i,\n          j,\n          len2,\n          p,\n          parts = layer._parts,\n          len = parts.length,\n          ctx = this._ctx;\n\n      if (!len) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n\n      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n\n      var p = layer._point,\n          ctx = this._ctx,\n          r = Math.max(Math.round(layer._radius), 1),\n          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n      if (s !== 1) {\n        ctx.restore();\n      }\n\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n          layer,\n          clickedLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {\n          clickedLayer = layer;\n        }\n      }\n\n      if (clickedLayer) {\n        fakeStop(e);\n\n        this._fireEvent([clickedLayer], e);\n      }\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n\n      var point = this._map.mouseEventToLayerPoint(e);\n\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n\n        this._fireEvent([layer], e, 'mouseout');\n\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n\n      var layer, candidateHoveredLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n\n      if (this._hoveredLayer) {\n        this._fireEvent([this._hoveredLayer], e);\n      }\n\n      this._mouseHoverThrottled = true;\n      setTimeout(L.bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n\n      this._requestRedraw(layer);\n    }\n  }); // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n\n  function canvas$1(options) {\n    return canvas ? new Canvas(options) : null;\n  }\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      return function (name) {\n        return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n      };\n    }\n  }();\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n\n\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n\n      this._container.appendChild(container);\n\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n          fill = layer._fill,\n          options = layer.options,\n          container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n          r = Math.round(layer._radius),\n          r2 = Math.round(layer._radiusY || r);\n\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create$2 = vml ? vmlCreate : svgCreate;\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.zoomstart = this._onZoomStart;\n      return events;\n    },\n    _initContainer: function () {\n      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths\n\n      this._container.setAttribute('pointer-events', 'none');\n\n      this._rootGroup = create$2('g');\n\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _onZoomStart: function () {\n      // Drag-then-pinch interactions might mess up the center and zoom.\n      // In this case, the easiest way to prevent this is re-do the renderer\n      //   bounds and padding when the zooming starts.\n      this._update();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          size = b.getSize(),\n          container = this._container; // set size of svg-container if changed\n\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      } // movement: update container viewBox so that we don't have to change coordinates of individual layers\n\n\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n    _initPath: function (layer) {\n      var path = layer._path = create$2('path'); // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n\n      this._rootGroup.appendChild(layer._path);\n\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n          options = layer.options;\n\n      if (!path) {\n        return;\n      }\n\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n          r = Math.max(Math.round(layer._radius), 1),\n          r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs\n\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n\n  if (vml) {\n    SVG.include(vmlMixin);\n  } // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n\n\n  function svg$1(options) {\n    return svg || vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n\n      var renderer = this._paneRenderers[name];\n\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas$1(options) || svg$1(options);\n    }\n  });\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create$2;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      } // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n\n\n      this._clearDeferredResetState();\n\n      this._resetState();\n\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n\n        this._map.fire('boxzoomstart');\n      }\n\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n          size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n\n      this._finish();\n\n      if (!this._moved) {\n        return;\n      } // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n\n\n      this._clearDeferredResetState();\n\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n      }\n    }\n  }); // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n          oldZoom = map.getZoom(),\n          delta = map.options.zoomDelta,\n          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  }); // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map be draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default unless running on old Android devices.\n    inertia: !android23,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second.\n    inertiaDeceleration: 3400,\n    // px/s^2\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n\n      this._draggable.enable();\n\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n\n      map._stop();\n\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n\n      map.fire('movestart').fire('dragstart');\n\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n        this._positions.push(pos);\n\n        this._times.push(time);\n\n        this._prunePositions(time);\n      }\n\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n      var limit = this._offsetLimit;\n\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n          halfWidth = Math.round(worldWidth / 2),\n          dx = this._initialWorldOffset,\n          x = this._draggable._newPos.x,\n          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n          options = map.options,\n          noInertia = !options.inertia || this._times.length < 2;\n      map.fire('dragend', e);\n\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n\n        var direction = this._lastPos.subtract(this._positions[0]),\n            duration = (this._lastTime - this._times[0]) / 1000,\n            ease = options.easeLinearity,\n            speedVector = direction.multiplyBy(ease / duration),\n            speed = speedVector.distanceTo([0, 0]),\n            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  }); // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n\n  Map.addInitHook('addHandler', 'dragging', Drag);\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Keyboard Navigation Options\n\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n\n      this._setPanDelta(map.options.keyboardPanDelta);\n\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container; // make the container focusable by tabbing\n\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n\n      var body = document.body,\n          docEl = document.documentElement,\n          top = body.scrollTop || docEl.scrollTop,\n          left = body.scrollLeft || docEl.scrollLeft;\n\n      this._map._container.focus();\n\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      var key = e.keyCode,\n          map = this._map,\n          offset;\n\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n\n          map.panBy(offset);\n\n          if (map.options.maxBounds) {\n            map.panInsideBounds(map.options.maxBounds);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n\n      stop(e);\n    }\n  }); // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Mousewheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'mousewheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n          zoom = map.getZoom(),\n          snap = this._map.options.zoomSnap || 0;\n\n      map._stop(); // stop panning and fly animations if any\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n\n\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n\n      if (!delta) {\n        return;\n      }\n\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  }); // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n  /*\n   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tap: Boolean = true\n    // Enables mobile hacks for supporting instant taps (fixing 200ms click\n    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).\n    tap: true,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var Tap = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      if (!e.touches) {\n        return;\n      }\n\n      preventDefault(e);\n      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch\n\n      if (e.touches.length > 1) {\n        this._fireClick = false;\n        clearTimeout(this._holdTimeout);\n        return;\n      }\n\n      var first = e.touches[0],\n          el = first.target;\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it\n\n      if (el.tagName && el.tagName.toLowerCase() === 'a') {\n        addClass(el, 'leaflet-active');\n      } // simulate long hold but setting a timeout\n\n\n      this._holdTimeout = setTimeout(bind(function () {\n        if (this._isTapValid()) {\n          this._fireClick = false;\n\n          this._onUp();\n\n          this._simulateEvent('contextmenu', first);\n        }\n      }, this), 1000);\n\n      this._simulateEvent('mousedown', first);\n\n      on(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n    },\n    _onUp: function (e) {\n      clearTimeout(this._holdTimeout);\n      off(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n\n      if (this._fireClick && e && e.changedTouches) {\n        var first = e.changedTouches[0],\n            el = first.target;\n\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n          removeClass(el, 'leaflet-active');\n        }\n\n        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much\n\n\n        if (this._isTapValid()) {\n          this._simulateEvent('click', first);\n        }\n      }\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n\n      this._simulateEvent('mousemove', first);\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = document.createEvent('MouseEvents');\n      simulatedEvent._simulated = true;\n      e.target._simulatedClick = true;\n      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  }); // @section Handlers\n  // @property tap: Handler\n  // Mobile touch hacks (quick tap and touch hold) handler.\n\n  if (touch && !pointer) {\n    Map.addInitHook('addHandler', 'tap', Tap);\n  }\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers except for old Androids.\n    touchZoom: touch && !android23,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n\n      map._stop();\n\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n\n      var map = this._map,\n          p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]),\n          scale = p1.distanceTo(p2) / this._startDist;\n\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n\n      if (!this._moved) {\n        map._moveStart(true, false);\n\n        this._moved = true;\n      }\n\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      });\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'touchend', this._onTouchEnd); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  }); // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.Tap = Tap;\n  Map.TouchZoom = TouchZoom;\n  Object.freeze = freeze;\n  exports.version = version;\n  exports.Control = Control;\n  exports.control = control;\n  exports.Browser = Browser;\n  exports.Evented = Evented;\n  exports.Mixin = Mixin;\n  exports.Util = Util;\n  exports.Class = Class;\n  exports.Handler = Handler;\n  exports.extend = extend;\n  exports.bind = bind;\n  exports.stamp = stamp;\n  exports.setOptions = setOptions;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.PosAnimation = PosAnimation;\n  exports.Draggable = Draggable;\n  exports.LineUtil = LineUtil;\n  exports.PolyUtil = PolyUtil;\n  exports.Point = Point;\n  exports.point = toPoint;\n  exports.Bounds = Bounds;\n  exports.bounds = toBounds;\n  exports.Transformation = Transformation;\n  exports.transformation = toTransformation;\n  exports.Projection = index;\n  exports.LatLng = LatLng;\n  exports.latLng = toLatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.latLngBounds = toLatLngBounds;\n  exports.CRS = CRS;\n  exports.GeoJSON = GeoJSON;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.layerGroup = layerGroup;\n  exports.FeatureGroup = FeatureGroup;\n  exports.featureGroup = featureGroup;\n  exports.ImageOverlay = ImageOverlay;\n  exports.imageOverlay = imageOverlay;\n  exports.VideoOverlay = VideoOverlay;\n  exports.videoOverlay = videoOverlay;\n  exports.SVGOverlay = SVGOverlay;\n  exports.svgOverlay = svgOverlay;\n  exports.DivOverlay = DivOverlay;\n  exports.Popup = Popup;\n  exports.popup = popup;\n  exports.Tooltip = Tooltip;\n  exports.tooltip = tooltip;\n  exports.Icon = Icon;\n  exports.icon = icon;\n  exports.DivIcon = DivIcon;\n  exports.divIcon = divIcon;\n  exports.Marker = Marker;\n  exports.marker = marker;\n  exports.TileLayer = TileLayer;\n  exports.tileLayer = tileLayer;\n  exports.GridLayer = GridLayer;\n  exports.gridLayer = gridLayer;\n  exports.SVG = SVG;\n  exports.svg = svg$1;\n  exports.Renderer = Renderer;\n  exports.Canvas = Canvas;\n  exports.canvas = canvas$1;\n  exports.Path = Path;\n  exports.CircleMarker = CircleMarker;\n  exports.circleMarker = circleMarker;\n  exports.Circle = Circle;\n  exports.circle = circle;\n  exports.Polyline = Polyline;\n  exports.polyline = polyline;\n  exports.Polygon = Polygon;\n  exports.polygon = polygon;\n  exports.Rectangle = Rectangle;\n  exports.rectangle = rectangle;\n  exports.Map = Map;\n  exports.map = createMap;\n  var oldL = window.L;\n\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  }; // Always export us to window global (see #2364)\n\n\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvVXRpbC5qcz8yZTY0Iiwid2VicGFjazovLy8uLi9zcmMvY29yZS9DbGFzcy5qcz8wMWFjIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9FdmVudHMuanM/MTM2ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzPzE1NDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanM/MWM3OSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmdCb3VuZHMuanM/YjU3YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmcuanM/NWI2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLmpzP2IyY2QiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcz8xMDE5Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcz8xZTVlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanM/YzI1MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzP2YyMmUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanM/OTBjMSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvQnJvd3Nlci5qcz83ZGUzIiwid2VicGFjazovLy8uLi9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanM/ODY0NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanM/ZTc2ZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21VdGlsLmpzPzdjOTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kb20vRG9tRXZlbnQuanM/MWVhYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanM/YjZiMSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9NYXAuanM/NzNlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5qcz81MjkxIiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcz82NGQ0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanM/MTU1MCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcz84YzY0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzPzJjZDciLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb250cm9sL2luZGV4LmpzPzBjYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL0hhbmRsZXIuanM/NGU1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW5kZXguanM/ZTBlMCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9EcmFnZ2FibGUuanM/Y2NlYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L0xpbmVVdGlsLmpzPzE4N2EiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcz9kNTdlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanM/OWQ4NSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanM/YjJiYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzP2ZkYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcz8wYzNiIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanM/ZDk4MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcz85YmU4Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9pbmRleC5qcz82NmQ5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvTGF5ZXIuanM/NjcwMyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanM/N2Y2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcz8yNDRhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanM/MDU4OCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanM/MjdlNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcz8yZmI1Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcz8zZGQyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanM/MjQ4ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanM/OWQxYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcz85YzM3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanM/MjcyNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0dlb0pTT04uanM/YWFlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcz8wMTg5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzPzAzZTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9TVkdPdmVybGF5LmpzPzNjZjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzPzAwMjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9Qb3B1cC5qcz84ZTExIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVG9vbHRpcC5qcz8wZGIyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanM/ZTBkZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9pbmRleC5qcz84ZjM4Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanM/Mzg4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzPzI2MjAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanM/ZjllNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvaW5kZXguanM/NDI4YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcz8xMGVlIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcz9iOWViIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanM/YzkzNCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanM/Zjg0YiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcz81ZmE3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcz8wZDdhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzPzFlMTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9pbmRleC5qcz8xMjIyIiwid2VicGFjazovLy8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanM/ZTljYyIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanM/MDJkNSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzP2JjZDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanM/M2YzYiIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanM/MWYxNCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanM/OTFiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9pbmRleC5qcz8yMDUyIiwid2VicGFjazovLy8uLi9zcmMvTGVhZmxldC5qcz82YzExIl0sIm5hbWVzIjpbIlV0aWwuY3JlYXRlIiwiVXRpbC5leHRlbmQiLCJVdGlsLmlzQXJyYXkiLCJVdGlsLnNwbGl0V29yZHMiLCJVdGlsLmZhbHNlRm4iLCJVdGlsLmJpbmQiLCJVdGlsLnN0YW1wIiwiVXRpbC5mb3JtYXROdW0iLCJVdGlsLndyYXBOdW0iLCJCcm93c2VyLnN2ZyIsInN0eWxlIiwiQnJvd3Nlci5tc1BvaW50ZXIiLCJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsIkJyb3dzZXIucG9pbnRlciIsInRvdWNoIiwiQnJvd3Nlci5lZGdlIiwiQnJvd3Nlci5wYXNzaXZlRXZlbnRzIiwiY3JlYXRlIiwiVXRpbC50cmltIiwiQnJvd3Nlci5pZTNkIiwiQnJvd3Nlci5hbnkzZCIsIkRvbUV2ZW50Lm9uIiwiRG9tRXZlbnQub2ZmIiwiQnJvd3Nlci50b3VjaCIsIkJyb3dzZXIuY2hyb21lIiwiQnJvd3Nlci5hbmRyb2lkIiwiQnJvd3Nlci53aW4iLCJCcm93c2VyLmdlY2tvIiwiRG9tVXRpbC5nZXRQb3NpdGlvbiIsIlV0aWwucmVxdWVzdEFuaW1GcmFtZSIsIkRvbVV0aWwuc2V0UG9zaXRpb24iLCJVdGlsLmNhbmNlbEFuaW1GcmFtZSIsIlV0aWwuc2V0T3B0aW9ucyIsIkRvbVV0aWwuVFJBTlNJVElPTiIsIkJyb3dzZXIubW9iaWxlT3BlcmEiLCJEb21VdGlsLlRSQU5TSVRJT05fRU5EIiwiRG9tVXRpbC5hZGRDbGFzcyIsIkRvbVV0aWwucmVtb3ZlIiwiRG9tVXRpbC5jcmVhdGUiLCJEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uIiwiRG9tVXRpbC5nZXQiLCJCcm93c2VyLnJldGluYSIsIkJyb3dzZXIuaWVsdDkiLCJCcm93c2VyLnNhZmFyaSIsIkRvbVV0aWwuZ2V0U3R5bGUiLCJyZW1vdmUiLCJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwiRG9tRXZlbnQuc2tpcHBlZCIsIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCJVdGlsLmluZGV4T2YiLCJEb21VdGlsLnJlbW92ZUNsYXNzIiwiRG9tVXRpbC5UUkFOU0ZPUk0iLCJEb21VdGlsLnNldFRyYW5zZm9ybSIsIkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwiRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiRG9tRXZlbnQuc3RvcCIsIkRvbVV0aWwuZW1wdHkiLCJwcmV2ZW50T3V0bGluZSIsIkRvbVV0aWwuaGFzQ2xhc3MiLCJEb21VdGlsLmRpc2FibGVJbWFnZURyYWciLCJEb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uIiwiRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUiLCJEb21VdGlsLmdldFNjYWxlIiwiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCJEb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24iLCJMaW5lVXRpbC5fZ2V0Qml0Q29kZSIsIkxpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9pbnQiLCJsYXRMbmciLCJEb21VdGlsLnNldE9wYWNpdHkiLCJMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJMaW5lVXRpbC5pc0ZsYXQiLCJMaW5lVXRpbC5jbGlwU2VnbWVudCIsIkxpbmVVdGlsLnNpbXBsaWZ5IiwiTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIkxpbmVVdGlsLl9mbGF0IiwiUG9seVV0aWwuY2xpcFBvbHlnb24iLCJEb21VdGlsLnRvRnJvbnQiLCJEb21VdGlsLnRvQmFjayIsIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsIkJyb3dzZXIubW9iaWxlIiwiVXRpbC50aHJvdHRsZSIsImxhdExuZ0JvdW5kcyIsIkJyb3dzZXIuYW5kcm9pZDIzIiwiVXRpbC50ZW1wbGF0ZSIsIlV0aWwuZW1wdHlJbWFnZVVybCIsIkJyb3dzZXIuYW5kcm9pZFN0b2NrIiwiRG9tRXZlbnQuZmFrZVN0b3AiLCJjYW52YXMiLCJCcm93c2VyLmNhbnZhcyIsIkJyb3dzZXIudm1sIiwic3ZnIiwiRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFNTyxNQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBcEI7O0FBQ1AsUUFBTSxDQUFDLE1BQVAsR0FBZ0IsVUFBVSxHQUFWLEVBQWU7QUFBRSxXQUFPLEdBQVA7QUFBYSxHQUE5QyxDOzs7O0FBSU8sV0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXNCO0FBQzVCLFFBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLEVBQWUsR0FBZjs7QUFFQSxTQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxHQUFHLFNBQVMsQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsR0FBeEMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFrRDtBQUNqRCxTQUFHLEdBQUcsU0FBUyxDQUFDLENBQUQsQ0FBZjs7QUFDQSxXQUFLLENBQUwsSUFBVSxHQUFWLEVBQWU7QUFDZCxZQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsR0FBRyxDQUFDLENBQUQsQ0FBYjtBQUNBO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFQO0FBQ0EsRzs7OztBQUlNLE1BQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFQLElBQWtCLFlBQVk7QUFDakQsYUFBUyxDQUFULEdBQWEsQ0FBRTs7QUFDZixXQUFPLFVBQVUsS0FBVixFQUFpQjtBQUN2QixPQUFDLENBQUMsU0FBRixHQUFjLEtBQWQ7QUFDQSxhQUFPLElBQUksQ0FBSixFQUFQO0FBQ0EsS0FIRDtBQUlBLEdBTm9DLEVBQTlCLEM7Ozs7O0FBV0EsV0FBUyxJQUFULENBQWMsRUFBZCxFQUFrQixHQUFsQixF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QTtBQUVBVCxTQUFZLENBQUMsUUFBRCxFQUFXLFdBQVgsRUFBd0IsS0FBSyxZQUE3QixDQUFaQTtBQUNBQSxTQUFZLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsS0FBSyxXQUE1QixDQUFaQSxDQVZ3QixDOztBQWF4QixVQUFJLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsYUFBdEIsRUFBcUM7QUFDcEMsYUFBSyxJQUFMLENBQVUsWUFBVixDQUF1QixLQUFLLE9BQTVCLEVBQXFDLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsS0FBSyxLQUExQixDQUFyQyxFQUF1RSxJQUF2RSxFQUE2RSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLFFBQS9GO0FBQ0EsT0FGRCxNQUVPO0FBQ04sYUFBSyxJQUFMLENBQVUsVUFBVixDQUFxQixLQUFLLE9BQTFCLEVBQW1DLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsS0FBSyxLQUExQixDQUFuQztBQUNBO0FBQ0Q7QUEvRm9DLEdBQWYsQ0FBaEIsQzs7OztBQXFHUCxLQUFHLENBQUMsV0FBSixDQUFnQixZQUFoQixFQUE4QixXQUE5QixFQUEyQyxTQUEzQztBQy9IQSxLQUFHLENBQUMsT0FBSixHQUFjLE9BQWQ7QUFFQSxLQUFHLENBQUMsZUFBSixHQUFzQixlQUF0QjtBQUVBLEtBQUcsQ0FBQyxJQUFKLEdBQVcsSUFBWDtBQUVBLEtBQUcsQ0FBQyxRQUFKLEdBQWUsUUFBZjtBQUVBLEtBQUcsQ0FBQyxlQUFKLEdBQXNCLGVBQXRCO0FBRUEsS0FBRyxDQUFDLEdBQUosR0FBVSxHQUFWO0FBRUEsS0FBRyxDQUFDLFNBQUosR0FBZ0IsU0FBaEI7QUNZQSxRQUFNLENBQUMsTUFBUCxHQUFnQixNQUFoQiIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZTtcclxuT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrbGFzdElkO1xyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA2IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBkaWdpdHMpIHtcclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIChkaWdpdHMgPT09IHVuZGVmaW5lZCA/IDYgOiBkaWdpdHMpKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbmV4cG9ydCB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbmV4cG9ydCB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbn1cclxuXHJcbnZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4vLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbmZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuZXhwb3J0IHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbi8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbi8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4vLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4vLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG5cdGlmIChpZCkge1xyXG5cdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0VXRpbC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gVXRpbC5leHRlbmQoVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcblx0XHQgICAgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycztcclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRpZiAobC5jdHggIT09IGNvbnRleHQpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRpZiAobC5mbiA9PT0gZm4pIHtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0XHRsLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBVdGlsLmV4dGVuZCh7fSwgZGF0YSwge1xyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR0YXJnZXQ6IHRoaXMsXHJcblx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuXHRcdFx0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xyXG4iLCJpbXBvcnQge2lzQXJyYXksIGZvcm1hdE51bX0gZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG5cdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG5cdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9jcnMvQ1JTLkVhcnRoJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db29yZGluYXRlX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuZXhwb3J0IHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogZWFydGhSYWRpdXMsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpKSB7XHJcblx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5fYSA9IGFbMF07XHJcblx0XHR0aGlzLl9iID0gYVsxXTtcclxuXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG5cdFx0dGhpcy5fZCA9IGFbM107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59XHJcblxyXG5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuLy8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG59XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHMzg1NyA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgRVBTRzkwMDkxMyA9IFV0aWwuZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4vLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbi8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbi8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbmV4cG9ydCBmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuXHR2YXIgc3RyID0gJycsXG5cdGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0fVxuXG5cdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuXG5cblxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5pbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuZXhwb3J0IHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbmV4cG9ydCB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5leHBvcnQgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG5leHBvcnQgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbmV4cG9ydCB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxudmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxuZXhwb3J0IHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbmV4cG9ydCB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5leHBvcnQgdmFyIGNocm9tZSA9IHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbmV4cG9ydCB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbmV4cG9ydCB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5leHBvcnQgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuZXhwb3J0IHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuZXhwb3J0IHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbmV4cG9ydCB2YXIgcG9pbnRlciA9ICF3ZWJraXQgJiYgISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbi8vIFRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbi8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuLy8gdG91Y2ggZXZlbnRzLlxyXG5leHBvcnQgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmIChwb2ludGVyIHx8ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxyXG5cdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuZXhwb3J0IHZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4vLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxuZXhwb3J0IHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xyXG59KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuZXhwb3J0IHZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbmV4cG9ydCB2YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuZXhwb3J0IHZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgVEFHX1dISVRFX0xJU1QgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXTtcblxudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gRG9tRXZlbnQuRG91YmxlVGFwIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhpc1xuZXhwb3J0IHZhciBfcG9pbnRlcnNDb3VudCA9IDA7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0X2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IFV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdC8vIHRoZSBjb250cm9scyB3aWxsIHN0b3Agd29ya2luZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBvZiB0YWcgbmFtZXMgdGhhdFxuXHRcdFx0Ly8gbmVlZCB0aGVzZSBldmVudHMuIEZvciBvdGhlciB0YXJnZXQgdGFncywgd2UgcHJldmVudCBkZWZhdWx0IG9uIHRoZSBldmVudC5cblx0XHRcdGlmIChUQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fSk7XG5cblx0b2JqWydfbGVhZmxldF90b3VjaHN0YXJ0JyArIGlkXSA9IG9uRG93bjtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRfcG9pbnRlcnNDb3VudCsrO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0X3BvaW50ZXJzQ291bnQtLTtcbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaG1vdmUnICsgaWRdID0gb25Nb3ZlO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvblVwID0gZnVuY3Rpb24gKGUpIHtcblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcbn1cblxuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge19wb2ludGVyc0NvdW50fSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5cclxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbnZhciBfdG91Y2hzdGFydCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JztcclxudmFyIF90b3VjaGVuZCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJztcclxudmFyIF9wcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHQgICAgZGVsYXkgPSAyNTA7XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHR2YXIgY291bnQ7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRpZiAoKCFCcm93c2VyLmVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGNvdW50ID0gX3BvaW50ZXJzQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvdW50ID4gMSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0dG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaC5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGlmICgoIUJyb3dzZXIuZWRnZSkgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuXHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCkgOiBwcm9wO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHR0b3VjaC5idXR0b24gPSAwO1xyXG5cdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0bGFzdCA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgb25Ub3VjaEVuZCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZTw1NSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSB0b3VjaGVuZC9wb2ludGVydXAgZXZlbnRzIGJ1dCBkb2VzIGZpcmVcclxuXHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0Ly8gRWRnZSAxNCBhbHNvIGZpcmVzIG5hdGl2ZSBkYmxjbGlja3MsIGJ1dCBvbmx5IGZvciBwb2ludGVyVHlwZSBtb3VzZSwgc2VlICM1MTgwLlxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XHJcblx0dmFyIHRvdWNoc3RhcnQgPSBvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdCAgICB0b3VjaGVuZCA9IG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdLFxyXG5cdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCB0b3VjaGVuZCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRpZiAoIUJyb3dzZXIuZWRnZSkge1xyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuZXhwb3J0IHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG5cdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4vLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcblx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0fVxyXG5cdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IFV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgVXRpbC50cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcblx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcblx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG5cdH1cclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcblx0ZG8ge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuXHRyZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4vLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcblx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG5cdH07XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuaW1wb3J0IHtnZXRTY2FsZX0gZnJvbSAnLi9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh0eXBlcykge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKHZhciBqIGluIG9ialtldmVudHNLZXldKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIGosIG9ialtldmVudHNLZXldW2pdKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAoQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG5cdFx0YWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIGFkZERvdWJsZVRhcExpc3RlbmVyICYmXHJcblx0ICAgICAgICAgICAhKEJyb3dzZXIucG9pbnRlciAmJiBCcm93c2VyLmNocm9tZSkpIHtcclxuXHRcdC8vIENocm9tZSA+NTUgZG9lcyBub3QgbmVlZCB0aGUgc3ludGhldGljIGRibGNsaWNrcyBmcm9tIGFkZERvdWJsZVRhcExpc3RlbmVyXHJcblx0XHQvLyBTZWUgIzUxODBcclxuXHRcdGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdvbndoZWVsJyBpbiBvYmogPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIEJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHR0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6XHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cdHNraXBwZWQoZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ21vdXNld2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0YWRkT25lKGVsLCAnY2xpY2snLCBmYWtlU3RvcCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG5cdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcblx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG5cdCk7XHJcbn1cclxuXHJcbi8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcbi8vIGFuZCBGaXJlZm94IHNjcm9sbHMgZGV2aWNlIHBpeGVscywgbm90IENTUyBwaXhlbHNcclxudmFyIHdoZWVsUHhGYWN0b3IgPVxyXG5cdChCcm93c2VyLndpbiAmJiBCcm93c2VyLmNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdEJyb3dzZXIuZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZXdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbi8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbi8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcblx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuXHQgICAgICAgMDtcclxufVxyXG5cclxudmFyIHNraXBFdmVudHMgPSB7fTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWtlU3RvcChlKSB7XHJcblx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBza2lwcGVkKGUpXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNraXBwZWQoZSkge1xyXG5cdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XHJcblx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRyZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcblx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR0cnkge1xyXG5cdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxufVxyXG5cclxudmFyIGxhc3RDbGljaztcclxuXHJcbi8vIHRoaXMgaXMgYSBob3JyaWJsZSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcclxuZnVuY3Rpb24gZmlsdGVyQ2xpY2soZSwgaGFuZGxlcikge1xyXG5cdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSksXHJcblx0ICAgIGVsYXBzZWQgPSBsYXN0Q2xpY2sgJiYgKHRpbWVTdGFtcCAtIGxhc3RDbGljayk7XHJcblxyXG5cdC8vIGFyZSB0aGV5IGNsb3NlciB0b2dldGhlciB0aGFuIDUwMG1zIHlldCBtb3JlIHRoYW4gMTAwbXM/XHJcblx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xyXG5cdC8vIG9yIGNoZWNrIGlmIGNsaWNrIGlzIHNpbXVsYXRlZCBvbiB0aGUgZWxlbWVudCwgYW5kIGlmIGl0IGlzLCByZWplY3QgYW55IG5vbi1zaW11bGF0ZWQgZXZlbnRzXHJcblxyXG5cdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdHN0b3AoZSk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdGxhc3RDbGljayA9IHRpbWVTdGFtcDtcclxuXHJcblx0aGFuZGxlcihlKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5leHBvcnQge29uIGFzIGFkZExpc3RlbmVyfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5leHBvcnQge29mZiBhcyByZW1vdmVMaXN0ZW5lcn07XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQge0VQU0czODU3fSBmcm9tICcuLi9nZW8vY3JzL0NSUy5FUFNHMzg1Nyc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtCb3VuZHMsIHRvQm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi4vZG9tL1Bvc0FuaW1hdGlvbic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IFV0aWwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IERvbVV0aWwuVFJBTlNJVElPTiAmJiBCcm93c2VyLmFueTNkICYmICFCcm93c2VyLm1vYmlsZU9wZXJhICYmXHJcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKHRoaXMuX3Byb3h5LCBEb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChtb3ZlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gYHBhZGRpbmdgLCBgcGFkZGluZ1RvcExlZnRgIGFuZCBgcGFkZGluZ1RvcFJpZ2h0YCBvcHRpb25zIHRvIGZpdFxyXG5cdC8vIHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMsIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcblx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcblx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdChjZW50ZXIpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBoYWxmUGl4ZWxCb3VuZHMgPSBwaXhlbEJvdW5kcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKTtcclxuXHJcblx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgZGlmZiA9IHBpeGVsQ2VudGVyLnN1YnRyYWN0KHBpeGVsUG9pbnQpLFxyXG5cdFx0XHQgICAgbmV3Q2VudGVyID0gdG9Qb2ludChwaXhlbFBvaW50LnggKyBkaWZmLngsIHBpeGVsUG9pbnQueSArIGRpZmYueSk7XHJcblxyXG5cdFx0XHRpZiAocGl4ZWxQb2ludC54IDwgcGFkZGVkQm91bmRzLm1pbi54IHx8IHBpeGVsUG9pbnQueCA+IHBhZGRlZEJvdW5kcy5tYXgueCkge1xyXG5cdFx0XHRcdG5ld0NlbnRlci54ID0gcGl4ZWxDZW50ZXIueCAtIGRpZmYueDtcclxuXHRcdFx0XHRpZiAoZGlmZi54ID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggKz0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggLT0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nQlIueDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueSA8IHBhZGRlZEJvdW5kcy5taW4ueSB8fCBwaXhlbFBvaW50LnkgPiBwYWRkZWRCb3VuZHMubWF4LnkpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueSA9IHBpeGVsQ2VudGVyLnkgLSBkaWZmLnk7XHJcblx0XHRcdFx0aWYgKGRpZmYueSA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55ICs9IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55IC09IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ0JSLnk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QobmV3Q2VudGVyKSwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG5cdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcblx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG5cdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcblx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0XHR3YXRjaDogZmFsc2VcclxuXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdCAgICBvbkVycm9yID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG5cdFx0XHRjb2RlOiBjLFxyXG5cdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcblx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcblx0XHQgICAgbGF0bG5nID0gbmV3IExhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IFV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gRG9tRXZlbnQub2ZmIDogRG9tRXZlbnQub247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcblx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcblx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiBEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IERvbUV2ZW50LnNraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nIHx8IHR5cGUgPT09ICdrZXlwcmVzcycgfHwgdHlwZSA9PT0gJ2tleXVwJyB8fCB0eXBlID09PSAna2V5ZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IFV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBVdGlsLmluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gRG9tVXRpbC5UUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcHJveHkpO1xyXG5cdFx0dGhpcy5vZmYoJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbU1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpXHJcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE90aGVyIEV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcblx0XHQvLyBGaXJlZCBhdCBsZWFzdCBvbmNlIHBlciB6b29tIGFuaW1hdGlvbi4gRm9yIGNvbnRpbnVvdXMgem9vbSwgbGlrZSBwaW5jaCB6b29taW5nLCBmaXJlZCBvbmNlIHBlciBmcmFtZSBkdXJpbmcgem9vbS5cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xyXG5cclxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb24gPSBEb21VdGlsLmNyZWF0ZSgnc2VjdGlvbicsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuZXhwb3J0IHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJysnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnJiN4MjIxMjsnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICcmI3gyMjEyOycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuXHRcdC8vIEBwcm9wZXJ0eSB6b29tQ29udHJvbDogQ29udHJvbC5ab29tXHJcblx0XHQvLyBUaGUgZGVmYXVsdCB6b29tIGNvbnRyb2wgKG9ubHkgYXZhaWxhYmxlIGlmIHRoZVxyXG5cdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuZXhwb3J0IHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XHJcbiIsIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xufTtcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbmV4cG9ydCB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q29udHJvbCwgY29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCB7TGF5ZXJzLCBsYXllcnN9IGZyb20gJy4vQ29udHJvbC5MYXllcnMnO1xuaW1wb3J0IHtab29tLCB6b29tfSBmcm9tICcuL0NvbnRyb2wuWm9vbSc7XG5pbXBvcnQge1NjYWxlLCBzY2FsZX0gZnJvbSAnLi9Db250cm9sLlNjYWxlJztcbmltcG9ydCB7QXR0cmlidXRpb24sIGF0dHJpYnV0aW9ufSBmcm9tICcuL0NvbnRyb2wuQXR0cmlidXRpb24nO1xuXG5Db250cm9sLkxheWVycyA9IExheWVycztcbkNvbnRyb2wuWm9vbSA9IFpvb207XG5Db250cm9sLlNjYWxlID0gU2NhbGU7XG5Db250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbmNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuY29udHJvbC56b29tID0gem9vbTtcbmNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbmNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuZXhwb3J0IHtDb250cm9sLCBjb250cm9sfTtcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5leHBvcnQgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4vLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbi8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5IYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuL0Jyb3dzZXInO1xuZXhwb3J0IHtCcm93c2VyfTtcblxuZXhwb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi9FdmVudHMnO1xuaW1wb3J0IHtFdmVudHN9IGZyb20gJy4vRXZlbnRzJztcbmV4cG9ydCB7RXZlbnRlZH07XG5leHBvcnQgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuZXhwb3J0IHtIYW5kbGVyfSBmcm9tICcuL0hhbmRsZXInO1xuXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XG5leHBvcnQge1V0aWx9O1xuZXhwb3J0IHtleHRlbmQsIGJpbmQsIHN0YW1wLCBzZXRPcHRpb25zfSBmcm9tICcuL1V0aWwnO1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG52YXIgRU5EID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG59O1xyXG52YXIgTU9WRSA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcblx0XHQgICAgc2l6ZWRQYXJlbnQgPSBEb21VdGlsLmdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdC8vIENhY2hlIHRoZSBzY2FsZSwgc28gdGhhdCB3ZSBjYW4gY29udGludW91c2x5IGNvbXBlbnNhdGUgZm9yIGl0IGR1cmluZyBkcmFnIChfb25Nb3ZlKS5cclxuXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gRG9tVXRpbC5nZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIE1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBFTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcblx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIE1PVkUpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBNT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIEVORFtpXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbi8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4vLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbi8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbi8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbi8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmNvbS9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcblx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuXHRcdFx0YSA9IHA7XHJcblx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGIgPSBwO1xyXG5cdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0ICAgIHgsIHk7XHJcblxyXG5cdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtYXgueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtaW4ueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0eCA9IG1heC54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdHggPSBtaW4ueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5leHBvcnQgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0dmFyIHggPSBwMS54LFxyXG5cdCAgICB5ID0gcDEueSxcclxuXHQgICAgZHggPSBwMi54IC0geCxcclxuXHQgICAgZHkgPSBwMi55IC0geSxcclxuXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcblx0ICAgIHQ7XHJcblxyXG5cdGlmIChkb3QgPiAwKSB7XHJcblx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuXHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0eSA9IHAyLnk7XHJcblx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHR5ICs9IGR5ICogdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR4ID0gcC54IC0geDtcclxuXHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG5cdHJldHVybiAhVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcblx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIExvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuIiwiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG4iLCJcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiAhIWxheWVyICYmIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVyR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4uLy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge3NldE9wdGlvbnN9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gKi9cblxuZXhwb3J0IHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKCFJY29uRGVmYXVsdC5pbWFnZVBhdGgpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHR2YXIgcGF0aCA9IERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cblx0XHRpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoLmluZGV4T2YoJ3VybCcpICE9PSAwKSB7XG5cdFx0XHRwYXRoID0gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL151cmxcXChbXCInXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lLCBjYW5jZWxBbmltRnJhbWV9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICovXG5cbmV4cG9ydCB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcblx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG5cdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuXHRcdFx0dGhpcy5fb25EcmFnKGUpO1xuXG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG5cdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XHJcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nIGFzIGxhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge01hcmtlckRyYWd9IGZyb20gJy4vTWFya2VyLkRyYWcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbmV4cG9ydCB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAmJiBzdHlsZSAmJiBzdHlsZS5oYXNPd25Qcm9wZXJ0eSgnd2VpZ2h0JykpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyB0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FYXJ0aCc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QocCksXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG5cdFx0XSk7XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IExpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKExpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59XG5cbi8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cblBvbHlsaW5lLl9mbGF0ID0gTGluZVV0aWwuX2ZsYXQ7XG4iLCJpbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9seVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IFV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0ICAgIGxheWVycyA9IFtdLFxyXG5cdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcblx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnUG9seWdvbic6XHJcblx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRkZWZhdWx0OlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG5cdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0cHJlY2lzaW9uID0gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiA2O1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuXHQvLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuXHQvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG5cdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cDovL3d3dy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAqXHJcbiAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAqIEhUTUw1IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcblx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBCcm93c2VyIGNvbXBhdGliaWxpdHktIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0XHJcblx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiB2aWQuc3R5bGUuaGFzT3duUHJvcGVydHkoJ29iamVjdEZpdCcpKSB7IHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7IH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IERvbVV0aWwuY3JlYXRlKCdzb3VyY2UnKTtcclxuXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFNWR092ZXJsYXlcbiAqIEBha2EgTC5TVkdPdmVybGF5XG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gKlxuICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAqXG4gKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cblx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdGVsLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXHR9XG5cblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG5leHBvcnQgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbmV4cG9ydCB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoRG9tVXRpbC5yZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAocGFyZW50LCBsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcclxuXHRcdFx0bGF5ZXIgPSBwYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIHBhcmVudC5fbGF5ZXJzKSB7XHJcblx0XHRcdFx0bGF5ZXIgPSBwYXJlbnQuX2xheWVyc1tpZF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRpZiAobGF5ZXIuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIuZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgb3ZlcmxheSBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG5cdFx0dGhpcy5fc291cmNlID0gbGF5ZXI7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICogSGVyZSdzIGEgbW9yZSBjb21wbGljYXRlZCB3YXkgdG8gb3BlbiBhIHBvcHVwIG9uIGEgbWFwOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG5cdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuIFRoZSBzYW1lIGFzIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuZXhwb3J0IHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgUG9wdXApIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF0bG5nID0gdGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxyXG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcblx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcblx0fSxcclxuXHJcblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdC8vIGlmIHRoaXMgaW5oZXJpdHMgZnJvbSBQYXRoIGl0cyBhIHZlY3RvciBhbmQgd2UgY2FuIGp1c3RcclxuXHRcdC8vIG9wZW4gdGhlIHBvcHVwIGF0IHRoZSBuZXcgbG9jYXRpb25cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIFBhdGgpIHtcclxuXHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXllciB8fCBlLnRhcmdldCwgZS5sYXRsbmcpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcbiIsIlxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKEJyb3dzZXIudG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KC10b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoIC8gMiAtIG9mZnNldC54LCAtb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnYXV0bycgJiYgdG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KG9mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5leHBvcnQgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtlbXB0eX0gZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuZXhwb3J0IHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG5cdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHRlbXB0eShkaXYpO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IHBvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5leHBvcnQge2ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XG5JY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcbmV4cG9ydCB7SWNvbn07XG5cbmV4cG9ydCB7RGl2SWNvbiwgZGl2SWNvbn0gZnJvbSAnLi9EaXZJY29uJztcbmV4cG9ydCB7TWFya2VyLCBtYXJrZXJ9IGZyb20gJy4vTWFya2VyJztcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuZXhwb3J0IHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3Rpbmdcblx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRVdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25DcmVhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKE1hdGgucm91bmQoem9vbSkpO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEJyb3dzZXIuYW5kcm9pZCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMpIHtcblx0XHRcdHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBVdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBVdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7R3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJ01hcCBkYXRhICZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvXCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzLCA8YSBocmVmPVwiaHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzIuMC9cIj5DQy1CWS1TQTwvYT4nfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyID0gR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtaW5ab29tOiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1heFpvb206IDE4LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHQvKlxyXG5cdFx0IFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuXHRcdCBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEvcm9sZXMjdGV4dGFsdGVybmF0aXZlY29tcHV0YXRpb25cclxuXHRcdCovXHJcblx0XHR0aWxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBVdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgVXRpbC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHQvLyB1bmxlc3Mgd2UncmUgb24gQW5kcm9pZCdzIHN0b2NrIGJyb3dzZXIsXHJcblx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZFN0b2NrKSB7XHJcblx0XHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBVdGlsLmVtcHR5SW1hZ2VVcmwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gVXRpbC5lbXB0eUltYWdlVXJsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge1RpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xyXG5pbXBvcnQge2V4dGVuZCwgc2V0T3B0aW9ucywgZ2V0UGFyYW1TdHJpbmd9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7cmV0aW5hfSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xLFxuXG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdHRvbGVyYW5jZSA6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRVdGlsLnN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG5cdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkgJiYgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpY2tlZExheWVyKSAge1xuXHRcdFx0RG9tRXZlbnQuZmFrZVN0b3AoZSk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NsaWNrZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHR9LFxuXG5cblx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChMLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH1cbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbmV4cG9ydCB2YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHREb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IFV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIERyYWctdGhlbi1waW5jaCBpbnRlcmFjdGlvbnMgbWlnaHQgbWVzcyB1cCB0aGUgY2VudGVyIGFuZCB6b29tLlxuXHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHIyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fcGF0aCk7XG5cdH1cbn0pO1xuXG5pZiAoQnJvd3Nlci52bWwpIHtcblx0U1ZHLmluY2x1ZGUodm1sTWl4aW4pO1xufVxuXG4vLyBAbmFtZXNwYWNlIFNWR1xuLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vLi4vbWFwL01hcCc7XG5pbXBvcnQge2NhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMob3B0aW9ucykpIHx8IHN2ZyhvcHRpb25zKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZWN0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuIiwiZXhwb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5leHBvcnQge0NhbnZhcywgY2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge1NWRywgY3JlYXRlLCBwb2ludHNUb1BhdGgsIHN2Z30gZnJvbSAnLi9TVkcnO1xuU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5leHBvcnQge1NWRywgc3ZnfTtcbmltcG9ydCAnLi9SZW5kZXJlci5nZXRSZW5kZXJlcic7XHQvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IG5lZWRlZCBiZWNhdXNlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5leHBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5leHBvcnQge0NpcmNsZU1hcmtlciwgY2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5leHBvcnQge0NpcmNsZSwgY2lyY2xlfSBmcm9tICcuL0NpcmNsZSc7XG5leHBvcnQge1BvbHlsaW5lLCBwb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5leHBvcnQge1BvbHlnb24sIHBvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5leHBvcnQge1JlY3RhbmdsZSwgcmVjdGFuZ2xlfSBmcm9tICcuL1JlY3RhbmdsZSc7XG4iLCJleHBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmV4cG9ydCB7TGF5ZXJHcm91cCwgbGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcbmV4cG9ydCB7RmVhdHVyZUdyb3VwLCBmZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbiwgZ2VvbWV0cnlUb0xheWVyLCBjb29yZHNUb0xhdExuZywgY29vcmRzVG9MYXRMbmdzLCBsYXRMbmdUb0Nvb3JkcywgbGF0TG5nc1RvQ29vcmRzLCBnZXRGZWF0dXJlLCBhc0ZlYXR1cmV9IGZyb20gJy4vR2VvSlNPTic7XG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5leHBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb259O1xuXG5leHBvcnQge0ltYWdlT3ZlcmxheSwgaW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5leHBvcnQge1ZpZGVvT3ZlcmxheSwgdmlkZW9PdmVybGF5fSBmcm9tICcuL1ZpZGVvT3ZlcmxheSc7XG5leHBvcnQge1NWR092ZXJsYXksIHN2Z092ZXJsYXl9IGZyb20gJy4vU1ZHT3ZlcmxheSc7XG5cbmV4cG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmV4cG9ydCB7UG9wdXAsIHBvcHVwfSBmcm9tICcuL1BvcHVwJztcbmV4cG9ydCB7VG9vbHRpcCwgdG9vbHRpcH0gZnJvbSAnLi9Ub29sdGlwJztcblxuZXhwb3J0ICogZnJvbSAnLi9tYXJrZXIvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90aWxlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmVjdG9yL2luZGV4JztcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm94ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge29uLCBvZmYsIHN0b3B9IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbmV4cG9ydCB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuZXhwb3J0IHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG5cdHRhcDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcCA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAoQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5wb2ludGVyKSB7XG5cdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoICYmICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBVdGlsLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRhcCc7XG5NYXAuVGFwID0gVGFwO1xuaW1wb3J0IHtUb3VjaFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuVG91Y2hab29tJztcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbmV4cG9ydCB7TWFwLCBjcmVhdGVNYXAgYXMgbWFwfSBmcm9tICcuL01hcCc7XG4iLCJcclxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG5leHBvcnQge3ZlcnNpb259O1xyXG5cclxuLy8gY29udHJvbFxyXG5leHBvcnQgKiBmcm9tICcuL2NvbnRyb2wvaW5kZXgnO1xyXG5cclxuLy8gY29yZVxyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXgnO1xyXG5cclxuLy8gZG9tXHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2luZGV4JztcclxuXHJcbi8vIGdlb21ldHJ5XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkvaW5kZXgnO1xyXG5cclxuLy8gZ2VvXHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvL2luZGV4JztcclxuXHJcbi8vIGxheWVyXHJcbmV4cG9ydCAqIGZyb20gJy4vbGF5ZXIvaW5kZXgnO1xyXG5cclxuLy8gbWFwXHJcbmV4cG9ydCAqIGZyb20gJy4vbWFwL2luZGV4JztcclxuXHJcbmltcG9ydCB7ZnJlZXplfSBmcm9tICcuL2NvcmUvVXRpbCc7XHJcbk9iamVjdC5mcmVlemUgPSBmcmVlemU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},25:function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzFkZTUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVybCIsIm9wdGlvbnMiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInRlc3QiLCJzbGljZSIsImhhc2giLCJuZWVkUXVvdGVzIiwiY29uY2F0IiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7QUFDdkMsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWjtBQUNBQSxXQUFPLEdBQUcsRUFBVjtBQUNELEdBSnNDLENBSXJDOzs7QUFHRkQsS0FBRyxHQUFHQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0UsVUFBWCxHQUF3QkYsR0FBRyxDQUFDRyxPQUE1QixHQUFzQ0gsR0FBNUM7O0FBRUEsTUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsV0FBT0EsR0FBUDtBQUNELEdBWHNDLENBV3JDOzs7QUFHRixNQUFJLGVBQWVJLElBQWYsQ0FBb0JKLEdBQXBCLENBQUosRUFBOEI7QUFDNUI7QUFDQUEsT0FBRyxHQUFHQSxHQUFHLENBQUNLLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJSixPQUFPLENBQUNLLElBQVosRUFBa0I7QUFDaEI7QUFDQU4sT0FBRyxJQUFJQyxPQUFPLENBQUNLLElBQWY7QUFDRCxHQXRCc0MsQ0FzQnJDO0FBQ0Y7OztBQUdBLE1BQUksY0FBY0YsSUFBZCxDQUFtQkosR0FBbkIsS0FBMkJDLE9BQU8sQ0FBQ00sVUFBdkMsRUFBbUQ7QUFDakQsV0FBTyxLQUFLQyxNQUFMLENBQVlSLEdBQUcsQ0FBQ1MsT0FBSixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUJBLE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLENBQVosRUFBNEQsSUFBNUQsQ0FBUDtBQUNEOztBQUVELFNBQU9ULEdBQVA7QUFDRCxDQS9CRCIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIHVybCA9IHVybCAmJiB1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')},3:function(module,exports,__webpack_require__){"use strict";eval('\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sIm1hcHBpbmdzIjoiQUFBYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVVDLFlBQVYsRUFBd0I7QUFDdkMsTUFBSUMsSUFBSSxHQUFHLEVBQVgsQ0FEdUMsQ0FDeEI7O0FBRWZBLE1BQUksQ0FBQ0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ2xDLFdBQU8sS0FBS0MsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7QUFDOUIsVUFBSUMsT0FBTyxHQUFHQyxzQkFBc0IsQ0FBQ0YsSUFBRCxFQUFPSixZQUFQLENBQXBDOztBQUVBLFVBQUlJLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtBQUNYLGVBQU8sVUFBVUcsTUFBVixDQUFpQkgsSUFBSSxDQUFDLENBQUQsQ0FBckIsRUFBMEIsSUFBMUIsRUFBZ0NHLE1BQWhDLENBQXVDRixPQUF2QyxFQUFnRCxHQUFoRCxDQUFQO0FBQ0Q7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LFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0FBQzVCO0FBQ0EsTUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlTCxTQUFmLENBQUQsQ0FBbkIsQ0FBVCxDQUFqQjtBQUNBLE1BQUlNLElBQUksR0FBRywrREFBK0R6QixNQUEvRCxDQUFzRW9CLE1BQXRFLENBQVg7QUFDQSxTQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},9:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ chart_esm_Chart; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ adapters; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ registerables; });\n\n// UNUSED EXPORTS: defaults, Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, DatasetController, Decimation, DomPlatform, DoughnutController, Element, Filler, Interaction, Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, SubTitle, Ticks, TimeScale, TimeSeriesScale, Title, Tooltip, _detectPlatform, animator, controllers, elements, layouts, plugins, registry, scales\n\n// CONCATENATED MODULE: ./node_modules/chart.js/dist/chunks/helpers.segment.js\n/*!\n * Chart.js v3.5.1\n * https://www.chartjs.org\n * (c) 2021 Chart.js Contributors\n * Released under the MIT License\n */\nfunction helpers_segment_fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\nconst requestAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return function (callback) {\n      return callback();\n    };\n  }\n\n  return window.requestAnimationFrame;\n}();\n\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || (args => Array.prototype.slice.call(args));\n\n  let ticking = false;\n  let args = [];\n  return function (...rest) {\n    args = updateArgs(rest);\n\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\n\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay);\n    } else {\n      fn();\n    }\n\n    return delay;\n  };\n}\n\nconst _toLeftRightCenter = align => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\nfunction noop() {}\n\nconst uid = function () {\n  let id = 0;\n  return function () {\n    return id++;\n  };\n}();\n\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\n\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n\n  const type = Object.prototype.toString.call(value);\n\n  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\nconst isNumberFinite = value => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nconst toPercentage = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : value / dimension;\n\nconst toDimension = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n\n  if (isArray(loopable)) {\n    len = loopable.length;\n\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\n\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n\n    if (!isObject(source)) {\n      continue;\n    }\n\n    const keys = Object.keys(source);\n\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n\n  return target;\n}\n\nfunction mergeIf(target, source) {\n  return merge(target, source, {\n    merger: _mergerIf\n  });\n}\n\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\n\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\nconst emptyString = '';\nconst dot = '.';\n\nfunction indexOfDotOrLength(key, start) {\n  const idx = key.indexOf(dot, start);\n  return idx === -1 ? key.length : idx;\n}\n\nfunction resolveObjectKey(obj, key) {\n  if (key === emptyString) {\n    return obj;\n  }\n\n  let pos = 0;\n  let idx = indexOfDotOrLength(key, pos);\n\n  while (obj && idx > pos) {\n    obj = obj[key.substr(pos, idx - pos)];\n    pos = idx + 1;\n    idx = indexOfDotOrLength(key, pos);\n  }\n\n  return obj;\n}\n\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nconst defined = value => typeof value !== 'undefined';\n\nconst isFunction = value => typeof value === 'function';\n\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\n\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\n\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\n\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\n\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n\n  let e = 1;\n  let p = 0;\n\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n\n  return p;\n}\n\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < -0.5 * PI) {\n    angle += TAU;\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\n\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n\n  const s = _normalizeAngle(start);\n\n  const e = _normalizeAngle(end);\n\n  const angleToStart = _normalizeAngle(s - a);\n\n  const angleToEnd = _normalizeAngle(e - a);\n\n  const startToAngle = _normalizeAngle(a - s);\n\n  const endToAngle = _normalizeAngle(a - e);\n\n  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\n\nconst atEdge = t => t === 0 || t === 1;\n\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\n\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t) {\n    let s = 1.70158;\n\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n    }\n\n    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n\n    if (t < 1 / d) {\n      return m * t * t;\n    }\n\n    if (t < 2 / d) {\n      return m * (t -= 1.5 / d) * t + 0.75;\n    }\n\n    if (t < 2.5 / d) {\n      return m * (t -= 2.25 / d) * t + 0.9375;\n    }\n\n    return m * (t -= 2.625 / d) * t + 0.984375;\n  },\n\n  easeInOutBounce: t => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n/*!\n * @kurkle/color v0.1.9\n * https://github.com/kurkle/color#readme\n * (c) 2020 Jukka Kurkela\n * Released under the MIT License\n */\n\nconst map = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15\n};\nconst hex = '0123456789ABCDEF';\n\nconst h1 = b => hex[b & 0xF];\n\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\n\nconst eq = b => (b & 0xF0) >> 4 === (b & 0xF);\n\nfunction isShort(v) {\n  return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\n}\n\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map[str[1]] * 17,\n        g: 255 & map[str[2]] * 17,\n        b: 255 & map[str[3]] * 17,\n        a: len === 5 ? map[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map[str[1]] << 4 | map[str[2]],\n        g: map[str[3]] << 4 | map[str[4]],\n        b: map[str[5]] << 4 | map[str[6]],\n        a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255\n      };\n    }\n  }\n\n  return ret;\n}\n\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v ? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '') : v;\n}\n\nfunction helpers_segment_round(v) {\n  return v + 0.5 | 0;\n}\n\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\n\nfunction p2b(v) {\n  return lim(helpers_segment_round(v * 2.55), 0, 255);\n}\n\nfunction n2b(v) {\n  return lim(helpers_segment_round(v * 255), 0, 255);\n}\n\nfunction b2n(v) {\n  return lim(helpers_segment_round(v / 2.55) / 100, 0, 1);\n}\n\nfunction n2p(v) {\n  return lim(helpers_segment_round(v * 100), 0, 100);\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n\n  if (!m) {\n    return;\n  }\n\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = 255 & (m[8] ? p2b(v) : v * 255);\n  }\n\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : r);\n  g = 255 & (m[4] ? p2b(g) : g);\n  b = 255 & (m[6] ? p2b(b) : b);\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\n\nfunction rgbString(v) {\n  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n\n  return [f(0), f(8), f(4)];\n}\n\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n\n  return [f(5), f(3), f(1)];\n}\n\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n\n  return rgb;\n}\n\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n    h = h * 60 + 0.5;\n  }\n\n  return [h | 0, s || 0, l];\n}\n\nfunction calln(f, a, b, c) {\n  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);\n}\n\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\n\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\n\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\n\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\n\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n\n  if (!m) {\n    return;\n  }\n\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\n\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\n\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map$1 = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst helpers_segment_names = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\n\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(helpers_segment_names);\n  const tkeys = Object.keys(map$1);\n  let i, j, k, ok, nk;\n\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map$1[k]);\n    }\n\n    k = parseInt(helpers_segment_names[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n\n  return unpacked;\n}\n\nlet names$1;\n\nfunction nameParse(str) {\n  if (!names$1) {\n    names$1 = unpack();\n    names$1.transparent = [0, 0, 0, 0];\n  }\n\n  const a = names$1[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\n\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\n\nfunction fromObject(input) {\n  var v = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  };\n\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {\n        r: input[0],\n        g: input[1],\n        b: input[2],\n        a: 255\n      };\n\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    });\n    v.a = n2b(v.a);\n  }\n\n  return v;\n}\n\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n\n  return hueParse(str);\n}\n\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n\n    const type = typeof input;\n    let v;\n\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n\n    this._rgb = v;\n    this._valid = !!v;\n  }\n\n  get valid() {\n    return this._valid;\n  }\n\n  get rgb() {\n    var v = clone(this._rgb);\n\n    if (v) {\n      v.a = b2n(v.a);\n    }\n\n    return v;\n  }\n\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : this._rgb;\n  }\n\n  hexString() {\n    return this._valid ? hexString(this._rgb) : this._rgb;\n  }\n\n  hslString() {\n    return this._valid ? hslString(this._rgb) : this._rgb;\n  }\n\n  mix(color, weight) {\n    const me = this;\n\n    if (color) {\n      const c1 = me.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      me.rgb = c1;\n    }\n\n    return me;\n  }\n\n  clone() {\n    return new Color(this.rgb);\n  }\n\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n\n  greyscale() {\n    const rgb = this._rgb;\n    const val = helpers_segment_round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nconst isPatternOrGradient = value => value instanceof CanvasGradient || value instanceof CanvasPattern;\n\nfunction helpers_segment_color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\n\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst helpers_segment_descriptors = Object.create(null);\n\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n\n  const keys = key.split('.');\n\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n\n  return node;\n}\n\nfunction helpers_segment_set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n\n  return merge(getScope$1(root, ''), scope);\n}\n\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n\n    this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();\n\n    this.elements = {};\n    this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.describe(_descriptors);\n  }\n\n  set(scope, values) {\n    return helpers_segment_set(this, scope, values);\n  }\n\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n\n  describe(scope, values) {\n    return helpers_segment_set(helpers_segment_descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return helpers_segment_set(overrides, scope, values);\n  }\n\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n\n          return valueOrDefault(local, target);\n        },\n\n        set(value) {\n          this[privateName] = value;\n        }\n\n      }\n    });\n  }\n\n}\n\nvar defaults = new Defaults({\n  _scriptable: name => !name.startsWith('on'),\n  _indexable: name => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n\n  return longest;\n}\n\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n  const gcLen = gc.length / 2;\n\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n\n    gc.splice(0, gcLen);\n  }\n\n  return longest;\n}\n\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nfunction drawPoint(ctx, options, x, y) {\n  let type, xOffset, yOffset, size, cornerRadius;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n    default:\n      ctx.arc(x, y, radius, 0, TAU);\n      ctx.closePath();\n      break;\n\n    case 'triangle':\n      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n\n    case 'rectRounded':\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        ctx.rect(x - size, y - size, 2 * size, 2 * size);\n        break;\n      }\n\n      rad += QUARTER_PI;\n\n    case 'rectRot':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      ctx.closePath();\n      break;\n\n    case 'crossRot':\n      rad += QUARTER_PI;\n\n    case 'cross':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n\n    case 'star':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      rad += QUARTER_PI;\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n\n    case 'line':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n      break;\n  }\n\n  ctx.fill();\n\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\n\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\n\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n\n  ctx.lineTo(target.x, target.y);\n}\n\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n\n  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\n\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n\n  ctx.restore();\n}\n\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction addRoundedRectPath(ctx, rect) {\n  const {\n    x,\n    y,\n    w,\n    h,\n    radius\n  } = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\n\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n\n    case '%':\n      value /= 100;\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = v => +v || 0;\n\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n\n  return ret;\n}\n\nfunction toTRBL(value) {\n  return _readValueToProps(value, {\n    top: 'y',\n    right: 'x',\n    bottom: 'y',\n    left: 'x'\n  });\n}\n\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\n\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n\n  let style = valueOrDefault(options.style, fallback.style);\n\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\n\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n\n    if (value === undefined) {\n      continue;\n    }\n\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n\n      return value;\n    }\n  }\n}\n\nfunction _addGrace(minmax, grace) {\n  const {\n    min,\n    max\n  } = minmax;\n  return {\n    min: min - Math.abs(toDimension(grace, min)),\n    max: max + toDimension(grace, max)\n  };\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || (index => table[index] < value);\n\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n\n  while (hi - lo > 1) {\n    mid = lo + hi >> 1;\n\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {\n    lo,\n    hi\n  };\n}\n\nconst _lookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] < value);\n\nconst _rlookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] >= value);\n\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach(key => {\n    const method = '_onData' + _capitalize(key);\n\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach(object => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n\n    });\n  });\n}\n\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach(key => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\n\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n\n  if (set.size === ilen) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: scope => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n\n    get(target, prop) {\n      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      storage[prop] = value;\n      delete target[prop];\n      delete target._keys;\n      return true;\n    }\n\n  });\n}\n\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n\n    get(target, prop, receiver) {\n      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n        enumerable: true,\n        configurable: true\n      } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n\n  });\n}\n\nfunction _descriptors(proxy, defaults = {\n  scriptable: true,\n  indexable: true\n}) {\n  const {\n    _scriptable = defaults.scriptable,\n    _indexable = defaults.indexable,\n    _allKeys = defaults.allKeys\n  } = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\n\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters';\n\nfunction _cached(target, prop, resolve) {\n  let value = target[prop];\n\n  if (defined(value)) {\n    return value;\n  }\n\n  value = resolve();\n\n  if (defined(value)) {\n    target[prop] = value;\n  }\n\n  return value;\n}\n\nfunction _resolveWithContext(target, prop, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors\n  } = target;\n  let value = _proxy[prop];\n\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n\n  return value;\n}\n\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _stack\n  } = target;\n\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n\n  _stack.add(prop);\n\n  value = value(_context, _subProxy || receiver);\n\n  _stack.delete(prop);\n\n  if (isObject(value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n\n  return value;\n}\n\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors\n  } = target;\n\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n\n    value = [];\n\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n\n  return value;\n}\n\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key, parent) => key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(set, parentScopes, key, parentFallback) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, scope);\n\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n\n  return false;\n}\n\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop);\n\n  if (key === null) {\n    return false;\n  }\n\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key);\n\n    if (key === null) {\n      return false;\n    }\n  }\n\n  return _createResolver(Array.from(set), [''], rootScopes, fallback, () => subGetTarget(resolver, prop, value));\n}\n\nfunction addScopesFromKey(set, allScopes, key, fallback) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback);\n  }\n\n  return key;\n}\n\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n\n  const target = parent[prop];\n\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n\n  return target;\n}\n\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n\n    if (defined(value)) {\n      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n    }\n  }\n}\n\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n\n    const value = scope[key];\n\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n\n  return Array.from(set);\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\n\nconst getValueAxis = indexAxis => indexAxis === 'x' ? 'y' : 'x';\n\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n\n    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n\n  let inAreaNext = _isPointInArea(points[0], area);\n\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n\n    if (!inArea) {\n      continue;\n    }\n\n    point = points[i];\n\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n\n  if (options.spanGaps) {\n    points = points.filter(pt => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n\n  return parent;\n}\n\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = element => window.getComputedStyle(element, null);\n\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\n\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\n\nfunction getCanvasPosition(evt, canvas) {\n  const e = evt.native || evt;\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {\n    offsetX,\n    offsetY\n  } = source;\n  let box = false;\n  let x, y;\n\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n\n  return {\n    x,\n    y,\n    box\n  };\n}\n\nfunction getRelativePosition(evt, chart) {\n  const {\n    canvas,\n    currentDevicePixelRatio\n  } = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {\n    x,\n    y,\n    box\n  } = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {\n    width,\n    height\n  } = chart;\n\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = v => Math.round(v * 10) / 10;\n\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {\n    width,\n    height\n  } = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n\n  return {\n    width,\n    height\n  };\n}\n\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n\n  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n\n  return false;\n}\n\nconst supportsEventListenerOptions = function () {\n  let passiveSupported = false;\n\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {}\n\n  return passiveSupported;\n}();\n\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n  };\n}\n\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {\n    x: p1.cp2x,\n    y: p1.cp2y\n  };\n  const cp2 = {\n    x: p2.cp1x,\n    y: p2.cp1y\n  };\n\n  const a = _pointInLine(p1, cp1, t);\n\n  const b = _pointInLine(cp1, cp2, t);\n\n  const c = _pointInLine(cp2, p2, t);\n\n  const d = _pointInLine(a, b, t);\n\n  const e = _pointInLine(b, c, t);\n\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\n\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n\n  return formatter;\n}\n\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function (rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n\n    setWidth(w) {\n      width = w;\n    },\n\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n\n      return align === 'right' ? 'left' : 'right';\n    },\n\n    xPlus(x, value) {\n      return x - value;\n    },\n\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    }\n\n  };\n};\n\nconst getLeftToRightAdapter = function () {\n  return {\n    x(x) {\n      return x;\n    },\n\n    setWidth(w) {},\n\n    textAlign(align) {\n      return align;\n    },\n\n    xPlus(x, value) {\n      return x + value;\n    },\n\n    leftForLtr(x, _itemWidth) {\n      return x;\n    }\n\n  };\n};\n\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\n\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle\n    };\n  }\n\n  return {\n    between: (n, s, e) => n >= Math.min(s, e) && n <= Math.max(e, s),\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({\n  start,\n  end,\n  count,\n  loop,\n  style\n}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const {\n    between,\n    normalize\n  } = propertyFn(property);\n  const count = points.length;\n  let {\n    start,\n    end,\n    loop\n  } = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n\n      start--;\n      end--;\n    }\n\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n\n  return {\n    start,\n    end,\n    loop,\n    style: segment.style\n  };\n}\n\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const count = points.length;\n  const {\n    compare,\n    between,\n    normalize\n  } = propertyFn(property);\n  const {\n    start,\n    end,\n    loop,\n    style\n  } = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n\n  const shouldStart = () => inside || startIsBefore();\n\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({\n        start: subStart,\n        end: i,\n        loop,\n        count,\n        style\n      }));\n      subStart = null;\n    }\n\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({\n      start: subStart,\n      end,\n      loop,\n      count,\n      style\n    }));\n  }\n\n  return result;\n}\n\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n\n  return result;\n}\n\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  start %= count;\n\n  if (loop) {\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  end %= count;\n  return {\n    start,\n    end\n  };\n}\n\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({\n          start: start % count,\n          end: (end - 1) % count,\n          loop\n        });\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n\n      if (prev.skip) {\n        start = end;\n      }\n    }\n\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({\n      start: start % count,\n      end: last % count,\n      loop\n    });\n  }\n\n  return result;\n}\n\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {\n    start,\n    end\n  } = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{\n      start,\n      end,\n      loop\n    }], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const baseStyle = readStyle(line.options);\n  const count = points.length;\n  const result = [];\n  let start = segments[0].start;\n  let i = start;\n\n  for (const segment of segments) {\n    let prevStyle = baseStyle;\n    let prev = points[start % count];\n    let style;\n\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext({\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex: line._datasetIndex\n      }));\n\n      if (styleChanged(style, prevStyle)) {\n        result.push({\n          start: start,\n          end: i - 1,\n          loop: segment.loop,\n          style: prevStyle\n        });\n        prevStyle = style;\n        start = i - 1;\n      }\n\n      prev = pt;\n      prevStyle = style;\n    }\n\n    if (start < i - 1) {\n      result.push({\n        start,\n        end: i - 1,\n        loop: segment.loop,\n        style\n      });\n      start = i - 1;\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n\n// CONCATENATED MODULE: ./node_modules/chart.js/dist/chart.esm.js\n/*!\n * Chart.js v3.5.1\n * https://www.chartjs.org\n * (c) 2021 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\nclass chart_esm_Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  _refresh() {\n    const me = this;\n\n    if (me._request) {\n      return;\n    }\n\n    me._running = true;\n    me._request = requestAnimFrame.call(window, () => {\n      me._update();\n\n      me._request = null;\n\n      if (me._running) {\n        me._refresh();\n      }\n    });\n  }\n\n  _update(date = Date.now()) {\n    const me = this;\n    let remaining = 0;\n\n    me._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n\n        me._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n\n        me._notify(chart, anims, date, 'complete');\n\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    me._lastDate = date;\n\n    if (remaining === 0) {\n      me._running = false;\n    }\n  }\n\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n\n    return anims;\n  }\n\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n\n    this._getAnims(chart).items.push(...items);\n  }\n\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  start(chart) {\n    const anims = this._charts.get(chart);\n\n    if (!anims) {\n      return;\n    }\n\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n\n    const anims = this._charts.get(chart);\n\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n\n    return true;\n  }\n\n  stop(chart) {\n    const anims = this._charts.get(chart);\n\n    if (!anims || !anims.items.length) {\n      return;\n    }\n\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n\n    anims.items = [];\n\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n\n}\n\nvar animator = new chart_esm_Animator();\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n\n  color(from, to, factor) {\n    const c0 = helpers_segment_color(from || transparent);\n    const c1 = c0.valid && helpers_segment_color(to || transparent);\n    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n  },\n\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n\n};\n\nclass chart_esm_Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    const me = this;\n\n    if (me._active) {\n      me._notify(false);\n\n      const currentValue = me._target[me._prop];\n      const elapsed = date - me._start;\n      const remain = me._duration - elapsed;\n      me._start = date;\n      me._duration = Math.floor(Math.max(remain, cfg.duration));\n      me._total += elapsed;\n      me._loop = !!cfg.loop;\n      me._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      me._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    const me = this;\n\n    if (me._active) {\n      me.tick(Date.now());\n      me._active = false;\n\n      me._notify(false);\n    }\n  }\n\n  tick(date) {\n    const me = this;\n    const elapsed = date - me._start;\n    const duration = me._duration;\n    const prop = me._prop;\n    const from = me._from;\n    const loop = me._loop;\n    const to = me._to;\n    let factor;\n    me._active = from !== to && (loop || elapsed < duration);\n\n    if (!me._active) {\n      me._target[prop] = to;\n\n      me._notify(true);\n\n      return;\n    }\n\n    if (elapsed < 0) {\n      me._target[prop] = from;\n      return;\n    }\n\n    factor = elapsed / duration % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = me._easing(Math.min(1, Math.max(0, factor)));\n    me._target[prop] = me._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({\n        res,\n        rej\n      });\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined\n});\nconst chart_esm_animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: name => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  }\n});\ndefaults.describe('animations', {\n  _fallback: 'animation'\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      }\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      }\n    }\n  }\n});\n\nclass chart_esm_Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n\n      if (!isObject(cfg)) {\n        return;\n      }\n\n      const resolved = {};\n\n      for (const option of chart_esm_animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach(prop => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {});\n    }\n\n    return animations;\n  }\n\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new chart_esm_Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n\n    return animations;\n  }\n\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n\n  let options = target.options;\n\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {\n      $shared: false,\n      $animations: {}\n    });\n  }\n\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n\n      break;\n    }\n\n    otherValue = stack.values[datasetIndex];\n\n    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n      value += otherValue;\n    }\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || stacked === undefined && meta.stack !== undefined;\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {\n    min,\n    max,\n    minDefined,\n    maxDefined\n  } = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive) {\n  for (const meta of vScale.getMatchingVisibleMetas('bar').reverse()) {\n    const value = stack[meta.index];\n\n    if (positive && value > 0 || !positive && value < 0) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {\n    chart,\n    _cachedMeta: meta\n  } = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {\n    iScale,\n    vScale,\n    index: datasetIndex\n  } = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {\n      [iAxis]: index,\n      [vAxis]: value\n    } = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true);\n    stack._bottom = getLastIndexInStack(stack, vScale, false);\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return Object.assign(Object.create(parent), {\n    active: false,\n    dataset: undefined,\n    datasetIndex: index,\n    index,\n    mode: 'default',\n    type: 'dataset'\n  });\n}\n\nfunction createDataContext(parent, index, element) {\n  return Object.assign(Object.create(parent), {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n\n    delete stacks[axis][datasetIndex];\n  }\n}\n\nconst isDirectUpdateMode = mode => mode === 'reset' || mode === 'none';\n\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\n\nclass chart_esm_DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n\n  initialize() {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.configure();\n    me.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    me.addElements();\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const me = this;\n    const chart = me.chart;\n    const meta = me._cachedMeta;\n    const dataset = me.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = me.getScaleForId(xid);\n    meta.yScale = me.getScaleForId(yid);\n    meta.rScale = me.getScaleForId(rid);\n    meta.iScale = me.getScaleForId(iid);\n    meta.vScale = me.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale ? meta.vScale : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  _destroy() {\n    const meta = this._cachedMeta;\n\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  _dataCheck() {\n    const me = this;\n    const dataset = me.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = me._data;\n\n    if (isObject(data)) {\n      me._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, me);\n        const meta = me._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, me);\n      }\n\n      me._syncList = [];\n      me._data = data;\n    }\n  }\n\n  addElements() {\n    const me = this;\n    const meta = me._cachedMeta;\n\n    me._dataCheck();\n\n    if (me.datasetElementType) {\n      meta.dataset = new me.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const dataset = me.getDataset();\n    let stackChanged = false;\n\n    me._dataCheck();\n\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    me._resyncElements(resetNewElements);\n\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(me, meta._parsed);\n    }\n  }\n\n  configure() {\n    const me = this;\n    const config = me.chart.config;\n    const scopeKeys = config.datasetScopeKeys(me._type);\n    const scopes = config.getOptionScopes(me.getDataset(), scopeKeys, true);\n    me.options = config.createResolver(scopes, me.getContext());\n    me._parsing = me.options.parsing;\n  }\n\n  parse(start, count) {\n    const me = this;\n    const {\n      _cachedMeta: meta,\n      _data: data\n    } = me;\n    const {\n      iScale,\n      _stacked\n    } = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (me._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = me.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = me.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = me.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n\n          prev = cur;\n        }\n      }\n\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(me, parsed);\n    }\n  }\n\n  parsePrimitiveData(meta, data, start, count) {\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n\n    return parsed;\n  }\n\n  parseArrayData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n\n    return parsed;\n  }\n\n  parseObjectData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const {\n      xAxisKey = 'x',\n      yAxisKey = 'y'\n    } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n\n    return parsed;\n  }\n\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {\n      mode\n    });\n  }\n\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n\n    if (stack && values) {\n      stack.values = values;\n      range.min = Math.min(range.min, value);\n      range.max = Math.max(range.max, value);\n      value = applyStack(stack, parsedValue, this._cachedMeta.index, {\n        all: true\n      });\n    }\n\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  getMinMax(scale, canStack) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n\n    const otherScale = me._getOtherScale(scale);\n\n    const stack = canStack && meta._stacked && {\n      keys: getSortedDatasetIndices(me.chart, true),\n      values: null\n    };\n    const range = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n    const {\n      min: otherMin,\n      max: otherMax\n    } = getUserBounds(otherScale);\n    let i, value, parsed, otherValue;\n\n    function _skip() {\n      parsed = _parsed[i];\n      value = parsed[scale.axis];\n      otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(value) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n\n      me.updateRangeFromParsed(range, scale, parsed, stack);\n\n      if (sorted) {\n        break;\n      }\n    }\n\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n\n        me.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n\n    return values;\n  }\n\n  getMaxOverflow() {\n    return false;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = me.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  _update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.configure();\n    me._cachedDataOpts = {};\n    me.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(me.options.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));\n  }\n\n  update(mode) {}\n\n  draw() {\n    const me = this;\n    const ctx = me._ctx;\n    const chart = me.chart;\n    const meta = me._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = me._drawStart || 0;\n    const count = me._drawCount || elements.length - start;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n\n      if (element.hidden) {\n        continue;\n      }\n\n      if (element.active) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  getContext(index, active, mode) {\n    const me = this;\n    const dataset = me.getDataset();\n    let context;\n\n    if (index >= 0 && index < me._cachedMeta.data.length) {\n      const element = me._cachedMeta.data[index];\n      context = element.$context || (element.$context = createDataContext(me.getContext(), index, element));\n      context.parsed = me.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = me.$context || (me.$context = createDatasetContext(me.chart.getContext(), me.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = me.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const me = this;\n    const active = mode === 'active';\n    const cache = me._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = me.enableOptionSharing && defined(index);\n\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n\n    const config = me.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(me._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n\n    const context = () => me.getContext(index, active);\n\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n  _resolveAnimations(index, transition, active) {\n    const me = this;\n    const chart = me.chart;\n    const cache = me._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n\n    if (cached) {\n      return cached;\n    }\n\n    let options;\n\n    if (chart.options.animation !== false) {\n      const config = me.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(me._type, transition);\n      const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, me.getContext(index, active, transition));\n    }\n\n    const animations = new chart_esm_Animations(chart, options && options.animations);\n\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: !active && this.getSharedOptions(options) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  _resyncElements(resetNewElements) {\n    const me = this;\n    const data = me._data;\n    const elements = me._cachedMeta.data;\n\n    for (const [method, arg1, arg2] of me._syncList) {\n      me[method](arg1, arg2);\n    }\n\n    me._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      me.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      me._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      me._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  _insertElements(start, count, resetNewElements = true) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = arr => {\n      arr.length += count;\n\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new me.dataElementType();\n    }\n\n    if (me._parsing) {\n      move(meta._parsed);\n    }\n\n    me.parse(start, count);\n\n    if (resetNewElements) {\n      me.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {}\n\n  _removeElements(start, count) {\n    const me = this;\n    const meta = me._cachedMeta;\n\n    if (me._parsing) {\n      const removed = meta._parsed.splice(start, count);\n\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n\n    meta.data.splice(start, count);\n  }\n\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    this._sync(['_removeElements', start, count]);\n\n    this._sync(['_insertElements', start, arguments.length - 2]);\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n\n}\n\nchart_esm_DatasetController.defaults = {};\nchart_esm_DatasetController.prototype.datasetElementType = null;\nchart_esm_DatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale) {\n  if (!scale._cache.$bar) {\n    const metas = scale.getMatchingVisibleMetas('bar');\n    let values = [];\n\n    for (let i = 0, ilen = metas.length; i < ilen; i++) {\n      values = values.concat(metas[i].controller.getAllParsedValues(scale));\n    }\n\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n\n  return scale._cache.$bar;\n}\n\nfunction computeMinSampleSize(scale) {\n  const values = getAllScaleValues(scale);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - size / 2\n  };\n}\n\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n\n  return {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  };\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  const {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  } = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nclass chart_esm_BarController extends chart_esm_DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  parseObjectData(meta, data, start, count) {\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const {\n      xAxisKey = 'x',\n      yAxisKey = 'y'\n    } = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n\n    return parsed;\n  }\n\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  getMaxOverflow() {\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const parsed = me.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    const me = this;\n    me.enableOptionSharing = true;\n    super.initialize();\n    const meta = me._cachedMeta;\n    meta.stack = me.getDataset().stack;\n  }\n\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      index,\n      _cachedMeta: {\n        vScale\n      }\n    } = me;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n\n    const ruler = me._getRuler();\n\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = me.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n        base,\n        head: base\n      } : me._calculateBarValuePixels(i);\n\n      const ipixels = me._calculateBarIndexPixels(i, ruler);\n\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || me.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n\n      setBorderSkipped(properties, properties.options || bars[i].options, stack, index);\n      me.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  _getStacks(last, dataIndex) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const iScale = meta.iScale;\n    const metasets = iScale.getMatchingVisibleMetas(me._type);\n    const stacked = iScale.options.stacked;\n    const ilen = metasets.length;\n    const stacks = [];\n    let i, item;\n\n    for (i = 0; i < ilen; ++i) {\n      item = metasets[i];\n\n      if (!item.controller.options.grouped) {\n        continue;\n      }\n\n      if (typeof dataIndex !== 'undefined') {\n        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];\n\n        if (isNullOrUndef(val) || isNaN(val)) {\n          continue;\n        }\n      }\n\n      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === undefined && item.stack === undefined) {\n        stacks.push(item.stack);\n      }\n\n      if (item.index === last) {\n        break;\n      }\n    }\n\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n\n    const index = name !== undefined ? stacks.indexOf(name) : -1;\n    return index === -1 ? stacks.length - 1 : index;\n  }\n\n  _getRuler() {\n    const me = this;\n    const opts = me.options;\n    const meta = me._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(iScale);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: me._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  _calculateBarValuePixels(index) {\n    const me = this;\n    const {\n      _cachedMeta: {\n        vScale,\n        _stacked\n      },\n      options: {\n        base: baseValue,\n        minBarLength\n      }\n    } = me;\n    const actualBase = baseValue || 0;\n    const parsed = me.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (me.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n\n      head = base + size;\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  _calculateBarIndexPixels(index, ruler) {\n    const me = this;\n    const scale = ruler.scale;\n    const options = me.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n\n    if (ruler.grouped) {\n      const stackCount = skipNull ? me._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack, skipNull ? index : undefined);\n\n      center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(me.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const me = this;\n    const meta = me._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (me.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(me._ctx);\n      }\n    }\n  }\n\n}\n\nchart_esm_BarController.id = 'bar';\nchart_esm_BarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nchart_esm_BarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true\n    }\n  }\n};\n\nclass chart_esm_BubbleController extends chart_esm_DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  parseObjectData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const {\n      xAxisKey = 'x',\n      yAxisKey = 'y'\n    } = this._parsing;\n    const parsed = [];\n    let i, ilen, item;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      item = data[i];\n      parsed.push({\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), i),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), i),\n        _custom: item && item.r && +item.r\n      });\n    }\n\n    return parsed;\n  }\n\n  getMaxOverflow() {\n    const {\n      data,\n      _parsed\n    } = this._cachedMeta;\n    let max = 0;\n\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);\n    }\n\n    return max > 0 && max;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = me.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const me = this;\n    const points = me._cachedMeta.data;\n    me.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      iScale,\n      vScale\n    } = me._cachedMeta;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && me.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = me.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      me.updateElement(point, i, properties, mode);\n    }\n\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    if (values.$shared) {\n      values = Object.assign({}, values, {\n        $shared: false\n      });\n    }\n\n    const radius = values.radius;\n\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n\n}\n\nchart_esm_BubbleController.id = 'bubble';\nchart_esm_BubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nchart_esm_BubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n\n  return {\n    ratioX,\n    ratioY,\n    offsetX,\n    offsetY\n  };\n}\n\nclass chart_esm_DoughnutController extends chart_esm_DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    let i, ilen;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      meta._parsed[i] = +data[i];\n    }\n  }\n\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    const me = this;\n\n    for (let i = 0; i < me.chart.data.datasets.length; ++i) {\n      if (me.chart.isDatasetVisible(i)) {\n        const controller = me.chart.getDatasetMeta(i).controller;\n\n        const rotation = controller._getRotation();\n\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min\n    };\n  }\n\n  update(mode) {\n    const me = this;\n    const chart = me.chart;\n    const {\n      chartArea\n    } = chart;\n    const meta = me._cachedMeta;\n    const arcs = meta.data;\n    const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs) + me.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(me.options.cutout, maxSize), 1);\n\n    const chartWeight = me._getRingWeight(me.index);\n\n    const {\n      circumference,\n      rotation\n    } = me._getRotationExtents();\n\n    const {\n      ratioX,\n      ratioY,\n      offsetX,\n      offsetY\n    } = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(me.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n\n    const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();\n\n    me.offsetX = offsetX * outerRadius;\n    me.offsetY = offsetY * outerRadius;\n    meta.total = me.calculateTotal();\n    me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);\n    me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);\n    me.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  _circumference(i, reset) {\n    const me = this;\n    const opts = me.options;\n    const meta = me._cachedMeta;\n\n    const circumference = me._getCircumference();\n\n    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n\n    return me.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const chart = me.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : me.innerRadius;\n    const outerRadius = animateScale ? 0 : me.outerRadius;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n\n    let startAngle = me._getRotation();\n\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += me._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = me._circumference(i, reset);\n\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + me.offsetX,\n        y: centerY + me.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || me.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n\n      startAngle += circumference;\n      me.updateElement(arc, i, properties, mode);\n    }\n\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const chart = me.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    const me = this;\n    let max = 0;\n    const chart = me.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n\n          if (controller !== me) {\n            controller.configure();\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n\n    return max;\n  }\n\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n\n}\n\nchart_esm_DoughnutController.id = 'doughnut';\nchart_esm_DoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    }\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r'\n};\nchart_esm_DoughnutController.descriptors = {\n  _scriptable: name => name !== 'spacing',\n  _indexable: name => name !== 'spacing'\n};\nchart_esm_DoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            const {\n              labels: {\n                pointStyle\n              }\n            } = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n\n      },\n\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return dataLabel;\n        }\n\n      }\n    }\n  }\n};\n\nclass chart_esm_LineController extends chart_esm_DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const {\n      dataset: line,\n      data: points = [],\n      _dataset\n    } = meta;\n    const animationsDisabled = me.chart._animationsDisabled;\n    let {\n      start,\n      count\n    } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    me._drawStart = start;\n    me._drawCount = count;\n\n    if (scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    line._datasetIndex = me.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = me.resolveDatasetElementOptions(mode);\n\n    if (!me.options.showLine) {\n      options.borderWidth = 0;\n    }\n\n    options.segment = me.options.segment;\n    me.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    me.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      iScale,\n      vScale,\n      _stacked\n    } = me._cachedMeta;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(firstOpts);\n    const includeOptions = me.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const spanGaps = me.options.spanGaps;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = me.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && me.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = me.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? me.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;\n      properties.parsed = parsed;\n\n      if (includeOptions) {\n        properties.options = sharedOptions || me.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        me.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    me.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  getMaxOverflow() {\n    const me = this;\n    const meta = me._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(me.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n\n}\n\nchart_esm_LineController.id = 'line';\nchart_esm_LineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false\n};\nchart_esm_LineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category'\n    },\n    _value_: {\n      type: 'linear'\n    }\n  }\n};\n\nfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {\n      iScale,\n      _parsed\n    } = meta;\n    const axis = iScale.axis;\n    const {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n    }\n\n    if (maxDefined) {\n      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {\n    start,\n    count\n  };\n}\n\nfunction scaleRangesChanged(meta) {\n  const {\n    xScale,\n    yScale,\n    _scaleRanges\n  } = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n\n  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nclass chart_esm_PolarAreaController extends chart_esm_DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const chart = me.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value\n    };\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  _updateRadius() {\n    const me = this;\n    const chart = me.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    me.outerRadius = outerRadius - radiusLength * me.index;\n    me.innerRadius = me.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const chart = me.chart;\n    const dataset = me.getDataset();\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = me._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / me.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += me._computeAngle(i, mode, defaultAngle);\n    }\n\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n\n      let endAngle = angle + me._computeAngle(i, mode, defaultAngle);\n\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: me.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      me.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const dataset = this.getDataset();\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n  }\n\n}\n\nchart_esm_PolarAreaController.id = 'polarArea';\nchart_esm_PolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    }\n  },\n  indexAxis: 'r',\n  startAngle: 0\n};\nchart_esm_PolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            const {\n              labels: {\n                pointStyle\n              }\n            } = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n\n      },\n\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends chart_esm_DoughnutController {}\n\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends chart_esm_DatasetController {\n  getLabelAndValue(index) {\n    const me = this;\n    const vScale = me._cachedMeta.vScale;\n    const parsed = me.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n\n    if (mode !== 'resize') {\n      const options = me.resolveDatasetElementOptions(mode);\n\n      if (!me.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      me.updateElement(line, undefined, properties, mode);\n    }\n\n    me.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const me = this;\n    const dataset = me.getDataset();\n    const scale = me._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = me.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      me.updateElement(point, i, properties, mode);\n    }\n  }\n\n}\n\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  }\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear'\n    }\n  }\n};\n\nclass ScatterController extends chart_esm_LineController {}\n\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\nvar controllers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BarController: chart_esm_BarController,\n  BubbleController: chart_esm_BubbleController,\n  DoughnutController: chart_esm_DoughnutController,\n  LineController: chart_esm_LineController,\n  PolarAreaController: chart_esm_PolarAreaController,\n  PieController: PieController,\n  RadarController: RadarController,\n  ScatterController: ScatterController\n});\n\nfunction chart_esm_abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n\n  formats() {\n    return chart_esm_abstract();\n  }\n\n  parse(value, format) {\n    return chart_esm_abstract();\n  }\n\n  format(timestamp, format) {\n    return chart_esm_abstract();\n  }\n\n  add(timestamp, amount, unit) {\n    return chart_esm_abstract();\n  }\n\n  diff(a, b, unit) {\n    return chart_esm_abstract();\n  }\n\n  startOf(timestamp, unit, weekday) {\n    return chart_esm_abstract();\n  }\n\n  endOf(timestamp, unit) {\n    return chart_esm_abstract();\n  }\n\n}\n\nDateAdapter.override = function (members) {\n  Object.assign(DateAdapter.prototype, members);\n};\n\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction chart_esm_getRelativePosition(e, chart) {\n  if ('native' in e) {\n    return {\n      x: e.x,\n      y: e.y\n    };\n  }\n\n  return getRelativePosition(e, chart);\n}\n\nfunction evaluateAllVisibleItems(chart, handler) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  let index, data, element;\n\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    ({\n      index,\n      data\n    } = metasets[i]);\n\n    for (let j = 0, jlen = data.length; j < jlen; ++j) {\n      element = data[j];\n\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {\n    controller,\n    data,\n    _sorted\n  } = metaset;\n  const iScale = controller._cachedMeta.iScale;\n\n  if (iScale && axis === iScale.axis && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {\n          lo: start.lo,\n          hi: end.hi\n        };\n      }\n    }\n  }\n\n  return {\n    lo: 0,\n    hi: data.length - 1\n  };\n}\n\nfunction optimizedEvaluateItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {\n      index,\n      data\n    } = metasets[i];\n    const {\n      lo,\n      hi\n    } = binarySearch(metasets[i], axis, value, intersect);\n\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function (pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\nfunction getIntersectItems(chart, position, axis, useFinalPosition) {\n  const items = [];\n\n  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n\n  const evaluationFunc = function (element, datasetIndex, index) {\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({\n        element,\n        datasetIndex,\n        index\n      });\n    }\n  };\n\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition) {\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  let items = [];\n\n  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n\n  const evaluationFunc = function (element, datasetIndex, index) {\n    if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n\n    if (!_isPointInArea(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n\n    if (distance < minDistance) {\n      items = [{\n        element,\n        datasetIndex,\n        index\n      }];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({\n        element,\n        datasetIndex,\n        index\n      });\n    }\n  };\n\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\nfunction getAxisItems(chart, e, options, useFinalPosition) {\n  const position = chart_esm_getRelativePosition(e, chart);\n  const items = [];\n  const axis = options.axis;\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({\n        element,\n        datasetIndex,\n        index\n      });\n    }\n\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      intersectsItem = true;\n    }\n  });\n\n  if (options.intersect && !intersectsItem) {\n    return [];\n  }\n\n  return items;\n}\n\nvar Interaction = {\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach(meta => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        if (element && !element.skip) {\n          elements.push({\n            element,\n            datasetIndex: meta.index,\n            index\n          });\n        }\n      });\n      return elements;\n    },\n\n    dataset(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n\n        for (let i = 0; i < data.length; ++i) {\n          items.push({\n            element: data[i],\n            datasetIndex,\n            index: i\n          });\n        }\n      }\n\n      return items;\n    },\n\n    point(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getIntersectItems(chart, position, axis, useFinalPosition);\n    },\n\n    nearest(chart, e, options, useFinalPosition) {\n      const position = chart_esm_getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\n    },\n\n    x(chart, e, options, useFinalPosition) {\n      options.axis = 'x';\n      return getAxisItems(chart, e, options, useFinalPosition);\n    },\n\n    y(chart, e, options, useFinalPosition) {\n      options.axis = 'y';\n      return getAxisItems(chart, e, options, useFinalPosition);\n    }\n\n  }\n};\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({\n      position: pos,\n      options: {\n        stack,\n        stackWeight = 1\n      }\n    } = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && pos + stack,\n      stackWeight\n    });\n  }\n\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n\n  for (const wrap of layouts) {\n    const {\n      stack,\n      pos,\n      stackWeight\n    } = wrap;\n\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n\n    const _stack = stacks[stack] || (stacks[stack] = {\n      count: 0,\n      placed: 0,\n      weight: 0,\n      size: 0\n    });\n\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n\n  return stacks;\n}\n\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {\n    vBoxMaxWidth,\n    hBoxMaxHeight\n  } = params;\n  let i, ilen, layout;\n\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {\n      fullSize\n    } = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {\n    pos,\n    box\n  } = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n\n    const stack = stacks[layout.stack] || {\n      size: 0,\n      count: 1\n    };\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal ? {\n    same: widthChanged,\n    other: heightChanged\n  } : {\n    same: heightChanged,\n    other: widthChanged\n  };\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    positions.forEach(pos => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n    const {\n      same,\n      other\n    } = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {\n    x,\n    y\n  } = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {\n      count: 1,\n      placed: 0,\n      weight: 1\n    };\n    const weight = layout.stackWeight / stack.weight || 1;\n\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\ndefaults.set('layout', {\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n\n    item._layers = item._layers || function () {\n      return [{\n        z: 0,\n\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w\n    };\n    each(boxes.chartArea, layout => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h);\n    });\n  }\n\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n\n  releaseContext(context) {\n    return false;\n  }\n\n  addEventListener(chart, type, listener) {}\n\n  removeEventListener(chart, type, listener) {}\n\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  isAttached(canvas) {\n    return true;\n  }\n\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\nconst eventListenerOptions = supportsEventListenerOptions ? {\n  passive: true\n} : false;\n\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {\n    x,\n    y\n  } = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null\n  };\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n\n  const container = canvas && _getParentNode(canvas);\n\n  const element = container || canvas;\n  const observer = new MutationObserver(entries => {\n    const parent = _getParentNode(element);\n\n    entries.forEach(entry => {\n      for (let i = 0; i < entry.addedNodes.length; i++) {\n        const added = entry.addedNodes[i];\n\n        if (added === element || added === parent) {\n          listener(entry.target);\n        }\n      }\n    });\n  });\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n\n  const container = canvas && _getParentNode(canvas);\n\n  if (!container) {\n    return;\n  }\n\n  const observer = new MutationObserver(entries => {\n    entries.forEach(entry => {\n      for (let i = 0; i < entry.removedNodes.length; i++) {\n        if (entry.removedNodes[i] === canvas) {\n          listener();\n          break;\n        }\n      }\n    });\n  });\n  observer.observe(container, {\n    childList: true\n  });\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n\n  const container = canvas && _getParentNode(canvas);\n\n  if (!container) {\n    return;\n  }\n\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n\n    if (width === 0 && height === 0) {\n      return;\n    }\n\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled(event => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, args => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\n\nclass chart_esm_DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  releaseContext(context) {\n    const canvas = context.canvas;\n\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach(prop => {\n      const value = initial[prop];\n\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach(key => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n\n    return !!(container && container.isConnected);\n  }\n\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return BasicPlatform;\n  }\n\n  return chart_esm_DomPlatform;\n}\n\nclass chart_esm_Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n\n  tooltipPosition(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  getProps(props, final) {\n    const me = this;\n    const anims = this.$animations;\n\n    if (!final || !anims) {\n      return me;\n    }\n\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];\n    });\n    return ret;\n  }\n\n}\n\nchart_esm_Element.defaults = {};\nchart_esm_Element.defaultRoutes = undefined;\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {\n      notation,\n      minimumFractionDigits: numDecimal,\n      maximumFractionDigits: numDecimal\n    };\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n\n    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n\n    return '';\n  }\n\n};\n\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n\n  return delta;\n}\n\nvar Ticks = {\n  formatters\n};\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: name => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: name => name !== 'borderDash' && name !== 'tickBorderDash'\n});\ndefaults.describe('scales', {\n  _fallback: 'scale'\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: name => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: name => name !== 'backdropPadding'\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    chart_esm_skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      chart_esm_skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n\n    chart_esm_skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n\n  chart_esm_skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n\n  const tickLength = scale._tickSize();\n\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n\n  return Math.max(spacing, 1);\n}\n\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\nfunction chart_esm_skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n\n  return diff;\n}\n\nconst reverseAlign = align => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\n\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\n\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n\n  return result;\n}\n\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n\n    lineValue += validIndex < index ? offset : -offset;\n\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n\n  return lineValue;\n}\n\nfunction garbageCollect(caches, length) {\n  each(caches, cache => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return lines * font.lineHeight + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return Object.assign(Object.create(parent), {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return Object.assign(Object.create(parent), {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n\n  if (reverse && position !== 'right' || !reverse && position === 'right') {\n    ret = reverseAlign(ret);\n  }\n\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {\n    top,\n    left,\n    bottom,\n    right,\n    chart\n  } = scale;\n  const {\n    chartArea,\n    scales\n  } = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n\n  return {\n    titleX,\n    titleY,\n    maxWidth,\n    rotation\n  };\n}\n\nclass chart_esm_Scale extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  init(options) {\n    const me = this;\n    me.options = options.setContext(me.getContext());\n    me.axis = options.axis;\n    me._userMin = me.parse(options.min);\n    me._userMax = me.parse(options.max);\n    me._suggestedMin = me.parse(options.suggestedMin);\n    me._suggestedMax = me.parse(options.suggestedMax);\n  }\n\n  parse(raw, index) {\n    return raw;\n  }\n\n  getUserBounds() {\n    let {\n      _userMin,\n      _userMax,\n      _suggestedMin,\n      _suggestedMax\n    } = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n\n  getMinMax(canStack) {\n    const me = this;\n    let {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {\n        min,\n        max\n      };\n    }\n\n    const metas = me.getMatchingVisibleMetas();\n\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(me, canStack);\n\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  getPadding() {\n    const me = this;\n    return {\n      left: me.paddingLeft || 0,\n      top: me.paddingTop || 0,\n      right: me.paddingRight || 0,\n      bottom: me.paddingBottom || 0\n    };\n  }\n\n  getTicks() {\n    return this.ticks;\n  }\n\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const tickOpts = me.options.ticks;\n    const sampleSize = tickOpts.sampleSize;\n    me.beforeUpdate();\n    me.maxWidth = maxWidth;\n    me.maxHeight = maxHeight;\n    me._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    me.ticks = null;\n    me._labelSizes = null;\n    me._gridLineItems = null;\n    me._labelItems = null;\n    me.beforeSetDimensions();\n    me.setDimensions();\n    me.afterSetDimensions();\n    me._maxLength = me.isHorizontal() ? me.width + margins.left + margins.right : me.height + margins.top + margins.bottom;\n\n    if (!me._dataLimitsCached) {\n      me.beforeDataLimits();\n      me.determineDataLimits();\n      me.afterDataLimits();\n      me._range = _addGrace(me, me.options.grace);\n      me._dataLimitsCached = true;\n    }\n\n    me.beforeBuildTicks();\n    me.ticks = me.buildTicks() || [];\n    me.afterBuildTicks();\n    const samplingEnabled = sampleSize < me.ticks.length;\n\n    me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);\n\n    me.configure();\n    me.beforeCalculateLabelRotation();\n    me.calculateLabelRotation();\n    me.afterCalculateLabelRotation();\n\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      me.ticks = autoSkip(me, me.ticks);\n      me._labelSizes = null;\n    }\n\n    if (samplingEnabled) {\n      me._convertTicksToLabels(me.ticks);\n    }\n\n    me.beforeFit();\n    me.fit();\n    me.afterFit();\n    me.afterUpdate();\n  }\n\n  configure() {\n    const me = this;\n    let reversePixels = me.options.reverse;\n    let startPixel, endPixel;\n\n    if (me.isHorizontal()) {\n      startPixel = me.left;\n      endPixel = me.right;\n    } else {\n      startPixel = me.top;\n      endPixel = me.bottom;\n      reversePixels = !reversePixels;\n    }\n\n    me._startPixel = startPixel;\n    me._endPixel = endPixel;\n    me._reversePixels = reversePixels;\n    me._length = endPixel - startPixel;\n    me._alignToPixels = me.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n\n  setDimensions() {\n    const me = this;\n\n    if (me.isHorizontal()) {\n      me.width = me.maxWidth;\n      me.left = 0;\n      me.right = me.width;\n    } else {\n      me.height = me.maxHeight;\n      me.top = 0;\n      me.bottom = me.height;\n    }\n\n    me.paddingLeft = 0;\n    me.paddingTop = 0;\n    me.paddingRight = 0;\n    me.paddingBottom = 0;\n  }\n\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    const me = this;\n    me.chart.notifyPlugins(name, me.getContext());\n    callback(me.options[name], [me]);\n  }\n\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n\n  determineDataLimits() {}\n\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n\n  buildTicks() {\n    return [];\n  }\n\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n\n  generateTickLabels(ticks) {\n    const me = this;\n    const tickOpts = me.options.ticks;\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], me);\n    }\n  }\n\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n\n  calculateLabelRotation() {\n    const me = this;\n    const options = me.options;\n    const tickOpts = options.ticks;\n    const numTicks = me.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\n      me.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = me._getLabelSizes();\n\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    const maxWidth = _limitValue(me.chart.width - maxLabelWidth, 0, me.maxWidth);\n\n    tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = me.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, me.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    me.labelRotation = labelRotation;\n  }\n\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n\n  fit() {\n    const me = this;\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {\n      chart,\n      options: {\n        ticks: tickOpts,\n        title: titleOpts,\n        grid: gridOpts\n      }\n    } = me;\n\n    const display = me._isVisible();\n\n    const isHorizontal = me.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = me.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      if (tickOpts.display && me.ticks.length) {\n        const {\n          first,\n          last,\n          widest,\n          highest\n        } = me._getLabelSizes();\n\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(me.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n\n        me._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    me._handleMargins();\n\n    if (isHorizontal) {\n      me.width = me._length = chart.width - me._margins.left - me._margins.right;\n      me.height = minSize.height;\n    } else {\n      me.width = minSize.width;\n      me.height = me._length = chart.height - me._margins.top - me._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const me = this;\n    const {\n      ticks: {\n        align,\n        padding\n      },\n      position\n    } = me.options;\n    const isRotated = me.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && me.axis === 'x';\n\n    if (me.isHorizontal()) {\n      const offsetLeft = me.getPixelForTick(0) - me.left;\n      const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);\n      me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      me.paddingTop = paddingTop + padding;\n      me.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  _handleMargins() {\n    const me = this;\n\n    if (me._margins) {\n      me._margins.left = Math.max(me.paddingLeft, me._margins.left);\n      me._margins.top = Math.max(me.paddingTop, me._margins.top);\n      me._margins.right = Math.max(me.paddingRight, me._margins.right);\n      me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n\n  isHorizontal() {\n    const {\n      axis,\n      position\n    } = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  _convertTicksToLabels(ticks) {\n    const me = this;\n    me.beforeTickToLabelConversion();\n    me.generateTickLabels(ticks);\n    let i, ilen;\n\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    me.afterTickToLabelConversion();\n  }\n\n  _getLabelSizes() {\n    const me = this;\n    let labelSizes = me._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = me.options.ticks.sampleSize;\n      let ticks = me.ticks;\n\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);\n    }\n\n    return labelSizes;\n  }\n\n  _computeLabelSizes(ticks, length) {\n    const {\n      ctx,\n      _longestTextCache: caches\n    } = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {\n        data: {},\n        gc: []\n      };\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = idx => ({\n      width: widths[idx] || 0,\n      height: heights[idx] || 0\n    });\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights\n    };\n  }\n\n  getLabelForValue(value) {\n    return value;\n  }\n\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n\n  getValueForPixel(pixel) {}\n\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getPixelForDecimal(decimal) {\n    const me = this;\n\n    if (me._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = me._startPixel + decimal * me._length;\n    return _int16Range(me._alignToPixels ? _alignPixel(me.chart, pixel, 0) : pixel);\n  }\n\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  getBaseValue() {\n    const {\n      min,\n      max\n    } = this;\n    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n  }\n\n  getContext(index) {\n    const me = this;\n    const ticks = me.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context || (tick.$context = createTickContext(me.getContext(), index, tick));\n    }\n\n    return me.$context || (me.$context = createScaleContext(me.chart.getContext(), me));\n  }\n\n  _tickSize() {\n    const me = this;\n    const optionTicks = me.options.ticks;\n    const rot = toRadians(me.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = me._getLabelSizes();\n\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  _computeGridLineItems(chartArea) {\n    const me = this;\n    const axis = me.axis;\n    const chart = me.chart;\n    const options = me.options;\n    const {\n      grid,\n      position\n    } = options;\n    const offset = grid.offset;\n    const isHorizontal = me.isHorizontal();\n    const ticks = me.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(me.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n\n    const alignBorderValue = function (pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(me.bottom);\n      ty1 = me.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(me.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = me.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(me.right);\n      tx1 = me.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(me.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = me.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(me.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = grid.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(me, i, offset);\n\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset\n      });\n    }\n\n    me._ticksLength = ticksLength;\n    me._borderValue = borderValue;\n    return items;\n  }\n\n  _computeLabelItems(chartArea) {\n    const me = this;\n    const axis = me.axis;\n    const options = me.options;\n    const {\n      position,\n      ticks: optionTicks\n    } = options;\n    const isHorizontal = me.isHorizontal();\n    const ticks = me.ticks;\n    const {\n      align,\n      crossAlign,\n      padding,\n      mirror\n    } = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(me.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = me.bottom - hTickAndPadding;\n      textAlign = me._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = me.top + hTickAndPadding;\n      textAlign = me._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = me._getYAxisLabelAlignment(tl);\n\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = me._getYAxisLabelAlignment(tl);\n\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n\n      textAlign = me._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = me.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n\n      textAlign = me._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = me._getLabelSizes();\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(me.getContext(i));\n      pixel = me.getPixelForTick(i) + optionTicks.labelOffset;\n      font = me._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n\n        switch (textBaseline) {\n          case 'middle':\n            top -= height / 2;\n            break;\n\n          case 'bottom':\n            top -= height;\n            break;\n        }\n\n        switch (textAlign) {\n          case 'center':\n            left -= width / 2;\n            break;\n\n          case 'right':\n            left -= width;\n            break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor\n        };\n      }\n\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const me = this;\n    const {\n      position,\n      ticks\n    } = me.options;\n    const rotation = -toRadians(me.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const me = this;\n    const {\n      position,\n      ticks: {\n        crossAlign,\n        mirror,\n        padding\n      }\n    } = me.options;\n\n    const labelSizes = me._getLabelSizes();\n\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = me.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = me.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= widest / 2;\n        } else {\n          textAlign = 'left';\n          x = me.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = me.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= widest / 2;\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = me.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = me.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {\n      textAlign,\n      x\n    };\n  }\n\n  _computeLabelArea() {\n    const me = this;\n\n    if (me.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = me.chart;\n    const position = me.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {\n        top: 0,\n        left: me.left,\n        bottom: chart.height,\n        right: me.right\n      };\n    }\n\n    if (position === 'top' || position === 'bottom') {\n      return {\n        top: me.top,\n        left: 0,\n        bottom: me.bottom,\n        right: chart.width\n      };\n    }\n  }\n\n  drawBackground() {\n    const {\n      ctx,\n      options: {\n        backgroundColor\n      },\n      left,\n      top,\n      width,\n      height\n    } = this;\n\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const me = this;\n    const grid = me.options.grid;\n\n    if (!me._isVisible() || !grid.display) {\n      return 0;\n    }\n\n    const ticks = me.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n\n    if (index >= 0) {\n      const opts = grid.setContext(me.getContext(index));\n      return opts.lineWidth;\n    }\n\n    return 0;\n  }\n\n  drawGrid(chartArea) {\n    const me = this;\n    const grid = me.options.grid;\n    const ctx = me.ctx;\n\n    const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\n\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine({\n            x: item.x1,\n            y: item.y1\n          }, {\n            x: item.x2,\n            y: item.y2\n          }, item);\n        }\n\n        if (grid.drawTicks) {\n          drawLine({\n            x: item.tx1,\n            y: item.ty1\n          }, {\n            x: item.tx2,\n            y: item.ty2\n          }, {\n            color: item.tickColor,\n            width: item.tickWidth,\n            borderDash: item.tickBorderDash,\n            borderDashOffset: item.tickBorderDashOffset\n          });\n        }\n      }\n    }\n  }\n\n  drawBorder() {\n    const me = this;\n    const {\n      chart,\n      ctx,\n      options: {\n        grid\n      }\n    } = me;\n    const borderOpts = grid.setContext(me.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n\n    if (!axisWidth) {\n      return;\n    }\n\n    const lastLineWidth = grid.setContext(me.getContext(0)).lineWidth;\n    const borderValue = me._borderValue;\n    let x1, x2, y1, y2;\n\n    if (me.isHorizontal()) {\n      x1 = _alignPixel(chart, me.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, me.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  drawLabels(chartArea) {\n    const me = this;\n    const optionTicks = me.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = me.ctx;\n\n    const area = me._computeLabelArea();\n\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));\n\n    let i, ilen;\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  drawTitle() {\n    const {\n      ctx,\n      options: {\n        position,\n        title,\n        reverse\n      }\n    } = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    } = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY]\n    });\n  }\n\n  draw(chartArea) {\n    const me = this;\n\n    if (!me._isVisible()) {\n      return;\n    }\n\n    me.drawBackground();\n    me.drawGrid(chartArea);\n    me.drawBorder();\n    me.drawTitle();\n    me.drawLabels(chartArea);\n  }\n\n  _layers() {\n    const me = this;\n    const opts = me.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n\n    if (!me._isVisible() || me.draw !== chart_esm_Scale.prototype.draw) {\n      return [{\n        z: tz,\n\n        draw(chartArea) {\n          me.draw(chartArea);\n        }\n\n      }];\n    }\n\n    return [{\n      z: gz,\n\n      draw(chartArea) {\n        me.drawBackground();\n        me.drawGrid(chartArea);\n        me.drawTitle();\n      }\n\n    }, {\n      z: gz + 1,\n\n      draw() {\n        me.drawBorder();\n      }\n\n    }, {\n      z: tz,\n\n      draw(chartArea) {\n        me.drawLabels(chartArea);\n      }\n\n    }];\n  }\n\n  getMatchingVisibleMetas(type) {\n    const me = this;\n    const metas = me.chart.getSortedVisibleDatasetMetas();\n    const axisID = me.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n\n      if (meta[axisID] === me.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  _maxDigits() {\n    const me = this;\n\n    const fontSize = me._resolveTickFontOptions(0).lineHeight;\n\n    return (me.isHorizontal() ? me.width : me.height) / fontSize;\n  }\n\n}\n\nclass chart_esm_TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  register(item) {\n    const me = this;\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      parentScope = me.register(proto);\n    }\n\n    const items = me.items;\n    const id = item.id;\n    const scope = me.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n\n    if (me.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  get(id) {\n    return this.items[id];\n  }\n\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [parentScope ? defaults.get(parentScope) : {}, defaults.get(scope), item.defaults]);\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass chart_esm_Registry {\n  constructor() {\n    this.controllers = new chart_esm_TypedRegistry(chart_esm_DatasetController, 'datasets', true);\n    this.elements = new chart_esm_TypedRegistry(chart_esm_Element, 'elements');\n    this.plugins = new chart_esm_TypedRegistry(Object, 'plugins');\n    this.scales = new chart_esm_TypedRegistry(chart_esm_Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  _each(method, args, typedRegistry) {\n    const me = this;\n    [...args].forEach(arg => {\n      const reg = typedRegistry || me._getRegistryForType(arg);\n\n      if (typedRegistry || reg.isForType(arg) || reg === me.plugins && arg.id) {\n        me._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || me._getRegistryForType(item);\n\n          me._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n\n    return this.plugins;\n  }\n\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n\n    return item;\n  }\n\n}\n\nvar chart_esm_registry = new chart_esm_Registry();\n\nclass chart_esm_PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  notify(chart, hook, args, filter) {\n    const me = this;\n\n    if (hook === 'beforeInit') {\n      me._init = me._createDescriptors(chart, true);\n\n      me._notify(me._init, chart, 'install');\n    }\n\n    const descriptors = filter ? me._descriptors(chart).filter(filter) : me._descriptors(chart);\n\n    const result = me._notify(descriptors, chart, hook, args);\n\n    if (hook === 'destroy') {\n      me._notify(descriptors, chart, 'stop');\n\n      me._notify(me._init, chart, 'uninstall');\n    }\n\n    return result;\n  }\n\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n\n}\n\nfunction allPlugins(config) {\n  const plugins = [];\n  const keys = Object.keys(chart_esm_registry.plugins.items);\n\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(chart_esm_registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n    }\n  }\n\n  return plugins;\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n\n  if (options === true) {\n    return {};\n  }\n\n  return options;\n}\n\nfunction createDescriptors(chart, plugins, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (let i = 0; i < plugins.length; i++) {\n    const plugin = plugins[i];\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n\n    if (opts === null) {\n      continue;\n    }\n\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, plugin, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, plugin, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {\n    scales: {}\n  };\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{\n      axis\n    }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{\n        axis\n      }, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nclass chart_esm_Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n\n    this._resolverCache.clear();\n  }\n\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType, () => [[`datasets.${datasetType}`, '']]);\n  }\n\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`, () => [[`datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}`], [`datasets.${datasetType}`, '']]);\n  }\n\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`, () => [[`datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, '']]);\n  }\n\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`, () => [[`plugins.${id}`, ...(plugin.additionalOptionScopes || [])]]);\n  }\n\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n\n    let cache = _scopeCache.get(mainScope);\n\n    if (!cache || resetCache) {\n      cache = new Map();\n\n      _scopeCache.set(mainScope, cache);\n    }\n\n    return cache;\n  }\n\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {\n      options,\n      type\n    } = this;\n\n    const cache = this._cachedScopes(mainScope, resetCache);\n\n    const cached = cache.get(keyLists);\n\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, helpers_segment_descriptors, key));\n    });\n    const array = Array.from(scopes);\n\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n\n    return array;\n  }\n\n  chartOptionScopes() {\n    const {\n      options,\n      type\n    } = this;\n    return [options, overrides[type] || {}, defaults.datasets[type] || {}, {\n      type\n    }, defaults, helpers_segment_descriptors];\n  }\n\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {\n      $shared: true\n    };\n    const {\n      resolver,\n      subPrefixes\n    } = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n\n    return result;\n  }\n\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {\n      resolver\n    } = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n  }\n\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n\n  return cached;\n}\n\nfunction needContext(proxy, names) {\n  const {\n    isScriptable,\n    isIndexable\n  } = _descriptors(proxy);\n\n  for (const prop of names) {\n    if (isScriptable(prop) && isFunction(proxy[prop]) || isIndexable(prop) && isArray(proxy[prop])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar version = \"3.5.1\";\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\n\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\n\nfunction compare2Level(l1, l2) {\n  return function (a, b) {\n    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n\n  return item;\n}\n\nconst instances = {};\n\nconst getChart = key => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter(c => c.canvas === canvas).pop();\n};\n\nclass chart_esm_Chart {\n  constructor(item, userConfig) {\n    const me = this;\n    const config = this.config = new chart_esm_Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n\n    if (existingChart) {\n      throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas can be reused.');\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), me.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    const context = me.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new chart_esm_PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(() => this.update('resize'), options.resizeDelay || 0);\n    instances[me.id] = me;\n\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(me, 'complete', onAnimationsComplete);\n    animator.listen(me, 'progress', onAnimationProgress);\n\n    me._initialize();\n\n    if (me.attached) {\n      me.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {\n      options: {\n        aspectRatio,\n        maintainAspectRatio\n      },\n      width,\n      height,\n      _aspectRatio\n    } = this;\n\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  _initialize() {\n    const me = this;\n    me.notifyPlugins('beforeInit');\n\n    if (me.options.responsive) {\n      me.resize();\n    } else {\n      retinaScale(me, me.options.devicePixelRatio);\n    }\n\n    me.bindEvents();\n    me.notifyPlugins('afterInit');\n    return me;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {\n        width,\n        height\n      };\n    }\n  }\n\n  _resize(width, height) {\n    const me = this;\n    const options = me.options;\n    const canvas = me.canvas;\n    const aspectRatio = options.maintainAspectRatio && me.aspectRatio;\n    const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || me.platform.getDevicePixelRatio();\n    me.width = newSize.width;\n    me.height = newSize.height;\n    me._aspectRatio = me.aspectRatio;\n\n    if (!retinaScale(me, newRatio, true)) {\n      return;\n    }\n\n    me.notifyPlugins('resize', {\n      size: newSize\n    });\n    callback(options.onResize, [me, newSize], me);\n\n    if (me.attached) {\n      if (me._doResize()) {\n        me.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  buildOrUpdateScales() {\n    const me = this;\n    const options = me.options;\n    const scaleOpts = options.scales;\n    const scales = me.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(Object.keys(scaleOpts).map(id => {\n        const scaleOptions = scaleOpts[id];\n        const axis = determineAxis(id, scaleOptions);\n        const isRadial = axis === 'r';\n        const isHorizontal = axis === 'x';\n        return {\n          options: scaleOptions,\n          dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n          dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n        };\n      }));\n    }\n\n    each(items, item => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = chart_esm_registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: me.ctx,\n          chart: me\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, scale => {\n      layouts.configure(me, scale, scale.options);\n      layouts.addBox(me, scale);\n    });\n  }\n\n  _updateMetasets() {\n    const me = this;\n    const metasets = me._metasets;\n    const numData = me.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        me._destroyDatasetMeta(i);\n      }\n\n      metasets.splice(numData, numMeta - numData);\n    }\n\n    me._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  _removeUnreferencedMetasets() {\n    const me = this;\n    const {\n      _metasets: metasets,\n      data: {\n        datasets\n      }\n    } = me;\n\n    if (metasets.length > datasets.length) {\n      delete me._stacks;\n    }\n\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        me._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const me = this;\n    const newControllers = [];\n    const datasets = me.data.datasets;\n    let i, ilen;\n\n    me._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = me.getDatasetMeta(i);\n      const type = dataset.type || me.config.type;\n\n      if (meta.type && meta.type !== type) {\n        me._destroyDatasetMeta(i);\n\n        meta = me.getDatasetMeta(i);\n      }\n\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = me.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = chart_esm_registry.getController(type);\n        const {\n          datasetElementType,\n          dataElementType\n        } = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: chart_esm_registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && chart_esm_registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(me, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    me._updateMetasets();\n\n    return newControllers;\n  }\n\n  _resetElements() {\n    const me = this;\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      me.getDatasetMeta(datasetIndex).controller.reset();\n    }, me);\n  }\n\n  reset() {\n    this._resetElements();\n\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const me = this;\n    const config = me.config;\n    config.update();\n    me._options = config.createResolver(config.chartOptionScopes(), me.getContext());\n    each(me.scales, scale => {\n      layouts.removeBox(me, scale);\n    });\n    const animsDisabled = me._animationsDisabled = !me.options.animation;\n    me.ensureScalesHaveIDs();\n    me.buildOrUpdateScales();\n    const existingEvents = new Set(Object.keys(me._listeners));\n    const newEvents = new Set(me.options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== me.options.responsive) {\n      me.unbindEvents();\n      me.bindEvents();\n    }\n\n    me._plugins.invalidate();\n\n    if (me.notifyPlugins('beforeUpdate', {\n      mode,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    const newControllers = me.buildOrUpdateControllers();\n    me.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n\n    for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\n      const {\n        controller\n      } = me.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n\n    me._minPadding = minPadding;\n\n    me._updateLayout(minPadding);\n\n    if (!animsDisabled) {\n      each(newControllers, controller => {\n        controller.reset();\n      });\n    }\n\n    me._updateDatasets(mode);\n\n    me.notifyPlugins('afterUpdate', {\n      mode\n    });\n\n    me._layers.sort(compare2Level('z', '_idx'));\n\n    if (me._lastEvent) {\n      me._eventHandler(me._lastEvent, true);\n    }\n\n    me.render();\n  }\n\n  _updateLayout(minPadding) {\n    const me = this;\n\n    if (me.notifyPlugins('beforeLayout', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    layouts.update(me, me.width, me.height, minPadding);\n    const area = me.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    me._layers = [];\n    each(me.boxes, box => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n\n      if (box.configure) {\n        box.configure();\n      }\n\n      me._layers.push(...box._layers());\n    }, me);\n\n    me._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    me.notifyPlugins('afterLayout');\n  }\n\n  _updateDatasets(mode) {\n    const me = this;\n    const isFunction = typeof mode === 'function';\n\n    if (me.notifyPlugins('beforeDatasetsUpdate', {\n      mode,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n      me._updateDataset(i, isFunction ? mode({\n        datasetIndex: i\n      }) : mode);\n    }\n\n    me.notifyPlugins('afterDatasetsUpdate', {\n      mode\n    });\n  }\n\n  _updateDataset(index, mode) {\n    const me = this;\n    const meta = me.getDatasetMeta(index);\n    const args = {\n      meta,\n      index,\n      mode,\n      cancelable: true\n    };\n\n    if (me.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    me.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    const me = this;\n\n    if (me.notifyPlugins('beforeRender', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    if (animator.has(me)) {\n      if (me.attached && !animator.running(me)) {\n        animator.start(me);\n      }\n    } else {\n      me.draw();\n      onAnimationsComplete({\n        chart: me\n      });\n    }\n  }\n\n  draw() {\n    const me = this;\n    let i;\n\n    if (me._resizeBeforeDraw) {\n      const {\n        width,\n        height\n      } = me._resizeBeforeDraw;\n\n      me._resize(width, height);\n\n      me._resizeBeforeDraw = null;\n    }\n\n    me.clear();\n\n    if (me.width <= 0 || me.height <= 0) {\n      return;\n    }\n\n    if (me.notifyPlugins('beforeDraw', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    const layers = me._layers;\n\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(me.chartArea);\n    }\n\n    me._drawDatasets();\n\n    for (; i < layers.length; ++i) {\n      layers[i].draw(me.chartArea);\n    }\n\n    me.notifyPlugins('afterDraw');\n  }\n\n  _getSortedDatasetMetas(filterVisible) {\n    const me = this;\n    const metasets = me._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  _drawDatasets() {\n    const me = this;\n\n    if (me.notifyPlugins('beforeDatasetsDraw', {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n\n    const metasets = me.getSortedVisibleDatasetMetas();\n\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      me._drawDataset(metasets[i]);\n    }\n\n    me.notifyPlugins('afterDatasetsDraw');\n  }\n\n  _drawDataset(meta) {\n    const me = this;\n    const ctx = me.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = me.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (me.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? me.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    me.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const me = this;\n    const dataset = me.data.datasets[datasetIndex];\n    const metasets = me._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = {\n      chart: this,\n      type: 'chart'\n    });\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const me = this;\n    const mode = visible ? 'show' : 'hide';\n    const meta = me.getDatasetMeta(datasetIndex);\n\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      me.update();\n    } else {\n      me.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {\n        visible\n      });\n      me.update(ctx => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  _destroyDatasetMeta(datasetIndex) {\n    const me = this;\n    const meta = me._metasets && me._metasets[datasetIndex];\n\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n\n      delete me._metasets[datasetIndex];\n    }\n  }\n\n  destroy() {\n    const me = this;\n    const {\n      canvas,\n      ctx\n    } = me;\n    let i, ilen;\n    me.stop();\n    animator.remove(me);\n\n    for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n      me._destroyDatasetMeta(i);\n    }\n\n    me.config.clearCache();\n\n    if (canvas) {\n      me.unbindEvents();\n      clearCanvas(canvas, ctx);\n      me.platform.releaseContext(ctx);\n      me.canvas = null;\n      me.ctx = null;\n    }\n\n    me.notifyPlugins('destroy');\n    delete instances[me.id];\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  bindEvents() {\n    this.bindUserEvents();\n\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  bindUserEvents() {\n    const me = this;\n    const listeners = me._listeners;\n    const platform = me.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(me, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = function (e, x, y) {\n      e.offsetX = x;\n      e.offsetY = y;\n\n      me._eventHandler(e);\n    };\n\n    each(me.options.events, type => _add(type, listener));\n  }\n\n  bindResponsiveEvents() {\n    const me = this;\n\n    if (!me._responsiveListeners) {\n      me._responsiveListeners = {};\n    }\n\n    const listeners = me._responsiveListeners;\n    const platform = me.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(me, type, listener);\n      listeners[type] = listener;\n    };\n\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(me, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (me.canvas) {\n        me.resize(width, height);\n      }\n    };\n\n    let detached;\n\n    const attached = () => {\n      _remove('attach', attached);\n\n      me.attached = true;\n      me.resize();\n\n      _add('resize', listener);\n\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      me.attached = false;\n\n      _remove('resize', listener);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(me.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  unbindEvents() {\n    const me = this;\n    each(me._listeners, (listener, type) => {\n      me.platform.removeEventListener(me, type, listener);\n    });\n    me._listeners = {};\n    each(me._responsiveListeners, (listener, type) => {\n      me.platform.removeEventListener(me, type, listener);\n    });\n    me._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  setActiveElements(activeElements) {\n    const me = this;\n    const lastActive = me._active || [];\n    const active = activeElements.map(({\n      datasetIndex,\n      index\n    }) => {\n      const meta = me.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      me._active = active;\n\n      me._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  _updateHoverStyles(active, lastActive, replay) {\n    const me = this;\n    const hoverOptions = me.options.hover;\n\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      me.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      me.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  _eventHandler(e, replay) {\n    const me = this;\n    const args = {\n      event: e,\n      replay,\n      cancelable: true\n    };\n\n    const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.type);\n\n    if (me.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = me._handleEvent(e, replay);\n\n    args.cancelable = false;\n    me.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      me.render();\n    }\n\n    return me;\n  }\n\n  _handleEvent(e, replay) {\n    const me = this;\n    const {\n      _active: lastActive = [],\n      options\n    } = me;\n    const hoverOptions = options.hover;\n    const useFinalPosition = replay;\n    let active = [];\n    let changed = false;\n    let lastEvent = null;\n\n    if (e.type !== 'mouseout') {\n      active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n      lastEvent = e.type === 'click' ? me._lastEvent : e;\n    }\n\n    me._lastEvent = null;\n\n    if (_isPointInArea(e, me.chartArea, me._minPadding)) {\n      callback(options.onHover, [e, active, me], me);\n\n      if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {\n        callback(options.onClick, [e, active, me], me);\n      }\n    }\n\n    changed = !_elementsEqual(active, lastActive);\n\n    if (changed || replay) {\n      me._active = active;\n\n      me._updateHoverStyles(active, lastActive, replay);\n    }\n\n    me._lastEvent = lastEvent;\n    return changed;\n  }\n\n}\n\nconst invalidatePlugins = () => each(chart_esm_Chart.instances, chart => chart._plugins.invalidate());\n\nconst enumerable = true;\nObject.defineProperties(chart_esm_Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: chart_esm_registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      chart_esm_registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      chart_esm_registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {\n    startAngle,\n    pixelMargin,\n    x,\n    y,\n    outerRadius,\n    innerRadius\n  } = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  const computeOuterLimit = val => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n  };\n}\n\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta)\n  };\n}\n\nfunction pathArc(ctx, element, offset, spacing, end) {\n  const {\n    x,\n    y,\n    startAngle: start,\n    pixelMargin,\n    innerRadius: innerR\n  } = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {\n    outerStart,\n    outerEnd,\n    innerStart,\n    innerEnd\n  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n\n  if (outerEnd > 0) {\n    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n  }\n\n  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n  ctx.lineTo(p4.x, p4.y);\n\n  if (innerEnd > 0) {\n    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n  }\n\n  ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);\n\n  if (innerStart > 0) {\n    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n  }\n\n  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n  ctx.lineTo(p8.x, p8.y);\n\n  if (outerStart > 0) {\n    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(ctx, element, offset, spacing) {\n  const {\n    fullCircles,\n    startAngle,\n    circumference\n  } = element;\n  let endAngle = element.endAngle;\n\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU);\n\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {\n    x,\n    y,\n    startAngle,\n    pixelMargin,\n    fullCircles\n  } = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\n\nfunction drawBorder(ctx, element, offset, spacing, endAngle) {\n  const {\n    options\n  } = element;\n  const inner = options.borderAlign === 'inner';\n\n  if (!options.borderWidth) {\n    return;\n  }\n\n  if (inner) {\n    ctx.lineWidth = options.borderWidth * 2;\n    ctx.lineJoin = 'round';\n  } else {\n    ctx.lineWidth = options.borderWidth;\n    ctx.lineJoin = 'bevel';\n  }\n\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.stroke();\n}\n\nclass chart_esm_ArcElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {\n      angle,\n      distance\n    } = getAngleFromPoint(point, {\n      x: chartX,\n      y: chartY\n    });\n    const {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius,\n      circumference\n    } = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n\n    const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n\n    const withinRadius = distance >= innerRadius + rAdjust && distance <= outerRadius + rAdjust;\n    return betweenAngles && withinRadius;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius\n    } = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);\n    const {\n      offset,\n      spacing\n    } = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx) {\n    const me = this;\n    const {\n      options,\n      circumference\n    } = me;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    me.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n    me.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n    let radiusOffset = 0;\n\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (me.startAngle + me.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n\n      if (me.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, me, radiusOffset, spacing);\n    drawBorder(ctx, me, radiusOffset, spacing, endAngle);\n    ctx.restore();\n  }\n\n}\n\nchart_esm_ArcElement.id = 'arc';\nchart_esm_ArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined\n};\nchart_esm_ArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {\n    start: paramsStart = 0,\n    end: paramsEnd = count - 1\n  } = params;\n  const {\n    start: segmentStart,\n    end: segmentEnd\n  } = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\nfunction pathSegment(ctx, line, segment, params) {\n  const {\n    points,\n    options\n  } = line;\n  const {\n    count,\n    start,\n    loop,\n    ilen\n  } = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {\n    move = true,\n    reverse\n  } = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {\n    count,\n    start,\n    ilen\n  } = pathVars(points, segment, params);\n  const {\n    move = true,\n    reverse\n  } = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;\n\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n\n    lastY = y;\n  }\n\n  drawX();\n}\n\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n\n  if (!path) {\n    path = line._path = new Path2D();\n\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {\n    segments,\n    options\n  } = line;\n\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n\n    if (segmentMethod(ctx, line, segment, {\n      start,\n      end: start + count - 1\n    })) {\n      ctx.closePath();\n    }\n\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && line.segments.length === 1) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nclass chart_esm_LineElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const me = this;\n    const options = me.options;\n\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !me._pointsUpdated) {\n      const loop = options.spanGaps ? me._loop : me._fullLoop;\n\n      _updateBezierControlPoints(me._points, options, chartArea, loop, indexAxis);\n\n      me._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    const me = this;\n    me._points = points;\n    delete me._segments;\n    delete me._path;\n    me._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  interpolate(point, property) {\n    const me = this;\n    const options = me.options;\n    const value = point[property];\n    const points = me.points;\n\n    const segments = _boundSegments(me, {\n      property,\n      start: value,\n      end: value\n    });\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n\n    const _interpolate = _getInterpolationMethod(options);\n\n    let i, ilen;\n\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {\n        start,\n        end\n      } = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  path(ctx, start, count) {\n    const me = this;\n    const segments = me.segments;\n\n    const segmentMethod = _getSegmentMethod(me);\n\n    let loop = me._loop;\n    start = start || 0;\n    count = count || me.points.length - start;\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, me, segment, {\n        start,\n        end: start + count - 1\n      });\n    }\n\n    return !!loop;\n  }\n\n  draw(ctx, chartArea, start, count) {\n    const me = this;\n    const options = me.options || {};\n    const points = me.points || [];\n\n    if (!points.length || !options.borderWidth) {\n      return;\n    }\n\n    ctx.save();\n    draw(ctx, me, start, count);\n    ctx.restore();\n\n    if (me.animated) {\n      me._pointsUpdated = false;\n      me._path = undefined;\n    }\n  }\n\n}\n\nchart_esm_LineElement.id = 'line';\nchart_esm_LineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0\n};\nchart_esm_LineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nchart_esm_LineElement.descriptors = {\n  _scriptable: true,\n  _indexable: name => name !== 'borderDash' && name !== 'fill'\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {\n    [axis]: value\n  } = el.getProps([axis], useFinalPosition);\n  return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\n\nclass chart_esm_PointElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx, area) {\n    const me = this;\n    const options = me.options;\n\n    if (me.skip || options.radius < 0.1 || !_isPointInArea(me, area, me.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, me.x, me.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n\n}\n\nchart_esm_PointElement.id = 'point';\nchart_esm_PointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nchart_esm_PointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {\n    x,\n    y,\n    base,\n    width,\n    height\n  } = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {\n    enableBorderRadius\n  } = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nclass chart_esm_BarElement extends chart_esm_Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const {\n      inner,\n      outer\n    } = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    const inflateAmount = 0.33;\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = options.borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount, outer));\n    ctx.fillStyle = options.backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      base,\n      horizontal\n    } = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n\n}\n\nchart_esm_BarElement.id = 'bar';\nchart_esm_BarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  enableBorderRadius: true,\n  pointStyle: undefined\n};\nchart_esm_BarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nvar chart_esm_elements = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArcElement: chart_esm_ArcElement,\n  LineElement: chart_esm_LineElement,\n  PointElement: chart_esm_PointElement,\n  BarElement: chart_esm_BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {\n      x: pointAx,\n      y: pointAy\n    } = data[a];\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({ ...data[intermediateIndex1],\n            x: avgX\n          });\n        }\n\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({ ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      value: data\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach(dataset => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {\n    iScale\n  } = meta;\n  const {\n    min,\n    max,\n    minDefined,\n    maxDefined\n  } = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {\n    start,\n    count\n  };\n}\n\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {\n        _data,\n        indexAxis\n      } = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n\n      if (meta.type !== 'line') {\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n\n      if (chart.options.parsing) {\n        return;\n      }\n\n      let {\n        start,\n        count\n      } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function () {\n            return this._decimated;\n          },\n          set: function (d) {\n            this._data = d;\n          }\n        });\n      }\n\n      let decimated;\n\n      switch (options.algorithm) {\n        case 'lttb':\n          decimated = lttbDecimation(data, start, count, availableWidth, options);\n          break;\n\n        case 'min-max':\n          decimated = minMaxDecimation(data, start, count, availableWidth);\n          break;\n\n        default:\n          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n\n};\n\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n\n  return fill;\n}\n\nfunction decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    if (fill[0] === '-' || fill[0] === '+') {\n      target = index + target;\n    }\n\n    if (target === index || target < 0 || target >= count) {\n      return false;\n    }\n\n    return target;\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction computeLinearBoundary(source) {\n  const {\n    scale = {},\n    fill\n  } = source;\n  let target = null;\n  let horizontal;\n\n  if (fill === 'start') {\n    target = scale.bottom;\n  } else if (fill === 'end') {\n    target = scale.top;\n  } else if (isObject(fill)) {\n    target = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    target = scale.getBasePixel();\n  }\n\n  if (isNumberFinite(target)) {\n    horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? target : null,\n      y: horizontal ? null : target\n    };\n  }\n\n  return null;\n}\n\nclass chart_esm_simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {\n      x,\n      y,\n      radius\n    } = this;\n    bounds = bounds || {\n      start: 0,\n      end: TAU\n    };\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {\n      x,\n      y,\n      radius\n    } = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n\n}\n\nfunction computeCircularBoundary(source) {\n  const {\n    scale,\n    fill\n  } = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const target = [];\n  const start = options.reverse ? scale.max : scale.min;\n  const end = options.reverse ? scale.min : scale.max;\n  let i, center, value;\n\n  if (fill === 'start') {\n    value = start;\n  } else if (fill === 'end') {\n    value = end;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n\n  if (options.grid.circular) {\n    center = scale.getPointPositionForValue(0, start);\n    return new chart_esm_simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n\n  return target;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n\n  return computeLinearBoundary(source);\n}\n\nfunction findSegmentEnd(start, end, points) {\n  for (; end > start; end--) {\n    const point = points[end];\n\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n\n  return end;\n}\n\nfunction pointsFromSegments(boundary, line) {\n  const {\n    x = null,\n    y = null\n  } = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({\n    start,\n    end\n  }) => {\n    end = findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n\n    if (y !== null) {\n      points.push({\n        x: first.x,\n        y\n      });\n      points.push({\n        x: last.x,\n        y\n      });\n    } else if (x !== null) {\n      points.push({\n        x,\n        y: first.y\n      });\n      points.push({\n        x,\n        y: last.y\n      });\n    }\n  });\n  return points;\n}\n\nfunction buildStackLine(source) {\n  const {\n    chart,\n    scale,\n    index,\n    line\n  } = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(chart, index);\n  linesBelow.push(createBoundaryLine({\n    x: null,\n    y: scale.bottom\n  }, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n\n  return new chart_esm_LineElement({\n    points,\n    options: {}\n  });\n}\n\nconst isLineAndNotInHideAnimation = meta => meta.type === 'line' && !meta.hidden;\n\nfunction getLinesBelow(chart, index) {\n  const below = [];\n  const metas = chart.getSortedVisibleDatasetMetas();\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n\n    if (meta.index === index) {\n      break;\n    }\n\n    if (isLineAndNotInHideAnimation(meta)) {\n      below.unshift(meta.dataset);\n    }\n  }\n\n  return below;\n}\n\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {\n      first,\n      last,\n      point\n    } = findPoint(line, sourcePoint, 'x');\n\n    if (!point || first && last) {\n      continue;\n    }\n\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n\n      if (!last) {\n        break;\n      }\n    }\n  }\n\n  points.push(...postponed);\n}\n\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n\n    if (pointValue >= firstValue && pointValue <= lastValue) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n\n  return {\n    first,\n    last,\n    point\n  };\n}\n\nfunction getTarget(source) {\n  const {\n    chart,\n    fill,\n    line\n  } = source;\n\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof chart_esm_simpleArc) {\n    return boundary;\n  }\n\n  return createBoundaryLine(boundary, line);\n}\n\nfunction createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new chart_esm_LineElement({\n    points,\n    options: {\n      tension: 0\n    },\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\nfunction _clip(ctx, target, clipY) {\n  ctx.beginPath();\n  target.path(ctx);\n  ctx.lineTo(target.last().x, clipY);\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n\n  return {\n    property,\n    start,\n    end\n  };\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {\n      start,\n      end\n    } = segment;\n    end = findSegmentEnd(start, end, points);\n    const bounds = getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n\n  return parts;\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {\n    top,\n    bottom\n  } = scale.chart.chartArea;\n  const {\n    property,\n    start,\n    end\n  } = bounds || {};\n\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nfunction _fill(ctx, cfg) {\n  const {\n    line,\n    target,\n    property,\n    color,\n    scale\n  } = cfg;\n\n  const segments = _segments(line, target, property);\n\n  for (const {\n    source: src,\n    target: tgt,\n    start,\n    end\n  } of segments) {\n    const {\n      style: {\n        backgroundColor = color\n      } = {}\n    } = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {\n        move: lineLoop,\n        reverse: true\n      });\n      loop = lineLoop && targetLoop;\n\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {\n    line,\n    target,\n    above,\n    below,\n    area,\n    scale\n  } = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    _clip(ctx, target, area.top);\n\n    _fill(ctx, {\n      line,\n      target,\n      color: above,\n      scale,\n      property\n    });\n\n    ctx.restore();\n    ctx.save();\n\n    _clip(ctx, target, area.bottom);\n  }\n\n  _fill(ctx, {\n    line,\n    target,\n    color: below,\n    scale,\n    property\n  });\n\n  ctx.restore();\n}\n\nfunction drawfill(ctx, source, area) {\n  const target = getTarget(source);\n  const {\n    line,\n    scale,\n    axis\n  } = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {\n    above = color,\n    below = color\n  } = fillOption || {};\n\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {\n      line,\n      target,\n      above,\n      below,\n      area,\n      scale,\n      axis\n    });\n    unclipArea(ctx);\n  }\n}\n\nvar plugin_filler = {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof chart_esm_LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n\n      if (draw) {\n        drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (source) {\n        drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {\n    boxHeight = fontSize,\n    boxWidth = fontSize\n  } = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nclass chart_esm_Legend extends chart_esm_Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    me.maxWidth = maxWidth;\n    me.maxHeight = maxHeight;\n    me._margins = margins;\n    me.setDimensions();\n    me.buildLabels();\n    me.fit();\n  }\n\n  setDimensions() {\n    const me = this;\n\n    if (me.isHorizontal()) {\n      me.width = me.maxWidth;\n      me.left = me._margins.left;\n      me.right = me.width;\n    } else {\n      me.height = me.maxHeight;\n      me.top = me._margins.top;\n      me.bottom = me.height;\n    }\n  }\n\n  buildLabels() {\n    const me = this;\n    const labelOpts = me.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter(item => labelOpts.filter(item, me.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));\n    }\n\n    if (me.options.reverse) {\n      legendItems.reverse();\n    }\n\n    me.legendItems = legendItems;\n  }\n\n  fit() {\n    const me = this;\n    const {\n      options,\n      ctx\n    } = me;\n\n    if (!options.display) {\n      me.width = me.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n\n    const titleHeight = me._computeTitleHeight();\n\n    const {\n      boxWidth,\n      itemHeight\n    } = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n\n    if (me.isHorizontal()) {\n      width = me.maxWidth;\n      height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = me.maxHeight;\n      width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n\n    me.width = Math.min(width, options.maxWidth || me.maxWidth);\n    me.height = Math.min(height, options.maxHeight || me.maxHeight);\n  }\n\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const me = this;\n    const {\n      ctx,\n      maxWidth,\n      options: {\n        labels: {\n          padding\n        }\n      }\n    } = me;\n    const hitboxes = me.legendHitBoxes = [];\n    const lineWidths = me.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    me.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {\n        left: 0,\n        top,\n        row,\n        width: itemWidth,\n        height: itemHeight\n      };\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const me = this;\n    const {\n      ctx,\n      maxHeight,\n      options: {\n        labels: {\n          padding\n        }\n      }\n    } = me;\n    const hitboxes = me.legendHitBoxes = [];\n    const columnSizes = me.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    me.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({\n          width: currentColWidth,\n          height: currentColHeight\n        });\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      hitboxes[i] = {\n        left,\n        top: currentColHeight,\n        col,\n        width: itemWidth,\n        height: itemHeight\n      };\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({\n      width: currentColWidth,\n      height: currentColHeight\n    });\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    const me = this;\n\n    if (!me.options.display) {\n      return;\n    }\n\n    const titleHeight = me._computeTitleHeight();\n\n    const {\n      legendHitBoxes: hitboxes,\n      options: {\n        align,\n        labels: {\n          padding\n        },\n        rtl\n      }\n    } = me;\n    const rtlHelper = getRtlAdapter(rtl, me.left, me.width);\n\n    if (this.isHorizontal()) {\n      let row = 0;\n\n      let left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\n\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\n        }\n\n        hitbox.top += me.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n\n      let top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\n\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\n        }\n\n        hitbox.top = top;\n        hitbox.left += me.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    const me = this;\n\n    if (me.options.display) {\n      const ctx = me.ctx;\n      clipArea(ctx, me);\n\n      me._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  _draw() {\n    const me = this;\n    const {\n      options: opts,\n      columnSizes,\n      lineWidths,\n      ctx\n    } = me;\n    const {\n      align,\n      labels: labelOpts\n    } = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\n    const labelFont = toFont(labelOpts.font);\n    const {\n      color: fontColor,\n      padding\n    } = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    me.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {\n      boxWidth,\n      boxHeight,\n      itemHeight\n    } = getBoxSize(labelOpts, fontSize);\n\n    const drawLegendBox = function (x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxWidth * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPoint(ctx, drawOptions, centerX, centerY);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function (x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    const isHorizontal = me.isHorizontal();\n\n    const titleHeight = this._computeTitleHeight();\n\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, me.left + padding, me.right - lineWidths[0]),\n        y: me.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: me.left + padding,\n        y: _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(me.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    me.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(me.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > me.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, me.left + padding, me.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > me.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : me.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(me.ctx, opts.textDirection);\n  }\n\n  drawTitle() {\n    const me = this;\n    const opts = me.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\n    const ctx = me.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = me.left;\n    let maxWidth = me.width;\n\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...me.lineWidths);\n      y = me.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, me.right - maxWidth);\n    } else {\n      const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());\n    }\n\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  _getLegendItemAt(x, y) {\n    const me = this;\n    let i, hitBox, lh;\n\n    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n      lh = me.legendHitBoxes;\n\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n          return me.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  handleEvent(e) {\n    const me = this;\n    const opts = me.options;\n\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    const hoveredItem = me._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove') {\n      const previous = me._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, me], me);\n      }\n\n      me._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, me], me);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, me], me);\n    }\n  }\n\n}\n\nfunction isListened(type, opts) {\n  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n\n  return false;\n}\n\nvar plugin_legend = {\n  id: 'legend',\n  _element: chart_esm_Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new chart_esm_Legend({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: ctx => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {\n          labels: {\n            usePointStyle,\n            pointStyle,\n            textAlign,\n            color\n          }\n        } = chart.legend.options;\n        return chart._getSortedDatasetMetas().map(meta => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n\n    },\n    title: {\n      color: ctx => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: ''\n    }\n  },\n  descriptors: {\n    _scriptable: name => !name.startsWith('on'),\n    labels: {\n      _scriptable: name => !['generateLabels', 'filter', 'sort'].includes(name)\n    }\n  }\n};\n\nclass chart_esm_Title extends chart_esm_Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const me = this;\n    const opts = me.options;\n    me.left = 0;\n    me.top = 0;\n\n    if (!opts.display) {\n      me.width = me.height = me.right = me.bottom = 0;\n      return;\n    }\n\n    me.width = me.right = maxWidth;\n    me.height = me.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    me._padding = toPadding(opts.padding);\n\n    const textSize = lineCount * toFont(opts.font).lineHeight + me._padding.height;\n\n    if (me.isHorizontal()) {\n      me.height = textSize;\n    } else {\n      me.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {\n      top,\n      left,\n      bottom,\n      right,\n      options\n    } = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n\n      maxWidth = bottom - top;\n    }\n\n    return {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    };\n  }\n\n  draw() {\n    const me = this;\n    const ctx = me.ctx;\n    const opts = me.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + me._padding.top;\n\n    const {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    } = me._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY]\n    });\n  }\n\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new chart_esm_Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nvar plugin_title = {\n  id: 'title',\n  _element: chart_esm_Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold'\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nconst chart_esm_map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new chart_esm_Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    chart_esm_map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart_esm_map.get(chart));\n    chart_esm_map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart_esm_map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal'\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n\n};\n\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n\n  return str;\n}\n\nfunction createTooltipItem(chart, item) {\n  const {\n    element,\n    datasetIndex,\n    index\n  } = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {\n    label,\n    value\n  } = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip._chart.ctx;\n  const {\n    body,\n    footer,\n    title\n  } = tooltip;\n  const {\n    boxWidth,\n    boxHeight\n  } = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n  }\n\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n  }\n\n  if (footerLineCount) {\n    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  let widthPadding = 0;\n\n  const maxLineWidth = function (line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? boxWidth + 2 : 0;\n  each(body, bodyItem => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {\n    width,\n    height\n  };\n}\n\nfunction determineYAlign(chart, size) {\n  const {\n    y,\n    height\n  } = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > chart.height - height / 2) {\n    return 'bottom';\n  }\n\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {\n    x,\n    width\n  } = size;\n  const caret = options.caretSize + options.caretPadding;\n\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {\n    x,\n    width\n  } = size;\n  const {\n    width: chartWidth,\n    chartArea: {\n      left,\n      right\n    }\n  } = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\nfunction determineAlignment(chart, options, size) {\n  const yAlign = options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {\n    x,\n    width\n  } = size;\n\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {\n    y,\n    height\n  } = size;\n\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= height / 2;\n  }\n\n  return y;\n}\n\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {\n    caretSize,\n    caretPadding,\n    cornerRadius\n  } = options;\n  const {\n    xAlign,\n    yAlign\n  } = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const radiusAndPadding = cornerRadius + caretPadding;\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= radiusAndPadding;\n  } else if (xAlign === 'right') {\n    x += radiusAndPadding;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return Object.assign(Object.create(parent), {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nclass chart_esm_Tooltip extends chart_esm_Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._chart = config._chart;\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  _resolveAnimations() {\n    const me = this;\n    const cached = me._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = me._chart;\n    const options = me.options.setContext(me.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new chart_esm_Animations(me._chart, opts);\n\n    if (opts._cacheable) {\n      me._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  getContext() {\n    const me = this;\n    return me.$context || (me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const me = this;\n    const {\n      callbacks\n    } = options;\n    const beforeTitle = callbacks.beforeTitle.apply(me, [context]);\n    const title = callbacks.title.apply(me, [context]);\n    const afterTitle = callbacks.afterTitle.apply(me, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n\n  getBody(tooltipItems, options) {\n    const me = this;\n    const {\n      callbacks\n    } = options;\n    const bodyItems = [];\n    each(tooltipItems, context => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(me, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n\n  getFooter(tooltipItems, options) {\n    const me = this;\n    const {\n      callbacks\n    } = options;\n    const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);\n    const footer = callbacks.footer.apply(me, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n\n  _createItems(options) {\n    const me = this;\n    const active = me._active;\n    const data = me._chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(me._chart, active[i]));\n    }\n\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    each(tooltipItems, context => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(me, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(me, context));\n      labelTextColors.push(scoped.labelTextColor.call(me, context));\n    });\n    me.labelColors = labelColors;\n    me.labelPointStyles = labelPointStyles;\n    me.labelTextColors = labelTextColors;\n    me.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const me = this;\n    const options = me.options.setContext(me.getContext());\n    const active = me._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (me.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(me, active, me._eventPosition);\n      tooltipItems = me._createItems(options);\n      me.title = me.getTitle(tooltipItems, options);\n      me.beforeBody = me.getBeforeBody(tooltipItems, options);\n      me.body = me.getBody(tooltipItems, options);\n      me.afterBody = me.getAfterBody(tooltipItems, options);\n      me.footer = me.getFooter(tooltipItems, options);\n      const size = me._size = getTooltipSize(me, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(me._chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, me._chart);\n      me.xAlign = alignment.xAlign;\n      me.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    me._tooltipItems = tooltipItems;\n    me.$context = undefined;\n\n    if (properties) {\n      me._resolveAnimations().update(me, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(me, {\n        chart: me._chart,\n        tooltip: me,\n        replay\n      });\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {\n      xAlign,\n      yAlign\n    } = this;\n    const {\n      cornerRadius,\n      caretSize\n    } = options;\n    const {\n      x: ptX,\n      y: ptY\n    } = tooltipPoint;\n    const {\n      width,\n      height\n    } = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + height / 2;\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + cornerRadius + caretSize;\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - cornerRadius - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n\n      y3 = y1;\n    }\n\n    return {\n      x1,\n      x2,\n      x3,\n      y1,\n      y2,\n      y3\n    };\n  }\n\n  drawTitle(pt, ctx, options) {\n    const me = this;\n    const title = me.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\n      pt.x = getAlignedX(me, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const me = this;\n    const labelColors = me.labelColors[i];\n    const labelPointStyle = me.labelPointStyles[i];\n    const {\n      boxHeight,\n      boxWidth\n    } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(me, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = labelColors.borderWidth || 1;\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    ctx.fillStyle = me.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const me = this;\n    const {\n      body\n    } = me;\n    const {\n      bodySpacing,\n      bodyAlign,\n      displayColors,\n      boxHeight,\n      boxWidth\n    } = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\n\n    const fillLineOfText = function (line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(me, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(me.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + 1 : boxWidth + 2 : 0;\n\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = me.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n\n      if (displayColors && lines.length) {\n        me._drawColorBox(ctx, pt, i, rtlHelper, options);\n\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(me.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n\n  drawFooter(pt, ctx, options) {\n    const me = this;\n    const footer = me.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\n      pt.x = getAlignedX(me, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {\n      xAlign,\n      yAlign\n    } = this;\n    const {\n      x,\n      y\n    } = pt;\n    const {\n      width,\n      height\n    } = tooltipSize;\n    const radius = options.cornerRadius;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  _updateAnimationTarget(options) {\n    const me = this;\n    const chart = me._chart;\n    const anims = me.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n\n    if (animX || animY) {\n      const position = positioners[options.position].call(me, me._active, me._eventPosition);\n\n      if (!position) {\n        return;\n      }\n\n      const size = me._size = getTooltipSize(me, options);\n      const positionAndSize = Object.assign({}, position, me._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n\n      if (animX._to !== point.x || animY._to !== point.y) {\n        me.xAlign = alignment.xAlign;\n        me.yAlign = alignment.yAlign;\n        me.width = size.width;\n        me.height = size.height;\n        me.caretX = position.x;\n        me.caretY = position.y;\n\n        me._resolveAnimations().update(me, point);\n      }\n    }\n  }\n\n  draw(ctx) {\n    const me = this;\n    const options = me.options.setContext(me.getContext());\n    let opacity = me.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    me._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: me.width,\n      height: me.height\n    };\n    const pt = {\n      x: me.x,\n      y: me.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      me.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      me.drawTitle(pt, ctx, options);\n      me.drawBody(pt, ctx, options);\n      me.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  setActiveElements(activeElements, eventPosition) {\n    const me = this;\n    const lastActive = me._active;\n    const active = activeElements.map(({\n      datasetIndex,\n      index\n    }) => {\n      const meta = me._chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n\n    const positionChanged = me._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      me._active = active;\n      me._eventPosition = eventPosition;\n      me.update(true);\n    }\n  }\n\n  handleEvent(e, replay) {\n    const me = this;\n    const options = me.options;\n    const lastActive = me._active || [];\n    let changed = false;\n    let active = [];\n\n    if (e.type !== 'mouseout') {\n      active = me._chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n      if (options.reverse) {\n        active.reverse();\n      }\n    }\n\n    const positionChanged = me._positionChanged(active, e);\n\n    changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    if (changed) {\n      me._active = active;\n\n      if (options.enabled || options.external) {\n        me._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        me.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  _positionChanged(active, e) {\n    const {\n      caretX,\n      caretY,\n      options\n    } = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n\n}\n\nchart_esm_Tooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: chart_esm_Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new chart_esm_Tooltip({\n        _chart: chart,\n        options\n      });\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    const args = {\n      tooltip\n    };\n\n    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n      return;\n    }\n\n    if (tooltip) {\n      tooltip.draw(chart.ctx);\n    }\n\n    chart.notifyPlugins('afterTooltipDraw', args);\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold'\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold'\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart'\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY']\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n\n        return '';\n      },\n\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n\n        let label = tooltipItem.dataset.label || '';\n\n        if (label) {\n          label += ': ';\n        }\n\n        const value = tooltipItem.formattedValue;\n\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n\n        return label;\n      },\n\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0\n        };\n      },\n\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation\n        };\n      },\n\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: name => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\nvar chart_esm_plugins = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Decimation: plugin_decimation,\n  Filler: plugin_filler,\n  Legend: plugin_legend,\n  SubTitle: plugin_subtitle,\n  Title: plugin_title,\n  Tooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index) => typeof raw === 'string' ? labels.push(raw) - 1 : isNaN(raw) ? null : index;\n\nfunction findOrAddLabel(labels, raw, index) {\n  const first = labels.indexOf(raw);\n\n  if (first === -1) {\n    return addIfString(labels, raw, index);\n  }\n\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nclass chart_esm_CategoryScale extends chart_esm_Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw));\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const {\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let {\n      min,\n      max\n    } = me.getMinMax(true);\n\n    if (me.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n\n      if (!maxDefined) {\n        max = me.getLabels().length - 1;\n      }\n    }\n\n    me.min = min;\n    me.max = max;\n  }\n\n  buildTicks() {\n    const me = this;\n    const min = me.min;\n    const max = me.max;\n    const offset = me.options.offset;\n    const ticks = [];\n    let labels = me.getLabels();\n    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n    me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    me._startValue = me.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({\n        value\n      });\n    }\n\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    const me = this;\n    const labels = me.getLabels();\n\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n\n    return value;\n  }\n\n  configure() {\n    const me = this;\n    super.configure();\n\n    if (!me.isHorizontal()) {\n      me._reversePixels = !me._reversePixels;\n    }\n  }\n\n  getPixelForValue(value) {\n    const me = this;\n\n    if (typeof value !== 'number') {\n      value = me.parse(value);\n    }\n\n    return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);\n  }\n\n  getPixelForTick(index) {\n    const me = this;\n    const ticks = me.ticks;\n\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n\n    return me.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n\n}\n\nchart_esm_CategoryScale.id = 'category';\nchart_esm_CategoryScale.defaults = {\n  ticks: {\n    callback: chart_esm_CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {\n    bounds,\n    step,\n    min,\n    max,\n    precision,\n    count,\n    maxTicks,\n    maxDigits,\n    includeBounds\n  } = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {\n    min: rmin,\n    max: rmax\n  } = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{\n      value: rmin\n    }, {\n      value: rmax\n    }];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({\n        value: min\n      });\n\n      if (niceMin < min) {\n        j++;\n      }\n\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    ticks.push({\n      value: Math.round((niceMin + j * spacing) * factor) / factor\n    });\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({\n        value: max\n      });\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({\n      value: niceMax\n    });\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {\n  horizontal,\n  minRotation\n}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nclass chart_esm_LinearScaleBase extends chart_esm_Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const me = this;\n    const {\n      beginAtZero\n    } = me.options;\n    const {\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let {\n      min,\n      max\n    } = me;\n\n    const setMin = v => min = minDefined ? min : v;\n\n    const setMax = v => max = maxDefined ? max : v;\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = 1;\n\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n\n    me.min = min;\n    me.max = max;\n  }\n\n  getTickLimit() {\n    const me = this;\n    const tickOpts = me.options.ticks;\n    let {\n      maxTicksLimit,\n      stepSize\n    } = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n    } else {\n      maxTicks = me.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const me = this;\n    const opts = me.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = me.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: me._maxDigits(),\n      horizontal: me.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = me._range || me;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, me, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n      me.start = me.max;\n      me.end = me.min;\n    } else {\n      me.start = me.min;\n      me.end = me.max;\n    }\n\n    return ticks;\n  }\n\n  configure() {\n    const me = this;\n    const ticks = me.ticks;\n    let start = me.min;\n    let end = me.max;\n    super.configure();\n\n    if (me.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n\n    me._startValue = start;\n    me._endValue = end;\n    me._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale);\n  }\n\n}\n\nclass chart_esm_LinearScale extends chart_esm_LinearScaleBase {\n  determineDataLimits() {\n    const me = this;\n    const {\n      min,\n      max\n    } = me.getMinMax(true);\n    me.min = isNumberFinite(min) ? min : 0;\n    me.max = isNumberFinite(max) ? max : 1;\n    me.handleTickRangeOptions();\n  }\n\n  computeTickLimit() {\n    const me = this;\n    const horizontal = me.isHorizontal();\n    const length = horizontal ? me.width : me.height;\n    const minRotation = toRadians(me.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n\n    const tickFont = me._resolveTickFontOptions(0);\n\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n\n}\n\nchart_esm_LinearScale.id = 'linear';\nchart_esm_LinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));\n  return remain === 1;\n}\n\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n  do {\n    ticks.push({\n      value: tickVal,\n      major: isMajor(tickVal)\n    });\n    ++significand;\n\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({\n    value: lastTick,\n    major: isMajor(tickVal)\n  });\n  return ticks;\n}\n\nclass chart_esm_LogarithmicScale extends chart_esm_Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = chart_esm_LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const {\n      min,\n      max\n    } = me.getMinMax(true);\n    me.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    me.max = isNumberFinite(max) ? Math.max(0, max) : null;\n\n    if (me.options.beginAtZero) {\n      me._zero = true;\n    }\n\n    me.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const me = this;\n    const {\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n    let min = me.min;\n    let max = me.max;\n\n    const setMin = v => min = minDefined ? min : v;\n\n    const setMax = v => max = maxDefined ? max : v;\n\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n\n    if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {\n      setMin(exp(min, -1));\n    }\n\n    me.min = min;\n    me.max = max;\n  }\n\n  buildTicks() {\n    const me = this;\n    const opts = me.options;\n    const generationOptions = {\n      min: me._userMin,\n      max: me._userMax\n    };\n    const ticks = generateTicks(generationOptions, me);\n\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, me, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n      me.start = me.max;\n      me.end = me.min;\n    } else {\n      me.start = me.min;\n      me.end = me.max;\n    }\n\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return value === undefined ? '0' : formatNumber(value, this.chart.options.locale);\n  }\n\n  configure() {\n    const me = this;\n    const start = me.min;\n    super.configure();\n    me._startValue = log10(start);\n    me._valueRange = log10(me.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    const me = this;\n\n    if (value === undefined || value === 0) {\n      value = me.min;\n    }\n\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n\n    return me.getPixelForDecimal(value === me.min ? 0 : (log10(value) - me._startValue) / me._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    const decimal = me.getDecimalForPixel(pixel);\n    return Math.pow(10, me._startValue + decimal * me._valueRange);\n  }\n\n}\n\nchart_esm_LogarithmicScale.id = 'logarithmic';\nchart_esm_LogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - size / 2,\n      end: pos + size / 2\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\nfunction fitWithPointLabels(scale) {\n  const furthestLimits = {\n    l: 0,\n    r: scale.width,\n    t: 0,\n    b: scale.height - scale.paddingTop\n  };\n  const furthestAngles = {};\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale.getLabels().length;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = scale.getIndexAngle(i);\n    const angle = toDegrees(angleRadians);\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n    if (hLimits.start < furthestLimits.l) {\n      furthestLimits.l = hLimits.start;\n      furthestAngles.l = angleRadians;\n    }\n\n    if (hLimits.end > furthestLimits.r) {\n      furthestLimits.r = hLimits.end;\n      furthestAngles.r = angleRadians;\n    }\n\n    if (vLimits.start < furthestLimits.t) {\n      furthestLimits.t = vLimits.start;\n      furthestAngles.t = angleRadians;\n    }\n\n    if (vLimits.end > furthestLimits.b) {\n      furthestLimits.b = vLimits.end;\n      furthestAngles.b = angleRadians;\n    }\n  }\n\n  scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale.getLabels().length;\n  const opts = scale.options;\n  const tickBackdropHeight = getTickBackdropHeight(opts);\n  const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n  for (let i = 0; i < valueCount; i++) {\n    const extra = i === 0 ? tickBackdropHeight / 2 : 0;\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);\n    const angle = toDegrees(scale.getIndexAngle(i));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= w / 2;\n  }\n\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= h / 2;\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n\n  return y;\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {\n    ctx,\n    options: {\n      pointLabels\n    }\n  } = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {\n      x,\n      y,\n      textAlign,\n      left,\n      top,\n      right,\n      bottom\n    } = scale._pointLabelItems[i];\n    const {\n      backdropColor\n    } = optsAtIndex;\n\n    if (!isNullOrUndef(backdropColor)) {\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\n    }\n\n    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n      color: optsAtIndex.color,\n      textAlign: textAlign,\n      textBaseline: 'middle'\n    });\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {\n    ctx\n  } = scale;\n\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {\n    color,\n    lineWidth\n  } = gridLineOpts;\n\n  if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction chart_esm_numberOrZero(param) {\n  return isNumber(param) ? param : 0;\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return Object.assign(Object.create(parent), {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nclass chart_esm_RadialLinearScale extends chart_esm_LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    const me = this;\n    me.width = me.maxWidth;\n    me.height = me.maxHeight;\n    me.paddingTop = getTickBackdropHeight(me.options) / 2;\n    me.xCenter = Math.floor(me.width / 2);\n    me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n    me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const {\n      min,\n      max\n    } = me.getMinMax(false);\n    me.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    me.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    me.handleTickRangeOptions();\n  }\n\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    const me = this;\n    chart_esm_LinearScaleBase.prototype.generateTickLabels.call(me, ticks);\n    me._pointLabels = me.getLabels().map((value, index) => {\n      const label = callback(me.options.pointLabels.callback, [value, index], me);\n      return label || label === 0 ? label : '';\n    });\n  }\n\n  fit() {\n    const me = this;\n    const opts = me.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(me);\n    } else {\n      me.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\n    const me = this;\n    let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n    let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n    let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n    let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n    radiusReductionLeft = chart_esm_numberOrZero(radiusReductionLeft);\n    radiusReductionRight = chart_esm_numberOrZero(radiusReductionRight);\n    radiusReductionTop = chart_esm_numberOrZero(radiusReductionTop);\n    radiusReductionBottom = chart_esm_numberOrZero(radiusReductionBottom);\n    me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));\n    me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    const me = this;\n    const maxRight = me.width - rightMovement - me.drawingArea;\n    const maxLeft = leftMovement + me.drawingArea;\n    const maxTop = topMovement + me.drawingArea;\n    const maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;\n    me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);\n    me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / this.getLabels().length;\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    const me = this;\n\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    const scalingFactor = me.drawingArea / (me.max - me.min);\n\n    if (me.options.reverse) {\n      return (me.max - value) * scalingFactor;\n    }\n\n    return (value - me.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const me = this;\n    const scaledDistance = distance / (me.drawingArea / (me.max - me.min));\n    return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const me = this;\n    const pointLabels = me._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(me.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter) {\n    const me = this;\n    const angle = me.getIndexAngle(index) - HALF_PI;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + me.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + me.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom\n    };\n  }\n\n  drawBackground() {\n    const me = this;\n    const {\n      backgroundColor,\n      grid: {\n        circular\n      }\n    } = me.options;\n\n    if (backgroundColor) {\n      const ctx = me.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  drawGrid() {\n    const me = this;\n    const ctx = me.ctx;\n    const opts = me.options;\n    const {\n      angleLines,\n      grid\n    } = opts;\n    const labelCount = me.getLabels().length;\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(me, labelCount);\n    }\n\n    if (grid.display) {\n      me.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = me.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(me.getContext(index - 1));\n          drawRadiusLine(me, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = me.getLabels().length - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(me.getPointLabelContext(i));\n        const {\n          color,\n          lineWidth\n        } = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\n        position = me.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(me.xCenter, me.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  drawBorder() {}\n\n  drawLabels() {\n    const me = this;\n    const ctx = me.ctx;\n    const opts = me.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = me.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(me.xCenter, me.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    me.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(me.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = me.getDistanceFromCenterForValue(me.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color\n      });\n    });\n    ctx.restore();\n  }\n\n  drawTitle() {}\n\n}\n\nchart_esm_RadialLinearScale.id = 'radialLinear';\nchart_esm_RadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n\n    callback(label) {\n      return label;\n    },\n\n    padding: 5\n  }\n};\nchart_esm_RadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nchart_esm_RadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: 1000\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: 60\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: 60\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: 24\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: 30\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: 4\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: 12\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: 4\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n  return a - b;\n}\n\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {\n    parser,\n    round,\n    isoWeekday\n  } = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n\n  return ticks;\n}\n\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nclass chart_esm_TimeScale extends chart_esm_Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const me = this;\n    const options = me.options;\n    const adapter = me._adapter;\n    const unit = options.time.unit || 'day';\n    let {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = me.getUserBounds();\n\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    if (!minDefined || !maxDefined) {\n      _applyBounds(me._getLabelBounds());\n\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(me.getMinMax(false));\n      }\n    }\n\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    me.min = Math.min(min, max - 1);\n    me.max = Math.max(min + 1, max);\n  }\n\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n\n    return {\n      min,\n      max\n    };\n  }\n\n  buildTicks() {\n    const me = this;\n    const options = me.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? me.getLabelTimestamps() : me._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      me.min = me._userMin || timestamps[0];\n      me.max = me._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = me.min;\n    const max = me.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min)) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\n    me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined : determineMajorUnit(me._unit);\n    me.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(me, ticks, me._majorUnit);\n  }\n\n  initOffsets(timestamps) {\n    const me = this;\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (me.options.offset && timestamps.length) {\n      first = me.getDecimalForValue(timestamps[0]);\n\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (me.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n\n      last = me.getDecimalForValue(timestamps[timestamps.length - 1]);\n\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    me._offsets = {\n      start,\n      end,\n      factor: 1 / (start + 1 + end)\n    };\n  }\n\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const min = me.min;\n    const max = me.max;\n    const options = me.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && me.getDataTimestamps();\n\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n\n  getLabelForValue(value) {\n    const me = this;\n    const adapter = me._adapter;\n    const timeOpts = me.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  _tickFormatFunction(time, index, ticks, format) {\n    const me = this;\n    const options = me.options;\n    const formats = options.time.displayFormats;\n    const unit = me._unit;\n    const majorUnit = me._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    const label = me._adapter.format(time, format || (major ? majorFormat : minorFormat));\n\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], me) : label;\n  }\n\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  getDecimalForValue(value) {\n    const me = this;\n    return value === null ? NaN : (value - me.min) / (me.max - me.min);\n  }\n\n  getPixelForValue(value) {\n    const me = this;\n    const offsets = me._offsets;\n    const pos = me.getDecimalForValue(value);\n    return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    const offsets = me._offsets;\n    const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return me.min + pos * (me.max - me.min);\n  }\n\n  _getLabelSize(label) {\n    const me = this;\n    const ticksOpts = me.options.ticks;\n    const tickLabelWidth = me.ctx.measureText(label).width;\n    const angle = toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n\n    const tickFontSize = me._resolveTickFontOptions(0).size;\n\n    return {\n      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n    };\n  }\n\n  _getLabelCapacity(exampleTime) {\n    const me = this;\n    const timeOpts = me.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n\n    const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\n\n    const size = me._getLabelSize(exampleLabel);\n\n    const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  getDataTimestamps() {\n    const me = this;\n    let timestamps = me._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = me.getMatchingVisibleMetas();\n\n    if (me._normalized && metas.length) {\n      return me._cache.data = metas[0].controller.getAllParsedValues(me);\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));\n    }\n\n    return me._cache.data = me.normalize(timestamps);\n  }\n\n  getLabelTimestamps() {\n    const me = this;\n    const timestamps = me._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = me.getLabels();\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(me, labels[i]));\n    }\n\n    return me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps);\n  }\n\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n\n}\n\nchart_esm_TimeScale.id = 'time';\nchart_esm_TimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({\n        lo,\n        hi\n      } = _lookupByKey(table, 'pos', val));\n    }\n\n    ({\n      pos: prevSource,\n      time: prevTarget\n    } = table[lo]);\n    ({\n      pos: nextSource,\n      time: nextTarget\n    } = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({\n        lo,\n        hi\n      } = _lookupByKey(table, 'time', val));\n    }\n\n    ({\n      time: prevSource,\n      pos: prevTarget\n    } = table[lo]);\n    ({\n      time: nextSource,\n      pos: nextTarget\n    } = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends chart_esm_TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n\n  initOffsets() {\n    const me = this;\n\n    const timestamps = me._getTimestampsForTable();\n\n    const table = me._table = me.buildLookupTable(timestamps);\n    me._minPos = interpolate(table, me.min);\n    me._tableRange = interpolate(table, me.max) - me._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  buildLookupTable(timestamps) {\n    const {\n      min,\n      max\n    } = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      return [{\n        time: min,\n        pos: 0\n      }, {\n        time: max,\n        pos: 1\n      }];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({\n          time: curr,\n          pos: i / (ilen - 1)\n        });\n      }\n    }\n\n    return table;\n  }\n\n  _getTimestampsForTable() {\n    const me = this;\n    let timestamps = me._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = me.getDataTimestamps();\n    const label = me.getLabelTimestamps();\n\n    if (data.length && label.length) {\n      timestamps = me.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n\n    timestamps = me._cache.all = timestamps;\n    return timestamps;\n  }\n\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  getValueForPixel(pixel) {\n    const me = this;\n    const offsets = me._offsets;\n    const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(me._table, decimal * me._tableRange + me._minPos, true);\n  }\n\n}\n\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = chart_esm_TimeScale.defaults;\nvar chart_esm_scales = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CategoryScale: chart_esm_CategoryScale,\n  LinearScale: chart_esm_LinearScale,\n  LogarithmicScale: chart_esm_LogarithmicScale,\n  RadialLinearScale: chart_esm_RadialLinearScale,\n  TimeScale: chart_esm_TimeScale,\n  TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [controllers, chart_esm_elements, chart_esm_plugins, chart_esm_scales];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaHVua3MvaGVscGVycy5zZWdtZW50LmpzP2RkM2QiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQuZXNtLmpzPzliNGEiXSwibmFtZXMiOlsiZm9udFN0cmluZyIsInBpeGVsU2l6ZSIsImZvbnRTdHlsZSIsImZvbnRGYW1pbHkiLCJyZXF1ZXN0QW5pbUZyYW1lIiwid2luZG93IiwiY2FsbGJhY2siLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aHJvdHRsZWQiLCJmbiIsInRoaXNBcmciLCJ1cGRhdGVGbiIsInVwZGF0ZUFyZ3MiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJ0aWNraW5nIiwicmVzdCIsImFwcGx5IiwiZGVib3VuY2UiLCJkZWxheSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiYWxpZ24iLCJfYWxpZ25TdGFydEVuZCIsInN0YXJ0IiwiZW5kIiwiX3RleHRYIiwibGVmdCIsInJpZ2h0IiwicnRsIiwiY2hlY2siLCJub29wIiwidWlkIiwiaWQiLCJpc051bGxPclVuZGVmIiwidmFsdWUiLCJpc0FycmF5IiwidHlwZSIsIk9iamVjdCIsInRvU3RyaW5nIiwic3Vic3RyIiwiaXNPYmplY3QiLCJpc051bWJlckZpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiZmluaXRlT3JEZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwidmFsdWVPckRlZmF1bHQiLCJ0b1BlcmNlbnRhZ2UiLCJkaW1lbnNpb24iLCJlbmRzV2l0aCIsInBhcnNlRmxvYXQiLCJ0b0RpbWVuc2lvbiIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJpIiwibGVuIiwia2V5cyIsImxlbmd0aCIsIl9lbGVtZW50c0VxdWFsIiwiYTAiLCJhMSIsImlsZW4iLCJ2MCIsInYxIiwiZGF0YXNldEluZGV4IiwiaW5kZXgiLCJjbG9uZSQxIiwic291cmNlIiwibWFwIiwidGFyZ2V0IiwiY3JlYXRlIiwia2xlbiIsImsiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiaW5kZXhPZiIsIl9tZXJnZXIiLCJvcHRpb25zIiwidHZhbCIsInN2YWwiLCJtZXJnZSIsInNvdXJjZXMiLCJtZXJnZXIiLCJtZXJnZUlmIiwiX21lcmdlcklmIiwiaGFzT3duUHJvcGVydHkiLCJfZGVwcmVjYXRlZCIsInNjb3BlIiwicHJldmlvdXMiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwiY29uc29sZSIsIndhcm4iLCJlbXB0eVN0cmluZyIsImRvdCIsImluZGV4T2ZEb3RPckxlbmd0aCIsImlkeCIsInJlc29sdmVPYmplY3RLZXkiLCJvYmoiLCJwb3MiLCJfY2FwaXRhbGl6ZSIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJzZXRzRXF1YWwiLCJhIiwiYiIsInNpemUiLCJpdGVtIiwiaGFzIiwiUEkiLCJNYXRoIiwiVEFVIiwiUElUQVUiLCJJTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiUkFEX1BFUl9ERUciLCJIQUxGX1BJIiwiUVVBUlRFUl9QSSIsIlRXT19USElSRFNfUEkiLCJsb2cxMCIsInNpZ24iLCJuaWNlTnVtIiwicmFuZ2UiLCJyb3VuZGVkUmFuZ2UiLCJyb3VuZCIsImFsbW9zdEVxdWFscyIsIm5pY2VSYW5nZSIsInBvdyIsImZsb29yIiwiZnJhY3Rpb24iLCJuaWNlRnJhY3Rpb24iLCJfZmFjdG9yaXplIiwicmVzdWx0Iiwic3FydCIsInB1c2giLCJzb3J0IiwicG9wIiwiaXNOdW1iZXIiLCJuIiwiaXNOYU4iLCJ4IiwieSIsImVwc2lsb24iLCJhYnMiLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJhcnJheSIsInByb3BlcnR5IiwibWluIiwibWF4IiwidG9SYWRpYW5zIiwiZGVncmVlcyIsInRvRGVncmVlcyIsInJhZGlhbnMiLCJfZGVjaW1hbFBsYWNlcyIsImUiLCJwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0YW5jZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsIl9hbmdsZURpZmYiLCJfbm9ybWFsaXplQW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwicyIsImFuZ2xlVG9TdGFydCIsImFuZ2xlVG9FbmQiLCJzdGFydFRvQW5nbGUiLCJlbmRUb0FuZ2xlIiwiX2xpbWl0VmFsdWUiLCJfaW50MTZSYW5nZSIsImF0RWRnZSIsInQiLCJlbGFzdGljSW4iLCJzaW4iLCJlbGFzdGljT3V0IiwiZWZmZWN0cyIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiY29zIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJtIiwiZCIsImVhc2VJbk91dEJvdW5jZSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImMiLCJmIiwiaGV4IiwiaDEiLCJoMiIsImVxIiwiaXNTaG9ydCIsInYiLCJyIiwiZyIsImhleFBhcnNlIiwicmV0IiwiaGV4U3RyaW5nIiwibGltIiwibCIsImgiLCJwMmIiLCJuMmIiLCJiMm4iLCJuMnAiLCJSR0JfUkUiLCJyZ2JQYXJzZSIsImV4ZWMiLCJyZ2JTdHJpbmciLCJIVUVfUkUiLCJoc2wycmdibiIsImhzdjJyZ2JuIiwiaHdiMnJnYm4iLCJ3IiwicmdiIiwicmdiMmhzbCIsImNhbGxuIiwiaHNsMnJnYiIsImh3YjJyZ2IiLCJoc3YycmdiIiwiaHVlIiwiaHVlUGFyc2UiLCJwMSIsInAyIiwicm90YXRlIiwiZGVnIiwiaHNsU3RyaW5nIiwibWFwJDEiLCJaIiwiWSIsIlgiLCJXIiwiViIsIlUiLCJUIiwiUyIsIlIiLCJRIiwiUCIsIk8iLCJOIiwiTSIsIkwiLCJLIiwiRyIsIkgiLCJJIiwiSiIsIm5hbWVzIiwiT2ljZVhlIiwiYW50aXF1ZXdFdGUiLCJhcXVhIiwiYXF1YW1hclJlIiwiYXp1WSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuS2VkT21vbmQiLCJYZSIsIlhldmlUZXQiLCJiUHduIiwiYnVybHl3b29kIiwiY2FNdFhlIiwiS2FydFl1c2UiLCJLb2NUYXRlIiwiY1NPIiwiY1NuZmxvd2VyWGUiLCJjU25zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJ4WGUiLCJ4Y3lhbiIsInhnVE1uUGQiLCJ4V2F5IiwieGdZRiIsInhnWXkiLCJ4a2hha2kiLCJ4bWFnRnRhIiwieFRpdmVnWUYiLCJ4U2FuZ2UiLCJ4U2NFZCIsInhZZCIsInhzT21vbiIsInhzSGdZRiIsInhVWGUiLCJ4VVdheSIsInhVZ1l5IiwieFFlIiwieHZpVGV0IiwiZEFwcFJrIiwiZEFwc2t5WGUiLCJkaW1XYXkiLCJkaW1nWXkiLCJkb2RnZXJYZSIsImZpWWJyaWNrIiwiZmxTT3dFdGUiLCJmb1lzdFdBbiIsImZ1S3NpYSIsImdhUnNiU28iLCJnaG9zdHdFdGUiLCJnVGQiLCJnVE1uUGQiLCJXYXkiLCJnWUYiLCJnWUZMdyIsImdZeSIsImhvbmV5TXciLCJob3RwUmsiLCJSZGlhbllkIiwiUmRpZ28iLCJpdlN5Iiwia2hha2kiLCJsYXZGTXIiLCJsYXZGTXJYc2giLCJsYXduZ1lGIiwiTm1vbmNFZmZvbiIsIlpYZSIsIlpjU08iLCJaY3lhbiIsIlpnVE1uUGRMdyIsIlpXYXkiLCJaZ1lGIiwiWmdZeSIsIlpwUmsiLCJac09tb24iLCJac0hnWUYiLCJac2t5WGUiLCJaVVdheSIsIlpVZ1l5IiwiWnN0QWxYZSIsIlpMdyIsImxpbWUiLCJsaW1lZ1lGIiwibFJGIiwibWFnRnRhIiwibWFQb24iLCJWYXF1YW1hclJlIiwiVlhlIiwiVlNjRWQiLCJWcHVycE4iLCJWc0hnWUYiLCJWVVhlIiwiVnNwclJnZ1lGIiwiVlFlIiwiVnZpVGV0WWQiLCJtaWRuaWdodFhlIiwibVJ0Y1lhbSIsIm1pc3R5UHNlIiwibW9jY2FzUiIsIm5hdmFqb3dFdGUiLCJuYXZ5IiwiVGRsYWNlIiwiVGl2ZSIsIlRpdmVkQmIiLCJTYW5nZSIsIlNhbmdlWWQiLCJTY0VkIiwicE9lZ1RNblBkIiwicE9lZ1lGIiwicE9lUWUiLCJwT2V2aVRldFlkIiwicGFwYXlhd0VwIiwicEhLcHVmZiIsInBlcnUiLCJwUmsiLCJwbHVtIiwicG93TXJYZSIsInB1cnBOIiwiWWJlY2NhcHVycE4iLCJZZCIsIlBzeWJyb3duIiwiUHlPWGUiLCJzYWRkTmJQd24iLCJzT21vbiIsInNhbmR5YlB3biIsInNIZ1lGIiwic0hzaGVsbCIsInNpRm5hIiwic2lsdmVyIiwic2t5WGUiLCJVWGUiLCJVV2F5IiwiVWdZeSIsInNub3ciLCJzcHJSZ2dZRiIsInN0QWxYZSIsInRhbiIsInRlTyIsInRFc3ROIiwidG9tYXRvIiwiUWUiLCJ2aVRldCIsIkpIdCIsIndFdGUiLCJ3RXRlc21va2UiLCJMdyIsIkx3Z1lGIiwidW5wYWNrIiwidW5wYWNrZWQiLCJ0a2V5cyIsImoiLCJvayIsIm5rIiwicmVwbGFjZSIsInBhcnNlSW50IiwibmFtZXMkMSIsIm5hbWVQYXJzZSIsInRyYW5zcGFyZW50IiwidG9Mb3dlckNhc2UiLCJtb2RIU0wiLCJyYXRpbyIsInRtcCIsImNsb25lIiwicHJvdG8iLCJhc3NpZ24iLCJmcm9tT2JqZWN0IiwiaW5wdXQiLCJmdW5jdGlvblBhcnNlIiwiQ29sb3IiLCJjb25zdHJ1Y3RvciIsIl9yZ2IiLCJfdmFsaWQiLCJ2YWxpZCIsIm1peCIsImNvbG9yIiwid2VpZ2h0IiwibWUiLCJjMSIsImMyIiwidzIiLCJ3MSIsImFscGhhIiwiY2xlYXJlciIsImdyZXlzY2FsZSIsInZhbCIsIm9wYXF1ZXIiLCJuZWdhdGUiLCJsaWdodGVuIiwiZGFya2VuIiwic2F0dXJhdGUiLCJkZXNhdHVyYXRlIiwiaW5kZXhfZXNtIiwiaXNQYXR0ZXJuT3JHcmFkaWVudCIsIkNhbnZhc0dyYWRpZW50IiwiQ2FudmFzUGF0dGVybiIsImdldEhvdmVyQ29sb3IiLCJvdmVycmlkZXMiLCJkZXNjcmlwdG9ycyIsImdldFNjb3BlJDEiLCJub2RlIiwic3BsaXQiLCJzZXQiLCJyb290IiwidmFsdWVzIiwiRGVmYXVsdHMiLCJfZGVzY3JpcHRvcnMiLCJhbmltYXRpb24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImRhdGFzZXRzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNvbnRleHQiLCJjaGFydCIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImVsZW1lbnRzIiwiZXZlbnRzIiwiZm9udCIsImZhbWlseSIsInN0eWxlIiwibGluZUhlaWdodCIsImhvdmVyIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJjdHgiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJDb2xvciIsImluZGV4QXhpcyIsImludGVyYWN0aW9uIiwibW9kZSIsImludGVyc2VjdCIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJvbkhvdmVyIiwib25DbGljayIsInBhcnNpbmciLCJwbHVnaW5zIiwicmVzcG9uc2l2ZSIsInNjYWxlIiwic2NhbGVzIiwic2hvd0xpbmUiLCJkZXNjcmliZSIsImdldCIsIm92ZXJyaWRlIiwicm91dGUiLCJuYW1lIiwidGFyZ2V0U2NvcGUiLCJ0YXJnZXROYW1lIiwic2NvcGVPYmplY3QiLCJ0YXJnZXRTY29wZU9iamVjdCIsInByaXZhdGVOYW1lIiwiZGVmaW5lUHJvcGVydGllcyIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImxvY2FsIiwiZGVmYXVsdHMiLCJfc2NyaXB0YWJsZSIsInN0YXJ0c1dpdGgiLCJfaW5kZXhhYmxlIiwiX2ZhbGxiYWNrIiwidG9Gb250U3RyaW5nIiwiX21lYXN1cmVUZXh0IiwiZGF0YSIsImdjIiwibG9uZ2VzdCIsInN0cmluZyIsInRleHRXaWR0aCIsIm1lYXN1cmVUZXh0Iiwid2lkdGgiLCJfbG9uZ2VzdFRleHQiLCJhcnJheU9mVGhpbmdzIiwiY2FjaGUiLCJnYXJiYWdlQ29sbGVjdCIsInNhdmUiLCJqbGVuIiwidGhpbmciLCJuZXN0ZWRUaGluZyIsInJlc3RvcmUiLCJnY0xlbiIsInNwbGljZSIsIl9hbGlnblBpeGVsIiwicGl4ZWwiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsImhhbGZXaWR0aCIsImNsZWFyQ2FudmFzIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsInJlc2V0VHJhbnNmb3JtIiwiY2xlYXJSZWN0IiwiaGVpZ2h0IiwiZHJhd1BvaW50IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXJSYWRpdXMiLCJwb2ludFN0eWxlIiwicm90YXRpb24iLCJyYWRpdXMiLCJyYWQiLCJ0cmFuc2xhdGUiLCJkcmF3SW1hZ2UiLCJiZWdpblBhdGgiLCJhcmMiLCJjbG9zZVBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJTUVJUMV8yIiwicmVjdCIsImZpbGwiLCJib3JkZXJXaWR0aCIsInN0cm9rZSIsIl9pc1BvaW50SW5BcmVhIiwicG9pbnQiLCJhcmVhIiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwiY2xpcEFyZWEiLCJjbGlwIiwidW5jbGlwQXJlYSIsIl9zdGVwcGVkTGluZVRvIiwiZmxpcCIsIm1pZHBvaW50IiwiX2JlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiY3AxeCIsImNwMngiLCJjcDF5IiwiY3AyeSIsInJlbmRlclRleHQiLCJ0ZXh0Iiwib3B0cyIsImxpbmVzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VDb2xvciIsImxpbmUiLCJzZXRSZW5kZXJPcHRzIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VUZXh0IiwibWF4V2lkdGgiLCJmaWxsVGV4dCIsImRlY29yYXRlVGV4dCIsInRyYW5zbGF0aW9uIiwiZmlsbFN0eWxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwic3RyaWtldGhyb3VnaCIsInVuZGVybGluZSIsIm1ldHJpY3MiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJ5RGVjb3JhdGlvbiIsImRlY29yYXRpb25XaWR0aCIsImFkZFJvdW5kZWRSZWN0UGF0aCIsInRvcExlZnQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJ0b3BSaWdodCIsIkxJTkVfSEVJR0hUIiwiUmVnRXhwIiwiRk9OVF9TVFlMRSIsInRvTGluZUhlaWdodCIsIm1hdGNoZXMiLCJtYXRjaCIsIm51bWJlck9yWmVybyIsIl9yZWFkVmFsdWVUb1Byb3BzIiwicHJvcHMiLCJvYmpQcm9wcyIsInJlYWQiLCJwcm9wIiwidG9UUkJMIiwidG9UUkJMQ29ybmVycyIsInRvUGFkZGluZyIsInRvRm9udCIsImZhbGxiYWNrIiwicmVzb2x2ZSIsImlucHV0cyIsImluZm8iLCJjYWNoZWFibGUiLCJfYWRkR3JhY2UiLCJtaW5tYXgiLCJncmFjZSIsIl9sb29rdXAiLCJ0YWJsZSIsImNtcCIsImhpIiwibG8iLCJtaWQiLCJfbG9va3VwQnlLZXkiLCJfcmxvb2t1cEJ5S2V5IiwiX2ZpbHRlckJldHdlZW4iLCJhcnJheUV2ZW50cyIsImxpc3RlbkFycmF5RXZlbnRzIiwibGlzdGVuZXIiLCJfY2hhcnRqcyIsImxpc3RlbmVycyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZm9yRWFjaCIsIm1ldGhvZCIsImJhc2UiLCJyZXMiLCJvYmplY3QiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsIl9hcnJheVVuaXF1ZSIsIml0ZW1zIiwiU2V0IiwiYWRkIiwiZnJvbSIsIl9jcmVhdGVSZXNvbHZlciIsInNjb3BlcyIsInByZWZpeGVzIiwicm9vdFNjb3BlcyIsImdldFRhcmdldCIsIl9yZXNvbHZlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJfY2FjaGVhYmxlIiwiX3Njb3BlcyIsIl9yb290U2NvcGVzIiwiX2dldFRhcmdldCIsIlByb3h5IiwiZGVsZXRlUHJvcGVydHkiLCJfa2V5cyIsIl9jYWNoZWQiLCJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlJlZmxlY3QiLCJnZXRQcm90b3R5cGVPZiIsImdldEtleXNGcm9tQWxsU2NvcGVzIiwiaW5jbHVkZXMiLCJvd25LZXlzIiwic3RvcmFnZSIsIl9zdG9yYWdlIiwiX2F0dGFjaENvbnRleHQiLCJwcm94eSIsInN1YlByb3h5IiwiZGVzY3JpcHRvckRlZmF1bHRzIiwiX3Byb3h5IiwiX2NvbnRleHQiLCJfc3ViUHJveHkiLCJfc3RhY2siLCJzZXRDb250ZXh0IiwicmVjZWl2ZXIiLCJfcmVzb2x2ZVdpdGhDb250ZXh0IiwiYWxsS2V5cyIsInNjcmlwdGFibGUiLCJpbmRleGFibGUiLCJfYWxsS2V5cyIsImlzU2NyaXB0YWJsZSIsImlzSW5kZXhhYmxlIiwicmVhZEtleSIsInByZWZpeCIsIm5lZWRzU3ViUmVzb2x2ZXIiLCJfcmVzb2x2ZVNjcmlwdGFibGUiLCJfcmVzb2x2ZUFycmF5IiwiRXJyb3IiLCJqb2luIiwiZGVsZXRlIiwiY3JlYXRlU3ViUmVzb2x2ZXIiLCJhcnIiLCJmaWx0ZXIiLCJyZXNvbHZlciIsInJlc29sdmVGYWxsYmFjayIsImdldFNjb3BlIiwicGFyZW50IiwiYWRkU2NvcGVzIiwicGFyZW50U2NvcGVzIiwicGFyZW50RmFsbGJhY2siLCJhbGxTY29wZXMiLCJhZGRTY29wZXNGcm9tS2V5Iiwic3ViR2V0VGFyZ2V0IiwicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwiRVBTSUxPTiIsImdldFBvaW50IiwicG9pbnRzIiwic2tpcCIsImdldFZhbHVlQXhpcyIsInNwbGluZUN1cnZlIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsIm5leHQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwibW9ub3RvbmVBZGp1c3QiLCJkZWx0YUsiLCJtSyIsInBvaW50c0xlbiIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwibW9ub3RvbmVDb21wdXRlIiwidmFsdWVBeGlzIiwiZGVsdGEiLCJwb2ludEJlZm9yZSIsImlQaXhlbCIsInZQaXhlbCIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzbG9wZURlbHRhIiwiY2FwQ29udHJvbFBvaW50IiwicHQiLCJjYXBCZXppZXJQb2ludHMiLCJpbkFyZWEiLCJpbkFyZWFQcmV2IiwiaW5BcmVhTmV4dCIsIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwibG9vcCIsImNvbnRyb2xQb2ludHMiLCJzcGFuR2FwcyIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJwcmV2IiwidGVuc2lvbiIsIl9pc0RvbVN1cHBvcnRlZCIsImRvY3VtZW50IiwiX2dldFBhcmVudE5vZGUiLCJkb21Ob2RlIiwicGFyZW50Tm9kZSIsImhvc3QiLCJwYXJzZU1heFN0eWxlIiwic3R5bGVWYWx1ZSIsInBhcmVudFByb3BlcnR5IiwidmFsdWVJblBpeGVscyIsImdldENvbXB1dGVkU3R5bGUiLCJlbGVtZW50IiwiZ2V0U3R5bGUiLCJlbCIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbmVkU3R5bGUiLCJzdHlsZXMiLCJzdWZmaXgiLCJ1c2VPZmZzZXRQb3MiLCJzaGFkb3dSb290IiwiZ2V0Q2FudmFzUG9zaXRpb24iLCJldnQiLCJuYXRpdmUiLCJ0b3VjaGVzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJib3JkZXJCb3giLCJib3hTaXppbmciLCJwYWRkaW5ncyIsImJvcmRlcnMiLCJnZXRDb250YWluZXJTaXplIiwibWF4SGVpZ2h0IiwiY29udGFpbmVyIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjb250YWluZXJTdHlsZSIsImNvbnRhaW5lckJvcmRlciIsImNvbnRhaW5lclBhZGRpbmciLCJyb3VuZDEiLCJnZXRNYXhpbXVtU2l6ZSIsImJiV2lkdGgiLCJiYkhlaWdodCIsImFzcGVjdFJhdGlvIiwibWFyZ2lucyIsImNvbnRhaW5lclNpemUiLCJyZXRpbmFTY2FsZSIsImZvcmNlUmF0aW8iLCJmb3JjZVN0eWxlIiwicGl4ZWxSYXRpbyIsImRldmljZUhlaWdodCIsImRldmljZVdpZHRoIiwic2V0VHJhbnNmb3JtIiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmVTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkVXNlZFNpemUiLCJfcG9pbnRJbkxpbmUiLCJfc3RlcHBlZEludGVycG9sYXRpb24iLCJfYmV6aWVySW50ZXJwb2xhdGlvbiIsImNwMSIsImNwMiIsImludGxDYWNoZSIsIk1hcCIsImdldE51bWJlckZvcm1hdCIsImxvY2FsZSIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdHRlciIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJmb3JtYXQiLCJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCJyZWN0WCIsInNldFdpZHRoIiwieFBsdXMiLCJsZWZ0Rm9yTHRyIiwiaXRlbVdpZHRoIiwiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwiX2l0ZW1XaWR0aCIsImdldFJ0bEFkYXB0ZXIiLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJvcmlnaW5hbCIsImdldFByb3BlcnR5UHJpb3JpdHkiLCJzZXRQcm9wZXJ0eSIsInByZXZUZXh0RGlyZWN0aW9uIiwicmVzdG9yZVRleHREaXJlY3Rpb24iLCJwcm9wZXJ0eUZuIiwiYmV0d2VlbiIsImNvbXBhcmUiLCJub3JtYWxpemUiLCJub3JtYWxpemVTZWdtZW50IiwiY291bnQiLCJnZXRTZWdtZW50Iiwic2VnbWVudCIsImJvdW5kcyIsInN0YXJ0Qm91bmQiLCJlbmRCb3VuZCIsIl9ib3VuZFNlZ21lbnQiLCJpbnNpZGUiLCJzdWJTdGFydCIsInByZXZWYWx1ZSIsInN0YXJ0SXNCZWZvcmUiLCJlbmRJc0JlZm9yZSIsInNob3VsZFN0YXJ0Iiwic2hvdWxkU3RvcCIsIl9ib3VuZFNlZ21lbnRzIiwic2VnbWVudHMiLCJzdWIiLCJmaW5kU3RhcnRBbmRFbmQiLCJzb2xpZFNlZ21lbnRzIiwibGFzdCIsImN1ciIsInN0b3AiLCJfY29tcHV0ZVNlZ21lbnRzIiwic2VnbWVudE9wdGlvbnMiLCJfbG9vcCIsInNwbGl0QnlTdHlsZXMiLCJjb21wbGV0ZUxvb3AiLCJfZnVsbExvb3AiLCJkb1NwbGl0QnlTdHlsZXMiLCJiYXNlU3R5bGUiLCJyZWFkU3R5bGUiLCJwcmV2U3R5bGUiLCJwMCIsInAwRGF0YUluZGV4IiwicDFEYXRhSW5kZXgiLCJfZGF0YXNldEluZGV4Iiwic3R5bGVDaGFuZ2VkIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsIkFuaW1hdG9yIiwiX3JlcXVlc3QiLCJfY2hhcnRzIiwiX3J1bm5pbmciLCJfbGFzdERhdGUiLCJfbm90aWZ5IiwiYW5pbXMiLCJkYXRlIiwiY2FsbGJhY2tzIiwibnVtU3RlcHMiLCJkdXJhdGlvbiIsImluaXRpYWwiLCJjdXJyZW50U3RlcCIsIl9yZWZyZXNoIiwiX3VwZGF0ZSIsIkRhdGUiLCJub3ciLCJyZW1haW5pbmciLCJydW5uaW5nIiwiZHJhdyIsIl9hY3RpdmUiLCJfdG90YWwiLCJ0aWNrIiwiX2dldEFuaW1zIiwiY2hhcnRzIiwiY29tcGxldGUiLCJwcm9ncmVzcyIsImxpc3RlbiIsImV2ZW50IiwiY2IiLCJyZWR1Y2UiLCJhY2MiLCJfZHVyYXRpb24iLCJjYW5jZWwiLCJyZW1vdmUiLCJhbmltYXRvciIsImludGVycG9sYXRvcnMiLCJib29sZWFuIiwidG8iLCJmYWN0b3IiLCJjMCIsIm51bWJlciIsIkFuaW1hdGlvbiIsImNmZyIsImN1cnJlbnRWYWx1ZSIsIl9mbiIsIl9lYXNpbmciLCJlYXNpbmciLCJfc3RhcnQiLCJfdGFyZ2V0IiwiX3Byb3AiLCJfZnJvbSIsIl90byIsIl9wcm9taXNlcyIsImFjdGl2ZSIsInVwZGF0ZSIsImVsYXBzZWQiLCJyZW1haW4iLCJ3YWl0IiwicHJvbWlzZXMiLCJQcm9taXNlIiwicmVqIiwicmVzb2x2ZWQiLCJudW1iZXJzIiwiY29sb3JzIiwiYW5pbWF0aW9uT3B0aW9ucyIsInByb3BlcnRpZXMiLCJyZXNpemUiLCJzaG93IiwiYW5pbWF0aW9ucyIsInZpc2libGUiLCJoaWRlIiwiQW5pbWF0aW9ucyIsImNvbmZpZyIsIl9jaGFydCIsIl9wcm9wZXJ0aWVzIiwiY29uZmlndXJlIiwiYW5pbWF0ZWRQcm9wcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvcHRpb24iLCJfYW5pbWF0ZU9wdGlvbnMiLCJuZXdPcHRpb25zIiwicmVzb2x2ZVRhcmdldE9wdGlvbnMiLCJfY3JlYXRlQW5pbWF0aW9ucyIsIiRzaGFyZWQiLCJhd2FpdEFsbCIsIiRhbmltYXRpb25zIiwidGhlbiIsImFuaW0iLCJhbGwiLCJzY2FsZUNsaXAiLCJhbGxvd2VkT3ZlcmZsb3ciLCJkZWZhdWx0Q2xpcCIsInhTY2FsZSIsInlTY2FsZSIsInRvQ2xpcCIsImRpc2FibGVkIiwiZ2V0U29ydGVkRGF0YXNldEluZGljZXMiLCJmaWx0ZXJWaXNpYmxlIiwibWV0YXNldHMiLCJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwiYXBwbHlTdGFjayIsInN0YWNrIiwiZHNJbmRleCIsInNpbmdsZU1vZGUiLCJvdGhlclZhbHVlIiwiY29udmVydE9iamVjdERhdGFUb0FycmF5IiwiYWRhdGEiLCJpc1N0YWNrZWQiLCJtZXRhIiwic3RhY2tlZCIsImdldFN0YWNrS2V5IiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJnZXRVc2VyQm91bmRzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJORUdBVElWRV9JTkZJTklUWSIsImdldE9yQ3JlYXRlU3RhY2siLCJzdGFja3MiLCJzdGFja0tleSIsImluZGV4VmFsdWUiLCJzdWJTdGFjayIsImdldExhc3RJbmRleEluU3RhY2siLCJ2U2NhbGUiLCJwb3NpdGl2ZSIsImdldE1hdGNoaW5nVmlzaWJsZU1ldGFzIiwidXBkYXRlU3RhY2tzIiwiY29udHJvbGxlciIsInBhcnNlZCIsIl9jYWNoZWRNZXRhIiwiX3N0YWNrcyIsImlTY2FsZSIsImlBeGlzIiwiYXhpcyIsInZBeGlzIiwiaXRlbVN0YWNrcyIsIl90b3AiLCJfYm90dG9tIiwiZ2V0Rmlyc3RTY2FsZUlkIiwic2hpZnQiLCJjcmVhdGVEYXRhc2V0Q29udGV4dCIsImRhdGFzZXQiLCJjcmVhdGVEYXRhQ29udGV4dCIsImRhdGFJbmRleCIsInJhdyIsImNsZWFyU3RhY2tzIiwiX3BhcnNlZCIsImlzRGlyZWN0VXBkYXRlTW9kZSIsImNsb25lSWZOb3RTaGFyZWQiLCJjYWNoZWQiLCJzaGFyZWQiLCJEYXRhc2V0Q29udHJvbGxlciIsIl9jdHgiLCJfY2FjaGVkRGF0YU9wdHMiLCJnZXRNZXRhIiwiX3R5cGUiLCJfcGFyc2luZyIsIl9kYXRhIiwiX29iamVjdERhdGEiLCJfc2hhcmVkT3B0aW9ucyIsIl9kcmF3U3RhcnQiLCJfZHJhd0NvdW50IiwiZW5hYmxlT3B0aW9uU2hhcmluZyIsIiRjb250ZXh0IiwiX3N5bmNMaXN0IiwiaW5pdGlhbGl6ZSIsImxpbmtTY2FsZXMiLCJfc3RhY2tlZCIsImFkZEVsZW1lbnRzIiwidXBkYXRlSW5kZXgiLCJnZXREYXRhc2V0IiwiY2hvb3NlSWQiLCJ4aWQiLCJ4QXhpc0lEIiwieWlkIiwieUF4aXNJRCIsInJpZCIsInJBeGlzSUQiLCJpaWQiLCJpQXhpc0lEIiwidmlkIiwidkF4aXNJRCIsImdldFNjYWxlRm9ySWQiLCJyU2NhbGUiLCJnZXREYXRhc2V0TWV0YSIsInNjYWxlSUQiLCJfZ2V0T3RoZXJTY2FsZSIsInJlc2V0IiwiX2Rlc3Ryb3kiLCJfZGF0YUNoZWNrIiwiaXNFeHRlbnNpYmxlIiwiZGF0YXNldEVsZW1lbnRUeXBlIiwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwicmVzZXROZXdFbGVtZW50cyIsInN0YWNrQ2hhbmdlZCIsIm9sZFN0YWNrZWQiLCJfcmVzeW5jRWxlbWVudHMiLCJzY29wZUtleXMiLCJkYXRhc2V0U2NvcGVLZXlzIiwiZ2V0T3B0aW9uU2NvcGVzIiwiY3JlYXRlUmVzb2x2ZXIiLCJwYXJzZSIsInNvcnRlZCIsIl9zb3J0ZWQiLCJwYXJzZUFycmF5RGF0YSIsInBhcnNlT2JqZWN0RGF0YSIsInBhcnNlUHJpbWl0aXZlRGF0YSIsImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwic2luZ2xlU2NhbGUiLCJ4QXhpc0tleSIsInlBeGlzS2V5IiwiZ2V0UGFyc2VkIiwiZ2V0RGF0YUVsZW1lbnQiLCJ1cGRhdGVSYW5nZUZyb21QYXJzZWQiLCJwYXJzZWRWYWx1ZSIsIk5hTiIsImdldE1pbk1heCIsImNhblN0YWNrIiwib3RoZXJTY2FsZSIsIm90aGVyTWluIiwib3RoZXJNYXgiLCJfc2tpcCIsImdldEFsbFBhcnNlZFZhbHVlcyIsImdldE1heE92ZXJmbG93IiwiZ2V0TGFiZWxBbmRWYWx1ZSIsImxhYmVsIiwiZ2V0TGFiZWxGb3JWYWx1ZSIsIl9jbGlwIiwiY2hhcnRBcmVhIiwiaGlkZGVuIiwicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZGF0YUVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGUiLCJzaGFyaW5nIiwiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCJyZXNvbHZlTmFtZWRPcHRpb25zIiwiZnJlZXplIiwiX3Jlc29sdmVBbmltYXRpb25zIiwidHJhbnNpdGlvbiIsImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCJnZXRTaGFyZWRPcHRpb25zIiwiaW5jbHVkZU9wdGlvbnMiLCJzaGFyZWRPcHRpb25zIiwiX2FuaW1hdGlvbnNEaXNhYmxlZCIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVTaGFyZWRPcHRpb25zIiwiX3NldFN0eWxlIiwicmVtb3ZlSG92ZXJTdHlsZSIsInNldEhvdmVyU3R5bGUiLCJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCJfc2V0RGF0YXNldEhvdmVyU3R5bGUiLCJhcmcxIiwiYXJnMiIsIm51bU1ldGEiLCJudW1EYXRhIiwiX2luc2VydEVsZW1lbnRzIiwiX3JlbW92ZUVsZW1lbnRzIiwibW92ZSIsInVwZGF0ZUVsZW1lbnRzIiwicmVtb3ZlZCIsIl9zeW5jIiwiX29uRGF0YVB1c2giLCJhcmd1bWVudHMiLCJfb25EYXRhUG9wIiwiX29uRGF0YVNoaWZ0IiwiX29uRGF0YVNwbGljZSIsIl9vbkRhdGFVbnNoaWZ0IiwiZ2V0QWxsU2NhbGVWYWx1ZXMiLCJfY2FjaGUiLCIkYmFyIiwibWV0YXMiLCJjb25jYXQiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsIl9sZW5ndGgiLCJjdXJyIiwidXBkYXRlTWluQW5kUHJldiIsImdldFBpeGVsRm9yVmFsdWUiLCJ0aWNrcyIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsInJ1bGVyIiwic3RhY2tDb3VudCIsInRoaWNrbmVzcyIsImJhclRoaWNrbmVzcyIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJjaHVuayIsInBpeGVscyIsImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCJwZXJjZW50IiwicGFyc2VGbG9hdEJhciIsImVudHJ5Iiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiYmFyU3RhcnQiLCJiYXJFbmQiLCJfY3VzdG9tIiwicGFyc2VWYWx1ZSIsInBhcnNlQXJyYXlPclByaW1pdGl2ZSIsImlzRmxvYXRCYXIiLCJjdXN0b20iLCJiYXJTaWduIiwiYWN0dWFsQmFzZSIsImlzSG9yaXpvbnRhbCIsImJvcmRlclByb3BzIiwiaG9yaXpvbnRhbCIsInNldEJvcmRlclNraXBwZWQiLCJlZGdlIiwiYm9yZGVyU2tpcHBlZCIsImVuYWJsZUJvcmRlclJhZGl1cyIsInBhcnNlRWRnZSIsInN3YXAiLCJzdGFydEVuZCIsIm9yaWciLCJ2MiIsIkJhckNvbnRyb2xsZXIiLCJpQXhpc0tleSIsInZBeGlzS2V5IiwiYmFycyIsImdldEJhc2VQaXhlbCIsIl9nZXRSdWxlciIsImZpcnN0T3B0cyIsInZwaXhlbHMiLCJoZWFkIiwiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImNlbnRlciIsIl9nZXRTdGFja3MiLCJncm91cGVkIiwiX2dldFN0YWNrQ291bnQiLCJfZ2V0U3RhY2tJbmRleCIsIl9zdGFydFBpeGVsIiwiX2VuZFBpeGVsIiwiYmFzZVZhbHVlIiwibWluQmFyTGVuZ3RoIiwiZmxvYXRpbmciLCJnZXREYXRhVmlzaWJpbGl0eSIsImhhbGZHcmlkIiwiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCJza2lwTnVsbCIsIm1heEJhclRoaWNrbmVzcyIsIkluZmluaXR5Iiwic3RhY2tJbmRleCIsInJlY3RzIiwiX2luZGV4XyIsIm9mZnNldCIsImdyaWQiLCJfdmFsdWVfIiwiYmVnaW5BdFplcm8iLCJCdWJibGVDb250cm9sbGVyIiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwidG9vbHRpcCIsInRpdGxlIiwiZ2V0UmF0aW9BbmRPZmZzZXQiLCJjaXJjdW1mZXJlbmNlIiwiY3V0b3V0IiwicmF0aW9YIiwicmF0aW9ZIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJjYWxjTWF4IiwiY2FsY01pbiIsIm1heFgiLCJtYXhZIiwibWluWCIsIm1pblkiLCJEb3VnaG51dENvbnRyb2xsZXIiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiX2dldFJvdGF0aW9uIiwiX2dldENpcmN1bWZlcmVuY2UiLCJfZ2V0Um90YXRpb25FeHRlbnRzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImFyY3MiLCJzcGFjaW5nIiwiZ2V0TWF4Qm9yZGVyV2lkdGgiLCJnZXRNYXhPZmZzZXQiLCJtYXhTaXplIiwiY2hhcnRXZWlnaHQiLCJfZ2V0UmluZ1dlaWdodCIsIm1heFJhZGl1cyIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwidG90YWwiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiX2NpcmN1bWZlcmVuY2UiLCJhbmltYXRlUm90YXRlIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImFuaW1hdGlvbk9wdHMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImFuaW1hdGVTY2FsZSIsIm1ldGFEYXRhIiwiYm9yZGVyQWxpZ24iLCJob3ZlckJvcmRlcldpZHRoIiwiaG92ZXJPZmZzZXQiLCJyaW5nV2VpZ2h0T2Zmc2V0IiwibGVnZW5kIiwiZ2VuZXJhdGVMYWJlbHMiLCJsZWdlbmRJdGVtIiwidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImZvcm1hdHRlZFZhbHVlIiwiTGluZUNvbnRyb2xsZXIiLCJfZGF0YXNldCIsImFuaW1hdGlvbnNEaXNhYmxlZCIsImdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJzY2FsZVJhbmdlc0NoYW5nZWQiLCJfZGVjaW1hdGVkIiwiYW5pbWF0ZWQiLCJtYXhHYXBMZW5ndGgiLCJkaXJlY3RVcGRhdGUiLCJwcmV2UGFyc2VkIiwibnVsbERhdGEiLCJib3JkZXIiLCJsYXN0UG9pbnQiLCJ1cGRhdGVDb250cm9sUG9pbnRzIiwicG9pbnRDb3VudCIsIl9zY2FsZVJhbmdlcyIsIm5ld1JhbmdlcyIsInhtaW4iLCJ4bWF4IiwieW1pbiIsInltYXgiLCJjaGFuZ2VkIiwiUG9sYXJBcmVhQ29udHJvbGxlciIsIl91cGRhdGVSYWRpdXMiLCJtaW5TaXplIiwiY3V0b3V0UGVyY2VudGFnZSIsImdldFZpc2libGVEYXRhc2V0Q291bnQiLCJ4Q2VudGVyIiwieUNlbnRlciIsImRhdGFzZXRTdGFydEFuZ2xlIiwiZ2V0SW5kZXhBbmdsZSIsImRlZmF1bHRBbmdsZSIsImNvdW50VmlzaWJsZUVsZW1lbnRzIiwiX2NvbXB1dGVBbmdsZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwiYW5nbGVMaW5lcyIsImRpc3BsYXkiLCJjaXJjdWxhciIsInBvaW50TGFiZWxzIiwiUGllQ29udHJvbGxlciIsIlJhZGFyQ29udHJvbGxlciIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJTY2F0dGVyQ29udHJvbGxlciIsImNvbnRyb2xsZXJzIiwiX19wcm90b19fIiwiYWJzdHJhY3QiLCJEYXRlQWRhcHRlciIsImZvcm1hdHMiLCJ0aW1lc3RhbXAiLCJhbW91bnQiLCJ1bml0IiwiZGlmZiIsInN0YXJ0T2YiLCJ3ZWVrZGF5IiwiZW5kT2YiLCJtZW1iZXJzIiwiYWRhcHRlcnMiLCJfZGF0ZSIsImdldFJlbGF0aXZlUG9zaXRpb24kMSIsImV2YWx1YXRlQWxsVmlzaWJsZUl0ZW1zIiwiaGFuZGxlciIsImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCJiaW5hcnlTZWFyY2giLCJtZXRhc2V0IiwibG9va3VwTWV0aG9kIiwiX3JldmVyc2VQaXhlbHMiLCJnZXRSYW5nZSIsIm9wdGltaXplZEV2YWx1YXRlSXRlbXMiLCJwb3NpdGlvbiIsImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsInVzZVgiLCJ1c2VZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJ1c2VGaW5hbFBvc2l0aW9uIiwiX21pblBhZGRpbmciLCJldmFsdWF0aW9uRnVuYyIsImluUmFuZ2UiLCJnZXROZWFyZXN0SXRlbXMiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiZ2V0Q2VudGVyUG9pbnQiLCJnZXRBeGlzSXRlbXMiLCJyYW5nZU1ldGhvZCIsImludGVyc2VjdHNJdGVtIiwiSW50ZXJhY3Rpb24iLCJtb2RlcyIsIm5lYXJlc3QiLCJTVEFUSUNfUE9TSVRJT05TIiwiZmlsdGVyQnlQb3NpdGlvbiIsImZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyIsInNvcnRCeVdlaWdodCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJzdGFja1dlaWdodCIsImJ1aWxkU3RhY2tzIiwibGF5b3V0cyIsIndyYXAiLCJwbGFjZWQiLCJzZXRMYXlvdXREaW1zIiwicGFyYW1zIiwidkJveE1heFdpZHRoIiwiaEJveE1heEhlaWdodCIsImxheW91dCIsImZ1bGxTaXplIiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJidWlsZExheW91dEJveGVzIiwiY2VudGVySG9yaXpvbnRhbCIsImNlbnRlclZlcnRpY2FsIiwibGVmdEFuZFRvcCIsInJpZ2h0QW5kQm90dG9tIiwidmVydGljYWwiLCJnZXRDb21iaW5lZE1heCIsIm1heFBhZGRpbmciLCJ1cGRhdGVNYXhQYWRkaW5nIiwiYm94UGFkZGluZyIsInVwZGF0ZURpbXMiLCJnZXRQYWRkaW5nIiwibmV3V2lkdGgiLCJvdXRlcldpZHRoIiwibmV3SGVpZ2h0Iiwib3V0ZXJIZWlnaHQiLCJ3aWR0aENoYW5nZWQiLCJoZWlnaHRDaGFuZ2VkIiwic2FtZSIsIm90aGVyIiwiaGFuZGxlTWF4UGFkZGluZyIsInVwZGF0ZVBvcyIsImNoYW5nZSIsImdldE1hcmdpbnMiLCJtYXJnaW5Gb3JQb3NpdGlvbnMiLCJmaXRCb3hlcyIsInJlZml0Qm94ZXMiLCJyZWZpdCIsInNldEJveERpbXMiLCJwbGFjZUJveGVzIiwidXNlclBhZGRpbmciLCJwYWRkaW5nIiwiYWRkQm94IiwiX2xheWVycyIsInoiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwibWluUGFkZGluZyIsInZlcnRpY2FsQm94ZXMiLCJob3Jpem9udGFsQm94ZXMiLCJiZWZvcmVMYXlvdXQiLCJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsIkJhc2VQbGF0Zm9ybSIsImFjcXVpcmVDb250ZXh0IiwicmVsZWFzZUNvbnRleHQiLCJpc0F0dGFjaGVkIiwiQmFzaWNQbGF0Zm9ybSIsIkVYUEFORE9fS0VZIiwiRVZFTlRfVFlQRVMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm91dCIsImlzTnVsbE9yRW1wdHkiLCJpbml0Q2FudmFzIiwicmVuZGVySGVpZ2h0IiwiZ2V0QXR0cmlidXRlIiwicmVuZGVyV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiZnJvbU5hdGl2ZUV2ZW50IiwiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiYWRkZWROb2RlcyIsImFkZGVkIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjcmVhdGVEZXRhY2hPYnNlcnZlciIsInJlbW92ZWROb2RlcyIsImRycExpc3RlbmluZ0NoYXJ0cyIsIm9sZERldmljZVBpeGVsUmF0aW8iLCJvbldpbmRvd1Jlc2l6ZSIsImRwciIsImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsImNyZWF0ZVJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJjb250ZW50UmVjdCIsInJlbGVhc2VPYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJjcmVhdGVQcm94eUFuZExpc3RlbiIsIkRvbVBsYXRmb3JtIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicHJveGllcyIsIiRwcm94aWVzIiwiaGFuZGxlcnMiLCJhdHRhY2giLCJkZXRhY2giLCJpc0Nvbm5lY3RlZCIsIl9kZXRlY3RQbGF0Zm9ybSIsIk9mZnNjcmVlbkNhbnZhcyIsIkVsZW1lbnQiLCJ0b29sdGlwUG9zaXRpb24iLCJnZXRQcm9wcyIsImhhc1ZhbHVlIiwiZmluYWwiLCJkZWZhdWx0Um91dGVzIiwiZm9ybWF0dGVycyIsIm51bWVyaWMiLCJ0aWNrVmFsdWUiLCJub3RhdGlvbiIsIm1heFRpY2siLCJjYWxjdWxhdGVEZWx0YSIsImxvZ0RlbHRhIiwibnVtRGVjaW1hbCIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImxvZ2FyaXRobWljIiwiVGlja3MiLCJkcmF3Qm9yZGVyIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja0xlbmd0aCIsInRpY2tXaWR0aCIsInRpY2tDb2xvciIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJtaXJyb3IiLCJ0ZXh0U3Ryb2tlV2lkdGgiLCJ0ZXh0U3Ryb2tlQ29sb3IiLCJhdXRvU2tpcCIsImF1dG9Ta2lwUGFkZGluZyIsImxhYmVsT2Zmc2V0IiwibWlub3IiLCJtYWpvciIsImNyb3NzQWxpZ24iLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wQ29sb3IiLCJiYWNrZHJvcFBhZGRpbmciLCJ0aWNrT3B0cyIsInRpY2tzTGltaXQiLCJtYXhUaWNrc0xpbWl0IiwiZGV0ZXJtaW5lTWF4VGlja3MiLCJtYWpvckluZGljZXMiLCJlbmFibGVkIiwiZ2V0TWFqb3JJbmRpY2VzIiwibnVtTWFqb3JJbmRpY2VzIiwiZmlyc3QiLCJuZXdUaWNrcyIsInNraXBNYWpvcnMiLCJjYWxjdWxhdGVTcGFjaW5nIiwiYXZnTWFqb3JTcGFjaW5nIiwiX3RpY2tTaXplIiwibWF4U2NhbGUiLCJtYXhDaGFydCIsIl9tYXhMZW5ndGgiLCJldmVuTWFqb3JTcGFjaW5nIiwiZ2V0RXZlblNwYWNpbmciLCJmYWN0b3JzIiwiY2VpbCIsIm1ham9yU3RhcnQiLCJtYWpvckVuZCIsInJldmVyc2VBbGlnbiIsIm9mZnNldEZyb21FZGdlIiwic2FtcGxlIiwibnVtSXRlbXMiLCJpbmNyZW1lbnQiLCJnZXRQaXhlbEZvckdyaWRMaW5lIiwib2Zmc2V0R3JpZExpbmVzIiwidmFsaWRJbmRleCIsImxpbmVWYWx1ZSIsImNhY2hlcyIsImdldFRpY2tNYXJrTGVuZ3RoIiwiZ2V0VGl0bGVIZWlnaHQiLCJjcmVhdGVTY2FsZUNvbnRleHQiLCJjcmVhdGVUaWNrQ29udGV4dCIsInRpdGxlQWxpZ24iLCJ0aXRsZUFyZ3MiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJwb3NpdGlvbkF4aXNJRCIsIlNjYWxlIiwiX21hcmdpbnMiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwibGFiZWxSb3RhdGlvbiIsIl9yYW5nZSIsIl9ncmlkTGluZUl0ZW1zIiwiX2xhYmVsSXRlbXMiLCJfbGFiZWxTaXplcyIsIl9sb25nZXN0VGV4dENhY2hlIiwiX3VzZXJNYXgiLCJfdXNlck1pbiIsIl9zdWdnZXN0ZWRNYXgiLCJfc3VnZ2VzdGVkTWluIiwiX3RpY2tzTGVuZ3RoIiwiX2JvcmRlclZhbHVlIiwiX2RhdGFMaW1pdHNDYWNoZWQiLCJpbml0Iiwic3VnZ2VzdGVkTWluIiwic3VnZ2VzdGVkTWF4IiwiZ2V0VGlja3MiLCJ4TGFiZWxzIiwieUxhYmVscyIsImJlZm9yZVVwZGF0ZSIsInNhbXBsZVNpemUiLCJiZWZvcmVTZXREaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsImFmdGVyU2V0RGltZW5zaW9ucyIsImJlZm9yZURhdGFMaW1pdHMiLCJkZXRlcm1pbmVEYXRhTGltaXRzIiwiYWZ0ZXJEYXRhTGltaXRzIiwiYmVmb3JlQnVpbGRUaWNrcyIsImJ1aWxkVGlja3MiLCJhZnRlckJ1aWxkVGlja3MiLCJzYW1wbGluZ0VuYWJsZWQiLCJfY29udmVydFRpY2tzVG9MYWJlbHMiLCJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwiY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImJlZm9yZUZpdCIsImZpdCIsImFmdGVyRml0IiwiYWZ0ZXJVcGRhdGUiLCJyZXZlcnNlUGl4ZWxzIiwic3RhcnRQaXhlbCIsImVuZFBpeGVsIiwiX2FsaWduVG9QaXhlbHMiLCJhbGlnblRvUGl4ZWxzIiwiX2NhbGxIb29rcyIsIm5vdGlmeVBsdWdpbnMiLCJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJnZW5lcmF0ZVRpY2tMYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsIm51bVRpY2tzIiwibWF4TGFiZWxEaWFnb25hbCIsIl9pc1Zpc2libGUiLCJsYWJlbFNpemVzIiwiX2dldExhYmVsU2l6ZXMiLCJtYXhMYWJlbFdpZHRoIiwid2lkZXN0IiwibWF4TGFiZWxIZWlnaHQiLCJoaWdoZXN0IiwiYXNpbiIsInRpdGxlT3B0cyIsImdyaWRPcHRzIiwidGl0bGVIZWlnaHQiLCJ0aWNrUGFkZGluZyIsImFuZ2xlUmFkaWFucyIsImxhYmVsSGVpZ2h0IiwibGFiZWxXaWR0aCIsIl9jYWxjdWxhdGVQYWRkaW5nIiwiX2hhbmRsZU1hcmdpbnMiLCJpc1JvdGF0ZWQiLCJsYWJlbHNCZWxvd1RpY2tzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaXNGdWxsU2l6ZSIsIl9jb21wdXRlTGFiZWxTaXplcyIsIndpZHRocyIsImhlaWdodHMiLCJ3aWRlc3RMYWJlbFNpemUiLCJoaWdoZXN0TGFiZWxTaXplIiwidGlja0ZvbnQiLCJuZXN0ZWRMYWJlbCIsIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwidmFsdWVBdCIsImdldFZhbHVlRm9yUGl4ZWwiLCJkZWNpbWFsIiwiZ2V0RGVjaW1hbEZvclBpeGVsIiwiZ2V0QmFzZVZhbHVlIiwib3B0aW9uVGlja3MiLCJyb3QiLCJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCJ0aWNrc0xlbmd0aCIsInRsIiwiYm9yZGVyT3B0cyIsImF4aXNXaWR0aCIsImF4aXNIYWxmV2lkdGgiLCJhbGlnbkJvcmRlclZhbHVlIiwiYm9yZGVyVmFsdWUiLCJhbGlnbmVkTGluZVZhbHVlIiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJsaW1pdCIsInN0ZXAiLCJvcHRzQXRJbmRleCIsImxpbmVDb2xvciIsInRpY2tCb3JkZXJEYXNoIiwidGlja0JvcmRlckRhc2hPZmZzZXQiLCJfY29tcHV0ZUxhYmVsSXRlbXMiLCJ0aWNrQW5kUGFkZGluZyIsImhUaWNrQW5kUGFkZGluZyIsImxpbmVDb3VudCIsInRleHRPZmZzZXQiLCJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwiaGFsZkNvdW50IiwiYmFja2Ryb3AiLCJsYWJlbFBhZGRpbmciLCJfY29tcHV0ZUxhYmVsQXJlYSIsImRyYXdCYWNrZ3JvdW5kIiwiZmlsbFJlY3QiLCJmaW5kSW5kZXgiLCJkcmF3R3JpZCIsImRyYXdMaW5lIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsImxhc3RMaW5lV2lkdGgiLCJkcmF3TGFiZWxzIiwiZHJhd1RpdGxlIiwidHoiLCJneiIsImF4aXNJRCIsIl9tYXhEaWdpdHMiLCJmb250U2l6ZSIsIlR5cGVkUmVnaXN0cnkiLCJpc0ZvclR5cGUiLCJpc1Byb3RvdHlwZU9mIiwicmVnaXN0ZXIiLCJwYXJlbnRTY29wZSIsImlzSUNoYXJ0Q29tcG9uZW50IiwicmVnaXN0ZXJEZWZhdWx0cyIsInVucmVnaXN0ZXIiLCJpdGVtRGVmYXVsdHMiLCJyb3V0ZURlZmF1bHRzIiwicm91dGVzIiwicHJvcGVydHlQYXJ0cyIsInNvdXJjZU5hbWUiLCJzb3VyY2VTY29wZSIsInBhcnRzIiwiUmVnaXN0cnkiLCJfdHlwZWRSZWdpc3RyaWVzIiwiX2VhY2giLCJhZGRDb250cm9sbGVycyIsImFkZFBsdWdpbnMiLCJhZGRTY2FsZXMiLCJnZXRDb250cm9sbGVyIiwiX2dldCIsImdldEVsZW1lbnQiLCJnZXRQbHVnaW4iLCJnZXRTY2FsZSIsInJlbW92ZUNvbnRyb2xsZXJzIiwicmVtb3ZlRWxlbWVudHMiLCJyZW1vdmVQbHVnaW5zIiwicmVtb3ZlU2NhbGVzIiwidHlwZWRSZWdpc3RyeSIsImFyZyIsInJlZyIsIl9nZXRSZWdpc3RyeUZvclR5cGUiLCJfZXhlYyIsIml0ZW1SZWciLCJyZWdpc3RyeSIsImNvbXBvbmVudCIsImNhbWVsTWV0aG9kIiwiUGx1Z2luU2VydmljZSIsIl9pbml0Iiwibm90aWZ5IiwiaG9vayIsIl9jcmVhdGVEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJwbHVnaW4iLCJjYW5jZWxhYmxlIiwiaW52YWxpZGF0ZSIsIl9vbGRDYWNoZSIsIl9ub3RpZnlTdGF0ZUNoYW5nZXMiLCJhbGxQbHVnaW5zIiwiY3JlYXRlRGVzY3JpcHRvcnMiLCJwcmV2aW91c0Rlc2NyaXB0b3JzIiwic29tZSIsImdldE9wdHMiLCJwbHVnaW5PcHRzIiwicGx1Z2luU2NvcGVLZXlzIiwiZ2V0SW5kZXhBeGlzIiwiZGF0YXNldERlZmF1bHRzIiwiZGF0YXNldE9wdGlvbnMiLCJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwiZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyIsImF4aXNGcm9tUG9zaXRpb24iLCJkZXRlcm1pbmVBeGlzIiwic2NhbGVPcHRpb25zIiwibWVyZ2VTY2FsZUNvbmZpZyIsImNoYXJ0RGVmYXVsdHMiLCJjb25maWdTY2FsZXMiLCJjaGFydEluZGV4QXhpcyIsImZpcnN0SURzIiwic2NhbGVDb25mIiwiZGVmYXVsdElkIiwiZGVmYXVsdFNjYWxlT3B0aW9ucyIsImRlZmF1bHRJRCIsImluaXRPcHRpb25zIiwiaW5pdERhdGEiLCJpbml0Q29uZmlnIiwia2V5Q2FjaGUiLCJrZXlzQ2FjaGVkIiwiY2FjaGVkS2V5cyIsImdlbmVyYXRlIiwiYWRkSWZGb3VuZCIsIkNvbmZpZyIsIl9jb25maWciLCJfc2NvcGVDYWNoZSIsIl9yZXNvbHZlckNhY2hlIiwiY2xlYXJDYWNoZSIsImNsZWFyIiwiZGF0YXNldFR5cGUiLCJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwiX2NhY2hlZFNjb3BlcyIsIm1haW5TY29wZSIsInJlc2V0Q2FjaGUiLCJrZXlMaXN0cyIsImNoYXJ0T3B0aW9uU2NvcGVzIiwic3ViUHJlZml4ZXMiLCJnZXRSZXNvbHZlciIsIm5lZWRDb250ZXh0Iiwic3ViUmVzb2x2ZXIiLCJyZXNvbHZlckNhY2hlIiwidmVyc2lvbiIsIktOT1dOX1BPU0lUSU9OUyIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29tcGFyZTJMZXZlbCIsImwxIiwibDIiLCJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsIm9uQ29tcGxldGUiLCJvbkFuaW1hdGlvblByb2dyZXNzIiwib25Qcm9ncmVzcyIsImdldENhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwiaW5zdGFuY2VzIiwiZ2V0Q2hhcnQiLCJDaGFydCIsInVzZXJDb25maWciLCJpbml0aWFsQ2FudmFzIiwiZXhpc3RpbmdDaGFydCIsIl9vcHRpb25zIiwiX2FzcGVjdFJhdGlvIiwiX21ldGFzZXRzIiwiX2xhc3RFdmVudCIsIl9saXN0ZW5lcnMiLCJfcmVzcG9uc2l2ZUxpc3RlbmVycyIsIl9zb3J0ZWRNZXRhc2V0cyIsIl9wbHVnaW5zIiwiX2hpZGRlbkluZGljZXMiLCJhdHRhY2hlZCIsIl9kb1Jlc2l6ZSIsInJlc2l6ZURlbGF5IiwiZXJyb3IiLCJfaW5pdGlhbGl6ZSIsImJpbmRFdmVudHMiLCJfcmVzaXplIiwiX3Jlc2l6ZUJlZm9yZURyYXciLCJuZXdTaXplIiwibmV3UmF0aW8iLCJvblJlc2l6ZSIsInJlbmRlciIsImVuc3VyZVNjYWxlc0hhdmVJRHMiLCJzY2FsZXNPcHRpb25zIiwiYXhpc09wdGlvbnMiLCJidWlsZE9yVXBkYXRlU2NhbGVzIiwic2NhbGVPcHRzIiwidXBkYXRlZCIsImlzUmFkaWFsIiwiZHBvc2l0aW9uIiwiZHR5cGUiLCJzY2FsZVR5cGUiLCJzY2FsZUNsYXNzIiwiaGFzVXBkYXRlZCIsIl91cGRhdGVNZXRhc2V0cyIsIl9kZXN0cm95RGF0YXNldE1ldGEiLCJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsIm9yZGVyIiwiQ29udHJvbGxlckNsYXNzIiwiX3Jlc2V0RWxlbWVudHMiLCJhbmltc0Rpc2FibGVkIiwiZXhpc3RpbmdFdmVudHMiLCJuZXdFdmVudHMiLCJ1bmJpbmRFdmVudHMiLCJfdXBkYXRlTGF5b3V0IiwiX3VwZGF0ZURhdGFzZXRzIiwiX2V2ZW50SGFuZGxlciIsIm5vQXJlYSIsIl9pZHgiLCJfdXBkYXRlRGF0YXNldCIsImxheWVycyIsIl9kcmF3RGF0YXNldHMiLCJfZHJhd0RhdGFzZXQiLCJ1c2VDbGlwIiwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsInNldERhdGFzZXRWaXNpYmlsaXR5IiwiX3VwZGF0ZVZpc2liaWxpdHkiLCJkZXN0cm95IiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsImJpbmRVc2VyRXZlbnRzIiwiYmluZFJlc3BvbnNpdmVFdmVudHMiLCJfYWRkIiwiX3JlbW92ZSIsImRldGFjaGVkIiwidXBkYXRlSG92ZXJTdHlsZSIsImdldEFjdGl2ZUVsZW1lbnRzIiwic2V0QWN0aXZlRWxlbWVudHMiLCJhY3RpdmVFbGVtZW50cyIsImxhc3RBY3RpdmUiLCJfdXBkYXRlSG92ZXJTdHlsZXMiLCJyZXBsYXkiLCJob3Zlck9wdGlvbnMiLCJkZWFjdGl2YXRlZCIsImFjdGl2YXRlZCIsImV2ZW50RmlsdGVyIiwiX2hhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwiaW52YWxpZGF0ZVBsdWdpbnMiLCJjbGlwQXJjIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsInRvUmFkaXVzQ29ybmVycyIsInBhcnNlQm9yZGVyUmFkaXVzJDEiLCJhbmdsZURlbHRhIiwibyIsImJvcmRlclJhZGl1cyIsImhhbGZUaGlja25lc3MiLCJpbm5lckxpbWl0IiwiY29tcHV0ZU91dGVyTGltaXQiLCJvdXRlckFyY0xpbWl0Iiwib3V0ZXJTdGFydCIsIm91dGVyRW5kIiwiaW5uZXJTdGFydCIsImlubmVyRW5kIiwiclRoZXRhVG9YWSIsInRoZXRhIiwicGF0aEFyYyIsImlubmVyUiIsInNwYWNpbmdPZmZzZXQiLCJub1NwYWNpbmdJbm5lclJhZGl1cyIsIm5vU3BhY2luZ091dGVyUmFkaXVzIiwiYXZOb2dTcGFjaW5nUmFkaXVzIiwiYWRqdXN0ZWRBbmdsZSIsImJldGEiLCJhbmdsZU9mZnNldCIsIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsInBDZW50ZXIiLCJwNCIsInA4IiwiZHJhd0FyYyIsImZ1bGxDaXJjbGVzIiwiZHJhd0Z1bGxDaXJjbGVCb3JkZXJzIiwiaW5uZXIiLCJsaW5lSm9pbiIsIkFyY0VsZW1lbnQiLCJjaGFydFgiLCJjaGFydFkiLCJyQWRqdXN0IiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJyYWRpdXNPZmZzZXQiLCJzZXRTdHlsZSIsImxpbmVDYXAiLCJnZXRMaW5lTWV0aG9kIiwic3RlcHBlZCIsInBhdGhWYXJzIiwicGFyYW1zU3RhcnQiLCJwYXJhbXNFbmQiLCJzZWdtZW50U3RhcnQiLCJzZWdtZW50RW5kIiwib3V0c2lkZSIsInBhdGhTZWdtZW50IiwibGluZU1ldGhvZCIsImZhc3RQYXRoU2VnbWVudCIsImF2Z1giLCJjb3VudFgiLCJwcmV2WCIsImxhc3RZIiwicG9pbnRJbmRleCIsImRyYXdYIiwidHJ1bmNYIiwiX2dldFNlZ21lbnRNZXRob2QiLCJ1c2VGYXN0UGF0aCIsIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwic3Ryb2tlUGF0aFdpdGhDYWNoZSIsInBhdGgiLCJfcGF0aCIsIlBhdGgyRCIsInN0cm9rZVBhdGhEaXJlY3QiLCJzZWdtZW50TWV0aG9kIiwidXNlUGF0aDJEIiwiTGluZUVsZW1lbnQiLCJfcG9pbnRzIiwiX3NlZ21lbnRzIiwiX3BvaW50c1VwZGF0ZWQiLCJpbnRlcnBvbGF0ZSIsIl9pbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImluUmFuZ2UkMSIsImhpdFJhZGl1cyIsIlBvaW50RWxlbWVudCIsIm1vdXNlWCIsIm1vdXNlWSIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJob3ZlclJhZGl1cyIsImdldEJhckJvdW5kcyIsImJhciIsImhhbGYiLCJza2lwT3JMaW1pdCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsInBhcnNlQm9yZGVyUmFkaXVzIiwibWF4UiIsImVuYWJsZUJvcmRlciIsImJvdW5kaW5nUmVjdHMiLCJvdXRlciIsInNraXBYIiwic2tpcFkiLCJza2lwQm90aCIsImhhc1JhZGl1cyIsImFkZE5vcm1hbFJlY3RQYXRoIiwiaW5mbGF0ZVJlY3QiLCJyZWZSZWN0IiwiQmFyRWxlbWVudCIsImFkZFJlY3RQYXRoIiwiaW5mbGF0ZUFtb3VudCIsImx0dGJEZWNpbWF0aW9uIiwic2FtcGxlcyIsImRlY2ltYXRlZCIsImJ1Y2tldFdpZHRoIiwic2FtcGxlZEluZGV4IiwiZW5kSW5kZXgiLCJtYXhBcmVhUG9pbnQiLCJtYXhBcmVhIiwibmV4dEEiLCJhdmdZIiwiYXZnUmFuZ2VTdGFydCIsImF2Z1JhbmdlRW5kIiwiYXZnUmFuZ2VMZW5ndGgiLCJyYW5nZU9mZnMiLCJyYW5nZVRvIiwicG9pbnRBeCIsInBvaW50QXkiLCJtaW5NYXhEZWNpbWF0aW9uIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInN0YXJ0SW5kZXgiLCJ4TWluIiwieE1heCIsImR4IiwibGFzdEluZGV4IiwiaW50ZXJtZWRpYXRlSW5kZXgxIiwiaW50ZXJtZWRpYXRlSW5kZXgyIiwiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwiY2xlYW5EZWNpbWF0ZWREYXRhIiwiZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQiLCJwbHVnaW5fZGVjaW1hdGlvbiIsImFsZ29yaXRobSIsImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwieEF4aXMiLCJ0aHJlc2hvbGQiLCJnZXRMaW5lQnlJbmRleCIsInBhcnNlRmlsbE9wdGlvbiIsImZpbGxPcHRpb24iLCJkZWNvZGVGaWxsIiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5Iiwic2ltcGxlQXJjIiwiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCJjb21wdXRlQm91bmRhcnkiLCJmaW5kU2VnbWVudEVuZCIsInBvaW50c0Zyb21TZWdtZW50cyIsImJvdW5kYXJ5IiwibGluZVBvaW50cyIsImJ1aWxkU3RhY2tMaW5lIiwic291cmNlUG9pbnRzIiwibGluZXNCZWxvdyIsImdldExpbmVzQmVsb3ciLCJjcmVhdGVCb3VuZGFyeUxpbmUiLCJhZGRQb2ludHNCZWxvdyIsImlzTGluZUFuZE5vdEluSGlkZUFuaW1hdGlvbiIsImJlbG93IiwidW5zaGlmdCIsInNvdXJjZVBvaW50IiwicG9zdHBvbmVkIiwiZmluZFBvaW50IiwicG9pbnRWYWx1ZSIsImZpcnN0VmFsdWUiLCJsYXN0VmFsdWUiLCJyZXNvbHZlVGFyZ2V0IiwicHJvcGFnYXRlIiwidmlzaXRlZCIsImNsaXBZIiwiZ2V0Qm91bmRzIiwiX2dldEVkZ2UiLCJ0cG9pbnRzIiwidGFyZ2V0U2VnbWVudHMiLCJ0Z3QiLCJzdWJCb3VuZHMiLCJmaWxsU291cmNlcyIsImZpbGxTb3VyY2UiLCJjbGlwQm91bmRzIiwiaW50ZXJwb2xhdGVkTGluZVRvIiwiaW50ZXJwb2xhdGVkUG9pbnQiLCJfZmlsbCIsInNyYyIsIm5vdFNoYXBlIiwibGluZUxvb3AiLCJ0YXJnZXRMb29wIiwiZG9GaWxsIiwiYWJvdmUiLCJkcmF3ZmlsbCIsImxpbmVPcHRzIiwicGx1Z2luX2ZpbGxlciIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCJfYXJncyIsIiRmaWxsZXIiLCJiZWZvcmVEcmF3IiwiZHJhd1RpbWUiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJiZWZvcmVEYXRhc2V0RHJhdyIsImdldEJveFNpemUiLCJsYWJlbE9wdHMiLCJib3hIZWlnaHQiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJpdGVtSGVpZ2h0IiwiaXRlbXNFcXVhbCIsIkxlZ2VuZCIsIl9hZGRlZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwibGVnZW5kSXRlbXMiLCJjb2x1bW5TaXplcyIsImxpbmVXaWR0aHMiLCJidWlsZExhYmVscyIsImxhYmVsRm9udCIsIl9jb21wdXRlVGl0bGVIZWlnaHQiLCJfZml0Um93cyIsIl9maXRDb2xzIiwiaGl0Ym94ZXMiLCJ0b3RhbEhlaWdodCIsInJvdyIsImhlaWdodExpbWl0IiwidG90YWxXaWR0aCIsImN1cnJlbnRDb2xXaWR0aCIsImN1cnJlbnRDb2xIZWlnaHQiLCJjb2wiLCJhZGp1c3RIaXRCb3hlcyIsInJ0bEhlbHBlciIsImhpdGJveCIsIl9kcmF3IiwiZGVmYXVsdENvbG9yIiwiZm9udENvbG9yIiwiaGFsZkZvbnRTaXplIiwiY3Vyc29yIiwiZHJhd0xlZ2VuZEJveCIsImxpbmVEYXNoIiwiZHJhd09wdGlvbnMiLCJTUVJUMiIsInlCb3hUb3AiLCJ4Qm94TGVmdCIsInRleHREaXJlY3Rpb24iLCJyZWFsWCIsInRpdGxlRm9udCIsInRpdGxlUGFkZGluZyIsInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaGFuZGxlRXZlbnQiLCJpc0xpc3RlbmVkIiwiaG92ZXJlZEl0ZW0iLCJzYW1lSXRlbSIsIm9uTGVhdmUiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJhZnRlckV2ZW50IiwiY2kiLCJUaXRsZSIsIl9wYWRkaW5nIiwidGV4dFNpemUiLCJfZHJhd0FyZ3MiLCJmb250T3B0cyIsImNyZWF0ZVRpdGxlIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIldlYWtNYXAiLCJwbHVnaW5fc3VidGl0bGUiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsInNwbGl0TmV3bGluZXMiLCJTdHJpbmciLCJjcmVhdGVUb29sdGlwSXRlbSIsImdldFRvb2x0aXBTaXplIiwiYm9keSIsImZvb3RlciIsImJvZHlGb250IiwiZm9vdGVyRm9udCIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50IiwiYm9keUxpbmVJdGVtQ291bnQiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlQm9keSIsImFmdGVyQm9keSIsInRpdGxlU3BhY2luZyIsInRpdGxlTWFyZ2luQm90dG9tIiwiYm9keUxpbmVIZWlnaHQiLCJkaXNwbGF5Q29sb3JzIiwiYm9keVNwYWNpbmciLCJmb290ZXJNYXJnaW5Ub3AiLCJmb290ZXJTcGFjaW5nIiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwiZGV0ZXJtaW5lWUFsaWduIiwiZG9lc05vdEZpdFdpdGhBbGlnbiIsInhBbGlnbiIsImNhcmV0IiwiY2FyZXRTaXplIiwiY2FyZXRQYWRkaW5nIiwiZGV0ZXJtaW5lWEFsaWduIiwieUFsaWduIiwiY2hhcnRXaWR0aCIsImRldGVybWluZUFsaWdubWVudCIsImFsaWduWCIsImFsaWduWSIsInBhZGRpbmdBbmRTaXplIiwiZ2V0QmFja2dyb3VuZFBvaW50IiwiYWxpZ25tZW50IiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJjcmVhdGVUb29sdGlwQ29udGV4dCIsInRvb2x0aXBJdGVtcyIsIm92ZXJyaWRlQ2FsbGJhY2tzIiwiVG9vbHRpcCIsIm9wYWNpdHkiLCJfZXZlbnRQb3NpdGlvbiIsIl9zaXplIiwiX2NhY2hlZEFuaW1hdGlvbnMiLCJfdG9vbHRpcEl0ZW1zIiwiZGF0YVBvaW50cyIsImNhcmV0WCIsImNhcmV0WSIsImxhYmVsQ29sb3JzIiwibGFiZWxQb2ludFN0eWxlcyIsImxhYmVsVGV4dENvbG9ycyIsImdldFRpdGxlIiwiYmVmb3JlVGl0bGUiLCJhZnRlclRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJzY29wZWQiLCJiZWZvcmVMYWJlbCIsImFmdGVyTGFiZWwiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJiZWZvcmVGb290ZXIiLCJhZnRlckZvb3RlciIsIl9jcmVhdGVJdGVtcyIsIml0ZW1Tb3J0IiwibGFiZWxDb2xvciIsImxhYmVsUG9pbnRTdHlsZSIsImxhYmVsVGV4dENvbG9yIiwicG9zaXRpb25BbmRTaXplIiwiYmFja2dyb3VuZFBvaW50IiwiZXh0ZXJuYWwiLCJkcmF3Q2FyZXQiLCJ0b29sdGlwUG9pbnQiLCJjYXJldFBvc2l0aW9uIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIngzIiwieTMiLCJwdFgiLCJwdFkiLCJ0aXRsZUNvbG9yIiwiX2RyYXdDb2xvckJveCIsImNvbG9yWCIsInJ0bENvbG9yWCIsInlPZmZTZXQiLCJjb2xvclkiLCJtdWx0aUtleUJhY2tncm91bmQiLCJvdXRlclgiLCJpbm5lclgiLCJzdHJva2VSZWN0IiwiZHJhd0JvZHkiLCJib2R5QWxpZ24iLCJ4TGluZVBhZGRpbmciLCJmaWxsTGluZU9mVGV4dCIsImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwidGV4dENvbG9yIiwiYm9keUNvbG9yIiwiZHJhd0Zvb3RlciIsImZvb3RlckFsaWduIiwiZm9vdGVyQ29sb3IiLCJ0b29sdGlwU2l6ZSIsInF1YWRyYXRpY0N1cnZlVG8iLCJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwiYW5pbVgiLCJhbmltWSIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJwb3NpdGlvbkNoYW5nZWQiLCJfcG9zaXRpb25DaGFuZ2VkIiwicGx1Z2luX3Rvb2x0aXAiLCJhZnRlckluaXQiLCJhZnRlckRyYXciLCJsYWJlbENvdW50IiwiRGVjaW1hdGlvbiIsIkZpbGxlciIsIlN1YlRpdGxlIiwiYWRkSWZTdHJpbmciLCJmaW5kT3JBZGRMYWJlbCIsImxhc3RJbmRleE9mIiwiQ2F0ZWdvcnlTY2FsZSIsIl9zdGFydFZhbHVlIiwiX3ZhbHVlUmFuZ2UiLCJnZW5lcmF0ZVRpY2tzJDEiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwicHJlY2lzaW9uIiwibWF4VGlja3MiLCJtYXhEaWdpdHMiLCJpbmNsdWRlQm91bmRzIiwibWF4U3BhY2VzIiwicm1pbiIsInJtYXgiLCJjb3VudERlZmluZWQiLCJtaW5TcGFjaW5nIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJkZWNpbWFsUGxhY2VzIiwicmVsYXRpdmVMYWJlbFNpemUiLCJMaW5lYXJTY2FsZUJhc2UiLCJfZW5kVmFsdWUiLCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwic2V0TWluIiwic2V0TWF4IiwibWluU2lnbiIsIm1heFNpZ24iLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsImdldFRpY2tMaW1pdCIsInN0ZXBTaXplIiwiY29tcHV0ZVRpY2tMaW1pdCIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiTGluZWFyU2NhbGUiLCJpc01ham9yIiwidGlja1ZhbCIsImdlbmVyYXRlVGlja3MiLCJlbmRFeHAiLCJlbmRTaWduaWZpY2FuZCIsImV4cCIsInNpZ25pZmljYW5kIiwibGFzdFRpY2siLCJMb2dhcml0aG1pY1NjYWxlIiwiX3plcm8iLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludExhYmVsQ29udGV4dCIsImdldFBvaW50UG9zaXRpb24iLCJkcmF3aW5nQXJlYSIsInBsRm9udCIsIl9wb2ludExhYmVscyIsImhMaW1pdHMiLCJ2TGltaXRzIiwiX3NldFJlZHVjdGlvbnMiLCJfcG9pbnRMYWJlbEl0ZW1zIiwiYnVpbGRQb2ludExhYmVsSXRlbXMiLCJ0aWNrQmFja2Ryb3BIZWlnaHQiLCJvdXRlckRpc3RhbmNlIiwiZXh0cmEiLCJwb2ludExhYmVsUG9zaXRpb24iLCJ5Rm9yQW5nbGUiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImxlZnRGb3JUZXh0QWxpZ24iLCJkcmF3UG9pbnRMYWJlbHMiLCJwYXRoUmFkaXVzTGluZSIsImRyYXdSYWRpdXNMaW5lIiwiZ3JpZExpbmVPcHRzIiwicGFyYW0iLCJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsIlJhZGlhbExpbmVhclNjYWxlIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsInNjYWxlZERpc3RhbmNlIiwicG9pbnRMYWJlbCIsImRpc3RhbmNlRnJvbUNlbnRlciIsImdldEJhc2VQb3NpdGlvbiIsImdldFBvaW50TGFiZWxQb3NpdGlvbiIsImFuaW1hdGUiLCJJTlRFUlZBTFMiLCJtaWxsaXNlY29uZCIsImNvbW1vbiIsInN0ZXBzIiwic2Vjb25kIiwibWludXRlIiwiaG91ciIsImRheSIsIndlZWsiLCJtb250aCIsInF1YXJ0ZXIiLCJ5ZWFyIiwiVU5JVFMiLCJzb3J0ZXIiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJpc29XZWVrZGF5IiwiX3BhcnNlT3B0cyIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwiYWRkVGljayIsInRpbWUiLCJ0aW1lc3RhbXBzIiwic2V0TWFqb3JUaWNrcyIsIm1ham9yVW5pdCIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJUaW1lU2NhbGUiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfb2Zmc2V0cyIsIl9ub3JtYWxpemVkIiwiZGlzcGxheUZvcm1hdHMiLCJub3JtYWxpemVkIiwiX2FwcGx5Qm91bmRzIiwiX2dldExhYmVsQm91bmRzIiwiZ2V0TGFiZWxUaW1lc3RhbXBzIiwidGltZU9wdHMiLCJfZ2VuZXJhdGUiLCJfZ2V0TGFiZWxDYXBhY2l0eSIsImluaXRPZmZzZXRzIiwiZ2V0RGVjaW1hbEZvclZhbHVlIiwiaGFzV2Vla2RheSIsImdldERhdGFUaW1lc3RhbXBzIiwidG9vbHRpcEZvcm1hdCIsImRhdGV0aW1lIiwiX3RpY2tGb3JtYXRGdW5jdGlvbiIsIm1pbm9yRm9ybWF0IiwibWFqb3JGb3JtYXQiLCJvZmZzZXRzIiwiX2dldExhYmVsU2l6ZSIsInRpY2tzT3B0cyIsInRpY2tMYWJlbFdpZHRoIiwiY29zUm90YXRpb24iLCJzaW5Sb3RhdGlvbiIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwicHJldlNvdXJjZSIsIm5leHRTb3VyY2UiLCJwcmV2VGFyZ2V0IiwibmV4dFRhcmdldCIsInNwYW4iLCJUaW1lU2VyaWVzU2NhbGUiLCJfdGFibGUiLCJfbWluUG9zIiwiX3RhYmxlUmFuZ2UiLCJfZ2V0VGltZXN0YW1wc0ZvclRhYmxlIiwiYnVpbGRMb29rdXBUYWJsZSIsInJlZ2lzdGVyYWJsZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLDBCQUFULENBQW9CQyxTQUFwQixFQUErQkMsU0FBL0IsRUFBMENDLFVBQTFDLEVBQXNEO0FBQ3BELFNBQU9ELFNBQVMsR0FBRyxHQUFaLEdBQWtCRCxTQUFsQixHQUE4QixLQUE5QixHQUFzQ0UsVUFBN0M7QUFDRDs7QUFDRCxNQUFNQyxnQkFBZ0IsR0FBSSxZQUFXO0FBQ25DLE1BQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUNqQyxXQUFPLFVBQVNDLFFBQVQsRUFBbUI7QUFDeEIsYUFBT0EsUUFBUSxFQUFmO0FBQ0QsS0FGRDtBQUdEOztBQUNELFNBQU9ELE1BQU0sQ0FBQ0UscUJBQWQ7QUFDRCxDQVB5QixFQUExQjs7QUFRQSxTQUFTQyxTQUFULENBQW1CQyxFQUFuQixFQUF1QkMsT0FBdkIsRUFBZ0NDLFFBQWhDLEVBQTBDO0FBQ3hDLFFBQU1DLFVBQVUsR0FBR0QsUUFBUSxLQUFNRSxJQUFELElBQVVDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCSixJQUEzQixDQUFmLENBQTNCOztBQUNBLE1BQUlLLE9BQU8sR0FBRyxLQUFkO0FBQ0EsTUFBSUwsSUFBSSxHQUFHLEVBQVg7QUFDQSxTQUFPLFVBQVMsR0FBR00sSUFBWixFQUFrQjtBQUN2Qk4sUUFBSSxHQUFHRCxVQUFVLENBQUNPLElBQUQsQ0FB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ZW50IjpbIi8qIVxuICogQ2hhcnQuanMgdjMuNS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjEgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cbmNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5jb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbiwgc3RhcnQsIGVuZCkgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuY29uc3QgX3RleHRYID0gKGFsaWduLCBsZWZ0LCByaWdodCwgcnRsKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgdWlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkKys7XG4gIH07XG59KCkpO1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmNvbnN0IGlzTnVtYmVyRmluaXRlID0gKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbmZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cbmNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiB2YWx1ZSAvIGRpbWVuc2lvbjtcbmNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcbmZ1bmN0aW9uIGNhbGxiYWNrKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZWFjaChsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcbiAgbGV0IGksIGxlbiwga2V5cztcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMCwgYTEpIHtcbiAgbGV0IGksIGlsZW4sIHYwLCB2MTtcbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvbmUkMShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lJDEpO1xuICB9XG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZSQxKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXJJZihrZXksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZSwgdmFsdWUsIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuXHRcdFx0J1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cbmNvbnN0IGVtcHR5U3RyaW5nID0gJyc7XG5jb25zdCBkb3QgPSAnLic7XG5mdW5jdGlvbiBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBzdGFydCkge1xuICBjb25zdCBpZHggPSBrZXkuaW5kZXhPZihkb3QsIHN0YXJ0KTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyBrZXkubGVuZ3RoIDogaWR4O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSkge1xuICBpZiAoa2V5ID09PSBlbXB0eVN0cmluZykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBpZHggPSBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBwb3MpO1xuICB3aGlsZSAob2JqICYmIGlkeCA+IHBvcykge1xuICAgIG9iaiA9IG9ialtrZXkuc3Vic3RyKHBvcywgaWR4IC0gcG9zKV07XG4gICAgcG9zID0gaWR4ICsgMTtcbiAgICBpZHggPSBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBwb3MpO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmNvbnN0IGRlZmluZWQgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5jb25zdCBzZXRzRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgVEFVID0gMiAqIFBJO1xuY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5jb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5jb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5jb25zdCBzaWduID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5mdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuZnVuY3Rpb24gYWxtb3N0V2hvbGUoeCwgZXBzaWxvbikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KGFycmF5LCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cbmZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHgpIHtcbiAgaWYgKCFpc051bWJlckZpbml0ZSh4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5mdW5jdGlvbiBfYW5nbGVEaWZmKGEsIGIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGEpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cbmZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0LCBlbmQsIHNhbWVBbmdsZUlzRnVsbENpcmNsZSkge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cbmZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0LCBzLCBwKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6IHQgPT4gdCxcbiAgZWFzZUluUXVhZDogdCA9PiB0ICogdCxcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxuICBlYXNlSW5PdXRRdWFkOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuICBlYXNlSW5DdWJpYzogdCA9PiB0ICogdCAqIHQsXG4gIGVhc2VPdXRDdWJpYzogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVhcnQ6IHQgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gIGVhc2VJblF1aW50OiB0ID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgZWFzZUluU2luZTogdCA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcbiAgZWFzZU91dFNpbmU6IHQgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICBlYXNlSW5FeHBvOiB0ID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICBlYXNlT3V0RXhwbzogdCA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogdCA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gIGVhc2VJbk91dENpcmM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG4gIGVhc2VJbkVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG4gIGVhc2VJbkJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuICBlYXNlT3V0QmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayh0KSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcbiAgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59O1xuXG4vKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMS45XG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjAgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmNvbnN0IG1hcCA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9ICcwMTIzNDU2Nzg5QUJDREVGJztcbmNvbnN0IGgxID0gKGIpID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gKGIpID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSAoYikgPT4gKCgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4RikpO1xuZnVuY3Rpb24gaXNTaG9ydCh2KSB7XG5cdHJldHVybiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xufVxuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG5cdHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXHR2YXIgcmV0O1xuXHRpZiAoc3RyWzBdID09PSAnIycpIHtcblx0XHRpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuXHRcdFx0cmV0ID0ge1xuXHRcdFx0XHRyOiAyNTUgJiBtYXBbc3RyWzFdXSAqIDE3LFxuXHRcdFx0XHRnOiAyNTUgJiBtYXBbc3RyWzJdXSAqIDE3LFxuXHRcdFx0XHRiOiAyNTUgJiBtYXBbc3RyWzNdXSAqIDE3LFxuXHRcdFx0XHRhOiBsZW4gPT09IDUgPyBtYXBbc3RyWzRdXSAqIDE3IDogMjU1XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuXHRcdFx0cmV0ID0ge1xuXHRcdFx0XHRyOiBtYXBbc3RyWzFdXSA8PCA0IHwgbWFwW3N0clsyXV0sXG5cdFx0XHRcdGc6IG1hcFtzdHJbM11dIDw8IDQgfCBtYXBbc3RyWzRdXSxcblx0XHRcdFx0YjogbWFwW3N0cls1XV0gPDwgNCB8IG1hcFtzdHJbNl1dLFxuXHRcdFx0XHRhOiBsZW4gPT09IDkgPyAobWFwW3N0cls3XV0gPDwgNCB8IG1hcFtzdHJbOF1dKSA6IDI1NVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGhleFN0cmluZyh2KSB7XG5cdHZhciBmID0gaXNTaG9ydCh2KSA/IGgxIDogaDI7XG5cdHJldHVybiB2XG5cdFx0PyAnIycgKyBmKHYucikgKyBmKHYuZykgKyBmKHYuYikgKyAodi5hIDwgMjU1ID8gZih2LmEpIDogJycpXG5cdFx0OiB2O1xufVxuZnVuY3Rpb24gcm91bmQodikge1xuXHRyZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcblx0cmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBuMmIodikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJuKHYpIHtcblx0cmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gbjJwKHYpIHtcblx0cmV0dXJuIGxpbShyb3VuZCh2ICogMTAwKSwgMCwgMTAwKTtcbn1cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG5cdGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuXHRsZXQgYSA9IDI1NTtcblx0bGV0IHIsIGcsIGI7XG5cdGlmICghbSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAobVs3XSAhPT0gcikge1xuXHRcdGNvbnN0IHYgPSArbVs3XTtcblx0XHRhID0gMjU1ICYgKG1bOF0gPyBwMmIodikgOiB2ICogMjU1KTtcblx0fVxuXHRyID0gK21bMV07XG5cdGcgPSArbVszXTtcblx0YiA9ICttWzVdO1xuXHRyID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiByKTtcblx0ZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogZyk7XG5cdGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGIpO1xuXHRyZXR1cm4ge1xuXHRcdHI6IHIsXG5cdFx0ZzogZyxcblx0XHRiOiBiLFxuXHRcdGE6IGFcblx0fTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG5cdHJldHVybiB2ICYmIChcblx0XHR2LmEgPCAyNTVcblx0XHRcdD8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuXHRcdFx0OiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuXHQpO1xufVxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcblx0Y29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG5cdGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcblx0cmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcblx0Y29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcblx0cmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcblx0Y29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcblx0bGV0IGk7XG5cdGlmICh3ICsgYiA+IDEpIHtcblx0XHRpID0gMSAvICh3ICsgYik7XG5cdFx0dyAqPSBpO1xuXHRcdGIgKj0gaTtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0cmdiW2ldICo9IDEgLSB3IC0gYjtcblx0XHRyZ2JbaV0gKz0gdztcblx0fVxuXHRyZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG5cdGNvbnN0IHJhbmdlID0gMjU1O1xuXHRjb25zdCByID0gdi5yIC8gcmFuZ2U7XG5cdGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcblx0Y29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuXHRjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0Y29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG5cdGxldCBoLCBzLCBkO1xuXHRpZiAobWF4ICE9PSBtaW4pIHtcblx0XHRkID0gbWF4IC0gbWluO1xuXHRcdHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblx0XHRoID0gbWF4ID09PSByXG5cdFx0XHQ/ICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdDogbWF4ID09PSBnXG5cdFx0XHRcdD8gKGIgLSByKSAvIGQgKyAyXG5cdFx0XHRcdDogKHIgLSBnKSAvIGQgKyA0O1xuXHRcdGggPSBoICogNjAgKyAwLjU7XG5cdH1cblx0cmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcblx0cmV0dXJuIChcblx0XHRBcnJheS5pc0FycmF5KGEpXG5cdFx0XHQ/IGYoYVswXSwgYVsxXSwgYVsyXSlcblx0XHRcdDogZihhLCBiLCBjKVxuXHQpLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG5cdHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcblx0cmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuXHRyZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcblx0cmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuXHRjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcblx0bGV0IGEgPSAyNTU7XG5cdGxldCB2O1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1bNV0gIT09IHYpIHtcblx0XHRhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuXHR9XG5cdGNvbnN0IGggPSBodWUoK21bMl0pO1xuXHRjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuXHRjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuXHRpZiAobVsxXSA9PT0gJ2h3YicpIHtcblx0XHR2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuXHR9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG5cdFx0diA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcblx0fSBlbHNlIHtcblx0XHR2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0cjogdlswXSxcblx0XHRnOiB2WzFdLFxuXHRcdGI6IHZbMl0sXG5cdFx0YTogYVxuXHR9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuXHR2YXIgaCA9IHJnYjJoc2wodik7XG5cdGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG5cdGggPSBoc2wycmdiKGgpO1xuXHR2LnIgPSBoWzBdO1xuXHR2LmcgPSBoWzFdO1xuXHR2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcblx0aWYgKCF2KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuXHRjb25zdCBoID0gYVswXTtcblx0Y29uc3QgcyA9IG4ycChhWzFdKTtcblx0Y29uc3QgbCA9IG4ycChhWzJdKTtcblx0cmV0dXJuIHYuYSA8IDI1NVxuXHRcdD8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG5cdFx0OiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuY29uc3QgbWFwJDEgPSB7XG5cdHg6ICdkYXJrJyxcblx0WjogJ2xpZ2h0Jyxcblx0WTogJ3JlJyxcblx0WDogJ2JsdScsXG5cdFc6ICdncicsXG5cdFY6ICdtZWRpdW0nLFxuXHRVOiAnc2xhdGUnLFxuXHRBOiAnZWUnLFxuXHRUOiAnb2wnLFxuXHRTOiAnb3InLFxuXHRCOiAncmEnLFxuXHRDOiAnbGF0ZWcnLFxuXHREOiAnaWdodHMnLFxuXHRSOiAnaW4nLFxuXHRROiAndHVycXVvaXMnLFxuXHRFOiAnaGknLFxuXHRQOiAncm8nLFxuXHRPOiAnYWwnLFxuXHROOiAnbGUnLFxuXHRNOiAnZGUnLFxuXHRMOiAneWVsbG8nLFxuXHRGOiAnZW4nLFxuXHRLOiAnY2gnLFxuXHRHOiAnYXJrcycsXG5cdEg6ICdlYScsXG5cdEk6ICdpZ2h0ZycsXG5cdEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyA9IHtcblx0T2ljZVhlOiAnZjBmOGZmJyxcblx0YW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuXHRhcXVhOiAnZmZmZicsXG5cdGFxdWFtYXJSZTogJzdmZmZkNCcsXG5cdGF6dVk6ICdmMGZmZmYnLFxuXHRiZWlnZTogJ2Y1ZjVkYycsXG5cdGJpc3F1ZTogJ2ZmZTRjNCcsXG5cdGJsYWNrOiAnMCcsXG5cdGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG5cdFhlOiAnZmYnLFxuXHRYZXZpVGV0OiAnOGEyYmUyJyxcblx0YlB3bjogJ2E1MmEyYScsXG5cdGJ1cmx5d29vZDogJ2RlYjg4NycsXG5cdGNhTXRYZTogJzVmOWVhMCcsXG5cdEthcnRZdXNlOiAnN2ZmZjAwJyxcblx0S29jVGF0ZTogJ2QyNjkxZScsXG5cdGNTTzogJ2ZmN2Y1MCcsXG5cdGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcblx0Y1Nuc2lsazogJ2ZmZjhkYycsXG5cdGNyaW1zb246ICdkYzE0M2MnLFxuXHRjeWFuOiAnZmZmZicsXG5cdHhYZTogJzhiJyxcblx0eGN5YW46ICc4YjhiJyxcblx0eGdUTW5QZDogJ2I4ODYwYicsXG5cdHhXYXk6ICdhOWE5YTknLFxuXHR4Z1lGOiAnNjQwMCcsXG5cdHhnWXk6ICdhOWE5YTknLFxuXHR4a2hha2k6ICdiZGI3NmInLFxuXHR4bWFnRnRhOiAnOGIwMDhiJyxcblx0eFRpdmVnWUY6ICc1NTZiMmYnLFxuXHR4U2FuZ2U6ICdmZjhjMDAnLFxuXHR4U2NFZDogJzk5MzJjYycsXG5cdHhZZDogJzhiMDAwMCcsXG5cdHhzT21vbjogJ2U5OTY3YScsXG5cdHhzSGdZRjogJzhmYmM4ZicsXG5cdHhVWGU6ICc0ODNkOGInLFxuXHR4VVdheTogJzJmNGY0ZicsXG5cdHhVZ1l5OiAnMmY0ZjRmJyxcblx0eFFlOiAnY2VkMScsXG5cdHh2aVRldDogJzk0MDBkMycsXG5cdGRBcHBSazogJ2ZmMTQ5MycsXG5cdGRBcHNreVhlOiAnYmZmZicsXG5cdGRpbVdheTogJzY5Njk2OScsXG5cdGRpbWdZeTogJzY5Njk2OScsXG5cdGRvZGdlclhlOiAnMWU5MGZmJyxcblx0ZmlZYnJpY2s6ICdiMjIyMjInLFxuXHRmbFNPd0V0ZTogJ2ZmZmFmMCcsXG5cdGZvWXN0V0FuOiAnMjI4YjIyJyxcblx0ZnVLc2lhOiAnZmYwMGZmJyxcblx0Z2FSc2JTbzogJ2RjZGNkYycsXG5cdGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG5cdGdUZDogJ2ZmZDcwMCcsXG5cdGdUTW5QZDogJ2RhYTUyMCcsXG5cdFdheTogJzgwODA4MCcsXG5cdGdZRjogJzgwMDAnLFxuXHRnWUZMdzogJ2FkZmYyZicsXG5cdGdZeTogJzgwODA4MCcsXG5cdGhvbmV5TXc6ICdmMGZmZjAnLFxuXHRob3RwUms6ICdmZjY5YjQnLFxuXHRSZGlhbllkOiAnY2Q1YzVjJyxcblx0UmRpZ286ICc0YjAwODInLFxuXHRpdlN5OiAnZmZmZmYwJyxcblx0a2hha2k6ICdmMGU2OGMnLFxuXHRsYXZGTXI6ICdlNmU2ZmEnLFxuXHRsYXZGTXJYc2g6ICdmZmYwZjUnLFxuXHRsYXduZ1lGOiAnN2NmYzAwJyxcblx0Tm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG5cdFpYZTogJ2FkZDhlNicsXG5cdFpjU086ICdmMDgwODAnLFxuXHRaY3lhbjogJ2UwZmZmZicsXG5cdFpnVE1uUGRMdzogJ2ZhZmFkMicsXG5cdFpXYXk6ICdkM2QzZDMnLFxuXHRaZ1lGOiAnOTBlZTkwJyxcblx0WmdZeTogJ2QzZDNkMycsXG5cdFpwUms6ICdmZmI2YzEnLFxuXHRac09tb246ICdmZmEwN2EnLFxuXHRac0hnWUY6ICcyMGIyYWEnLFxuXHRac2t5WGU6ICc4N2NlZmEnLFxuXHRaVVdheTogJzc3ODg5OScsXG5cdFpVZ1l5OiAnNzc4ODk5Jyxcblx0WnN0QWxYZTogJ2IwYzRkZScsXG5cdFpMdzogJ2ZmZmZlMCcsXG5cdGxpbWU6ICdmZjAwJyxcblx0bGltZWdZRjogJzMyY2QzMicsXG5cdGxSRjogJ2ZhZjBlNicsXG5cdG1hZ0Z0YTogJ2ZmMDBmZicsXG5cdG1hUG9uOiAnODAwMDAwJyxcblx0VmFxdWFtYXJSZTogJzY2Y2RhYScsXG5cdFZYZTogJ2NkJyxcblx0VlNjRWQ6ICdiYTU1ZDMnLFxuXHRWcHVycE46ICc5MzcwZGInLFxuXHRWc0hnWUY6ICczY2IzNzEnLFxuXHRWVVhlOiAnN2I2OGVlJyxcblx0VnNwclJnZ1lGOiAnZmE5YScsXG5cdFZRZTogJzQ4ZDFjYycsXG5cdFZ2aVRldFlkOiAnYzcxNTg1Jyxcblx0bWlkbmlnaHRYZTogJzE5MTk3MCcsXG5cdG1SdGNZYW06ICdmNWZmZmEnLFxuXHRtaXN0eVBzZTogJ2ZmZTRlMScsXG5cdG1vY2Nhc1I6ICdmZmU0YjUnLFxuXHRuYXZham93RXRlOiAnZmZkZWFkJyxcblx0bmF2eTogJzgwJyxcblx0VGRsYWNlOiAnZmRmNWU2Jyxcblx0VGl2ZTogJzgwODAwMCcsXG5cdFRpdmVkQmI6ICc2YjhlMjMnLFxuXHRTYW5nZTogJ2ZmYTUwMCcsXG5cdFNhbmdlWWQ6ICdmZjQ1MDAnLFxuXHRTY0VkOiAnZGE3MGQ2Jyxcblx0cE9lZ1RNblBkOiAnZWVlOGFhJyxcblx0cE9lZ1lGOiAnOThmYjk4Jyxcblx0cE9lUWU6ICdhZmVlZWUnLFxuXHRwT2V2aVRldFlkOiAnZGI3MDkzJyxcblx0cGFwYXlhd0VwOiAnZmZlZmQ1Jyxcblx0cEhLcHVmZjogJ2ZmZGFiOScsXG5cdHBlcnU6ICdjZDg1M2YnLFxuXHRwUms6ICdmZmMwY2InLFxuXHRwbHVtOiAnZGRhMGRkJyxcblx0cG93TXJYZTogJ2IwZTBlNicsXG5cdHB1cnBOOiAnODAwMDgwJyxcblx0WWJlY2NhcHVycE46ICc2NjMzOTknLFxuXHRZZDogJ2ZmMDAwMCcsXG5cdFBzeWJyb3duOiAnYmM4ZjhmJyxcblx0UHlPWGU6ICc0MTY5ZTEnLFxuXHRzYWRkTmJQd246ICc4YjQ1MTMnLFxuXHRzT21vbjogJ2ZhODA3MicsXG5cdHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG5cdHNIZ1lGOiAnMmU4YjU3Jyxcblx0c0hzaGVsbDogJ2ZmZjVlZScsXG5cdHNpRm5hOiAnYTA1MjJkJyxcblx0c2lsdmVyOiAnYzBjMGMwJyxcblx0c2t5WGU6ICc4N2NlZWInLFxuXHRVWGU6ICc2YTVhY2QnLFxuXHRVV2F5OiAnNzA4MDkwJyxcblx0VWdZeTogJzcwODA5MCcsXG5cdHNub3c6ICdmZmZhZmEnLFxuXHRzcHJSZ2dZRjogJ2ZmN2YnLFxuXHRzdEFsWGU6ICc0NjgyYjQnLFxuXHR0YW46ICdkMmI0OGMnLFxuXHR0ZU86ICc4MDgwJyxcblx0dEVzdE46ICdkOGJmZDgnLFxuXHR0b21hdG86ICdmZjYzNDcnLFxuXHRRZTogJzQwZTBkMCcsXG5cdHZpVGV0OiAnZWU4MmVlJyxcblx0Skh0OiAnZjVkZWIzJyxcblx0d0V0ZTogJ2ZmZmZmZicsXG5cdHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG5cdEx3OiAnZmZmZjAwJyxcblx0THdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuXHRjb25zdCB1bnBhY2tlZCA9IHt9O1xuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMpO1xuXHRjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCQxKTtcblx0bGV0IGksIGosIGssIG9rLCBuaztcblx0Zm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRvayA9IG5rID0ga2V5c1tpXTtcblx0XHRmb3IgKGogPSAwOyBqIDwgdGtleXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGsgPSB0a2V5c1tqXTtcblx0XHRcdG5rID0gbmsucmVwbGFjZShrLCBtYXAkMVtrXSk7XG5cdFx0fVxuXHRcdGsgPSBwYXJzZUludChuYW1lc1tva10sIDE2KTtcblx0XHR1bnBhY2tlZFtua10gPSBbayA+PiAxNiAmIDB4RkYsIGsgPj4gOCAmIDB4RkYsIGsgJiAweEZGXTtcblx0fVxuXHRyZXR1cm4gdW5wYWNrZWQ7XG59XG5sZXQgbmFtZXMkMTtcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcblx0aWYgKCFuYW1lcyQxKSB7XG5cdFx0bmFtZXMkMSA9IHVucGFjaygpO1xuXHRcdG5hbWVzJDEudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG5cdH1cblx0Y29uc3QgYSA9IG5hbWVzJDFbc3RyLnRvTG93ZXJDYXNlKCldO1xuXHRyZXR1cm4gYSAmJiB7XG5cdFx0cjogYVswXSxcblx0XHRnOiBhWzFdLFxuXHRcdGI6IGFbMl0sXG5cdFx0YTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG5cdH07XG59XG5mdW5jdGlvbiBtb2RIU0wodiwgaSwgcmF0aW8pIHtcblx0aWYgKHYpIHtcblx0XHRsZXQgdG1wID0gcmdiMmhzbCh2KTtcblx0XHR0bXBbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0bXBbaV0gKyB0bXBbaV0gKiByYXRpbywgaSA9PT0gMCA/IDM2MCA6IDEpKTtcblx0XHR0bXAgPSBoc2wycmdiKHRtcCk7XG5cdFx0di5yID0gdG1wWzBdO1xuXHRcdHYuZyA9IHRtcFsxXTtcblx0XHR2LmIgPSB0bXBbMl07XG5cdH1cbn1cbmZ1bmN0aW9uIGNsb25lKHYsIHByb3RvKSB7XG5cdHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xufVxuZnVuY3Rpb24gZnJvbU9iamVjdChpbnB1dCkge1xuXHR2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xuXHRpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0XHRpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcblx0XHRcdHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcblx0XHRcdGlmIChpbnB1dC5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdHYuYSA9IG4yYihpbnB1dFszXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHYgPSBjbG9uZShpbnB1dCwge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9KTtcblx0XHR2LmEgPSBuMmIodi5hKTtcblx0fVxuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyc2Uoc3RyKSB7XG5cdGlmIChzdHIuY2hhckF0KDApID09PSAncicpIHtcblx0XHRyZXR1cm4gcmdiUGFyc2Uoc3RyKTtcblx0fVxuXHRyZXR1cm4gaHVlUGFyc2Uoc3RyKTtcbn1cbmNsYXNzIENvbG9yIHtcblx0Y29uc3RydWN0b3IoaW5wdXQpIHtcblx0XHRpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuXHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdH1cblx0XHRjb25zdCB0eXBlID0gdHlwZW9mIGlucHV0O1xuXHRcdGxldCB2O1xuXHRcdGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0diA9IGZyb21PYmplY3QoaW5wdXQpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHYgPSBoZXhQYXJzZShpbnB1dCkgfHwgbmFtZVBhcnNlKGlucHV0KSB8fCBmdW5jdGlvblBhcnNlKGlucHV0KTtcblx0XHR9XG5cdFx0dGhpcy5fcmdiID0gdjtcblx0XHR0aGlzLl92YWxpZCA9ICEhdjtcblx0fVxuXHRnZXQgdmFsaWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkO1xuXHR9XG5cdGdldCByZ2IoKSB7XG5cdFx0dmFyIHYgPSBjbG9uZSh0aGlzLl9yZ2IpO1xuXHRcdGlmICh2KSB7XG5cdFx0XHR2LmEgPSBiMm4odi5hKTtcblx0XHR9XG5cdFx0cmV0dXJuIHY7XG5cdH1cblx0c2V0IHJnYihvYmopIHtcblx0XHR0aGlzLl9yZ2IgPSBmcm9tT2JqZWN0KG9iaik7XG5cdH1cblx0cmdiU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWxpZCA/IHJnYlN0cmluZyh0aGlzLl9yZ2IpIDogdGhpcy5fcmdiO1xuXHR9XG5cdGhleFN0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQgPyBoZXhTdHJpbmcodGhpcy5fcmdiKSA6IHRoaXMuX3JnYjtcblx0fVxuXHRoc2xTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkID8gaHNsU3RyaW5nKHRoaXMuX3JnYikgOiB0aGlzLl9yZ2I7XG5cdH1cblx0bWl4KGNvbG9yLCB3ZWlnaHQpIHtcblx0XHRjb25zdCBtZSA9IHRoaXM7XG5cdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRjb25zdCBjMSA9IG1lLnJnYjtcblx0XHRcdGNvbnN0IGMyID0gY29sb3IucmdiO1xuXHRcdFx0bGV0IHcyO1xuXHRcdFx0Y29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG5cdFx0XHRjb25zdCB3ID0gMiAqIHAgLSAxO1xuXHRcdFx0Y29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuXHRcdFx0Y29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0XHR3MiA9IDEgLSB3MTtcblx0XHRcdGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuXHRcdFx0YzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG5cdFx0XHRjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcblx0XHRcdGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuXHRcdFx0bWUucmdiID0gYzE7XG5cdFx0fVxuXHRcdHJldHVybiBtZTtcblx0fVxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMucmdiKTtcblx0fVxuXHRhbHBoYShhKSB7XG5cdFx0dGhpcy5fcmdiLmEgPSBuMmIoYSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Y2xlYXJlcihyYXRpbykge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcblx0XHRyZ2IuYSAqPSAxIC0gcmF0aW87XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0Z3JleXNjYWxlKCkge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcblx0XHRjb25zdCB2YWwgPSByb3VuZChyZ2IuciAqIDAuMyArIHJnYi5nICogMC41OSArIHJnYi5iICogMC4xMSk7XG5cdFx0cmdiLnIgPSByZ2IuZyA9IHJnYi5iID0gdmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG9wYXF1ZXIocmF0aW8pIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG5cdFx0cmdiLmEgKj0gMSArIHJhdGlvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdG5lZ2F0ZSgpIHtcblx0XHRjb25zdCB2ID0gdGhpcy5fcmdiO1xuXHRcdHYuciA9IDI1NSAtIHYucjtcblx0XHR2LmcgPSAyNTUgLSB2Lmc7XG5cdFx0di5iID0gMjU1IC0gdi5iO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxpZ2h0ZW4ocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAyLCByYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGFya2VuKHJhdGlvKSB7XG5cdFx0bW9kSFNMKHRoaXMuX3JnYiwgMiwgLXJhdGlvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRzYXR1cmF0ZShyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDEsIHJhdGlvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkZXNhdHVyYXRlKHJhdGlvKSB7XG5cdFx0bW9kSFNMKHRoaXMuX3JnYiwgMSwgLXJhdGlvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRyb3RhdGUoZGVnKSB7XG5cdFx0cm90YXRlKHRoaXMuX3JnYiwgZGVnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG5cdHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5jb25zdCBpc1BhdHRlcm5PckdyYWRpZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzUGF0dGVybjtcbmZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogaW5kZXhfZXNtKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogaW5kZXhfZXNtKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuXG5jb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gZ2V0U2NvcGUkMShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc2V0KHJvb3QsIHNjb3BlLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgJycpLCBzY29wZSk7XG59XG5jbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICB9O1xuICAgIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5vbkhvdmVyID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMucGFyc2luZyA9IHRydWU7XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICB9XG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBnZXQoc2NvcGUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gIH1cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgcm91dGUoc2NvcGUsIG5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgW3ByaXZhdGVOYW1lXToge1xuICAgICAgICB2YWx1ZTogc2NvcGVPYmplY3RbbmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFNjb3BlT2JqZWN0W3RhcmdldE5hbWVdO1xuICAgICAgICAgIGlmIChpc09iamVjdChsb2NhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KGxvY2FsLCB0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbnZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHguc2F2ZSgpO1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xuICBsZXQgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgZGVmYXVsdDpcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICBjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICBjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3QnOlxuICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICBjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ3JlY3RSb3QnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAnY3Jvc3MnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3Rhcic6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnbGluZSc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGFzaCc6XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgYnJlYWs7XG4gIH1cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7XG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuZnVuY3Rpb24gY2xpcEFyZWEoY3R4LCBhcmVhKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB1bmNsaXBBcmVhKGN0eCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwLCBtb2RlKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBvcHRzID0ge30pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpLCBsaW5lO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcbiAgICB5ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIC1IQUxGX1BJLCBQSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cblxuY29uc3QgTElORV9IRUlHSFQgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcbmNvbnN0IEZPTlRfU1RZTEUgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvKTtcbmZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZSwgc2l6ZSkge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gIGNhc2UgJ3B4JzpcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNhc2UgJyUnOlxuICAgIHZhbHVlIC89IDEwMDtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuY29uc3QgbnVtYmVyT3JaZXJvID0gdiA9PiArdiB8fCAwO1xuZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0b1RSQkwodmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cbmZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cbmZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZSkge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpO1xuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gdG9Gb250KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQ7XG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9ICcnO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHMsIGNvbnRleHQsIGluZGV4LCBpbmZvKSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXgsIGdyYWNlKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4gLSBNYXRoLmFicyh0b0RpbWVuc2lvbihncmFjZSwgbWluKSksXG4gICAgbWF4OiBtYXggKyB0b0RpbWVuc2lvbihncmFjZSwgbWF4KVxuICB9O1xufVxuXG5mdW5jdGlvbiBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgY21wKSB7XG4gIGNtcCA9IGNtcCB8fCAoKGluZGV4KSA9PiB0YWJsZVtpbmRleF0gPCB2YWx1ZSk7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBtaWQ7XG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvLCBoaX07XG59XG5jb25zdCBfbG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcbmNvbnN0IF9ybG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5mdW5jdGlvbiBfZmlsdGVyQmV0d2Vlbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG4gIHJldHVybiBzdGFydCA+IDAgfHwgZW5kIDwgdmFsdWVzLmxlbmd0aFxuICAgID8gdmFsdWVzLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgOiB2YWx1ZXM7XG59XG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ19vbkRhdGEnICsgX2NhcGl0YWxpemUoa2V5KTtcbiAgICBjb25zdCBiYXNlID0gYXJyYXlba2V5XTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG4gIGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcbn1cbmZ1bmN0aW9uIF9hcnJheVVuaXF1ZShpdGVtcykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc2V0LmFkZChpdGVtc1tpXSk7XG4gIH1cbiAgaWYgKHNldC5zaXplID09PSBpbGVuKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzID0gWycnXSwgcm9vdFNjb3BlcyA9IHNjb3BlcywgZmFsbGJhY2ssIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXSkge1xuICBpZiAoIWRlZmluZWQoZmFsbGJhY2spKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IHJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIHJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0KHByb3h5LCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhwcm94eSwgZGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfSkge1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4LCBuYW1lKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3AsIHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJztcbmZ1bmN0aW9uIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCByZXNvbHZlKSB7XG4gIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhbHVlID0gcmVzb2x2ZSgpO1xuICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGxldCB2YWx1ZSA9IF9wcm94eVtwcm9wXTtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgfVxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfc3RhY2t9ID0gdGFyZ2V0O1xuICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIGRldGVjdGVkOiAnICsgQXJyYXkuZnJvbShfc3RhY2spLmpvaW4oJy0+JykgKyAnLT4nICsgcHJvcCk7XG4gIH1cbiAgX3N0YWNrLmFkZChwcm9wKTtcbiAgdmFsdWUgPSB2YWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgaXNJbmRleGFibGUpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gdmFsdWVbX2NvbnRleHQuaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRmFsbGJhY2soZmFsbGJhY2ssIHByb3AsIHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2spIHtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50U2NvcGVzKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZShrZXksIHBhcmVudCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBzZXQuYWRkKHNjb3BlKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHNjb3BlLl9mYWxsYmFjaywga2V5LCBzY29wZSk7XG4gICAgICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIGRlZmluZWQocGFyZW50RmFsbGJhY2spICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3ApO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXkpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2spIHtcbiAgd2hpbGUgKGtleSkge1xuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXNvbHZlKGtleSwgc2NvcGVzKSB7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc2NvcGVba2V5XTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKGsgPT4gIWsuc3RhcnRzV2l0aCgnXycpKSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgY29uc3QgZmEgPSB0ICogczAxO1xuICBjb25zdCBmYiA9IHQgKiBzMTI7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSyA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KSA9PiAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcykge1xuICBjb25zdCBlID0gZXZ0Lm5hdGl2ZSB8fCBldnQ7XG4gIGNvbnN0IHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gIGNvbnN0IHNvdXJjZSA9IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZTtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlO1xuICBsZXQgYm94ID0gZmFsc2U7XG4gIGxldCB4LCB5O1xuICBpZiAodXNlT2Zmc2V0UG9zKG9mZnNldFgsIG9mZnNldFksIGUudGFyZ2V0KSkge1xuICAgIHggPSBvZmZzZXRYO1xuICAgIHkgPSBvZmZzZXRZO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IHNvdXJjZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIHkgPSBzb3VyY2UuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIGJveCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHt4LCB5LCBib3h9O1xufVxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihldnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpO1xuICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgbGV0IG1heFdpZHRoLCBtYXhIZWlnaHQ7XG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuY29uc3Qgcm91bmQxID0gdiA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gcmV0aW5hU2NhbGUoY2hhcnQsIGZvcmNlUmF0aW8sIGZvcmNlU3R5bGUpIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG4gIGNoYXJ0LmhlaWdodCA9IGRldmljZUhlaWdodCAvIHBpeGVsUmF0aW87XG4gIGNoYXJ0LndpZHRoID0gZGV2aWNlV2lkdGggLyBwaXhlbFJhdGlvO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5mdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuXG5jb25zdCBpbnRsQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bCwgcmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XG4gIGxldCBzdHlsZSwgb3JpZ2luYWw7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9yaWdpbmFsKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIGN0eC5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IChuLCBzLCBlKSA9PiBuID49IE1hdGgubWluKHMsIGUpICYmIG4gPD0gTWF0aC5tYXgoZSwgcyksXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHN0YXJ0ICU9IGNvdW50O1xuICBpZiAobG9vcCkge1xuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cbiAgZW5kICU9IGNvdW50O1xuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoe1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleDogbGluZS5fZGF0YXNldEluZGV4XG4gICAgICB9KSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQsIGVuZDogaSAtIDEsIGxvb3A6IHNlZ21lbnQubG9vcCwgc3R5bGU6IHByZXZTdHlsZX0pO1xuICAgICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgc3RhcnQgPSBpIC0gMTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0LCBlbmQ6IGkgLSAxLCBsb29wOiBzZWdtZW50Lmxvb3AsIHN0eWxlfSk7XG4gICAgICBzdGFydCA9IGkgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbmV4cG9ydCB7IG92ZXJyaWRlcyBhcyAkLCB0b1BhZGRpbmcgYXMgQSwgZWFjaCBhcyBCLCBnZXRNYXhpbXVtU2l6ZSBhcyBDLCBfZ2V0UGFyZW50Tm9kZSBhcyBELCByZWFkVXNlZFNpemUgYXMgRSwgdGhyb3R0bGVkIGFzIEYsIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgYXMgRywgSEFMRl9QSSBhcyBILCBfaXNEb21TdXBwb3J0ZWQgYXMgSSwgbG9nMTAgYXMgSiwgX2ZhY3Rvcml6ZSBhcyBLLCBmaW5pdGVPckRlZmF1bHQgYXMgTCwgY2FsbGJhY2sgYXMgTSwgX2FkZEdyYWNlIGFzIE4sIHRvRGVncmVlcyBhcyBPLCBQSSBhcyBQLCBfbWVhc3VyZVRleHQgYXMgUSwgX2ludDE2UmFuZ2UgYXMgUiwgX2FsaWduUGl4ZWwgYXMgUywgVEFVIGFzIFQsIGNsaXBBcmVhIGFzIFUsIHJlbmRlclRleHQgYXMgViwgdW5jbGlwQXJlYSBhcyBXLCB0b0ZvbnQgYXMgWCwgX3RvTGVmdFJpZ2h0Q2VudGVyIGFzIFksIF9hbGlnblN0YXJ0RW5kIGFzIFosIF9hcnJheVVuaXF1ZSBhcyBfLCByZXNvbHZlIGFzIGEsIG1lcmdlIGFzIGEwLCBfY2FwaXRhbGl6ZSBhcyBhMSwgZGVzY3JpcHRvcnMgYXMgYTIsIGlzRnVuY3Rpb24gYXMgYTMsIF9hdHRhY2hDb250ZXh0IGFzIGE0LCBfY3JlYXRlUmVzb2x2ZXIgYXMgYTUsIF9kZXNjcmlwdG9ycyBhcyBhNiwgbWVyZ2VJZiBhcyBhNywgdWlkIGFzIGE4LCBkZWJvdW5jZSBhcyBhOSwgX3NldE1pbkFuZE1heEJ5S2V5IGFzIGFBLCBuaWNlTnVtIGFzIGFCLCBhbG1vc3RXaG9sZSBhcyBhQywgYWxtb3N0RXF1YWxzIGFzIGFELCBfZGVjaW1hbFBsYWNlcyBhcyBhRSwgX2xvbmdlc3RUZXh0IGFzIGFGLCBfZmlsdGVyQmV0d2VlbiBhcyBhRywgX2xvb2t1cCBhcyBhSCwgZ2V0SG92ZXJDb2xvciBhcyBhSSwgY2xvbmUkMSBhcyBhSiwgX21lcmdlciBhcyBhSywgX21lcmdlcklmIGFzIGFMLCBfZGVwcmVjYXRlZCBhcyBhTSwgdG9Gb250U3RyaW5nIGFzIGFOLCBzcGxpbmVDdXJ2ZSBhcyBhTywgc3BsaW5lQ3VydmVNb25vdG9uZSBhcyBhUCwgZ2V0U3R5bGUgYXMgYVEsIGZvbnRTdHJpbmcgYXMgYVIsIHRvTGluZUhlaWdodCBhcyBhUywgUElUQVUgYXMgYVQsIElORklOSVRZIGFzIGFVLCBSQURfUEVSX0RFRyBhcyBhViwgUVVBUlRFUl9QSSBhcyBhVywgVFdPX1RISVJEU19QSSBhcyBhWCwgX2FuZ2xlRGlmZiBhcyBhWSwgcmV0aW5hU2NhbGUgYXMgYWEsIGNsZWFyQ2FudmFzIGFzIGFiLCBzZXRzRXF1YWwgYXMgYWMsIF9lbGVtZW50c0VxdWFsIGFzIGFkLCBnZXRBbmdsZUZyb21Qb2ludCBhcyBhZSwgX3JlYWRWYWx1ZVRvUHJvcHMgYXMgYWYsIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIGFzIGFnLCBfY29tcHV0ZVNlZ21lbnRzIGFzIGFoLCBfYm91bmRTZWdtZW50cyBhcyBhaSwgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIGFzIGFqLCBfYmV6aWVySW50ZXJwb2xhdGlvbiBhcyBhaywgX3BvaW50SW5MaW5lIGFzIGFsLCBfc3RlcHBlZExpbmVUbyBhcyBhbSwgX2JlemllckN1cnZlVG8gYXMgYW4sIGRyYXdQb2ludCBhcyBhbywgYWRkUm91bmRlZFJlY3RQYXRoIGFzIGFwLCB0b1RSQkwgYXMgYXEsIHRvVFJCTENvcm5lcnMgYXMgYXIsIF9ib3VuZFNlZ21lbnQgYXMgYXMsIF9ub3JtYWxpemVBbmdsZSBhcyBhdCwgZ2V0UnRsQWRhcHRlciBhcyBhdSwgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uIGFzIGF2LCBfdGV4dFggYXMgYXcsIHJlc3RvcmVUZXh0RGlyZWN0aW9uIGFzIGF4LCBub29wIGFzIGF5LCBkaXN0YW5jZUJldHdlZW5Qb2ludHMgYXMgYXosIGlzQXJyYXkgYXMgYiwgY29sb3IgYXMgYywgZGVmYXVsdHMgYXMgZCwgZWZmZWN0cyBhcyBlLCByZXNvbHZlT2JqZWN0S2V5IGFzIGYsIGlzTnVtYmVyRmluaXRlIGFzIGcsIGRlZmluZWQgYXMgaCwgaXNPYmplY3QgYXMgaSwgaXNOdWxsT3JVbmRlZiBhcyBqLCB0b1BlcmNlbnRhZ2UgYXMgaywgbGlzdGVuQXJyYXlFdmVudHMgYXMgbCwgdG9EaW1lbnNpb24gYXMgbSwgZm9ybWF0TnVtYmVyIGFzIG4sIF9hbmdsZUJldHdlZW4gYXMgbywgaXNOdW1iZXIgYXMgcCwgX2xpbWl0VmFsdWUgYXMgcSwgcmVxdWVzdEFuaW1GcmFtZSBhcyByLCBzaWduIGFzIHMsIHRvUmFkaWFucyBhcyB0LCB1bmxpc3RlbkFycmF5RXZlbnRzIGFzIHUsIHZhbHVlT3JEZWZhdWx0IGFzIHYsIF9sb29rdXBCeUtleSBhcyB3LCBnZXRSZWxhdGl2ZVBvc2l0aW9uIGFzIHgsIF9pc1BvaW50SW5BcmVhIGFzIHksIF9ybG9va3VwQnlLZXkgYXMgeiB9O1xuIiwiLyohXG4gKiBDaGFydC5qcyB2My41LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJlcXVlc3RBbmltRnJhbWUsIGEgYXMgcmVzb2x2ZSwgZSBhcyBlZmZlY3RzLCBjIGFzIGNvbG9yLCBkIGFzIGRlZmF1bHRzLCBpIGFzIGlzT2JqZWN0LCBiIGFzIGlzQXJyYXksIHYgYXMgdmFsdWVPckRlZmF1bHQsIHUgYXMgdW5saXN0ZW5BcnJheUV2ZW50cywgbCBhcyBsaXN0ZW5BcnJheUV2ZW50cywgZiBhcyByZXNvbHZlT2JqZWN0S2V5LCBnIGFzIGlzTnVtYmVyRmluaXRlLCBoIGFzIGRlZmluZWQsIHMgYXMgc2lnbiwgaiBhcyBpc051bGxPclVuZGVmLCBfIGFzIF9hcnJheVVuaXF1ZSwgdCBhcyB0b1JhZGlhbnMsIGsgYXMgdG9QZXJjZW50YWdlLCBtIGFzIHRvRGltZW5zaW9uLCBUIGFzIFRBVSwgbiBhcyBmb3JtYXROdW1iZXIsIG8gYXMgX2FuZ2xlQmV0d2VlbiwgSCBhcyBIQUxGX1BJLCBQIGFzIFBJLCBwIGFzIGlzTnVtYmVyLCBxIGFzIF9saW1pdFZhbHVlLCB3IGFzIF9sb29rdXBCeUtleSwgeCBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEsIHkgYXMgX2lzUG9pbnRJbkFyZWEsIHogYXMgX3Jsb29rdXBCeUtleSwgQSBhcyB0b1BhZGRpbmcsIEIgYXMgZWFjaCwgQyBhcyBnZXRNYXhpbXVtU2l6ZSwgRCBhcyBfZ2V0UGFyZW50Tm9kZSwgRSBhcyByZWFkVXNlZFNpemUsIEYgYXMgdGhyb3R0bGVkLCBHIGFzIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIEkgYXMgX2lzRG9tU3VwcG9ydGVkLCBKIGFzIGxvZzEwLCBLIGFzIF9mYWN0b3JpemUsIEwgYXMgZmluaXRlT3JEZWZhdWx0LCBNIGFzIGNhbGxiYWNrLCBOIGFzIF9hZGRHcmFjZSwgTyBhcyB0b0RlZ3JlZXMsIFEgYXMgX21lYXN1cmVUZXh0LCBSIGFzIF9pbnQxNlJhbmdlLCBTIGFzIF9hbGlnblBpeGVsLCBVIGFzIGNsaXBBcmVhLCBWIGFzIHJlbmRlclRleHQsIFcgYXMgdW5jbGlwQXJlYSwgWCBhcyB0b0ZvbnQsIFkgYXMgX3RvTGVmdFJpZ2h0Q2VudGVyLCBaIGFzIF9hbGlnblN0YXJ0RW5kLCAkIGFzIG92ZXJyaWRlcywgYTAgYXMgbWVyZ2UsIGExIGFzIF9jYXBpdGFsaXplLCBhMiBhcyBkZXNjcmlwdG9ycywgYTMgYXMgaXNGdW5jdGlvbiwgYTQgYXMgX2F0dGFjaENvbnRleHQsIGE1IGFzIF9jcmVhdGVSZXNvbHZlciwgYTYgYXMgX2Rlc2NyaXB0b3JzLCBhNyBhcyBtZXJnZUlmLCBhOCBhcyB1aWQsIGE5IGFzIGRlYm91bmNlLCBhYSBhcyByZXRpbmFTY2FsZSwgYWIgYXMgY2xlYXJDYW52YXMsIGFjIGFzIHNldHNFcXVhbCwgYWQgYXMgX2VsZW1lbnRzRXF1YWwsIGFlIGFzIGdldEFuZ2xlRnJvbVBvaW50LCBhZiBhcyBfcmVhZFZhbHVlVG9Qcm9wcywgYWcgYXMgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMsIGFoIGFzIF9jb21wdXRlU2VnbWVudHMsIGFpIGFzIF9ib3VuZFNlZ21lbnRzLCBhaiBhcyBfc3RlcHBlZEludGVycG9sYXRpb24sIGFrIGFzIF9iZXppZXJJbnRlcnBvbGF0aW9uLCBhbCBhcyBfcG9pbnRJbkxpbmUsIGFtIGFzIF9zdGVwcGVkTGluZVRvLCBhbiBhcyBfYmV6aWVyQ3VydmVUbywgYW8gYXMgZHJhd1BvaW50LCBhcCBhcyBhZGRSb3VuZGVkUmVjdFBhdGgsIGFxIGFzIHRvVFJCTCwgYXIgYXMgdG9UUkJMQ29ybmVycywgYXMgYXMgX2JvdW5kU2VnbWVudCwgYXQgYXMgX25vcm1hbGl6ZUFuZ2xlLCBhdSBhcyBnZXRSdGxBZGFwdGVyLCBhdiBhcyBvdmVycmlkZVRleHREaXJlY3Rpb24sIGF3IGFzIF90ZXh0WCwgYXggYXMgcmVzdG9yZVRleHREaXJlY3Rpb24sIGF5IGFzIG5vb3AsIGF6IGFzIGRpc3RhbmNlQmV0d2VlblBvaW50cywgYUEgYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhQiBhcyBuaWNlTnVtLCBhQyBhcyBhbG1vc3RXaG9sZSwgYUQgYXMgYWxtb3N0RXF1YWxzLCBhRSBhcyBfZGVjaW1hbFBsYWNlcywgYUYgYXMgX2xvbmdlc3RUZXh0LCBhRyBhcyBfZmlsdGVyQmV0d2VlbiwgYUggYXMgX2xvb2t1cCB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5leHBvcnQgeyBkIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50LmpzJztcblxuY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChtZS5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZS5fcnVubmluZyA9IHRydWU7XG4gICAgbWUuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICBtZS5fdXBkYXRlKCk7XG4gICAgICBtZS5fcmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAobWUuX3J1bm5pbmcpIHtcbiAgICAgICAgbWUuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuICAgIG1lLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICBtZS5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIG1lLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcbiAgICBtZS5fbGFzdERhdGUgPSBkYXRlO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIG1lLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG52YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBjb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLl9hY3RpdmUpIHtcbiAgICAgIG1lLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gbWUuX3RhcmdldFttZS5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIG1lLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IG1lLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICBtZS5fc3RhcnQgPSBkYXRlO1xuICAgICAgbWUuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgbWUuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICBtZS5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICBtZS5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICBtZS5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLl9hY3RpdmUpIHtcbiAgICAgIG1lLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICBtZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICBtZS5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gbWUuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gbWUuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSBtZS5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gbWUuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IG1lLl9sb29wO1xuICAgIGNvbnN0IHRvID0gbWUuX3RvO1xuICAgIGxldCBmYWN0b3I7XG4gICAgbWUuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcbiAgICBpZiAoIW1lLl9hY3RpdmUpIHtcbiAgICAgIG1lLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIG1lLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgbWUuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IG1lLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuICAgIG1lLl90YXJnZXRbcHJvcF0gPSBtZS5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICBkZWxheTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogMTAwMCxcbiAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgZm46IHVuZGVmaW5lZCxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICBsb29wOiB1bmRlZmluZWQsXG4gIHRvOiB1bmRlZmluZWQsXG4gIHR5cGU6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG59KTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgfSxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG59KTtcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBmbjogdiA9PiB2IHwgMFxuICAgICAgfSxcbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucykge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc051bWJlckZpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICB4OiBrZXksXG4gICAgICB5OiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdiYXInKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pO1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnQpLFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50KSwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gIH1cbn1cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBtZS5jb25maWd1cmUoKTtcbiAgICBtZS5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgbWUuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSBtZS5fZGF0YTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIG1lLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCBtZSk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCBtZSk7XG4gICAgICB9XG4gICAgICBtZS5fc3luY0xpc3QgPSBbXTtcbiAgICAgIG1lLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBtZS5fZGF0YUNoZWNrKCk7XG4gICAgaWYgKG1lLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IG1lLmRhdGFzZXRFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgfVxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG4gICAgbWUuX2RhdGFDaGVjaygpO1xuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG4gICAgbWUuX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKG1lLCBtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IG1lLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyhtZS5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhtZS5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgbWUub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIG1lLmdldENvbnRleHQoKSk7XG4gICAgbWUuX3BhcnNpbmcgPSBtZS5vcHRpb25zLnBhcnNpbmc7XG4gIH1cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gbWU7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcbiAgICBpZiAobWUuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSBtZS5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gbWUucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSBtZS5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG4gICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3MobWUsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc11cbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCwge2FsbDogdHJ1ZX0pO1xuICAgIH1cbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIHZhbHVlKTtcbiAgfVxuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSBtZS5fZ2V0T3RoZXJTY2FsZShzY2FsZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBjYW5TdGFjayAmJiBtZXRhLl9zdGFja2VkICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhtZS5jaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBjb25zdCB7bWluOiBvdGhlck1pbiwgbWF4OiBvdGhlck1heH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgIGxldCBpLCB2YWx1ZSwgcGFyc2VkLCBvdGhlclZhbHVlO1xuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgICAgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc051bWJlckZpbml0ZSh2YWx1ZSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtZS51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1lLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IG1lLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIG1lLmNvbmZpZ3VyZSgpO1xuICAgIG1lLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIG1lLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdChtZS5vcHRpb25zLmNsaXAsIGRlZmF1bHRDbGlwKG1ldGEueFNjYWxlLCBtZXRhLnlTY2FsZSwgbWUuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge31cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY3R4ID0gbWUuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gbWUuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gbWUuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGxldCBpO1xuICAgIGlmIChtZXRhLmRhdGFzZXQpIHtcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuICBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldFxuICAgICAgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSlcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgbWUuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZS5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQobWUuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSBtZS5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgY29udGV4dC5yYXcgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YUluZGV4ID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSBtZS4kY29udGV4dCB8fFxuICAgICAgICAobWUuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dChtZS5jaGFydC5nZXRDb250ZXh0KCksIG1lLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG4gICAgfVxuICAgIGNvbnRleHQuYWN0aXZlID0gISFhY3RpdmU7XG4gICAgY29udGV4dC5tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gbWUuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gbWUuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBkZWZpbmVkKGluZGV4KTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2xvbmVJZk5vdFNoYXJlZChjYWNoZWQsIHNoYXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSBtZS5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKG1lLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhtZS5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5lbGVtZW50c1tlbGVtZW50VHlwZV0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiBtZS5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoY2xvbmVJZk5vdFNoYXJlZCh2YWx1ZXMsIHNoYXJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGNvbnN0IGNhY2hlID0gbWUuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gbWUuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXMobWUuX3R5cGUsIHRyYW5zaXRpb24pO1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhtZS5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgbWUuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGRhdGEgPSBtZS5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1lLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiBtZS5fc3luY0xpc3QpIHtcbiAgICAgIG1lW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIG1lLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBtZS5wYXJzZSgwLCBjb3VudCk7XG4gICAgfVxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgbWUuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICBtZS5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBuZXcgbWUuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICAgIGlmIChtZS5fcGFyc2luZykge1xuICAgICAgbW92ZShtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgICBtZS5wYXJzZShzdGFydCwgY291bnQpO1xuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICBtZS51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGlmIChtZS5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICB9XG4gIF9vbkRhdGFQdXNoKCkge1xuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnRdKTtcbiAgfVxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCAtIDJdKTtcbiAgfVxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5EYXRhc2V0Q29udHJvbGxlci5kZWZhdWx0cyA9IHt9O1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2JhcicpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSkge1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IG1lLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbWUuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gbWUuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBtZS51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gbWU7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gbWUuX2dldFJ1bGVyKCk7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IG1lLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IG1lLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIG1lLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1lLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogbWUuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IG1lLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBtZS51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMobWUuX3R5cGUpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgbGV0IGksIGl0ZW07XG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFpdGVtLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGl0ZW0uY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KVtcbiAgICAgICAgICBpdGVtLmNvbnRyb2xsZXIuX2NhY2hlZE1ldGEudlNjYWxlLmF4aXNcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihpdGVtLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBpdGVtLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKGl0ZW0uc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xO1xuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWUuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUoaVNjYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IG1lLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWR9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IG1lO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSBtZS5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyBtZS5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcbiAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgbGV0IGJhc2UgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydFZhbHVlKTtcbiAgICBpZiAobWUuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XG4gICAgbGV0IGNlbnRlciwgc2l6ZTtcbiAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gbWUuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IG1lLl9nZXRTdGFja0luZGV4KG1lLmluZGV4LCBtZS5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCk7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtZS5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAobWUuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0c1tpXS5kcmF3KG1lLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuQmFyQ29udHJvbGxlci5pZCA9ICdiYXInO1xuQmFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcbiAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgZ3JvdXBlZDogdHJ1ZSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgIH1cbiAgfVxufTtcbkJhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW07XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpKSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpKSxcbiAgICAgICAgX2N1c3RvbTogaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3Qge2RhdGEsIF9wYXJzZWR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUoKSAvIDIsIF9wYXJzZWRbaV0uX2N1c3RvbSk7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBtZS5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBtZXRhLmxhYmVsLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHBvaW50cyA9IG1lLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgbWUudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IG1lLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSBtZS5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBtZS5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiBtZS5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWUudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIG1lLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuQnViYmxlQ29udHJvbGxlci5pZCA9ICdidWJibGUnO1xuQnViYmxlQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgIH1cbiAgfVxufTtcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge31cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBtZXRhLl9wYXJzZWRbaV0gPSArZGF0YVtpXTtcbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZS5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobWUuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbWUuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIG1lLmdldE1heE9mZnNldChhcmNzKSArIG1lLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZShtZS5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSBtZS5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKG1lLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIG1lLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgbWUub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICBtZS5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgIG1ldGEudG90YWwgPSBtZS5jYWxjdWxhdGVUb3RhbCgpO1xuICAgIG1lLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBtZS5fZ2V0UmluZ1dlaWdodE9mZnNldChtZS5pbmRleCk7XG4gICAgbWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICBtZS51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBtZS5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IG1lLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSBtZS5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBtZS5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IG1lLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IG1lLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBtZS5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIG1lLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyBtZS5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IG1lLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG4gICAgICBtZS51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIG1lLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSBtZS5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IG1lKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG5Eb3VnaG51dENvbnRyb2xsZXIuaWQgPSAnZG91Z2hudXQnO1xuRG91Z2hudXRDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICB9LFxuICB9LFxuICBjdXRvdXQ6ICc1MCUnLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJyxcbiAgc3BhY2luZzogMCxcbiAgaW5kZXhBeGlzOiAncicsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICAgIGxldCBkYXRhTGFiZWwgPSB0b29sdGlwSXRlbS5sYWJlbDtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9ICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcnJheShkYXRhTGFiZWwpKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcbiAgICAgICAgICAgIGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsICs9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YUxhYmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhID0gbWUuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IG1lLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgbWUuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIG1lLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBjb25zdCBvcHRpb25zID0gbWUucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIW1lLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSBtZS5vcHRpb25zLnNlZ21lbnQ7XG4gICAgbWUudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuICAgIG1lLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZH0gPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gbWUuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gbWUuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHNwYW5HYXBzID0gbWUub3B0aW9ucy5zcGFuR2FwcztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSBtZS5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiBtZS5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gbWUuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gbWUuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgbWUudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgICBtZS51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUobWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUobWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbkxpbmVDb250cm9sbGVyLmlkID0gJ2xpbmUnO1xuTGluZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBzcGFuR2FwczogZmFsc2UsXG59O1xuTGluZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgfSxcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKE1hdGgubWluKFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1pbikubG8sXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSkuaGkgKyAxKSxcbiAgICAgIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuZnVuY3Rpb24gc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cblxuY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuICAgIG1lLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xuICAgIG1lLmlubmVyUmFkaXVzID0gbWUub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gbWUuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIG1lLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IG1lLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyBtZS5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpXSkgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiBtZS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuICAgICAgbWUudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuUG9sYXJBcmVhQ29udHJvbGxlci5pZCA9ICdwb2xhckFyZWEnO1xuUG9sYXJBcmVhQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgfSxcbiAgfSxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHN0YXJ0QW5nbGU6IDAsXG59O1xuUG9sYXJBcmVhQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jaGFydC5kYXRhLmxhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gKyAnOiAnICsgY29udGV4dC5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcbn1cblBpZUNvbnRyb2xsZXIuaWQgPSAncGllJztcblBpZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGN1dG91dDogMCxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJSdcbn07XG5cbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB2U2NhbGUgPSBtZS5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbWUuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIW1lLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgbWUudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICBtZS51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG4gICAgY29uc3Qgc2NhbGUgPSBtZS5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gbWUucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCBkYXRhc2V0LmRhdGFbaV0pO1xuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cblJhZGFyQ29udHJvbGxlci5pZCA9ICdyYWRhcic7XG5SYWRhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGluZGV4QXhpczogJ3InLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgZWxlbWVudHM6IHtcbiAgICBsaW5lOiB7XG4gICAgICBmaWxsOiAnc3RhcnQnXG4gICAgfVxuICB9LFxufTtcblJhZGFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgTGluZUNvbnRyb2xsZXIge1xufVxuU2NhdHRlckNvbnRyb2xsZXIuaWQgPSAnc2NhdHRlcic7XG5TY2F0dGVyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgc2hvd0xpbmU6IGZhbHNlLFxuICBmaWxsOiBmYWxzZVxufTtcblNjYXR0ZXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBtb2RlOiAncG9pbnQnXG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuICcoJyArIGl0ZW0ubGFiZWwgKyAnLCAnICsgaXRlbS5mb3JtYXR0ZWRWYWx1ZSArICcpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29udHJvbGxlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5CYXJDb250cm9sbGVyOiBCYXJDb250cm9sbGVyLFxuQnViYmxlQ29udHJvbGxlcjogQnViYmxlQ29udHJvbGxlcixcbkRvdWdobnV0Q29udHJvbGxlcjogRG91Z2hudXRDb250cm9sbGVyLFxuTGluZUNvbnRyb2xsZXI6IExpbmVDb250cm9sbGVyLFxuUG9sYXJBcmVhQ29udHJvbGxlcjogUG9sYXJBcmVhQ29udHJvbGxlcixcblBpZUNvbnRyb2xsZXI6IFBpZUNvbnRyb2xsZXIsXG5SYWRhckNvbnRyb2xsZXI6IFJhZGFyQ29udHJvbGxlcixcblNjYXR0ZXJDb250cm9sbGVyOiBTY2F0dGVyQ29udHJvbGxlclxufSk7XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cbmNsYXNzIERhdGVBZGFwdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cbiAgZm9ybWF0cygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBwYXJzZSh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZm9ybWF0KHRpbWVzdGFtcCwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgYWRkKHRpbWVzdGFtcCwgYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZGlmZihhLCBiLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgc3RhcnRPZih0aW1lc3RhbXAsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBlbmRPZih0aW1lc3RhbXAsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XG4gIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcbn07XG52YXIgYWRhcHRlcnMgPSB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlclxufTtcblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCkge1xuICBpZiAoJ25hdGl2ZScgaW4gZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLngsXG4gICAgICB5OiBlLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEoZSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVBbGxWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGxldCBpbmRleCwgZGF0YSwgZWxlbWVudDtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAoe2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cbmZ1bmN0aW9uIG9wdGltaXplZEV2YWx1YXRlSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBpZiAoIV9pc1BvaW50SW5BcmVhKHBvc2l0aW9uLCBjaGFydC5jaGFydEFyZWEsIGNoYXJ0Ll9taW5QYWRkaW5nKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGlmICghX2lzUG9pbnRJbkFyZWEocG9zaXRpb24sIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmICghX2lzUG9pbnRJbkFyZWEoY2VudGVyLCBjaGFydC5jaGFydEFyZWEsIGNoYXJ0Ll9taW5QYWRkaW5nKSAmJiAhZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gIGV2YWx1YXRlQWxsVmlzaWJsZUl0ZW1zKGNoYXJ0LCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxudmFyIEludGVyYWN0aW9uID0ge1xuICBtb2Rlczoge1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIG9wdGlvbnMuYXhpcyA9ICd4JztcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgb3B0aW9ucy5heGlzID0gJ3knO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGJveCA9IGJveGVzW2ldO1xuICAgICh7cG9zaXRpb246IHBvcywgb3B0aW9uczoge3N0YWNrLCBzdGFja1dlaWdodCA9IDF9fSA9IGJveCk7XG4gICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGJveCxcbiAgICAgIHBvcyxcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgIHN0YWNrOiBzdGFjayAmJiAocG9zICsgc3RhY2spLFxuICAgICAgc3RhY2tXZWlnaHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcbiAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gIGNvbnN0IHt2Qm94TWF4V2lkdGgsIGhCb3hNYXhIZWlnaHR9ID0gcGFyYW1zO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgbGF5b3V0LndpZHRoID0gZmFjdG9yID8gZmFjdG9yICogdkJveE1heFdpZHRoIDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGhCb3hNYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xuICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gIHVwZGF0ZVBvcygncmlnaHQnKTtcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuICByZXR1cm4gaG9yaXpvbnRhbFxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxuICAgIDogbWFyZ2luRm9yUG9zaXRpb25zKFsndG9wJywgJ2JvdHRvbSddKTtcbn1cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcbiAgICBib3gudXBkYXRlKFxuICAgICAgbGF5b3V0LndpZHRoIHx8IGNoYXJ0QXJlYS53LFxuICAgICAgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcbiAgICApO1xuICAgIGNvbnN0IHtzYW1lLCBvdGhlcn0gPSB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcyk7XG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcbiAgICBpZiAoIWJveC5mdWxsU2l6ZSkge1xuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cbmRlZmF1bHRzLnNldCgnbGF5b3V0Jywge1xuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIGxheW91dHMgPSB7XG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oKTtcbiAgICB9KTtcbiAgfVxufTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge31cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbn1cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbiQxKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXIgfHwgY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IF9nZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJ5LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBlbnRyeS5hZGRlZE5vZGVzW2ldO1xuICAgICAgICBpZiAoYWRkZWQgPT09IGVsZW1lbnQgfHwgYWRkZWQgPT09IHBhcmVudCkge1xuICAgICAgICAgIGxpc3RlbmVyKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cnkucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlbnRyeS5yZW1vdmVkTm9kZXNbaV0gPT09IGNhbnZhcykge1xuICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaWYgKGRwciA9PT0gb2xkRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xuICAgIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gZHByKSB7XG4gICAgICByZXNpemUoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGxpc3RlbmVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5QW5kTGlzdGVuKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xuICAgIGlmIChjaGFydC5jdHggIT09IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcbiAgICB9XG4gIH0sIGNoYXJ0LCAoYXJncykgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICByZXR1cm4gW2V2ZW50LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgfSk7XG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5jbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGluaXRpYWwuc3R5bGUgfHwge307XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0pO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSk7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVMaXN0ZW5lcjtcbiAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RldGVjdFBsYXRmb3JtKGNhbnZhcykge1xuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XG4gICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cbiAgZ2V0UHJvcHMocHJvcHMsIGZpbmFsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgcmV0dXJuIG1lO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiBtZVtwcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5FbGVtZW50LmRlZmF1bHRzID0ge307XG5FbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcbiAgfSxcbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTtcbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSk7XG4gICAgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1KSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxudmFyIFRpY2tzID0ge2Zvcm1hdHRlcnN9O1xuXG5kZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICBkaXNwbGF5OiB0cnVlLFxuICBvZmZzZXQ6IGZhbHNlLFxuICByZXZlcnNlOiBmYWxzZSxcbiAgYmVnaW5BdFplcm86IGZhbHNlLFxuICBib3VuZHM6ICd0aWNrcycsXG4gIGdyYWNlOiAwLFxuICBncmlkOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgZHJhd0JvcmRlcjogdHJ1ZSxcbiAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcbiAgICBib3JkZXJXaWR0aDogMVxuICB9LFxuICB0aXRsZToge1xuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIHRleHQ6ICcnLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogNCxcbiAgICAgIGJvdHRvbTogNFxuICAgIH1cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgbWlycm9yOiBmYWxzZSxcbiAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgdGV4dFN0cm9rZUNvbG9yOiAnJyxcbiAgICBwYWRkaW5nOiAzLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgYXV0b1NraXA6IHRydWUsXG4gICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICBtaW5vcjoge30sXG4gICAgbWFqb3I6IHt9LFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBjcm9zc0FsaWduOiAnbmVhcicsXG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gIH1cbn0pO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdib3JkZXJDb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnLFxufSk7XG5cbmZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cbiAgbmV4dCA9IHN0YXJ0O1xuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02O1xuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZTogJ3NjYWxlJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY2ZnLmlkO1xuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN0eCA9IGNmZy5jdHg7XG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gMDtcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBtZS5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoKSk7XG4gICAgbWUuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICBtZS5fdXNlck1pbiA9IG1lLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICBtZS5fdXNlck1heCA9IG1lLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICBtZS5fc3VnZ2VzdGVkTWluID0gbWUucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIG1lLl9zdWdnZXN0ZWRNYXggPSBtZS5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIHJldHVybiByYXc7XG4gIH1cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQge191c2VyTWluLCBfdXNlck1heCwgX3N1Z2dlc3RlZE1pbiwgX3N1Z2dlc3RlZE1heH0gPSB0aGlzO1xuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgIG1pbkRlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWluKSxcbiAgICAgIG1heERlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWF4KVxuICAgIH07XG4gIH1cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gbWUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSBtZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KG1lLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuICBnZXRQYWRkaW5nKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbWUucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogbWUucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IG1lLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiBtZS5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuICAgIG1lLmJlZm9yZVVwZGF0ZSgpO1xuICAgIG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgbWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIG1lLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG4gICAgbWUudGlja3MgPSBudWxsO1xuICAgIG1lLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICBtZS5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgbWUuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICBtZS5zZXREaW1lbnNpb25zKCk7XG4gICAgbWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG4gICAgbWUuX21heExlbmd0aCA9IG1lLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IG1lLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiBtZS5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuICAgIGlmICghbWUuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIG1lLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgbWUuX3JhbmdlID0gX2FkZEdyYWNlKG1lLCBtZS5vcHRpb25zLmdyYWNlKTtcbiAgICAgIG1lLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbWUuYmVmb3JlQnVpbGRUaWNrcygpO1xuICAgIG1lLnRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuICAgIG1lLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCBtZS50aWNrcy5sZW5ndGg7XG4gICAgbWUuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZShtZS50aWNrcywgc2FtcGxlU2l6ZSkgOiBtZS50aWNrcyk7XG4gICAgbWUuY29uZmlndXJlKCk7XG4gICAgbWUuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIG1lLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICBtZS5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICBtZS50aWNrcyA9IGF1dG9Ta2lwKG1lLCBtZS50aWNrcyk7XG4gICAgICBtZS5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIG1lLl9jb252ZXJ0VGlja3NUb0xhYmVscyhtZS50aWNrcyk7XG4gICAgfVxuICAgIG1lLmJlZm9yZUZpdCgpO1xuICAgIG1lLmZpdCgpO1xuICAgIG1lLmFmdGVyRml0KCk7XG4gICAgbWUuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gbWUub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcbiAgICBpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSBtZS5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSBtZS5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IG1lLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gbWUuYm90dG9tO1xuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICBtZS5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgbWUuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgbWUuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIG1lLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgbWUuX2FsaWduVG9QaXhlbHMgPSBtZS5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuICAgICAgbWUubGVmdCA9IDA7XG4gICAgICBtZS5yaWdodCA9IG1lLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG4gICAgICBtZS50b3AgPSAwO1xuICAgICAgbWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuICAgIH1cbiAgICBtZS5wYWRkaW5nTGVmdCA9IDA7XG4gICAgbWUucGFkZGluZ1RvcCA9IDA7XG4gICAgbWUucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICBtZS5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbWUuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCBtZS5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGxiYWNrKG1lLm9wdGlvbnNbbmFtZV0sIFttZV0pO1xuICB9XG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbGJhY2sodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIG1lKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gbWUudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgIGlmICghbWUuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIW1lLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtZS5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZShtZS5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIG1lLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IG1lLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSBtZS5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIG1lLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG4gICAgbWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IG1lO1xuICAgIGNvbnN0IGRpc3BsYXkgPSBtZS5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgbWUudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4obWUubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBtZS5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZS5faGFuZGxlTWFyZ2lucygpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIG1lLndpZHRoID0gbWUuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gbWUuX21hcmdpbnMubGVmdCAtIG1lLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgbWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIG1lLmhlaWdodCA9IG1lLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSBtZS5fbWFyZ2lucy50b3AgLSBtZS5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gbWUubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIG1lLmF4aXMgPT09ICd4JztcbiAgICBpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSBtZS5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSBtZS5yaWdodCAtIG1lLmdldFBpeGVsRm9yVGljayhtZS50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgICBtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgbWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiBtZS53aWR0aCAvIChtZS53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cbiAgICAgIG1lLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIG1lLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChtZS5fbWFyZ2lucykge1xuICAgICAgbWUuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0LCBtZS5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIG1lLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KG1lLnBhZGRpbmdUb3AsIG1lLl9tYXJnaW5zLnRvcCk7XG4gICAgICBtZS5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KG1lLnBhZGRpbmdSaWdodCwgbWUuX21hcmdpbnMucmlnaHQpO1xuICAgICAgbWUuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSwgbWUuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIG1lLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIG1lLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCBsYWJlbFNpemVzID0gbWUuX2xhYmVsU2l6ZXM7XG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gbWUub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gbWUudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG4gICAgICBtZS5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSBtZS5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoKSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge31cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChtZS5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbCA9IG1lLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIG1lLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKG1lLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwobWUuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IG1lLnRpY2tzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dChtZS5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiBtZS4kY29udGV4dCB8fFxuXHRcdFx0KG1lLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KG1lLmNoYXJ0LmdldENvbnRleHQoKSwgbWUpKTtcbiAgfVxuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcbiAgICByZXR1cm4gbWUuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGF4aXMgPSBtZS5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9ufSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSBtZS50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQobWUuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUuYm90dG9tKTtcbiAgICAgIHR5MSA9IG1lLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gbWUudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUucmlnaHQpO1xuICAgICAgdHgxID0gbWUucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IG1lLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQobWUuZ2V0Q29udGV4dChpKSk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBncmlkLmJvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZShtZSwgaSwgb2Zmc2V0KTtcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWUuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgbWUuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYXhpcyA9IG1lLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IG1lLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gbWUuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gbWUuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IG1lLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IG1lLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSBtZS5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IG1lLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IG1lLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IG1lLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IG1lLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSBtZS5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSBtZS5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSBtZS5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGxldCBiYWNrZHJvcDtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuICAgICAgICBsZXQgdG9wID0geSArIHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IHggLSBsYWJlbFBhZGRpbmcubGVmdDtcbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgYmFja2Ryb3AsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gbWUucmlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IG1lLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSBtZS5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gbWUubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbWUubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IG1lLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gbWUuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtZS5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogbWUubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiBtZS5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IG1lLnRvcCwgbGVmdDogMCwgYm90dG9tOiBtZS5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZ3JpZCA9IG1lLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIW1lLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSBtZS50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBncmlkID0gbWUub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IG1lLl9ncmlkTGluZUl0ZW1zIHx8IChtZS5fZ3JpZExpbmVJdGVtcyA9IG1lLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtncmlkfX0gPSBtZTtcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gZ3JpZC5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSBtZS5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuICAgIGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgbWUubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIG1lLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmJvcmRlckNvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcztcbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gbWUuY3R4O1xuICAgIGNvbnN0IGFyZWEgPSBtZS5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IG1lLl9sYWJlbEl0ZW1zIHx8IChtZS5fbGFiZWxJdGVtcyA9IG1lLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGlmIChpdGVtLmJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLmJhY2tkcm9wLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaXRlbS5iYWNrZHJvcC5sZWZ0LCBpdGVtLmJhY2tkcm9wLnRvcCwgaXRlbS5iYWNrZHJvcC53aWR0aCwgaXRlbS5iYWNrZHJvcC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgbGV0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAoIW1lLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZS5kcmF3QmFja2dyb3VuZCgpO1xuICAgIG1lLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgbWUuZHJhd0JvcmRlcigpO1xuICAgIG1lLmRyYXdUaXRsZSgpO1xuICAgIG1lLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBpZiAoIW1lLl9pc1Zpc2libGUoKSB8fCBtZS5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIG1lLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICBtZS5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICBtZS5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICBtZS5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBneiArIDEsXG4gICAgICBkcmF3KCkge1xuICAgICAgICBtZS5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICBtZS5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtZXRhcyA9IG1lLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSBtZS5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gbWUuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbWUuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKG1lLmlzSG9yaXpvbnRhbCgpID8gbWUud2lkdGggOiBtZS5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cblxuY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgcGFyZW50U2NvcGUgPSBtZS5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gbWUuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gbWUuc2NvcGUgKyAnLicgKyBpZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmIChtZS5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG5cbmNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCBtZS5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gbWUucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIG1lLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IG1lLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgbWUuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgfVxuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XG5cbmNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgbWUuX2luaXQgPSBtZS5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgbWUuX25vdGlmeShtZS5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gbWUuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IG1lLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbWUuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgIGlmIChob29rID09PSAnZGVzdHJveScpIHtcbiAgICAgIG1lLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgbWUuX25vdGlmeShtZS5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbHVnaW5zO1xufVxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7c2NyaXB0YWJsZTogZmFsc2UsIGluZGV4YWJsZTogZmFsc2UsIGFsbEtleXM6IHRydWV9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIHNjYWxlT3B0aW9ucy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24oc2NhbGVPcHRpb25zLnBvc2l0aW9uKSB8fCBpZC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3QgZmlyc3RJRHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZik7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIGZpcnN0SURzW2F4aXNdID0gZmlyc3RJRHNbYXhpc10gfHwgaWQ7XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LFxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGlmICgoaXNTY3JpcHRhYmxlKHByb3ApICYmIGlzRnVuY3Rpb24ocHJveHlbcHJvcF0pKVxuICAgICAgfHwgKGlzSW5kZXhhYmxlKHByb3ApICYmIGlzQXJyYXkocHJveHlbcHJvcF0pKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjMuNS4xXCI7XG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5jbGFzcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCBtZS5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgY29uc3QgY29udGV4dCA9IG1lLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB0aGlzLnVwZGF0ZSgncmVzaXplJyksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgaW5zdGFuY2VzW21lLmlkXSA9IG1lO1xuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdG9yLmxpc3RlbihtZSwgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3RlbihtZSwgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgbWUuX2luaXRpYWxpemUoKTtcbiAgICBpZiAobWUuYXR0YWNoZWQpIHtcbiAgICAgIG1lLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcbiAgICBpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBtZS5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIG1lLmJpbmRFdmVudHMoKTtcbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcbiAgICByZXR1cm4gbWU7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IG1lLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gbWUucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgbWUucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIG1lLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICBtZS5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICBtZS5fYXNwZWN0UmF0aW8gPSBtZS5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKG1lLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWUubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcbiAgICBjYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbbWUsIG5ld1NpemVdLCBtZSk7XG4gICAgaWYgKG1lLmF0dGFjaGVkKSB7XG4gICAgICBpZiAobWUuX2RvUmVzaXplKCkpIHtcbiAgICAgICAgbWUucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gbWUuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiBtZS5jdHgsXG4gICAgICAgICAgY2hhcnQ6IG1lXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZShtZSwgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3gobWUsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gbWUuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIG1lLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICBtZS5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gbWU7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIG1lLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG1lLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IG1lLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG4gICAgbWUuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgbWUuY29uZmlnLnR5cGU7XG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICBtZS5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgbWUub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gbWUuaXNEYXRhc2V0VmlzaWJsZShpKTtcbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3MobWUsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIG1lLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgZWFjaChtZS5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCBtZSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjb25maWcgPSBtZS5jb25maWc7XG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIG1lLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCBtZS5nZXRDb250ZXh0KCkpO1xuICAgIGVhY2gobWUuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KG1lLCBzY2FsZSk7XG4gICAgfSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IG1lLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhbWUub3B0aW9ucy5hbmltYXRpb247XG4gICAgbWUuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIG1lLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobWUuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQobWUub3B0aW9ucy5ldmVudHMpO1xuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gbWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBtZS51bmJpbmRFdmVudHMoKTtcbiAgICAgIG1lLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gICAgbWUuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICAgIGlmIChtZS5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IG1lLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWUuX21pblBhZGRpbmcgPSBtaW5QYWRkaW5nO1xuICAgIG1lLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbWUuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcbiAgICBtZS5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuICAgIGlmIChtZS5fbGFzdEV2ZW50KSB7XG4gICAgICBtZS5fZXZlbnRIYW5kbGVyKG1lLl9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH1cbiAgICBtZS5yZW5kZXIoKTtcbiAgfVxuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheW91dHMudXBkYXRlKG1lLCBtZS53aWR0aCwgbWUuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcbiAgICBjb25zdCBhcmVhID0gbWUuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuICAgIG1lLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKG1lLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgbWUuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIG1lKTtcbiAgICBtZS5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAobWUubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBtZS5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcbiAgICBpZiAobWUubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChtZS5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3IuaGFzKG1lKSkge1xuICAgICAgaWYgKG1lLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKG1lKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydChtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogbWV9KTtcbiAgICB9XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IGk7XG4gICAgaWYgKG1lLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBtZS5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIG1lLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICBtZS5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIG1lLmNsZWFyKCk7XG4gICAgaWYgKG1lLndpZHRoIDw9IDAgfHwgbWUuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSBtZS5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcobWUuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgbWUuX2RyYXdEYXRhc2V0cygpO1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyhtZS5jaGFydEFyZWEpO1xuICAgIH1cbiAgICBtZS5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbWV0YXNldHMgPSBtZS5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKG1lLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gbWUuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWUuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG4gICAgbWUubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjdHggPSBtZS5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSBtZS5jaGFydEFyZWE7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmIChtZS5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCB7XG4gICAgICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxuICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyBtZS53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxuICAgICAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIGNsaXAudG9wLFxuICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IG1lLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBkYXRhc2V0ID0gbWUuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gbWUuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KTtcbiAgfVxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIG1lLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICBtZS51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1ldGEgPSBtZS5fbWV0YXNldHMgJiYgbWUuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSBtZS5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IG1lO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIG1lLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUobWUpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbWUuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gICAgbWUuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBtZS51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIG1lLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICBtZS5jYW52YXMgPSBudWxsO1xuICAgICAgbWUuY3R4ID0gbnVsbDtcbiAgICB9XG4gICAgbWUubm90aWZ5UGx1Z2lucygnZGVzdHJveScpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbbWUuaWRdO1xuICB9XG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IG1lLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBmdW5jdGlvbihlLCB4LCB5KSB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIG1lLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcbiAgICBlYWNoKG1lLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAoIW1lLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICBtZS5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBtZS5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IG1lLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAobWUuY2FudmFzKSB7XG4gICAgICAgIG1lLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgIG1lLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIG1lLnJlc2l6ZSgpO1xuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBtZS5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQobWUuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBlYWNoKG1lLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgbWUucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIG1lLl9saXN0ZW5lcnMgPSB7fTtcbiAgICBlYWNoKG1lLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIG1lLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICBtZS5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSBtZS5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIG1lLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBtZS5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gbWUub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIG1lLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICBtZS51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBhcmdzID0ge2V2ZW50OiBlLCByZXBsYXksIGNhbmNlbGFibGU6IHRydWV9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLnR5cGUpO1xuICAgIGlmIChtZS5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IG1lLl9oYW5kbGVFdmVudChlLCByZXBsYXkpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIG1lLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICBtZS5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lO1xuICB9XG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXkpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSBtZTtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSBvcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgbGV0IGFjdGl2ZSA9IFtdO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IGxhc3RFdmVudCA9IG51bGw7XG4gICAgaWYgKGUudHlwZSAhPT0gJ21vdXNlb3V0Jykge1xuICAgICAgYWN0aXZlID0gbWUuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgIGxhc3RFdmVudCA9IGUudHlwZSA9PT0gJ2NsaWNrJyA/IG1lLl9sYXN0RXZlbnQgOiBlO1xuICAgIH1cbiAgICBtZS5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICBpZiAoX2lzUG9pbnRJbkFyZWEoZSwgbWUuY2hhcnRBcmVhLCBtZS5fbWluUGFkZGluZykpIHtcbiAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgbWVdLCBtZSk7XG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xuICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIG1lXSwgbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICBtZS5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgbWUuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG4gICAgbWUuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxufVxuY29uc3QgaW52YWxpZGF0ZVBsdWdpbnMgPSAoKSA9PiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xuY29uc3QgZW51bWVyYWJsZSA9IHRydWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFydCwge1xuICBkZWZhdWx0czoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGRlZmF1bHRzXG4gIH0sXG4gIGluc3RhbmNlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGluc3RhbmNlc1xuICB9LFxuICBvdmVycmlkZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBvdmVycmlkZXNcbiAgfSxcbiAgcmVnaXN0cnk6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiByZWdpc3RyeVxuICB9LFxuICB2ZXJzaW9uOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogdmVyc2lvblxuICB9LFxuICBnZXRDaGFydDoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGdldENoYXJ0XG4gIH0sXG4gIHJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSkge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyQxKGFyYywgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBhbmdsZURlbHRhKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuZnVuY3Rpb24gclRoZXRhVG9YWShyLCB0aGV0YSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuICBpZiAoc3BhY2luZykge1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMkMShlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcbiAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgfVxuICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgfVxuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcbiAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG4gIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZykge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgc3RhcnRBbmdsZSArIFRBVSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlICUgVEFVO1xuICAgICAgaWYgKGNpcmN1bWZlcmVuY2UgJSBUQVUgPT09IDApIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gVEFVO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSk7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cbmZ1bmN0aW9uIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgZnVsbENpcmNsZXN9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGVsZW1lbnQuaW5uZXJSYWRpdXMgKyBwaXhlbE1hcmdpbjtcbiAgbGV0IGk7XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIHN0YXJ0QW5nbGUgKyBUQVUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpIHtcbiAgY29uc3Qge29wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuICBpZiAoIW9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gJ2JldmVsJztcbiAgfVxuICBpZiAoZWxlbWVudC5mdWxsQ2lyY2xlcykge1xuICAgIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKTtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcbiAgY3R4LnN0cm9rZSgpO1xufVxuY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShjaGFydFgsIGNoYXJ0WSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSB0aGlzLm9wdGlvbnMuc3BhY2luZyAvIDI7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IGNpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gaW5uZXJSYWRpdXMgKyByQWRqdXN0ICYmIGRpc3RhbmNlIDw9IG91dGVyUmFkaXVzICsgckFkanVzdCk7XG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnLFxuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSBtZTtcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyAyO1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBtZS5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIG1lLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IG1lLmlubmVyUmFkaXVzIDwgMCB8fCBtZS5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgcmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKG1lLnN0YXJ0QW5nbGUgKyBtZS5lbmRBbmdsZSkgLyAyO1xuICAgICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0KTtcbiAgICAgIGlmIChtZS5jaXJjdW1mZXJlbmNlID49IFBJKSB7XG4gICAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgZW5kQW5nbGUgPSBkcmF3QXJjKGN0eCwgbWUsIHJhZGl1c09mZnNldCwgc3BhY2luZyk7XG4gICAgZHJhd0JvcmRlcihjdHgsIG1lLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5BcmNFbGVtZW50LmlkID0gJ2FyYyc7XG5BcmNFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDIsXG4gIG9mZnNldDogMCxcbiAgc3BhY2luZzogMCxcbiAgYW5nbGU6IHVuZGVmaW5lZCxcbn07XG5BcmNFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbn07XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG4gIHJldHVybiBsaW5lVG87XG59XG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cbiAgcmV0dXJuICEhbG9vcDtcbn1cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgbGluZS5zZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIW1lLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IG1lLl9sb29wIDogbWUuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMobWUuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgbWUuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBtZS5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSBtZS5fc2VnbWVudHM7XG4gICAgZGVsZXRlIG1lLl9wYXRoO1xuICAgIG1lLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IG1lLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKG1lLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBzZWdtZW50cyA9IG1lLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChtZSk7XG4gICAgbGV0IGxvb3AgPSBtZS5fbG9vcDtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAobWUucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIG1lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gbWUucG9pbnRzIHx8IFtdO1xuICAgIGlmICghcG9pbnRzLmxlbmd0aCB8fCAhb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGRyYXcoY3R4LCBtZSwgc3RhcnQsIGNvdW50KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmIChtZS5hbmltYXRlZCkge1xuICAgICAgbWUuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIG1lLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuTGluZUVsZW1lbnQuaWQgPSAnbGluZSc7XG5MaW5lRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgYm9yZGVyV2lkdGg6IDMsXG4gIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICBmaWxsOiBmYWxzZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxuICBzdGVwcGVkOiBmYWxzZSxcbiAgdGVuc2lvbjogMCxcbn07XG5MaW5lRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcbkxpbmVFbGVtZW50LmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG59O1xuXG5mdW5jdGlvbiBpblJhbmdlJDEoZWwsIHBvcywgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cbmNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIHNpemUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cbiAgZHJhdyhjdHgsIGFyZWEpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgaWYgKG1lLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKG1lLCBhcmVhLCBtZS5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgbWUueCwgbWUueSk7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuUG9pbnRFbGVtZW50LmlkID0gJ3BvaW50JztcblBvaW50RWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGhpdFJhZGl1czogMSxcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgaG92ZXJSYWRpdXM6IDQsXG4gIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICByYWRpdXM6IDMsXG4gIHJvdGF0aW9uOiAwXG59O1xuUG9pbnRFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXG5cdFx0JiYgKHNraXBZIHx8IHkgPj0gYm91bmRzLnRvcCAmJiB5IDw9IGJvdW5kcy5ib3R0b20pO1xufVxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcbiAgICBjb25zdCBpbmZsYXRlQW1vdW50ID0gMC4zMztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuQmFyRWxlbWVudC5pZCA9ICdiYXInO1xuQmFyRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgZW5hYmxlQm9yZGVyUmFkaXVzOiB0cnVlLFxuICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbn07XG5CYXJFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5BcmNFbGVtZW50OiBBcmNFbGVtZW50LFxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxuUG9pbnRFbGVtZW50OiBQb2ludEVsZW1lbnQsXG5CYXJFbGVtZW50OiBCYXJFbGVtZW50XG59KTtcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge3ZhbHVlOiBkYXRhfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbnZhciBwbHVnaW5fZGVjaW1hdGlvbiA9IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdsaW5lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuZnVuY3Rpb24gZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIGlmIChmaWxsWzBdID09PSAnLScgfHwgZmlsbFswXSA9PT0gJysnKSB7XG4gICAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgbGV0IHRhcmdldCA9IG51bGw7XG4gIGxldCBob3Jpem9udGFsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHRhcmdldCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHRhcmdldCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHRhcmdldCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyRmluaXRlKHRhcmdldCkpIHtcbiAgICBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiB0YXJnZXRcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgZW5kID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICBsZXQgaSwgY2VudGVyLCB2YWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBlbmQ7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIHBvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IGZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIHNjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhjaGFydCwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5jb25zdCBpc0xpbmVBbmROb3RJbkhpZGVBbmltYXRpb24gPSAobWV0YSkgPT4gbWV0YS50eXBlID09PSAnbGluZScgJiYgIW1ldGEuaGlkZGVuO1xuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGlzTGluZUFuZE5vdEluSGlkZUFuaW1hdGlvbihtZXRhKSkge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChwb2ludFZhbHVlID49IGZpcnN0VmFsdWUgJiYgcG9pbnRWYWx1ZSA8PSBsYXN0VmFsdWUpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIGJ1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IHBvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbaW5kZXhdO1xuICBsZXQgdGFyZ2V0O1xuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfY2xpcChjdHgsIHRhcmdldCwgY2xpcFkpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICB0YXJnZXQucGF0aChjdHgpO1xuICBjdHgubGluZVRvKHRhcmdldC5sYXN0KCkueCwgY2xpcFkpO1xuICBjdHgubGluZVRvKHRhcmdldC5maXJzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG5mdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcbiAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBnZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICBjb25zdCB7dG9wLCBib3R0b219ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5mdW5jdGlvbiBfZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcbiAgICBsZXQgbG9vcDtcbiAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIGVuZCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlfSA9IGNmZztcbiAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuICBjdHguc2F2ZSgpO1xuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBfY2xpcChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIF9maWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgX2NsaXAoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBfZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5fSk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2xpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXN9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cbnZhciBwbHVnaW5fZmlsbGVyID0ge1xuICBpZDogJ2ZpbGxlcicsXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmZpbGwgPSByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBkcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG4gIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgIGJveFdpZHRoID0gTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYikgPT4gYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbHVtblNpemVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbWUubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICBtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgbWUuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgIG1lLnNldERpbWVuc2lvbnMoKTtcbiAgICBtZS5idWlsZExhYmVscygpO1xuICAgIG1lLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWUud2lkdGggPSBtZS5tYXhXaWR0aDtcbiAgICAgIG1lLmxlZnQgPSBtZS5fbWFyZ2lucy5sZWZ0O1xuICAgICAgbWUucmlnaHQgPSBtZS53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuICAgICAgbWUudG9wID0gbWUuX21hcmdpbnMudG9wO1xuICAgICAgbWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuICAgIH1cbiAgfVxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gbWUub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbbWUuY2hhcnRdLCBtZSkgfHwgW107XG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIG1lLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIG1lLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBtZS5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSBtZTtcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgbWUud2lkdGggPSBtZS5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSBtZS5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSBtZS5tYXhXaWR0aDtcbiAgICAgIGhlaWdodCA9IG1lLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IG1lLm1heEhlaWdodDtcbiAgICAgIHdpZHRoID0gbWUuX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9XG4gICAgbWUud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCBtZS5tYXhXaWR0aCk7XG4gICAgbWUuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCBtZS5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gbWU7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIG1lLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgfVxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSBtZTtcbiAgICBjb25zdCBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSBtZS5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgbWUubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgaWYgKCFtZS5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSBtZS5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSBtZTtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgbWUubGVmdCwgbWUud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLmxlZnQgKyBwYWRkaW5nLCBtZS5yaWdodCAtIG1lLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLmxlZnQgKyBwYWRkaW5nLCBtZS5yaWdodCAtIG1lLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSBtZS50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgbWUuYm90dG9tIC0gbWUuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIG1lLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgbWUuYm90dG9tIC0gbWUuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IG1lLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAobWUub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSBtZS5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIG1lKTtcbiAgICAgIG1lLl9kcmF3KCk7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSBtZTtcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgbWUubGVmdCwgbWUud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge2NvbG9yOiBmb250Q29sb3IsIHBhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG4gICAgbWUuZHJhd1RpdGxlKCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveFdpZHRoICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBtZS5sZWZ0ICsgcGFkZGluZywgbWUucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogbWUudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IG1lLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgbWUudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCBtZS5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24obWUuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBtZS5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aChtZS53aWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBwYWRkaW5nID4gbWUucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBtZS5sZWZ0ICsgcGFkZGluZywgbWUucmlnaHQgLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiBtZS5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBtZS50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIG1lLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogbWUucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbihtZS5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIG1lLmxlZnQsIG1lLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSBtZS5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcbiAgICBsZXQgbGVmdCA9IG1lLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gbWUud2lkdGg7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoLi4ubWUubGluZVdpZHRocyk7XG4gICAgICB5ID0gbWUudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgbWUucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IG1lLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBtZS50b3AsIG1lLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSBtZS5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuICAgIGlmICh4ID49IG1lLmxlZnQgJiYgeCA8PSBtZS5yaWdodCAmJiB5ID49IG1lLnRvcCAmJiB5IDw9IG1lLmJvdHRvbSkge1xuICAgICAgbGggPSBtZS5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcbiAgICAgICAgaWYgKHggPj0gaGl0Qm94LmxlZnQgJiYgeCA8PSBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aCAmJiB5ID49IGhpdEJveC50b3AgJiYgeSA8PSBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkge1xuICAgICAgICAgIHJldHVybiBtZS5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gbWUuX2hvdmVyZWRJdGVtO1xuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCBtZV0sIG1lKTtcbiAgICAgIH1cbiAgICAgIG1lLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgbWVdLCBtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbGJhY2sob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIG1lXSwgbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJyAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgaWQ6ICdsZWdlbmQnLFxuICBfZWxlbWVudDogTGVnZW5kLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgbWUubGVmdCA9IDA7XG4gICAgbWUudG9wID0gMDtcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgbWUud2lkdGggPSBtZS5oZWlnaHQgPSBtZS5yaWdodCA9IG1lLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lLndpZHRoID0gbWUucmlnaHQgPSBtYXhXaWR0aDtcbiAgICBtZS5oZWlnaHQgPSBtZS5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgbWUuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyBtZS5fcGFkZGluZy5oZWlnaHQ7XG4gICAgaWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtZS5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWUud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBjdHggPSBtZS5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG1lLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSBtZS5fZHJhd0FyZ3Mob2Zmc2V0KTtcbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG52YXIgcGx1Z2luX3RpdGxlID0ge1xuICBpZDogJ3RpdGxlJyxcbiAgX2VsZW1lbnQ6IFRpdGxlLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBwbHVnaW5fc3VidGl0bGUgPSB7XG4gIGlkOiAnc3VidGl0bGUnLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHggKz0gcG9zLng7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gY291bnQsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlO1xufVxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLl9jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuICBpZiAodGl0bGVMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMudGl0bGVTcGFjaW5nXG5cdFx0XHQrIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gIH1cbiAgaWYgKGNvbWJpbmVkQm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogb3B0aW9ucy5ib2R5U3BhY2luZztcbiAgfVxuICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gIH1cbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuICB3aWR0aFBhZGRpbmcgPSAwO1xuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuICBjdHgucmVzdG9yZSgpO1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gIGNvbnN0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0JyAmJiB4IC0gd2lkdGggLSBjYXJldCA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cbiAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuICByZXR1cm4geEFsaWduO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5mdW5jdGlvbiBhbGlnblgoc2l6ZSwgeEFsaWduKSB7XG4gIGxldCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3QgcmFkaXVzQW5kUGFkZGluZyA9IGNvcm5lclJhZGl1cyArIGNhcmV0UGFkZGluZztcbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSByYWRpdXNBbmRQYWRkaW5nO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gcmFkaXVzQW5kUGFkZGluZztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudCksIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9jaGFydCA9IGNvbmZpZy5fY2hhcnQ7XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGVkID0gbWUuX2NhY2hlZEFuaW1hdGlvbnM7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSBtZS5fY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnMuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhtZS5fY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIG1lLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgcmV0dXJuIG1lLiRjb250ZXh0IHx8XG5cdFx0XHQobWUuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dChtZS5fY2hhcnQuZ2V0Q29udGV4dCgpLCBtZSwgbWUuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KG1lLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IHRpdGxlID0gY2FsbGJhY2tzLnRpdGxlLmFwcGx5KG1lLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseShtZSwgW2NvbnRleHRdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmJlZm9yZUxhYmVsLmNhbGwobWUsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKG1lLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmFmdGVyTGFiZWwuY2FsbChtZSwgY29udGV4dCkpKTtcbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG4gIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseShtZSwgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseShtZSwgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1lLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IG1lLl9jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0obWUuX2NoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goc2NvcGVkLmxhYmVsQ29sb3IuY2FsbChtZSwgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKHNjb3BlZC5sYWJlbFBvaW50U3R5bGUuY2FsbChtZSwgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goc2NvcGVkLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIGNvbnRleHQpKTtcbiAgICB9KTtcbiAgICBtZS5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIG1lLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIG1lLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICBtZS5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcHRpb25zID0gbWUub3B0aW9ucy5zZXRDb250ZXh0KG1lLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gbWUuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAobWUub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKG1lLCBhY3RpdmUsIG1lLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IG1lLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcbiAgICAgIG1lLnRpdGxlID0gbWUuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIG1lLmJlZm9yZUJvZHkgPSBtZS5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBtZS5ib2R5ID0gbWUuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgbWUuYWZ0ZXJCb2R5ID0gbWUuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBtZS5mb290ZXIgPSBtZS5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpemUgPSBtZS5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKG1lLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChtZS5fY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIG1lLl9jaGFydCk7XG4gICAgICBtZS54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgbWUueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cbiAgICBtZS5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIG1lLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICBtZS5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUobWUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwobWUsIHtjaGFydDogbWUuX2NoYXJ0LCB0b29sdGlwOiBtZSwgcmVwbGF5fSk7XG4gICAgfVxuICB9XG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjb3JuZXJSYWRpdXMsIGNhcmV0U2l6ZX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgY29ybmVyUmFkaXVzICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gY29ybmVyUmFkaXVzIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpdGxlID0gbWUudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCBtZS54LCBtZS53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgobWUsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBtZS5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSBtZS5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgobWUsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMixcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoIHx8IDE7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9ycy5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3JzLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3JzLmJvcmRlclJhZGl1cyk7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IG1lLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5fSA9IG1lO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCBtZS54LCBtZS53aWR0aCk7XG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgIHB0LnggPSBnZXRBbGlnbmVkWChtZSwgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKG1lLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgMSkgOiAoYm94V2lkdGggKyAyKVxuICAgICAgOiAwO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gbWUubGFiZWxUZXh0Q29sb3JzW2ldO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIG1lLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgZWFjaChtZS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nO1xuICB9XG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBmb290ZXIgPSBtZS5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCBtZS54LCBtZS53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgobWUsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMuY29ybmVyUmFkaXVzO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgY2hhcnQgPSBtZS5fY2hhcnQ7XG4gICAgY29uc3QgYW5pbXMgPSBtZS4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKG1lLCBtZS5fYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSBtZS5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKG1lLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBtZS5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgbWUueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgbWUueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgICAgbWUud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICBtZS5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgbWUuY2FyZXRYID0gcG9zaXRpb24ueDtcbiAgICAgICAgbWUuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgbWUuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKG1lLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zLnNldENvbnRleHQobWUuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgb3BhY2l0eSA9IG1lLm9wYWNpdHk7XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogbWUud2lkdGgsXG4gICAgICBoZWlnaHQ6IG1lLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiBtZS54LFxuICAgICAgeTogbWUueVxuICAgIH07XG4gICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IG1lLnRpdGxlLmxlbmd0aCB8fCBtZS5iZWZvcmVCb2R5Lmxlbmd0aCB8fCBtZS5ib2R5Lmxlbmd0aCB8fCBtZS5hZnRlckJvZHkubGVuZ3RoIHx8IG1lLmZvb3Rlci5sZW5ndGg7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICBtZS5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcbiAgICAgIG1lLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIG1lLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgbWUuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZS5fY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSBtZS5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICBtZS5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgbWUuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgbWUudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFdmVudChlLCByZXBsYXkpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmUgfHwgW107XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgYWN0aXZlID0gW107XG4gICAgaWYgKGUudHlwZSAhPT0gJ21vdXNlb3V0Jykge1xuICAgICAgYWN0aXZlID0gbWUuX2NoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuICAgICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSBtZS5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG4gICAgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIG1lLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgbWUuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuICAgICAgICBtZS51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICBjb25zdCB7Y2FyZXRYLCBjYXJldFksIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcbiAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgfVxufVxuVG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xudmFyIHBsdWdpbl90b29sdGlwID0ge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtfY2hhcnQ6IGNoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgdG9vbHRpcFxuICAgIH07XG4gICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0b29sdGlwKSB7XG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcbiAgICB9XG4gICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gICAgICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICAgIGFmdGVyVGl0bGU6IG5vb3AsXG4gICAgICBiZWZvcmVCb2R5OiBub29wLFxuICAgICAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICBsYWJlbCArPSAnOiAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuICAgICAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgfSxcbiAgICAgIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxhYmVsOiBub29wLFxuICAgICAgYWZ0ZXJCb2R5OiBub29wLFxuICAgICAgYmVmb3JlRm9vdGVyOiBub29wLFxuICAgICAgZm9vdGVyOiBub29wLFxuICAgICAgYWZ0ZXJGb290ZXI6IG5vb3BcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcblxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5EZWNpbWF0aW9uOiBwbHVnaW5fZGVjaW1hdGlvbixcbkZpbGxlcjogcGx1Z2luX2ZpbGxlcixcbkxlZ2VuZDogcGx1Z2luX2xlZ2VuZCxcblN1YlRpdGxlOiBwbHVnaW5fc3VidGl0bGUsXG5UaXRsZTogcGx1Z2luX3RpdGxlLFxuVG9vbHRpcDogcGx1Z2luX3Rvb2x0aXBcbn0pO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgpID0+IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnXG4gID8gbGFiZWxzLnB1c2gocmF3KSAtIDFcbiAgOiBpc05hTihyYXcpID8gbnVsbCA6IGluZGV4O1xuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4KSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5jbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBtZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSBtZS5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgaWYgKG1lLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBtZS5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBtZS5taW4gPSBtaW47XG4gICAgbWUubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG1pbiA9IG1lLm1pbjtcbiAgICBjb25zdCBtYXggPSBtZS5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuICAgIG1lLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIG1lLl9zdGFydFZhbHVlID0gbWUubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICghbWUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1lLl9yZXZlcnNlUGl4ZWxzID0gIW1lLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IG1lLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIG1lLl9zdGFydFZhbHVlKSAvIG1lLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBtZS50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBtZS5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtZS5fc3RhcnRWYWx1ZSArIG1lLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiBtZS5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuQ2F0ZWdvcnlTY2FsZS5pZCA9ICdjYXRlZ29yeSc7XG5DYXRlZ29yeVNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBDYXRlZ29yeVNjYWxlLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcn0pO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgaWYgKGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBtZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSBtZTtcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IDE7XG4gICAgICBpZiAobWF4ID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG1pbiA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhtYXggKiAwLjA1KTtcbiAgICAgIH1cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWUubWluID0gbWluO1xuICAgIG1lLm1heCA9IG1heDtcbiAgfVxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSBtZS5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBsZXQgbWF4VGlja3MgPSBtZS5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogbWUuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogbWUuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSBtZS5fcmFuZ2UgfHwgbWU7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIG1lLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgbWUuc3RhcnQgPSBtZS5tYXg7XG4gICAgICBtZS5lbmQgPSBtZS5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLnN0YXJ0ID0gbWUubWluO1xuICAgICAgbWUuZW5kID0gbWUubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IG1lLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IG1lLm1pbjtcbiAgICBsZXQgZW5kID0gbWUubWF4O1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmIChtZS5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICBtZS5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIG1lLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICBtZS5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgfVxufVxuXG5jbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSBtZS5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgbWUubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgbWUubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XG4gICAgbWUuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnMobWUub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSBtZS5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG5MaW5lYXJTY2FsZS5pZCA9ICdsaW5lYXInO1xuTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcbiAgY29uc3QgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgbGV0IHRpY2tWYWwgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcbiAgbGV0IGV4cCA9IE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgZG8ge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICAgICsrc2lnbmlmaWNhbmQ7XG4gICAgaWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSAxO1xuICAgICAgKytleHA7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICByZXR1cm4gdGlja3M7XG59XG5jbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSBtZS5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgbWUubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIG1lLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcbiAgICBpZiAobWUub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgbWUuX3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICBtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gbWUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSBtZS5taW47XG4gICAgbGV0IG1heCA9IG1lLm1heDtcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGNvbnN0IGV4cCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh2KSkgKyBtKTtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGV4cChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGV4cChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuICAgICAgc2V0TWF4KGV4cChtaW4sICsxKSk7XG4gICAgfVxuICAgIGlmIChtZS5femVybyAmJiBtZS5taW4gIT09IG1lLl9zdWdnZXN0ZWRNaW4gJiYgbWluID09PSBleHAobWUubWluLCAwKSkge1xuICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgfVxuICAgIG1lLm1pbiA9IG1pbjtcbiAgICBtZS5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IG1lLl91c2VyTWluLFxuICAgICAgbWF4OiBtZS5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBtZSk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIG1lLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgbWUuc3RhcnQgPSBtZS5tYXg7XG4gICAgICBtZS5lbmQgPSBtZS5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLnN0YXJ0ID0gbWUubWluO1xuICAgICAgbWUuZW5kID0gbWUubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJzAnIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gbWUubWluO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIG1lLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIG1lLl92YWx1ZVJhbmdlID0gbG9nMTAobWUubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IG1lLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIG1lLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gbWUubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIG1lLl9zdGFydFZhbHVlKSAvIG1lLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgbWUuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogbWUuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG5Mb2dhcml0aG1pY1NjYWxlLmlkID0gJ2xvZ2FyaXRobWljJztcbkxvZ2FyaXRobWljU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcbiAgY29uc3QgZnVydGhlc3RMaW1pdHMgPSB7XG4gICAgbDogMCxcbiAgICByOiBzY2FsZS53aWR0aCxcbiAgICB0OiAwLFxuICAgIGI6IHNjYWxlLmhlaWdodCAtIHNjYWxlLnBhZGRpbmdUb3BcbiAgfTtcbiAgY29uc3QgZnVydGhlc3RBbmdsZXMgPSB7fTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcbiAgICBjb25zdCBhbmdsZSA9IHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuICAgICAgZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG4gICAgICBmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuICAgIH1cbiAgICBpZiAoaExpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5yKSB7XG4gICAgICBmdXJ0aGVzdExpbWl0cy5yID0gaExpbWl0cy5lbmQ7XG4gICAgICBmdXJ0aGVzdEFuZ2xlcy5yID0gYW5nbGVSYWRpYW5zO1xuICAgIH1cbiAgICBpZiAodkxpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLnQpIHtcbiAgICAgIGZ1cnRoZXN0TGltaXRzLnQgPSB2TGltaXRzLnN0YXJ0O1xuICAgICAgZnVydGhlc3RBbmdsZXMudCA9IGFuZ2xlUmFkaWFucztcbiAgICB9XG4gICAgaWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuICAgICAgZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuICAgICAgZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcbiAgICB9XG4gIH1cbiAgc2NhbGUuX3NldFJlZHVjdGlvbnMoc2NhbGUuZHJhd2luZ0FyZWEsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcyk7XG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgdGlja0JhY2tkcm9wSGVpZ2h0ID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpO1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBleHRyYSA9IChpID09PSAwID8gdGlja0JhY2tkcm9wSGVpZ2h0IC8gMiA6IDApO1xuICAgIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZ1tpXSk7XG4gICAgY29uc3QgYW5nbGUgPSB0b0RlZ3JlZXMoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSk7XG4gICAgY29uc3Qgc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG4gICAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gICAgaXRlbXMucHVzaCh7XG4gICAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICAgIHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICBsZWZ0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgICBib3R0b206IHkgKyBzaXplLmhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cbiAgcmV0dXJuICdyaWdodCc7XG59XG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ24sIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHNBdEluZGV4O1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCAtIHBhZGRpbmcubGVmdCwgdG9wIC0gcGFkZGluZy50b3AsIHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGgsIGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0KTtcbiAgICB9XG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBudW1iZXJPclplcm8ocGFyYW0pIHtcbiAgcmV0dXJuIGlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50KSwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cbmNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuICAgIG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcbiAgICBtZS5wYWRkaW5nVG9wID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG1lLm9wdGlvbnMpIC8gMjtcbiAgICBtZS54Q2VudGVyID0gTWF0aC5mbG9vcihtZS53aWR0aCAvIDIpO1xuICAgIG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAvIDIpO1xuICAgIG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4obWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCwgbWUud2lkdGgpIC8gMjtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gbWUuZ2V0TWluTWF4KGZhbHNlKTtcbiAgICBtZS5taW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICBtZS5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcbiAgICBtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwobWUsIHRpY2tzKTtcbiAgICBtZS5fcG9pbnRMYWJlbHMgPSBtZS5nZXRMYWJlbHMoKS5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBjYWxsYmFjayhtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgbWUpO1xuICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICB9KTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdHMgPSBtZS5vcHRpb25zO1xuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHMobWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgX3NldFJlZHVjdGlvbnMobGFyZ2VzdFBvc3NpYmxlUmFkaXVzLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG4gICAgbGV0IHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuICAgIGxldCByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuICAgIGxldCByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcbiAgICByYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkxlZnQpO1xuICAgIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblJpZ2h0KTtcbiAgICByYWRpdXNSZWR1Y3Rpb25Ub3AgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uVG9wKTtcbiAgICByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcbiAgICBtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWF4KGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAvIDIsIE1hdGgubWluKFxuICAgICAgTWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uTGVmdCArIHJhZGl1c1JlZHVjdGlvblJpZ2h0KSAvIDIpLFxuICAgICAgTWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uVG9wICsgcmFkaXVzUmVkdWN0aW9uQm90dG9tKSAvIDIpKSk7XG4gICAgbWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcbiAgfVxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuICAgIGNvbnN0IG1heExlZnQgPSBsZWZ0TW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcbiAgICBjb25zdCBtYXhUb3AgPSB0b3BNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xuICAgIGNvbnN0IG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG4gICAgbWUueENlbnRlciA9IE1hdGguZmxvb3IoKChtYXhMZWZ0ICsgbWF4UmlnaHQpIC8gMikgKyBtZS5sZWZ0KTtcbiAgICBtZS55Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heFRvcCArIG1heEJvdHRvbSkgLyAyKSArIG1lLnRvcCArIG1lLnBhZGRpbmdUb3ApO1xuICB9XG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyB0aGlzLmdldExhYmVscygpLmxlbmd0aDtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSBtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pO1xuICAgIGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAobWUubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIG1lLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvIChtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pKTtcbiAgICByZXR1cm4gbWUub3B0aW9ucy5yZXZlcnNlID8gbWUubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiBtZS5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBwb2ludExhYmVscyA9IG1lLl9wb2ludExhYmVscyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChtZS5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IG1lLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gbWUuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKG1lLCBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS5fZW5kVmFsdWUpLCBjaXJjdWxhciwgbWUuZ2V0TGFiZWxzKCkubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZH0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSBtZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKG1lLCBsYWJlbENvdW50KTtcbiAgICB9XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgbWUudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQobWUuZ2V0Q29udGV4dChpbmRleCAtIDEpKTtcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZShtZSwgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZm9yIChpID0gbWUuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQobWUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gbWUubWluIDogbWUubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSBtZS5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHt9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGN0eCA9IG1lLmN0eDtcbiAgICBjb25zdCBvcHRzID0gbWUub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgbWUudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dChtZS5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IG1lLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG1lLnRpY2tzW2luZGV4XS52YWx1ZSk7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7fVxufVxuUmFkaWFsTGluZWFyU2NhbGUuaWQgPSAncmFkaWFsTGluZWFyJztcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICBkaXNwbGF5OiB0cnVlLFxuICBhbmltYXRlOiB0cnVlLFxuICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG4gIGFuZ2xlTGluZXM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgfSxcbiAgZ3JpZDoge1xuICAgIGNpcmN1bGFyOiBmYWxzZVxuICB9LFxuICBzdGFydEFuZ2xlOiAwLFxuICB0aWNrczoge1xuICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfSxcbiAgcG9pbnRMYWJlbHM6IHtcbiAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgZm9udDoge1xuICAgICAgc2l6ZTogMTBcbiAgICB9LFxuICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBwYWRkaW5nOiA1XG4gIH1cbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0Um91dGVzID0ge1xuICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZXNjcmlwdG9ycyA9IHtcbiAgYW5nbGVMaW5lczoge1xuICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gIH1cbn07XG5cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5jb25zdCBVTklUUyA9IChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuICBpZiAoIWlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzKSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IG1lLmdldFVzZXJCb3VuZHMoKTtcbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgX2FwcGx5Qm91bmRzKG1lLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKG1lLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuICAgIG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgbWUubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IG1lLmdldExhYmVsVGltZXN0YW1wcygpIDogbWUuX2dlbmVyYXRlKCk7XG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBtZS5taW4gPSBtZS5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgbWUubWF4ID0gbWUuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSBtZS5taW47XG4gICAgY29uc3QgbWF4ID0gbWUubWF4O1xuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgIG1lLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCwgbWUuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgbWUubWluLCBtZS5tYXgpKTtcbiAgICBtZS5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgbWUuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQobWUuX3VuaXQpO1xuICAgIG1lLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIHRpY2tzLCBtZS5fbWFqb3JVbml0KTtcbiAgfVxuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgIGlmIChtZS5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSBtZS5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IChtZS5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IG1lLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIG1lLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG4gICAgbWUuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IG1lLm1pbjtcbiAgICBjb25zdCBtYXggPSBtZS5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIG1lLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiBtZS5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gbWUuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gbWUuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG4gICAgY29uc3QgbGFiZWwgPSBtZS5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgIHJldHVybiBmb3JtYXR0ZXIgPyBjYWxsYmFjayhmb3JtYXR0ZXIsIFtsYWJlbCwgaW5kZXgsIHRpY2tzXSwgbWUpIDogbGFiZWw7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSBtZS5taW4pIC8gKG1lLm1heCAtIG1lLm1pbik7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXRzID0gbWUuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gbWUuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gbWUubWluICsgcG9zICogKG1lLm1heCAtIG1lLm1pbik7XG4gIH1cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB0aWNrc09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gbWUuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyhtZS5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gbWUuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gbWUuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyhtZSwgW2V4YW1wbGVUaW1lXSwgbWUuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IG1lLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IobWUuaXNIb3Jpem9udGFsKCkgPyBtZS53aWR0aCAvIHNpemUudyA6IG1lLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGxldCB0aW1lc3RhbXBzID0gbWUuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSBtZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGlmIChtZS5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAobWUuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhtZSkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMobWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIChtZS5fY2FjaGUuZGF0YSA9IG1lLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gbWUuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKG1lLCBsYWJlbHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChtZS5fY2FjaGUubGFiZWxzID0gbWUuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogbWUubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuVGltZVNjYWxlLmlkID0gJ3RpbWUnO1xuVGltZVNjYWxlLmRlZmF1bHRzID0ge1xuICBib3VuZHM6ICdkYXRhJyxcbiAgYWRhcHRlcnM6IHt9LFxuICB0aW1lOiB7XG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB1bml0OiBmYWxzZSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgaXNvV2Vla2RheTogZmFsc2UsXG4gICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6ICdhdXRvJyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBtZS5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSBtZS5fdGFibGUgPSBtZS5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIG1lLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgbWUubWluKTtcbiAgICBtZS5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCBtZS5tYXgpIC0gbWUuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBtZS5fY2FjaGUuYWxsIHx8IFtdO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBtZS5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gbWUuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcyA9IG1lLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSBtZS5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKG1lLl90YWJsZSwgZGVjaW1hbCAqIG1lLl90YWJsZVJhbmdlICsgbWUuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblRpbWVTZXJpZXNTY2FsZS5pZCA9ICd0aW1lc2VyaWVzJztcblRpbWVTZXJpZXNTY2FsZS5kZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbmNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxuXTtcblxuZXhwb3J0IHsgQW5pbWF0aW9uLCBBbmltYXRpb25zLCBBcmNFbGVtZW50LCBCYXJDb250cm9sbGVyLCBCYXJFbGVtZW50LCBCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIEJ1YmJsZUNvbnRyb2xsZXIsIENhdGVnb3J5U2NhbGUsIENoYXJ0LCBEYXRhc2V0Q29udHJvbGxlciwgcGx1Z2luX2RlY2ltYXRpb24gYXMgRGVjaW1hdGlvbiwgRG9tUGxhdGZvcm0sIERvdWdobnV0Q29udHJvbGxlciwgRWxlbWVudCwgcGx1Z2luX2ZpbGxlciBhcyBGaWxsZXIsIEludGVyYWN0aW9uLCBwbHVnaW5fbGVnZW5kIGFzIExlZ2VuZCwgTGluZUNvbnRyb2xsZXIsIExpbmVFbGVtZW50LCBMaW5lYXJTY2FsZSwgTG9nYXJpdGhtaWNTY2FsZSwgUGllQ29udHJvbGxlciwgUG9pbnRFbGVtZW50LCBQb2xhckFyZWFDb250cm9sbGVyLCBSYWRhckNvbnRyb2xsZXIsIFJhZGlhbExpbmVhclNjYWxlLCBTY2FsZSwgU2NhdHRlckNvbnRyb2xsZXIsIHBsdWdpbl9zdWJ0aXRsZSBhcyBTdWJUaXRsZSwgVGlja3MsIFRpbWVTY2FsZSwgVGltZVNlcmllc1NjYWxlLCBwbHVnaW5fdGl0bGUgYXMgVGl0bGUsIHBsdWdpbl90b29sdGlwIGFzIFRvb2x0aXAsIGFkYXB0ZXJzIGFzIF9hZGFwdGVycywgX2RldGVjdFBsYXRmb3JtLCBhbmltYXRvciwgY29udHJvbGxlcnMsIGVsZW1lbnRzLCBsYXlvdXRzLCBwbHVnaW5zLCByZWdpc3RlcmFibGVzLCByZWdpc3RyeSwgc2NhbGVzIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")}}]);