!function(Q){var B={};function I(F){if(B[F])return B[F].exports;var U=B[F]={i:F,l:!1,exports:{}};return Q[F].call(U.exports,U,U.exports,I),U.l=!0,U.exports}I.m=Q,I.c=B,I.d=function(Q,B,F){I.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:F})},I.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},I.t=function(Q,B){if(1&B&&(Q=I(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(I.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)I.d(F,U,function(B){return Q[B]}.bind(null,U));return F},I.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(B,"a",B),B},I.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},I.p="",I(I.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on sâ€™endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/parsers/DataSourceParser.js\n\n\nclass DataSourceParser_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the connector protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @param {Number} properties.customUrlParams.video_bitrate - define a custom bitrate (in b/s)\n   * @param {Number} properties.customUrlParams.video_scale - define a custom scale, 0.0 < value < 1.0\n   * @param {Number} properties.customUrlParams.video_width - define a custom width\n   * @param {Number} properties.customUrlParams.video_height - define a custom height\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = \"\"; // adds protocol\n\n    url += properties.protocol + \"://\"; // adds endpoint url\n\n    url += properties.endpointUrl + \"?\"; // adds service\n\n    url += \"service=\" + properties.service; // adds version\n\n    url += \"&version=2.0&\"; // adds responseFormat (optional)\n\n    if (properties.responseFormat) {\n      url += \"&responseFormat=\" + properties.responseFormat;\n    }\n\n    if (isDefined(properties.customUrlParams) && Object.keys(properties.customUrlParams).length > 0) {\n      url += '&';\n\n      for (let key in properties.customUrlParams) {\n        url += key + '=' + properties.customUrlParams[key] + '&';\n      }\n\n      if (url.endsWith('&')) {\n        url = url.slice(0, -1);\n      }\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var parsers_DataSourceParser = (DataSourceParser_DataSourceParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/parsers/TimeSeriesParser.parser.js\n\n\n\nclass TimeSeriesParser_parser_TimeSeriesParserParser extends parsers_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the connector protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = super.buildUrl(properties); // adds request\n\n    url += \"&request=GetResult\"; // adds offering\n\n    url += \"&offering=\" + properties.offeringID; // adds observedProperty\n\n    url += \"&observedProperty=\" + properties.observedProperty; // adds temporalFilter\n\n    const stTime = isDefined(properties.lastTimeStamp) ? properties.lastTimeStamp : properties.startTime;\n    this.lastStartTime = properties.startTime;\n    let endTime = properties.endTime;\n    url += \"&temporalFilter=phenomenonTime,\" + stTime + \"/\" + endTime;\n\n    if (properties.replaySpeed) {\n      // adds replaySpeed\n      url += \"&replaySpeed=\" + properties.replaySpeed;\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var TimeSeriesParser_parser = (TimeSeriesParser_parser_TimeSeriesParserParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/parsers/SosGetResultJson.parser.js\n\n\nclass SosGetResultJson_parser_SosGetResultJsonParser extends TimeSeriesParser_parser {\n  /**\n   * Extracts timestamp from the message. The timestamp corresponds to the 'time' attribute of the JSON object.\n   * @param {String} data - the data to parse\n   * @return {Number} the extracted timestamp\n   */\n  parseTimeStamp(data) {\n    let rec = String.fromCharCode.apply(null, new Uint8Array(data));\n    return new Date(JSON.parse(rec)['time']).getTime();\n  }\n  /**\n   * Extract data from the message. The data are corresponding to the whole list of attributes of the JSON object\n   * excepting the 'time' one.\n   * @param {Object} data - the data to parse\n   * @return {Object} the parsed data\n   * @example\n   * {\n   *   location : {\n   *    lat:43.61758626,\n   *    lon: 1.42376557,\n   *    alt:100\n   *   }\n   * }\n   */\n\n\n  parseData(data) {\n    let rec = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(data)));\n    let result = {};\n\n    for (let key in rec) {\n      if (key !== 'time') {\n        result[key] = rec[key];\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the connector protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.foiId the foiId\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @return {String} the full url\n   */\n\n\n  buildUrl(properties) {\n    let url = super.buildUrl({ ...properties,\n      responseFormat: 'application/json'\n    }); // adds feature of interest urn\n\n    if (properties.foiId && properties.of !== '') {\n      url += '&featureOfInterest=' + properties.foiId;\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var SosGetResultJson_parser = (SosGetResultJson_parser_SosGetResultJsonParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/DataConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n/**\n * The DataConnector is the abstract class used to create different connectors.\n */\n\nclass DataConnector_DataConnector {\n  /**\n   * @param {String} url - The full url used to connect to the data stream\n   */\n  constructor(url) {\n    this.url = url;\n    this.id = \"DataConnector-\" + randomUUID();\n    this.reconnectTimeout = 1000 * 60 * 2; //2 min\n\n    this.status = Status.DISCONNECTED;\n    this.reconnectionInterval = -1;\n  }\n\n  checkAndClearReconnection() {\n    if (this.reconnectionInterval !== -1) {\n      clearInterval(this.reconnectionInterval);\n      this.reconnectionInterval = -1;\n    }\n  }\n\n  disconnect() {\n    this.checkStatus(Status.DISCONNECTED);\n    this.checkAndClearReconnection();\n  }\n  /**\n   * Sets the url\n   * @param url\n   */\n\n\n  setUrl(url) {\n    this.url = url;\n  }\n  /**\n   * The data connector default id.\n   * @return {String}\n   */\n\n\n  getId() {\n    return this.id;\n  }\n  /**\n   * The stream url.\n   * @return {String}\n   */\n\n\n  getUrl() {\n    return this.url;\n  }\n  /**\n   * Sets the reconnection timeout\n   * @param {Number} timeout - delay in milliseconds before reconnecting dataSource\n   */\n\n\n  setReconnectTimeout(timeout) {\n    this.reconnectTimeout = timeout;\n  }\n\n  onReconnect() {\n    return true;\n  }\n\n  connect() {}\n\n  forceReconnect() {\n    this.disconnect();\n    this.connect();\n  }\n  /**\n   * Called when the connection STATUS changes\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {}\n  /**\n   * Check a change of the status and call the corresponding callbacks if necessary\n   * @param {Status} status - the currentStatus\n   */\n\n\n  checkStatus(status) {\n    if (status !== this.status) {\n      this.onChangeStatus(status);\n      this.status = status;\n    }\n  }\n  /**\n   * Called when the connector has been disconnected\n   */\n\n\n  onDisconnect() {}\n  /**\n   * Called when the connector has been connected\n   */\n\n\n  onConnect() {}\n\n}\n\n/* harmony default export */ var dataconnector_DataConnector = (DataConnector_DataConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/WebSocketConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the WebSocketConnector to connect to a remote server by creating a WebSocket channel.\n * @extends DataConnector\n * @example\n * import WebSocketConnector from 'osh/dataconnector/WebSocketConnector.js';\n *\n * let url = ...;\n * let connector = new WebSocketConnector(url);\n *\n * // connect\n * connector.connect();\n *\n * // disconnect\n * connector.disconnect();\n *\n * // close\n * connector.close();\n *\n */\n\nclass WebSocketConnector_WebSocketConnector extends dataconnector_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.interval = -1;\n    this.lastReceiveTime = 0;\n  }\n  /**\n   * Connect to the webSocket. If the system supports WebWorker, it will automatically creates one otherwise use\n   * the main thread.\n   */\n\n\n  async connect() {\n    if (!this.init) {\n      this.closed = false;\n      this.init = true; //creates Web Socket\n\n      this.ws = new WebSocket(this.getUrl());\n      this.ws.binaryType = 'arraybuffer';\n      this.checkStatus(Status.CONNECTING);\n      console.warn('WebSocket stream connecting');\n\n      this.ws.onopen = function (event) {\n        this.checkAndClearReconnection();\n        this.checkStatus(Status.CONNECTED);\n        console.warn('WebSocket stream connected');\n      }.bind(this);\n\n      this.ws.onmessage = function (event) {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        if (event.data.byteLength > 0) {\n          this.onMessage(event.data);\n        }\n      }.bind(this); // closes socket if any errors occur\n\n\n      this.ws.onerror = function (event) {\n        console.error('WebSocket stream error');\n        this.checkStatus(Status.DISCONNECTED);\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.createReconnection();\n      }.bind(this);\n\n      this.ws.onclose = event => {\n        this.checkStatus(Status.DISCONNECTED);\n        console.warn('WebSocket stream closed: ', event.reason, event.code);\n        this.init = false;\n\n        if (event.code !== 1000 && !this.closed) {\n          this.createReconnection();\n        }\n      };\n    }\n  }\n\n  createReconnection() {\n    if (!this.closed && this.reconnectionInterval === -1 && this.onReconnect()) {\n      this.reconnectionInterval = setInterval(function () {\n        let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n        if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n          console.warn('trying to reconnect', this.url);\n          this.connect();\n        }\n      }.bind(this), this.reconnectTimeout);\n    }\n  }\n  /**\n   * Disconnects and close the websocket.\n   */\n\n\n  disconnect() {\n    super.disconnect();\n    this.init = false;\n    this.closed = true;\n\n    if (this.ws != null && this.ws.readyState !== WebSocket.CLOSED) {\n      this.ws.close();\n    }\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n\n  isConnected() {\n    return this.ws != null && this.ws.readyState === WebSocket.OPEN;\n  }\n\n}\n\n/* harmony default export */ var dataconnector_WebSocketConnector = (WebSocketConnector_WebSocketConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/Ajax.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the AjaxConnector to connect to a remote server by making AjaxRequest.\n * @extends DataConnector\n * @example\n * import Ajax from 'osh/dataconnector/Ajax.js';\n *\n * let request = ...;\n * let connector = new Ajax(url);\n *\n * // handle onSuccess\n * connector.onSuccess = function(event) {\n *  // does something\n * }\n *\n * connector.onError = function(event) {\n *  // does something\n * }\n *\n * // send request\n * connector.sendRequest(request);\n *\n */\n\nclass Ajax_Ajax extends dataconnector_DataConnector {\n  /**\n   * Creates Ajax.\n   * @param {String} url -\n   * @param {Object} properties -\n   * @param {String} properties.method -\n   * @param {String} properties.responseType -\n   */\n  constructor(url, properties) {\n    super(url);\n    this.method = \"POST\";\n    this.responseType = \"arraybuffer\";\n\n    if (isDefined(properties)) {\n      if (properties.method) {\n        this.method = properties.method;\n      }\n\n      if (properties.responseType) {\n        this.responseType = properties.responseType;\n      }\n    }\n  }\n  /**\n   * Sends the request to the defined server.\n   * @param {String} request - The Http request\n   * @param {String} extraUrl - get query parameters\n   */\n\n\n  sendRequest(request, extraUrl) {\n    let self = this;\n    let xmlhttp = new XMLHttpRequest();\n    xmlhttp.withCredentials = true;\n    xmlhttp.timeout = 60000;\n\n    if (request === null) {\n      if (isDefined(extraUrl)) {\n        xmlhttp.open(\"GET\", this.getUrl() + \"?\" + extraUrl, true);\n      } else {\n        xmlhttp.open(\"GET\", this.getUrl(), true);\n      }\n\n      xmlhttp.responseType = this.responseType;\n\n      xmlhttp.onload = oEvent => {\n        if (xmlhttp.response) {\n          self.onMessage(xmlhttp.response);\n        }\n\n        self.checkStatus(Status.DISCONNECTED);\n      };\n\n      xmlhttp.ontimeout = e => {\n        console.log(\"Timeout\");\n        self.checkStatus(Status.DISCONNECTED);\n      };\n\n      self.checkStatus(Status.CONNECTED);\n      xmlhttp.send(null);\n    } else {\n      xmlhttp.open(\"POST\", this.getUrl(), true);\n      xmlhttp.setRequestHeader('Content-Type', 'text/xml');\n      xmlhttp.send(request);\n      self.checkStatus(Status.CONNECTED);\n\n      xmlhttp.onreadystatechange = () => {\n        if (xmlhttp.readyState < 4) {// while waiting response from server\n        } else if (xmlhttp.readyState === 4) {\n          // 4 = Response from server has been completely loaded.\n          if (xmlhttp.status === 200 && xmlhttp.status < 300) {\n            // http status between 200 to 299 are all successful\n            self.onSuccess(xmlhttp.responseText);\n          } else {\n            self.onError(\"\");\n          }\n\n          self.checkStatus(Status.DISCONNECTED);\n        }\n      };\n    }\n  }\n  /**\n   * This is the callback method in case of getting error connection.\n   * @param event The error details\n   * @event\n   */\n\n\n  onError(event) {}\n  /**\n   * This is the callback method in case of getting success connection.\n   * @param event\n   * @event\n   */\n\n\n  onSuccess(event) {}\n  /**\n   * Sends the request\n   * @private\n   */\n\n\n  connect() {\n    this.sendRequest(null);\n  }\n\n  isConnected() {\n    return false;\n  }\n\n}\n\n/* harmony default export */ var dataconnector_Ajax = (Ajax_Ajax);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/TopicConnector.js\n\n/**\n * Defines the FileConnector to read a File content\n * @extends DataConnector\n * @example\n * import FileConnector from 'osh/dataconnector/TopicConnector.js';\n *\n * let connector = new TopicConnector(<topic_name>);\n *\n * // connect\n * connector.connect();\n *\n * // disconnect\n * connector.disconnect();\n *\n * // close\n * connector.close();\n *\n */\n\nclass TopicConnector_TopicConnector extends dataconnector_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.lastReceiveTime = -1;\n    this.interval = -1;\n    this.broadcastChannel = null;\n  }\n  /**\n   * Connect to the broadcastChannel.\n   */\n\n\n  connect() {\n    if (this.broadcastChannel === null) {\n      //creates broadcastChannel\n      this.broadcastChannel = new BroadcastChannel(this.getUrl());\n\n      this.broadcastChannel.onmessage = event => {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        this.onMessage(event.data.data);\n      }; // closes socket if any errors occur\n\n\n      this.broadcastChannel.onerror = event => {\n        console.error('BroadcastChannel stream error: ' + event);\n        this.broadcastChannel.close();\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.opened = false;\n      };\n\n      this.opened = true; //init the reconnect handler\n\n      if (this.interval === -1) {\n        this.interval = setInterval(function () {\n          let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n          if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n            console.warn(`trying to reconnect after ${this.reconnectTimeout} ..`);\n            this.reconnect();\n          }\n        }.bind(this), this.reconnectTimeout);\n      }\n    }\n  }\n  /**\n   * Disconnects the websocket.\n   */\n\n\n  disconnect() {\n    this.fullDisconnect(true);\n  }\n  /**\n   * Fully disconnect the websocket connection by sending a close message to the webWorker.\n   * @param {Boolean} removeInterval  - force removing the interval\n   */\n\n\n  fullDisconnect(removeInterval) {\n    if (this.broadcastChannel != null) {\n      this.broadcastChannel.close();\n      this.broadcastChannel = null;\n    }\n\n    if (removeInterval) {\n      clearInterval(this.interval);\n    }\n\n    this.opened = false;\n  }\n  /**\n   * Try to reconnect if the connexion if closed\n   */\n\n\n  reconnect() {\n    this.onReconnect();\n\n    if (this.init) {\n      this.fullDisconnect(false);\n    }\n\n    this.connect();\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n  /**\n   * Closes the webSocket.\n   */\n\n\n  close() {\n    this.disconnect();\n  }\n\n  isConnected() {\n    return this.broadcastChannel !== null && this.opened;\n  }\n\n}\n\n/* harmony default export */ var dataconnector_TopicConnector = (TopicConnector_TopicConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  STATUS: 'status'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/FileConnector.js\n\n\n/**\n * Defines the FileConnector to read a File content\n * @extends DataConnector\n * @example\n * import FileConnector from 'osh/dataconnector/FileConnector.js';\n *\n * let paths = ['path1','path2]...];\n * let connector = new FileConnector(paths);\n *\n * // connect\n * connector.connect();\n *\n * // disconnect\n * connector.disconnect();\n *\n * // close\n * connector.close();\n *\n */\n\nclass FileConnector_FileConnector extends dataconnector_DataConnector {\n  /**\n   * @param (string[]) paths - list of file paths\n   */\n  constructor(paths) {\n    super(paths);\n    this.opened = false;\n  }\n  /**\n   * Start reading file content\n   */\n\n\n  async connect() {\n    if (!this.opened) {\n      this.opened = true;\n      this.onChangeStatus(Status.CONNECTED);\n      const urls = this.getUrl();\n\n      for (let url of urls) {\n        this.onMessage(await fetch(url));\n      }\n\n      this.onChangeStatus(Status.DISCONNECTED); // read is done\n\n      this.opened = false;\n    }\n  }\n\n  isConnected() {\n    return this.opened;\n  }\n\n}\n\n/* harmony default export */ var dataconnector_FileConnector = (FileConnector_FileConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/workers/DataSourceHandler.js\n\n\n\n\n\n\n\n\nclass DataSourceHandler_DataSourceHandler {\n  constructor(parser) {\n    this.parser = parser;\n    this.connector = null;\n    this.reconnectTimeout = 1000 * 10; // 10 secs\n\n    this.values = [];\n  }\n\n  createConnector(propertiesStr, topic, dataSourceId) {\n    this.dataSourceId = dataSourceId; // check for existing connector\n\n    if (this.connector !== null) {\n      this.connector.disconnect();\n      this.connector = null;\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    const properties = JSON.parse(propertiesStr);\n\n    if (isDefined(properties.timeShift)) {\n      this.timeShift = properties.timeShift;\n    }\n\n    if (isDefined(properties.bufferingTime)) {\n      this.bufferingTime = properties.bufferingTime;\n    }\n\n    if (isDefined(properties.timeOut)) {\n      this.timeOut = properties.timeOut;\n    }\n\n    if (isDefined(properties.reconnectTimeout)) {\n      this.reconnectTimeout = properties.reconnectTimeout;\n    }\n\n    if (properties.startTime === 'now') {\n      this.batchSize = 1;\n    } else {\n      if (isDefined(properties.replaySpeed)) {\n        if (!isDefined(properties.batchSize)) {\n          this.batchSize = 1;\n        }\n      }\n\n      if (isDefined(properties.batchSize)) {\n        this.batchSize = properties.batchSize;\n      }\n    }\n\n    this.properties = properties;\n    this.createDataConnector(this.properties);\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    const url = this.parser.buildUrl({ ...properties,\n      timeShift: this.timeShift\n    }); // checks if type is WebSocketConnector\n\n    if (properties.protocol.startsWith('ws')) {\n      this.connector = new dataconnector_WebSocketConnector(url);\n    } else if (properties.protocol.startsWith('http')) {\n      this.connector = new dataconnector_Ajax(url);\n      this.connector.responseType = properties.responseType || 'arraybuffer';\n    } else if (properties.protocol.startsWith('topic')) {\n      this.connector = new dataconnector_TopicConnector(url);\n    } else if (properties.protocol.startsWith('file')) {\n      this.connector = new dataconnector_FileConnector(url, properties);\n    }\n\n    if (this.connector !== null) {\n      // set the reconnectTimeout\n      this.connector.setReconnectTimeout(this.reconnectTimeout); // connects the callback\n\n      this.connector.onMessage = this.onMessage.bind(this); // bind change connection STATUS\n\n      this.connector.onChangeStatus = this.onChangeStatus.bind(this);\n    }\n  }\n  /**\n   * Sets the current topic to listen\n   * @param {String} topic - the topic to listen\n   */\n\n\n  setTopic(topic) {\n    if (isDefined(this.broadcastChannel)) {\n      this.broadcastChannel.close();\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    this.topic = topic;\n  }\n\n  connect() {\n    if (this.connector !== null) {\n      this.connector.connect();\n    }\n  }\n\n  disconnect() {\n    if (this.connector !== null) {\n      this.connector.disconnect();\n    }\n  }\n\n  async onMessage(event) {\n    const data = await Promise.resolve(this.parser.parseData(event)); // check if data is array\n\n    if (Array.isArray(data)) {\n      for (let i = 0; i < data.length; i++) {\n        this.values.push({\n          data: data[i]\n        });\n\n        if (isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n          this.flush();\n        }\n      }\n    } else {\n      this.values.push({\n        data: data\n      });\n    } // because parseData is ASYNC, the connector can finish before the parsing method. In that case, we have to flushALl data\n\n\n    if (!this.isConnected()) {\n      this.flushAll();\n    } else if (isDefined(this.batchSize) && this.values.length !== 0 && this.values.length >= this.batchSize) {\n      this.flush();\n    }\n  }\n  /**\n   * Send a change status event into the broadcast channel\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {\n    if (status === Status.DISCONNECTED) {\n      this.flushAll();\n    }\n\n    this.broadcastChannel.postMessage({\n      type: EventType.STATUS,\n      status: status,\n      dataSourceId: this.dataSourceId\n    });\n  }\n\n  updateProperties(properties) {\n    this.disconnect();\n    this.createDataConnector({ ...this.properties,\n      ...properties\n    });\n    this.connect();\n  }\n\n  flushAll() {\n    while (this.values.length > 0) {\n      this.flush();\n    }\n  }\n\n  flush() {\n    let nbElements = this.values.length;\n\n    if (isDefined(this.batchSize) && this.values.length > this.batchSize) {\n      nbElements = this.batchSize;\n    }\n\n    this.broadcastChannel.postMessage({\n      dataSourceId: this.dataSourceId,\n      type: EventType.DATA,\n      values: this.values.splice(0, nbElements)\n    });\n  }\n\n  isConnected() {\n    return this.connector === null ? false : this.connector.isConnected();\n  }\n\n  handleMessage(message, worker) {\n    if (message.message === 'init') {\n      this.createConnector(message.properties, message.topic, message.id);\n    } else if (message.message === 'connect') {\n      this.connect();\n    } else if (message.message === 'disconnect') {\n      this.disconnect();\n    } else if (message.message === 'topic') {\n      this.setTopic(message.topic);\n    } else if (message.message === 'update-url') {\n      this.updateProperties(message.data);\n    } else if (message.message === 'is-connected') {\n      worker.postMessage({\n        message: 'is-connected',\n        data: this.isConnected()\n      });\n    }\n  }\n\n}\n\n/* harmony default export */ var workers_DataSourceHandler = (DataSourceHandler_DataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/workers/TimeSeriesDataSourceHandler.js\n\n\n\nclass TimeSeriesDataSourceHandler_TimeSeriesDataSourceHandler extends workers_DataSourceHandler {\n  constructor(parser) {\n    super(parser);\n    this.lastTimeStamp = null;\n    this.lastStartTime = 'now';\n    this.timeShift = 0;\n    this.timeBroadcastChannel = null;\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    super.createDataConnector({ ...properties,\n      timeShift: this.timeShift\n    });\n    const lastStartTimeCst = this.parser.lastStartTime;\n\n    this.connector.onReconnect = () => {\n      // if not real time, preserve last timestamp to reconnect at the last time received\n      // for that, we update the URL with the new last time received\n      if (lastStartTimeCst !== 'now') {\n        this.connector.setUrl(this.parser.buildUrl({ ...properties,\n          lastTimeStamp: isDefined(this.lastTimeStamp) ? new Date(this.lastTimeStamp).toISOString() : properties.startTime\n        }));\n      }\n\n      return true;\n    };\n  }\n\n  async onMessage(event) {\n    const timeStamp = await Promise.resolve(this.parser.parseTimeStamp(event) + this.timeShift);\n    const data = await Promise.resolve(this.parser.parseData(event)); // check if data is array\n\n    if (Array.isArray(data)) {\n      for (let i = 0; i < data.length; i++) {\n        this.values.push({\n          data: data[i],\n          timeStamp: timeStamp\n        });\n      }\n    } else {\n      this.values.push({\n        data: data,\n        timeStamp: timeStamp\n      });\n    }\n\n    this.lastTimeStamp = timeStamp;\n\n    if (this.parser.lastStartTime === 'now' || isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n      this.flush();\n\n      if (this.timeBroadcastChannel !== null) {\n        this.timeBroadcastChannel.postMessage({\n          timestamp: this.lastTimeStamp\n        });\n      }\n    }\n  }\n\n  getLastTimeStamp() {\n    return this.lastTimeStamp;\n  }\n\n  updateProperties(properties) {\n    this.disconnect();\n    let lastTimestamp = new Date(this.lastTimeStamp).toISOString();\n\n    if (properties.hasOwnProperty('startTime')) {\n      lastTimestamp = properties.startTime;\n    } else if (this.properties.startTime === 'now') {\n      //handle RealTime\n      lastTimestamp = 'now';\n    }\n\n    this.createDataConnector({ ...this.properties,\n      ...properties,\n      lastTimeStamp: lastTimestamp\n    });\n\n    if (isDefined(properties) && isDefined(properties.reconnect) && properties.reconnect) {\n      this.connect();\n    }\n  }\n\n  handleMessage(message, worker) {\n    super.handleMessage(message, worker);\n\n    if (message.message === 'last-timestamp') {\n      const lastTimeStamp = this.getLastTimeStamp();\n      worker.postMessage({\n        message: 'last-timestamp',\n        data: lastTimeStamp\n      });\n    } else if (message.message === 'topic') {\n      this.setTimeTopic(message.timeTopic);\n      super.setTopic(message.topic);\n    }\n  }\n\n  setTimeTopic(timeTopic) {\n    if (this.timeBroadcastChannel !== null) {\n      this.timeBroadcastChannel.close();\n    }\n\n    this.timeBroadcastChannel = new BroadcastChannel(timeTopic);\n  }\n\n}\n\n/* harmony default export */ var workers_TimeSeriesDataSourceHandler = (TimeSeriesDataSourceHandler_TimeSeriesDataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/workers/SosGetResultJson.worker.js\n\n\n\nconst dataSourceHandler = new workers_TimeSeriesDataSourceHandler(new SosGetResultJson_parser());\n\nself.onmessage = (event) => {\n    dataSourceHandler.handleMessage(event.data, self);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL3V0aWxzL1V0aWxzLmpzPzI0M2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvcGFyc2Vycy9EYXRhU291cmNlUGFyc2VyLmpzPzYwZmYiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvcGFyc2Vycy9UaW1lU2VyaWVzUGFyc2VyLnBhcnNlci5qcz85MzdmIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YXJlY2VpdmVyL3BhcnNlcnMvU29zR2V0UmVzdWx0SnNvbi5wYXJzZXIuanM/MTA1YiIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2RhdGFjb25uZWN0b3IvU3RhdHVzLmpzPzA5ODciLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhY29ubmVjdG9yL0RhdGFDb25uZWN0b3IuanM/YzgzNiIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2RhdGFjb25uZWN0b3IvV2ViU29ja2V0Q29ubmVjdG9yLmpzPzA1NWIiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhY29ubmVjdG9yL0FqYXguanM/MWZhZCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2RhdGFjb25uZWN0b3IvVG9waWNDb25uZWN0b3IuanM/NDgxZSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2V2ZW50L0V2ZW50VHlwZS5qcz8xMmUxIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YWNvbm5lY3Rvci9GaWxlQ29ubmVjdG9yLmpzP2M2YWYiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvd29ya2Vycy9EYXRhU291cmNlSGFuZGxlci5qcz9jNGIyIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YXJlY2VpdmVyL3dvcmtlcnMvVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyLmpzPzM4ZGIiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvd29ya2Vycy9Tb3NHZXRSZXN1bHRKc29uLndvcmtlci5qcz8xZTY1Il0sIm5hbWVzIjpbIk1BWF9MT05HIiwiTWF0aCIsInBvdyIsImlzRGVmaW5lZCIsInYiLCJoYXNWYWx1ZSIsImhleDJyZ2IiLCJoZXgiLCJyIiwiZyIsImIiLCJtYXRjaCIsIm1hcCIsIngiLCJwYXJzZUludCIsImhhc1R5cGUiLCJleHBlY3RlZFR5cGUiLCJoYXNWYWwiLCJpc09iamVjdCIsImxldE5hbWUiLCJpc0FycmF5IiwiQXJyYXkiLCJpc0Z1bmN0aW9uIiwiYXNzZXJ0RGVmaW5lZCIsImFzc2VydFRydWUiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdGFtcFVVSUQiLCJvYmoiLCJfb3NoX2lkIiwiUGFyc2VCeXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsInR5cGUiLCJ2aWV3IiwiRGF0YVZpZXciLCJ0eXBlTWFwIiwiZG91YmxlIiwidmFsIiwiZ2V0RmxvYXQ2NCIsImJ5dGVzIiwiZmxvYXQ2NCIsImZsb2F0MzIiLCJnZXRGbG9hdDMyIiwic2lnbmVkQnl0ZSIsImdldEludDgiLCJzaWduZWRJbnQiLCJnZXRJbnQzMiIsInNpZ25lZFNob3J0IiwiZ2V0SW50MTYiLCJ1bnNpZ25lZEJ5dGUiLCJnZXRVaW50OCIsInVuc2lnbmVkSW50IiwiZ2V0VWludDMyIiwidW5zaWduZWRTaG9ydCIsImdldFVpbnQxNiIsIlJlYWREYXRhIiwic3RydWN0IiwiZGF0YSIsIm9mZnNldEJ5dGVzIiwiaSIsImZpZWxkcyIsImxlbmd0aCIsImN1cnJGaWVsZFN0cnVjdCIsInJldCIsImNvdW50IiwiaXNOYU4iLCJpZCIsImZpZWxkTmFtZSIsImlkMkZpZWxkTWFwIiwiZmluZEZpZWxkQnlOYW1lIiwiaiIsImZpZWxkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHVzaCIsIkdldFJlc3VsdE9iamVjdCIsInJlc3VsdFN0cnVjdHVyZSIsInJlc3VsdCIsIm5hbWUiLCJpdGVtIiwiayIsImlzT3BlcmEiLCJ3aW5kb3ciLCJvcHIiLCJhZGRvbnMiLCJvcGVyYSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkhUTUxFbGVtZW50IiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJ3ZWJzdG9yZSIsImlzQmxpbmsiLCJDU1MiLCJpc0FycmF5SW50ZXJzZWN0IiwiYSIsImZpbHRlciIsImVsZW1lbnQiLCJpc0VsZW1lbnQiLCJvIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzV2ViV29ya2VyIiwiV29ya2VyIiwidGFrZVNjcmVlblNob3QiLCJkaXYiLCJyZW1vdmVDc3MiLCJjc3MiLCJkaXZDc3MiLCJjbGFzc05hbWUiLCJhZGRDc3MiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVMYXN0Q2hhcklmRXhpc3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwicm91bmRIYWxmIiwibnVtIiwicm91bmQiLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwiaW1tZWRpYXRlIiwidGltZW91dCIsImFyZ3MiLCJjb250ZXh0IiwidGltZXN0YW1wIiwibGF0ZXIiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImxhc3QiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjYWxsTm93IiwidGhyb3R0bGUiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJjdHgiLCJwcmV2aW91cyIsInJlbWFpbmluZyIsImNsZWFyVGltZW91dCIsIkRhdGFTb3VyY2VQYXJzZXIiLCJidWlsZFVybCIsInByb3BlcnRpZXMiLCJ1cmwiLCJwcm90b2NvbCIsImVuZHBvaW50VXJsIiwic2VydmljZSIsInJlc3BvbnNlRm9ybWF0IiwiY3VzdG9tVXJsUGFyYW1zIiwia2V5cyIsImtleSIsInNsaWNlIiwiVGltZVNlcmllc1BhcnNlclBhcnNlciIsIm9mZmVyaW5nSUQiLCJvYnNlcnZlZFByb3BlcnR5Iiwic3RUaW1lIiwibGFzdFRpbWVTdGFtcCIsInN0YXJ0VGltZSIsImxhc3RTdGFydFRpbWUiLCJlbmRUaW1lIiwicmVwbGF5U3BlZWQiLCJTb3NHZXRSZXN1bHRKc29uUGFyc2VyIiwiVGltZVNlcmllc1BhcnNlciIsInBhcnNlVGltZVN0YW1wIiwicmVjIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiVWludDhBcnJheSIsInBhcnNlRGF0YSIsImZvaUlkIiwib2YiLCJTdGF0dXMiLCJDT05ORUNUSU5HIiwiQ09OTkVDVEVEIiwiRElTQ09OTkVDVEVEIiwiRGF0YUNvbm5lY3RvciIsImNvbnN0cnVjdG9yIiwicmVjb25uZWN0VGltZW91dCIsInN0YXR1cyIsInJlY29ubmVjdGlvbkludGVydmFsIiwiY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbiIsImNsZWFySW50ZXJ2YWwiLCJkaXNjb25uZWN0IiwiY2hlY2tTdGF0dXMiLCJzZXRVcmwiLCJnZXRJZCIsImdldFVybCIsInNldFJlY29ubmVjdFRpbWVvdXQiLCJvblJlY29ubmVjdCIsImNvbm5lY3QiLCJmb3JjZVJlY29ubmVjdCIsIm9uQ2hhbmdlU3RhdHVzIiwib25EaXNjb25uZWN0Iiwib25Db25uZWN0IiwiV2ViU29ja2V0Q29ubmVjdG9yIiwiaW50ZXJ2YWwiLCJsYXN0UmVjZWl2ZVRpbWUiLCJpbml0IiwiY2xvc2VkIiwid3MiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwiY29uc29sZSIsIndhcm4iLCJvbm9wZW4iLCJldmVudCIsImJpbmQiLCJvbm1lc3NhZ2UiLCJieXRlTGVuZ3RoIiwib25NZXNzYWdlIiwib25lcnJvciIsImVycm9yIiwiY3JlYXRlUmVjb25uZWN0aW9uIiwib25jbG9zZSIsInJlYXNvbiIsImNvZGUiLCJzZXRJbnRlcnZhbCIsImRlbHRhIiwicmVhZHlTdGF0ZSIsIkNMT1NFRCIsImNsb3NlIiwiaXNDb25uZWN0ZWQiLCJPUEVOIiwiQWpheCIsIm1ldGhvZCIsInJlc3BvbnNlVHlwZSIsInNlbmRSZXF1ZXN0IiwicmVxdWVzdCIsImV4dHJhVXJsIiwic2VsZiIsInhtbGh0dHAiLCJYTUxIdHRwUmVxdWVzdCIsIndpdGhDcmVkZW50aWFscyIsIm9wZW4iLCJvbmxvYWQiLCJvRXZlbnQiLCJyZXNwb25zZSIsIm9udGltZW91dCIsImUiLCJsb2ciLCJzZW5kIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIm9uU3VjY2VzcyIsInJlc3BvbnNlVGV4dCIsIm9uRXJyb3IiLCJUb3BpY0Nvbm5lY3RvciIsImJyb2FkY2FzdENoYW5uZWwiLCJCcm9hZGNhc3RDaGFubmVsIiwib3BlbmVkIiwicmVjb25uZWN0IiwiZnVsbERpc2Nvbm5lY3QiLCJyZW1vdmVJbnRlcnZhbCIsIkV2ZW50VHlwZSIsIkRBVEEiLCJTVEFUVVMiLCJGaWxlQ29ubmVjdG9yIiwicGF0aHMiLCJ1cmxzIiwiZmV0Y2giLCJEYXRhU291cmNlSGFuZGxlciIsInBhcnNlciIsImNvbm5lY3RvciIsInZhbHVlcyIsImNyZWF0ZUNvbm5lY3RvciIsInByb3BlcnRpZXNTdHIiLCJ0b3BpYyIsImRhdGFTb3VyY2VJZCIsInRpbWVTaGlmdCIsImJ1ZmZlcmluZ1RpbWUiLCJ0aW1lT3V0IiwiYmF0Y2hTaXplIiwiY3JlYXRlRGF0YUNvbm5lY3RvciIsInN0YXJ0c1dpdGgiLCJzZXRUb3BpYyIsIlByb21pc2UiLCJyZXNvbHZlIiwiZmx1c2giLCJmbHVzaEFsbCIsInBvc3RNZXNzYWdlIiwidXBkYXRlUHJvcGVydGllcyIsIm5iRWxlbWVudHMiLCJzcGxpY2UiLCJoYW5kbGVNZXNzYWdlIiwibWVzc2FnZSIsIndvcmtlciIsIlRpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlciIsInRpbWVCcm9hZGNhc3RDaGFubmVsIiwibGFzdFN0YXJ0VGltZUNzdCIsInRvSVNPU3RyaW5nIiwidGltZVN0YW1wIiwiZ2V0TGFzdFRpbWVTdGFtcCIsImxhc3RUaW1lc3RhbXAiLCJoYXNPd25Qcm9wZXJ0eSIsInNldFRpbWVUb3BpYyIsInRpbWVUb3BpYyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QyxTQUFELEVBQVk7QUFDcEIsUUFBRyxLQUFLUixvQkFBTCxLQUE4QixJQUFqQyxFQUF1QztBQUNuQyxXQUFLQSxvQkFBTCxDQUEwQm5FLEtBQTFCO0FBQ0g7O0FBQ0QsU0FBS21FLG9CQUFMLEdBQTRCLElBQUl2QyxnQkFBSixDQUFxQitDLFNBQXJCLENBQTVCO0FBQ0g7O0FBL0dzRDs7QUFpSDVDVCwrSEFBZixFOztBQ3BId0U7QUFDQTs7QUFFeEUsOEJBQThCLG1DQUEyQixLQUFLLHVCQUFzQjs7QUFFcEY7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC5cbiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmVcbiBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cbiBTb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlXG4gZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIENvcHlyaWdodCAoQykgMjAxNS0yMDIwIE1hdGhpZXUgRGhhaW5hdXQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiBBdXRob3I6IE1hdGhpZXUgRGhhaW5hdXQgPG1hdGhpZXUuZGhhaW5hdXRAZ21haWwuY29tPlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKiAqIEBtb2R1bGUgVXRpbHMgKi9cblxuLyoqIE1heGltdW0gdmFsdWUgb2YgYSBsb25nICovXG5leHBvcnQgY29uc3QgTUFYX0xPTkcgPSBNYXRoLnBvdygyLCA1MykgKyAxO1xuXG4vKipcbiAqIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5lZCh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiAodikgIT09ICd1bmRlZmluZWQnICYmIHYgIT09IG51bGw7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGhhcyBhIHZhbHVlLFxuIHRoYXQgaXMgaXQgaXMgZGVmaW5lZCBhbmQgbm9uIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1ZhbHVlKHYpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKHYpICYmIHYgIT09IG51bGw7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBoZXggY29sb3IgaW50byBSR0JBXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXgycmdiKGhleCl7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gaGV4Lm1hdGNoKC9cXHdcXHcvZykubWFwKHggPT4gcGFyc2VJbnQoeCwgMTYpKTtcbiAgICByZXR1cm4gW3IsIGcsIGJdO1xufVxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgb2YgYSBwYXJ0aWN1bGFyIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1R5cGUodiwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgbGV0IGhhc1ZhbCA9IGhhc1ZhbHVlKHYpO1xuICAgIHJldHVybiBoYXNWYWwgJiYgdHlwZW9mICh2KSA9PT0gZXhwZWN0ZWRUeXBlO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnb2JqZWN0JywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHYpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKHYpICYmIEFycmF5LmlzQXJyYXkodik7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBkZWZpbmVkXCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHJ1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpIHx8ICF2KSB7XG4gICAgICAgIHRocm93IGxldE5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZSh2LCBleHBlY3RlZFR5cGUsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAodHlwZW9mICh2KSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIG9mIHR5cGUgXCIgKyBleHBlY3RlZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRCb29sZWFuKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnYm9vbGVhbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdHJpbmcodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdzdHJpbmcnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnbnVtYmVyJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFBvc2l0aXZlKHYsIGxldE5hbWUpIHtcbiAgICBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSk7XG4gICAgaWYgKHYgPD0gMCkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiO1xuICAgIH1cbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE9iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJyYXkodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBhbiBhcnJheVwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgZnVuY3Rpb25cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEhhc1ZhbHVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIWhhc1ZhbHVlKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IG5vdCBiZSBudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21VVUlEKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC14eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHN0YW1wcy9lbWJlZHMgYSBVVUlEIGludG8gYW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBVVUlEIGdlbmVyYXRlZCBmb3IgaXRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YW1wVVVJRChvYmopIHtcbiAgICBvYmouX29zaF9pZCA9IG9iai5fb3NoX2lkIHx8IHJhbmRvbVVVSUQoKTtcbiAgICByZXR1cm4gb2JqLl9vc2hfaWQ7XG59XG5cbi8vYnVmZmVyIGlzIGFuIEFycmF5QnVmZmVyIG9iamVjdCwgdGhlIG9mZnNldCBpZiBzcGVjaWZpZWQgaW4gYnl0ZXMsIGFuZCB0aGUgdHlwZSBpcyBhIHN0cmluZ1xuLy9jb3JyZXNwb25kaW5nIHRvIGFuIE9HQyBkYXRhIHR5cGUuXG4vL1NlZSBodHRwOi8vZGVmLnNlZWdyaWQuY3Npcm8uYXUvc2lzc3ZvYy9vZ2MtZGVmL3Jlc291cmNlP3VyaT1odHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9kYXRhVHlwZS9PR0MvMC9cbi8qKlxuICpcbiAqIEBwYXJhbSBidWZmZXJcbiAqIEBwYXJhbSBvZmZzZXRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gUGFyc2VCeXRlcyhidWZmZXIsIG9mZnNldCwgdHlwZSkge1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cbiAgICAvL05vdGU6IFRoZXJlIGV4aXN0IHR5cGVzIG5vdCBsaXN0ZWQgaW4gdGhlIG1hcCBiZWxvdyB0aGF0IGhhdmUgT0dDIGRlZmluaXRpb25zLCBidXQgbm8gYXBwcm9wcmlhdGVcbiAgICAvL21ldGhvZHMgb3IgY29ycmVzcG9uZGluZyB0eXBlcyBhdmFpbGFibGUgZm9yIHBhcnNpbmcgaW4gamF2YXNjcmlwdC4gVGhleSBhcmUgZmxvYXQxMjgsIGZsb2F0MTYsIHNpZ25lZExvbmcsXG4gICAgLy9hbmQgdW5zaWduZWRMb25nXG4gICAgbGV0IHR5cGVNYXAgPSB7XG4gICAgICAgIGRvdWJsZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0NjQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDMyOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIC8vVE9ETzogc3RyaW5nLXV0Zi04OlxuICAgIH07XG4gICAgcmV0dXJuIHR5cGVNYXBbdHlwZV0ob2Zmc2V0KTtcbn1cblxuLy9UaGlzIGZ1bmN0aW9uIHJlY3Vyc2l2bGV5IGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdFN0cnVjdHVyZSB0byBmaWxsIGluXG4vL3ZhbHVlcyByZWFkIGZyb20gZGF0YSB3aGljaCBzaG91bGQgYmUgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgcGF5bG9hZCBmcm9tIGEgd2Vic29ja2V0XG4vKipcbiAqXG4gKiBAcGFyYW0gc3RydWN0XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIG9mZnNldEJ5dGVzXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gUmVhZERhdGEoc3RydWN0LCBkYXRhLCBvZmZzZXRCeXRlcykge1xuICAgIGxldCBvZmZzZXQgPSBvZmZzZXRCeXRlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdC5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJGaWVsZFN0cnVjdCA9IHN0cnVjdC5maWVsZHNbaV07XG4gICAgICAgIGlmIChpc0RlZmluZWQoY3VyckZpZWxkU3RydWN0LnR5cGUpICYmIGN1cnJGaWVsZFN0cnVjdC50eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gUGFyc2VCeXRlcyhkYXRhLCBvZmZzZXQsIGN1cnJGaWVsZFN0cnVjdC50eXBlKTtcbiAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwgPSByZXQudmFsO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHJldC5ieXRlcztcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQoY3VyckZpZWxkU3RydWN0LmNvdW50KSAmJiBjdXJyRmllbGRTdHJ1Y3QuY291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgY291bnQgaXMgYSByZWZlcmVuY2UgdG8gYW5vdGhlciBsZXRpYWJsZVxuICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkTmFtZSA9IHN0cnVjdC5pZDJGaWVsZE1hcFtpZF07XG4gICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LmNvdW50ID0gc3RydWN0LmZpbmRGaWVsZEJ5TmFtZShmaWVsZE5hbWUpLnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VyckZpZWxkU3RydWN0LmNvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJGaWVsZFN0cnVjdC5maWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdXJyRmllbGRTdHJ1Y3QuZmllbGRzW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFJlYWREYXRhKGZpZWxkLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcmVzdWx0U3RydWN0dXJlXG4gKiBAcmV0dXJuIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdldFJlc3VsdE9iamVjdChyZXN1bHRTdHJ1Y3R1cmUpIHtcbiAgICAvL1RPRE86IGhhbmRsZSBjYXNlcyBmb3IgbmVzdGVkIGFycmF5cyAvIG1hdHJpeCBkYXRhIHR5cGVzXG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQpKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzW2tdLm5hbWVdID0gcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzW2tdLnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmEoKSB7XG4gICAgcmV0dXJuICghIXdpbmRvdy5vcHIgJiYgISFvcHIuYWRkb25zKSB8fCAhIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmlyZWZveCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICAgIHJldHVybiAhIXdpbmRvdy5jaHJvbWUgJiYgISF3aW5kb3cuY2hyb21lLndlYnN0b3JlO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHsqfGJvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JsaW5rKCkge1xuICAgIHJldHVybiAoaXNDaHJvbWUgfHwgaXNPcGVyYSkgJiYgISF3aW5kb3cuQ1NTO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5SW50ZXJzZWN0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihlbGVtZW50KSA+IC0xO1xuICAgIH0pLmxlbmd0aCA+IDA7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQobykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiAvL0RPTTJcbiAgICAgICAgbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCJcbiAgICApO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJXb3JrZXIoKSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZChXb3JrZXIpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGl2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWtlU2NyZWVuU2hvdChkaXYpIHtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjc3MgY2xhc3MgZnJvbSBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDc3MoZGl2LCBjc3MpIHtcbiAgICBsZXQgZGl2Q3NzID0gZGl2LmNsYXNzTmFtZTtcbiAgICBjc3MgPSBkaXZDc3MucmVwbGFjZShjc3MsIFwiXCIpO1xuICAgIGRpdi5jbGFzc05hbWUgPSBjc3M7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBjc3MgY2xhc3MgdG8gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIGFkZCB0aGUgY2xhc3MgdG9cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byBhZGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENzcyhkaXYsIGNzcykge1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkaXYuY2xhc3NOYW1lICsgXCIgXCIgKyBjc3MpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIGEge3N0cmluZ30gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGlucHV0IHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSB3aXRob3V0IHRoZSBsYXN0IGNoYXJhY3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGFzdENoYXJJZkV4aXN0KHZhbHVlKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodW5kZWZpbmVkKSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZS5sZW5ndGggPT09IDAgfHwgIXZhbHVlLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbn1cblxuLyoqXG4gKiBSb3VuZCBvZmYgbnVtYmVyIHRvIG5lYXJlc3QgMC41XG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIC0gVGhlIG51bWJlciB0byByb3VuZCBvZmZcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJvdW5kZWQgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZEhhbGYobnVtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtKjIpLzI7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsXG4gKiB3aWxsIG5vdCBiZSBleGVjdXRlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBleGVjdXRlZCB3aGVuXG4gKiBpdCB3aWxsIHN0b3AgYmVpbmcgY2FsbGVkIGZvciBtb3JlIHRoYW4gTiBtaWxsaXNlY29uZHMuXG4gKiBJZiB0aGUgYGltbWVkaWF0ZWAgcGFyYW1ldGVyIGlzIHRydWUsIHRoZW4gdGhlIGZ1bmN0aW9uXG4gKiB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBmaXJzdCBjYWxsIGluc3RlYWQgb2YgdGhlIGxhc3QuXG4gKiBQYXJhbWV0ZXJzIDpcbiAqIC0gZnVuYzogdGhlIGZ1bmN0aW9uIHRvIGBkZWJvdW5jZXJgLlxuICogLSB3YWl0OiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyAoTikgdG8gd2FpdCBiZWZvcmVcbiAqIGNhbGwgZnVuYygpXG4gKiAtIGltbWVkaWF0ZSAob3B0aW9uYWwpOiBDYWxsIGZ1bmMoKSBhdCB0aGUgZmlyc3QgaW52b2NhdGlvblxuICogaW5zdGVhZCBvZiB0aGUgbGFzdCBvbmUgKERlZmF1bHQgZmFsc2UpXG4gKiAtIGNvbnRleHQgKG9wdGlvbmFsKTogdGhlIGNvbnRleHQgaW4gd2hpY2ggdG8gY2FsbCBmdW5jKClcbiAqICh0aGlzIGJ5IGRlZmF1bHQpXG4gKi9cblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4vLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICBsYXN0ID0gbm93IC0gdGltZXN0YW1wO1xuXG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBsZWFkaW5nLCB0cmFpbGluZywgY29udGV4dCkge1xuICAgIHZhciBjdHgsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJldmlvdXMgPSBuZXcgRGF0ZTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmICFsZWFkaW5nKSBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICBjdHggPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiB0cmFpbGluZykge1xuICAgICAgICAgICAgLy8gU2lub24gb24gc+KAmWVuZG9ydCBwZW5kYW50IGxlIHRlbXBzIHJlc3RhbnRcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG4iLCJpbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL3V0aWxzL1V0aWxzXCI7XG5cbmNsYXNzIERhdGFTb3VyY2VQYXJzZXIge1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBmdWxsIHVybC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5wcm90b2NvbCB0aGUgY29ubmVjdG9yIHByb3RvY29sXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgdGhlIGVuZHBvaW50IHVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnNlcnZpY2UgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5vZmZlcmluZ0lEIHRoZSBvZmZlcmluZ0lEXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2JzZXJ2ZWRQcm9wZXJ0eSB0aGUgb2JzZXJ2ZWQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zdGFydFRpbWUgdGhlIHN0YXJ0IHRpbWUgKElTTyBmb3JtYXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kVGltZSB0aGUgZW5kIHRpbWUgKElTTyBmb3JtYXQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVwbGF5U3BlZWQgdGhlIHJlcGxheSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5yZXNwb25zZUZvcm1hdCB0aGUgcmVzcG9uc2UgZm9ybWF0IChlLmcgdmlkZW8vbXA0KVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gcHJvcGVydGllcy5sYXN0VGltZVN0YW1wIC0gdGhlIGxhc3QgdGltZXN0YW1wIHRvIHN0YXJ0IGF0IHRoaXMgdGltZSAoSVNPIFN0cmluZylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMgLSB0aGUgZW5jb2Rpbmcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb19iaXRyYXRlIC0gZGVmaW5lIGEgY3VzdG9tIGJpdHJhdGUgKGluIGIvcylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9fc2NhbGUgLSBkZWZpbmUgYSBjdXN0b20gc2NhbGUsIDAuMCA8IHZhbHVlIDwgMS4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX3dpZHRoIC0gZGVmaW5lIGEgY3VzdG9tIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX2hlaWdodCAtIGRlZmluZSBhIGN1c3RvbSBoZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmdWxsIHVybFxuICAgICAqL1xuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG5cbiAgICAgICAgLy8gYWRkcyBwcm90b2NvbFxuICAgICAgICB1cmwgKz0gcHJvcGVydGllcy5wcm90b2NvbCArIFwiOi8vXCI7XG5cbiAgICAgICAgLy8gYWRkcyBlbmRwb2ludCB1cmxcbiAgICAgICAgdXJsICs9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgKyBcIj9cIjtcblxuICAgICAgICAvLyBhZGRzIHNlcnZpY2VcbiAgICAgICAgdXJsICs9IFwic2VydmljZT1cIiArIHByb3BlcnRpZXMuc2VydmljZTtcblxuICAgICAgICAvLyBhZGRzIHZlcnNpb25cbiAgICAgICAgdXJsICs9IFwiJnZlcnNpb249Mi4wJlwiO1xuXG4gICAgICAgIC8vIGFkZHMgcmVzcG9uc2VGb3JtYXQgKG9wdGlvbmFsKVxuICAgICAgICBpZiAocHJvcGVydGllcy5yZXNwb25zZUZvcm1hdCkge1xuICAgICAgICAgICAgdXJsICs9IFwiJnJlc3BvbnNlRm9ybWF0PVwiICsgcHJvcGVydGllcy5yZXNwb25zZUZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzRGVmaW5lZChwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcykgJiYgT2JqZWN0LmtleXMocHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0ga2V5Kyc9Jytwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtc1trZXldKycmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHVybC5lbmRzV2l0aCgnJicpKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVNvdXJjZVBhcnNlcjtcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHNcIjtcbmltcG9ydCBEYXRhU291cmNlUGFyc2VyIGZyb20gXCIuL0RhdGFTb3VyY2VQYXJzZXJcIjtcblxuY2xhc3MgVGltZVNlcmllc1BhcnNlclBhcnNlciBleHRlbmRzIERhdGFTb3VyY2VQYXJzZXJ7XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGZ1bGwgdXJsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnByb3RvY29sIHRoZSBjb25uZWN0b3IgcHJvdG9jb2xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5lbmRwb2ludFVybCB0aGUgZW5kcG9pbnQgdXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuc2VydmljZSB0aGUgc2VydmljZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm9mZmVyaW5nSUQgdGhlIG9mZmVyaW5nSURcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5vYnNlcnZlZFByb3BlcnR5IHRoZSBvYnNlcnZlZCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnN0YXJ0VGltZSB0aGUgc3RhcnQgdGltZSAoSVNPIGZvcm1hdClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5lbmRUaW1lIHRoZSBlbmQgdGltZSAoSVNPIGZvcm1hdClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5yZXBsYXlTcGVlZCB0aGUgcmVwbGF5IGZhY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnJlc3BvbnNlRm9ybWF0IHRoZSByZXNwb25zZSBmb3JtYXQgKGUuZyB2aWRlby9tcDQpXG4gICAgICogQHBhcmFtIHtEYXRlfSBwcm9wZXJ0aWVzLmxhc3RUaW1lU3RhbXAgLSB0aGUgbGFzdCB0aW1lc3RhbXAgdG8gc3RhcnQgYXQgdGhpcyB0aW1lIChJU08gU3RyaW5nKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcyAtIHRoZSBlbmNvZGluZyBvcHRpb25zXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgZnVsbCB1cmxcbiAgICAgKi9cbiAgICBidWlsZFVybChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxldCB1cmwgPSBzdXBlci5idWlsZFVybChwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBhZGRzIHJlcXVlc3RcbiAgICAgICAgdXJsICs9IFwiJnJlcXVlc3Q9R2V0UmVzdWx0XCI7XG5cbiAgICAgICAgLy8gYWRkcyBvZmZlcmluZ1xuICAgICAgICB1cmwgKz0gXCImb2ZmZXJpbmc9XCIgKyBwcm9wZXJ0aWVzLm9mZmVyaW5nSUQ7XG5cbiAgICAgICAgLy8gYWRkcyBvYnNlcnZlZFByb3BlcnR5XG4gICAgICAgIHVybCArPSBcIiZvYnNlcnZlZFByb3BlcnR5PVwiICsgcHJvcGVydGllcy5vYnNlcnZlZFByb3BlcnR5O1xuXG4gICAgICAgIC8vIGFkZHMgdGVtcG9yYWxGaWx0ZXJcbiAgICAgICAgY29uc3Qgc3RUaW1lID0gKGlzRGVmaW5lZChwcm9wZXJ0aWVzLmxhc3RUaW1lU3RhbXApKSA/IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCA6ICBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5sYXN0U3RhcnRUaW1lID0gcHJvcGVydGllcy5zdGFydFRpbWU7XG4gICAgICAgIGxldCBlbmRUaW1lID0gcHJvcGVydGllcy5lbmRUaW1lO1xuICAgICAgICB1cmwgKz0gXCImdGVtcG9yYWxGaWx0ZXI9cGhlbm9tZW5vblRpbWUsXCIgKyBzdFRpbWUrIFwiL1wiICsgZW5kVGltZTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMucmVwbGF5U3BlZWQpIHtcbiAgICAgICAgICAgIC8vIGFkZHMgcmVwbGF5U3BlZWRcbiAgICAgICAgICAgIHVybCArPSBcIiZyZXBsYXlTcGVlZD1cIiArIHByb3BlcnRpZXMucmVwbGF5U3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc1BhcnNlclBhcnNlcjtcbiIsImltcG9ydCBUaW1lU2VyaWVzUGFyc2VyIGZyb20gXCIuL1RpbWVTZXJpZXNQYXJzZXIucGFyc2VyXCI7XG5cbmNsYXNzIFNvc0dldFJlc3VsdEpzb25QYXJzZXIgZXh0ZW5kcyBUaW1lU2VyaWVzUGFyc2VyIHtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aW1lc3RhbXAgZnJvbSB0aGUgbWVzc2FnZS4gVGhlIHRpbWVzdGFtcCBjb3JyZXNwb25kcyB0byB0aGUgJ3RpbWUnIGF0dHJpYnV0ZSBvZiB0aGUgSlNPTiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSB0aGUgZGF0YSB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGV4dHJhY3RlZCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBwYXJzZVRpbWVTdGFtcChkYXRhKSB7XG4gICAgICAgIGxldCByZWMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKEpTT04ucGFyc2UocmVjKVsndGltZSddKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBkYXRhIGZyb20gdGhlIG1lc3NhZ2UuIFRoZSBkYXRhIGFyZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB3aG9sZSBsaXN0IG9mIGF0dHJpYnV0ZXMgb2YgdGhlIEpTT04gb2JqZWN0XG4gICAgICogZXhjZXB0aW5nIHRoZSAndGltZScgb25lLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdGhlIGRhdGEgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYXJzZWQgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICoge1xuICAgICAqICAgbG9jYXRpb24gOiB7XG4gICAgICogICAgbGF0OjQzLjYxNzU4NjI2LFxuICAgICAqICAgIGxvbjogMS40MjM3NjU1NyxcbiAgICAgKiAgICBhbHQ6MTAwXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIHBhcnNlRGF0YShkYXRhKSB7XG4gICAgICAgIGxldCByZWMgPSBKU09OLnBhcnNlKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcblxuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHJlYykge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZWNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgZnVsbCB1cmwuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMucHJvdG9jb2wgdGhlIGNvbm5lY3RvciBwcm90b2NvbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZHBvaW50VXJsIHRoZSBlbmRwb2ludCB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zZXJ2aWNlIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2ZmZXJpbmdJRCB0aGUgb2ZmZXJpbmdJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHkgdGhlIG9ic2VydmVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZm9pSWQgdGhlIGZvaUlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuc3RhcnRUaW1lIHRoZSBzdGFydCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZFRpbWUgdGhlIGVuZCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnJlcGxheVNwZWVkIHRoZSByZXBsYXkgZmFjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQgdGhlIHJlc3BvbnNlIGZvcm1hdCAoZS5nIHZpZGVvL21wNClcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCAtIHRoZSBsYXN0IHRpbWVzdGFtcCB0byBzdGFydCBhdCB0aGlzIHRpbWUgKElTTyBTdHJpbmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zIC0gdGhlIGVuY29kaW5nIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmdWxsIHVybFxuICAgICAqL1xuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHVybCA9IHN1cGVyLmJ1aWxkVXJsKHtcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICByZXNwb25zZUZvcm1hdDogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0pO1xuXG4gICAgICAgICAvLyBhZGRzIGZlYXR1cmUgb2YgaW50ZXJlc3QgdXJuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmZvaUlkICYmIHByb3BlcnRpZXMub2YgIT09ICcnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZmZWF0dXJlT2ZJbnRlcmVzdD0nICsgcHJvcGVydGllcy5mb2lJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU29zR2V0UmVzdWx0SnNvblBhcnNlcjtcbiIsIi8qKlxuICogRW51bSBmb3IgY29ubmVjdGlvbiBzdGF0dXMuXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHt7bmFtZTogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IFN0YXR1cyA9IHtcbiAgICBDT05ORUNUSU5HOiBcImNvbm5lY3RpbmdcIixcbiAgICBDT05ORUNURUQ6ICBcImNvbm5lY3RlZFwiLFxuICAgIERJU0NPTk5FQ1RFRDogXCJkaXNjb25uZWN0ZWRcIlxufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IHtyYW5kb21VVUlEfSBmcm9tICcuLi91dGlscy9VdGlscy5qcyc7XG5pbXBvcnQge1N0YXR1c30gZnJvbSAnLi9TdGF0dXMuanMnO1xuXG4vKipcbiAqIFRoZSBEYXRhQ29ubmVjdG9yIGlzIHRoZSBhYnN0cmFjdCBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBkaWZmZXJlbnQgY29ubmVjdG9ycy5cbiAqL1xuY2xhc3MgRGF0YUNvbm5lY3RvciB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIGZ1bGwgdXJsIHVzZWQgdG8gY29ubmVjdCB0byB0aGUgZGF0YSBzdHJlYW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaWQgPSBcIkRhdGFDb25uZWN0b3ItXCIgKyByYW5kb21VVUlEKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IDEwMDAgKiA2MCAqIDI7IC8vMiBtaW5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAgU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9IC0xO1xuICAgIH1cblxuICAgIGNoZWNrQW5kQ2xlYXJSZWNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgIT09IC0xKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jaGVja1N0YXR1cyhTdGF0dXMuRElTQ09OTkVDVEVEKTtcbiAgICAgICAgdGhpcy5jaGVja0FuZENsZWFyUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdXJsXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIHNldFVybCh1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgY29ubmVjdG9yIGRlZmF1bHQgaWQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyZWFtIHVybC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIHRpbWVvdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgcmVjb25uZWN0aW5nIGRhdGFTb3VyY2VcbiAgICAgKi9cbiAgICBzZXRSZWNvbm5lY3RUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG5cbiAgICBvblJlY29ubmVjdCgpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25uZWN0KCkge31cblxuICAgIGZvcmNlUmVjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gU1RBVFVTIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIG5ldyBzdGF0dXNcbiAgICAgKi9cbiAgICBvbkNoYW5nZVN0YXR1cyhzdGF0dXMpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGEgY2hhbmdlIG9mIHRoZSBzdGF0dXMgYW5kIGNhbGwgdGhlIGNvcnJlc3BvbmRpbmcgY2FsbGJhY2tzIGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXMgLSB0aGUgY3VycmVudFN0YXR1c1xuICAgICAqL1xuICAgIGNoZWNrU3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZihzdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdG9yIGhhcyBiZWVuIGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdCgpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0b3IgaGFzIGJlZW4gY29ubmVjdGVkXG4gICAgICovXG4gICAgb25Db25uZWN0KCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhQ29ubmVjdG9yO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQgRGF0YUNvbm5lY3RvciBmcm9tICcuL0RhdGFDb25uZWN0b3IuanMnO1xuaW1wb3J0IHtpc1dlYldvcmtlcn0gZnJvbSAnLi4vdXRpbHMvVXRpbHMuanMnO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gJy4vU3RhdHVzLmpzJztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBXZWJTb2NrZXRDb25uZWN0b3IgdG8gY29ubmVjdCB0byBhIHJlbW90ZSBzZXJ2ZXIgYnkgY3JlYXRpbmcgYSBXZWJTb2NrZXQgY2hhbm5lbC5cbiAqIEBleHRlbmRzIERhdGFDb25uZWN0b3JcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgV2ViU29ja2V0Q29ubmVjdG9yIGZyb20gJ29zaC9kYXRhY29ubmVjdG9yL1dlYlNvY2tldENvbm5lY3Rvci5qcyc7XG4gKlxuICogbGV0IHVybCA9IC4uLjtcbiAqIGxldCBjb25uZWN0b3IgPSBuZXcgV2ViU29ja2V0Q29ubmVjdG9yKHVybCk7XG4gKlxuICogLy8gY29ubmVjdFxuICogY29ubmVjdG9yLmNvbm5lY3QoKTtcbiAqXG4gKiAvLyBkaXNjb25uZWN0XG4gKiBjb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICpcbiAqIC8vIGNsb3NlXG4gKiBjb25uZWN0b3IuY2xvc2UoKTtcbiAqXG4gKi9cblxuY2xhc3MgV2ViU29ja2V0Q29ubmVjdG9yIGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyAtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgd2ViU29ja2V0LiBJZiB0aGUgc3lzdGVtIHN1cHBvcnRzIFdlYldvcmtlciwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIG90aGVyd2lzZSB1c2VcbiAgICAgKiB0aGUgbWFpbiB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmluaXQgPSB0cnVlO1xuICAgICAgICAgICAgLy9jcmVhdGVzIFdlYiBTb2NrZXRcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMuZ2V0VXJsKCkpO1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RJTkcpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgc3RyZWFtIGNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQW5kQ2xlYXJSZWNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKFN0YXR1cy5DT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViU29ja2V0IHN0cmVhbSBjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBkYXRhIG9uIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIGNsb3NlcyBzb2NrZXQgaWYgYW55IGVycm9ycyBvY2N1clxuICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IHN0cmVhbSBlcnJvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViU29ja2V0IHN0cmVhbSBjbG9zZWQ6ICcsZXZlbnQucmVhc29uLCBldmVudC5jb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihldmVudC5jb2RlICE9PSAxMDAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVSZWNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmKCF0aGlzLmNsb3NlZCAmJiB0aGlzLnJlY29ubmVjdGlvbkludGVydmFsID09PSAtMSAmJiB0aGlzLm9uUmVjb25uZWN0KCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgPSAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RSZWNlaXZlVGltZTtcbiAgICAgICAgICAgICAgICAvLyAtMSBtZWFucyB0aGUgV1Mgd2VudCBpbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RSZWNlaXZlVGltZSA9PT0gLTEgfHwgKGRlbHRhID49IHRoaXMucmVjb25uZWN0VGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cnlpbmcgdG8gcmVjb25uZWN0JywgdGhpcy51cmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyBhbmQgY2xvc2UgdGhlIHdlYnNvY2tldC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgaWYgKHRoaXMud3MgIT0gbnVsbCAmJiB0aGlzLndzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb25NZXNzYWdlIG1ldGhvZCB1c2VkIGJ5IHRoZSB3ZWJzb2NrZXQgdG8gY2FsbGJhY2sgdGhlIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgY2FsbGJhY2sgZGF0YVxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgfVxuXG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndzICE9IG51bGwgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXRDb25uZWN0b3I7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC5cbiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmVcbiBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cbiBTb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlXG4gZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIENvcHlyaWdodCAoQykgMjAxNS0yMDIwIE1hdGhpZXUgRGhhaW5hdXQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiBBdXRob3I6IE1hdGhpZXUgRGhhaW5hdXQgPG1hdGhpZXUuZGhhaW5hdXRAZ21haWwuY29tPlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCBEYXRhQ29ubmVjdG9yIGZyb20gJy4vRGF0YUNvbm5lY3Rvci5qcyc7XG5pbXBvcnQge2lzRGVmaW5lZH0gZnJvbSAnLi4vdXRpbHMvVXRpbHMuanMnO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gJy4vU3RhdHVzLmpzJztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBBamF4Q29ubmVjdG9yIHRvIGNvbm5lY3QgdG8gYSByZW1vdGUgc2VydmVyIGJ5IG1ha2luZyBBamF4UmVxdWVzdC5cbiAqIEBleHRlbmRzIERhdGFDb25uZWN0b3JcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgQWpheCBmcm9tICdvc2gvZGF0YWNvbm5lY3Rvci9BamF4LmpzJztcbiAqXG4gKiBsZXQgcmVxdWVzdCA9IC4uLjtcbiAqIGxldCBjb25uZWN0b3IgPSBuZXcgQWpheCh1cmwpO1xuICpcbiAqIC8vIGhhbmRsZSBvblN1Y2Nlc3NcbiAqIGNvbm5lY3Rvci5vblN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICogIC8vIGRvZXMgc29tZXRoaW5nXG4gKiB9XG4gKlxuICogY29ubmVjdG9yLm9uRXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICogIC8vIGRvZXMgc29tZXRoaW5nXG4gKiB9XG4gKlxuICogLy8gc2VuZCByZXF1ZXN0XG4gKiBjb25uZWN0b3Iuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gKlxuICovXG5jbGFzcyBBamF4IGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIEFqYXguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm1ldGhvZCAtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlIC1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIodXJsKTtcblxuICAgICAgICB0aGlzLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IHByb3BlcnRpZXMubWV0aG9kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIGRlZmluZWQgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0IC0gVGhlIEh0dHAgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHRyYVVybCAtIGdldCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgZXh0cmFVcmwpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4bWxodHRwLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIHhtbGh0dHAudGltZW91dCA9IDYwMDAwO1xuICAgICAgICBpZiAocmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChleHRyYVVybCkpIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdGhpcy5nZXRVcmwoKSArIFwiP1wiICsgZXh0cmFVcmwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdGhpcy5nZXRVcmwoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxodHRwLnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgeG1saHR0cC5vbmxvYWQgPSAob0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhtbGh0dHAucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbk1lc3NhZ2UoeG1saHR0cC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeG1saHR0cC5vbnRpbWVvdXQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGltZW91dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RFRCk7XG4gICAgICAgICAgICB4bWxodHRwLnNlbmQobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJQT1NUXCIsIHRoaXMuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICAgICAgeG1saHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcblxuICAgICAgICAgICAgeG1saHR0cC5zZW5kKHJlcXVlc3QpO1xuICAgICAgICAgICAgc2VsZi5jaGVja1N0YXR1cyhTdGF0dXMuQ09OTkVDVEVEKTtcbiAgICAgICAgICAgIHhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PT0gNCkgeyAgICAgICAgICAgICAgICAvLyA0ID0gUmVzcG9uc2UgZnJvbSBzZXJ2ZXIgaGFzIGJlZW4gY29tcGxldGVseSBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnN0YXR1cyA9PT0gMjAwICYmIHhtbGh0dHAuc3RhdHVzIDwgMzAwKSB7IC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25TdWNjZXNzKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25FcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjYWxsYmFjayBtZXRob2QgaW4gY2FzZSBvZiBnZXR0aW5nIGVycm9yIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBlcnJvciBkZXRhaWxzXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25FcnJvcihldmVudCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY2FsbGJhY2sgbWV0aG9kIGluIGNhc2Ugb2YgZ2V0dGluZyBzdWNjZXNzIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25TdWNjZXNzKGV2ZW50KSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgcmVxdWVzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChudWxsKTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFqYXg7XG4iLCJpbXBvcnQgRGF0YUNvbm5lY3RvciBmcm9tIFwiLi9EYXRhQ29ubmVjdG9yXCI7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgRmlsZUNvbm5lY3RvciB0byByZWFkIGEgRmlsZSBjb250ZW50XG4gKiBAZXh0ZW5kcyBEYXRhQ29ubmVjdG9yXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IEZpbGVDb25uZWN0b3IgZnJvbSAnb3NoL2RhdGFjb25uZWN0b3IvVG9waWNDb25uZWN0b3IuanMnO1xuICpcbiAqIGxldCBjb25uZWN0b3IgPSBuZXcgVG9waWNDb25uZWN0b3IoPHRvcGljX25hbWU+KTtcbiAqXG4gKiAvLyBjb25uZWN0XG4gKiBjb25uZWN0b3IuY29ubmVjdCgpO1xuICpcbiAqIC8vIGRpc2Nvbm5lY3RcbiAqIGNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gKlxuICogLy8gY2xvc2VcbiAqIGNvbm5lY3Rvci5jbG9zZSgpO1xuICpcbiAqL1xuY2xhc3MgVG9waWNDb25uZWN0b3IgZXh0ZW5kcyBEYXRhQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIC1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHN1cGVyKHByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IC0xO1xuICAgICAgICB0aGlzLmludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgYnJvYWRjYXN0Q2hhbm5lbC5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsID09PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NyZWF0ZXMgYnJvYWRjYXN0Q2hhbm5lbFxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGhpcy5nZXRVcmwoKSk7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwub25tZXNzYWdlID0gIChldmVudCkgID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBkYXRhIG9uIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShldmVudC5kYXRhLmRhdGEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gY2xvc2VzIHNvY2tldCBpZiBhbnkgZXJyb3JzIG9jY3VyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwub25lcnJvciA9ICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdCcm9hZGNhc3RDaGFubmVsIHN0cmVhbSBlcnJvcjogJyArIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL2luaXQgdGhlIHJlY29ubmVjdCBoYW5kbGVyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UmVjZWl2ZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIC0xIG1lYW5zIHRoZSBXUyB3ZW50IGluIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RSZWNlaXZlVGltZSA9PT0gLTEgfHwgKGRlbHRhID49IHRoaXMucmVjb25uZWN0VGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgdHJ5aW5nIHRvIHJlY29ubmVjdCBhZnRlciAke3RoaXMucmVjb25uZWN0VGltZW91dH0gLi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZnVsbERpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVsbHkgZGlzY29ubmVjdCB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gYnkgc2VuZGluZyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIHdlYldvcmtlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZUludGVydmFsICAtIGZvcmNlIHJlbW92aW5nIHRoZSBpbnRlcnZhbFxuICAgICAqL1xuICAgIGZ1bGxEaXNjb25uZWN0KHJlbW92ZUludGVydmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyeSB0byByZWNvbm5lY3QgaWYgdGhlIGNvbm5leGlvbiBpZiBjbG9zZWRcbiAgICAgKi9cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMub25SZWNvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdCkge1xuICAgICAgICAgICAgdGhpcy5mdWxsRGlzY29ubmVjdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb25NZXNzYWdlIG1ldGhvZCB1c2VkIGJ5IHRoZSB3ZWJzb2NrZXQgdG8gY2FsbGJhY2sgdGhlIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgY2FsbGJhY2sgZGF0YVxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB3ZWJTb2NrZXQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RDaGFubmVsICE9PSBudWxsICYmIHRoaXMub3BlbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9waWNDb25uZWN0b3I7XG4iLCJleHBvcnQgY29uc3QgRXZlbnRUeXBlID0ge1xuICAgIERBVEE6ICdkYXRhJyxcbiAgICBTVEFUVVM6ICdzdGF0dXMnXG59O1xuIiwiaW1wb3J0IERhdGFDb25uZWN0b3IgZnJvbSBcIi4vRGF0YUNvbm5lY3RvclwiO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gXCIuL1N0YXR1c1wiO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIEZpbGVDb25uZWN0b3IgdG8gcmVhZCBhIEZpbGUgY29udGVudFxuICogQGV4dGVuZHMgRGF0YUNvbm5lY3RvclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBGaWxlQ29ubmVjdG9yIGZyb20gJ29zaC9kYXRhY29ubmVjdG9yL0ZpbGVDb25uZWN0b3IuanMnO1xuICpcbiAqIGxldCBwYXRocyA9IFsncGF0aDEnLCdwYXRoMl0uLi5dO1xuICogbGV0IGNvbm5lY3RvciA9IG5ldyBGaWxlQ29ubmVjdG9yKHBhdGhzKTtcbiAqXG4gKiAvLyBjb25uZWN0XG4gKiBjb25uZWN0b3IuY29ubmVjdCgpO1xuICpcbiAqIC8vIGRpc2Nvbm5lY3RcbiAqIGNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gKlxuICogLy8gY2xvc2VcbiAqIGNvbm5lY3Rvci5jbG9zZSgpO1xuICpcbiAqL1xuY2xhc3MgRmlsZUNvbm5lY3RvciBleHRlbmRzIERhdGFDb25uZWN0b3Ige1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAoc3RyaW5nW10pIHBhdGhzIC0gbGlzdCBvZiBmaWxlIHBhdGhzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0aHMpIHtcbiAgICAgICAgc3VwZXIocGF0aHMpO1xuICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHJlYWRpbmcgZmlsZSBjb250ZW50XG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYoIXRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlU3RhdHVzKFN0YXR1cy5DT05ORUNURUQpO1xuICAgICAgICAgICAgY29uc3QgdXJscyA9IHRoaXMuZ2V0VXJsKCk7XG4gICAgICAgICAgICBmb3IobGV0IHVybCBvZiB1cmxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoYXdhaXQgZmV0Y2godXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgLy8gcmVhZCBpcyBkb25lXG4gICAgICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGVDb25uZWN0b3I7XG4iLCJpbXBvcnQgV2ViU29ja2V0Q29ubmVjdG9yIGZyb20gXCIuLi8uLi9kYXRhY29ubmVjdG9yL1dlYlNvY2tldENvbm5lY3Rvci5qc1wiO1xuaW1wb3J0IEFqYXggZnJvbSBcIi4uLy4uL2RhdGFjb25uZWN0b3IvQWpheC5qc1wiO1xuaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IFRvcGljQ29ubmVjdG9yIGZyb20gXCIuLi8uLi9kYXRhY29ubmVjdG9yL1RvcGljQ29ubmVjdG9yLmpzXCI7XG5pbXBvcnQge0V2ZW50VHlwZX0gZnJvbSBcIi4uLy4uL2V2ZW50L0V2ZW50VHlwZS5qc1wiO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gXCIuLi8uLi9kYXRhY29ubmVjdG9yL1N0YXR1c1wiO1xuaW1wb3J0IEZpbGVDb25uZWN0b3IgZnJvbSBcIi4uLy4uL2RhdGFjb25uZWN0b3IvRmlsZUNvbm5lY3RvclwiO1xuXG5jbGFzcyBEYXRhU291cmNlSGFuZGxlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gMTAwMCAqIDEwOyAvLyAxMCBzZWNzXG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgY3JlYXRlQ29ubmVjdG9yKHByb3BlcnRpZXNTdHIsIHRvcGljLCBkYXRhU291cmNlSWQpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlSWQgPSBkYXRhU291cmNlSWQ7XG4gICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGluZyBjb25uZWN0b3JcbiAgICAgICAgaWYodGhpcy5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRvcGljKTtcblxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gSlNPTi5wYXJzZShwcm9wZXJ0aWVzU3RyKTtcblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMudGltZVNoaWZ0KSkge1xuICAgICAgICAgICAgdGhpcy50aW1lU2hpZnQgPSBwcm9wZXJ0aWVzLnRpbWVTaGlmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy5idWZmZXJpbmdUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJpbmdUaW1lID0gcHJvcGVydGllcy5idWZmZXJpbmdUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLnRpbWVPdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVPdXQgPSBwcm9wZXJ0aWVzLnRpbWVPdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMucmVjb25uZWN0VGltZW91dCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHByb3BlcnRpZXMucmVjb25uZWN0VGltZW91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHByb3BlcnRpZXMuc3RhcnRUaW1lID09PSAnbm93Jykge1xuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLnJlcGxheVNwZWVkKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKHByb3BlcnRpZXMuYmF0Y2hTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMuYmF0Y2hTaXplKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gcHJvcGVydGllcy5iYXRjaFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDb25uZWN0b3IodGhpcy5wcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNyZWF0ZURhdGFDb25uZWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLnBhcnNlci5idWlsZFVybCh7XG4gICAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdGltZVNoaWZ0OiB0aGlzLnRpbWVTaGlmdFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVja3MgaWYgdHlwZSBpcyBXZWJTb2NrZXRDb25uZWN0b3JcbiAgICAgICAgaWYgKHByb3BlcnRpZXMucHJvdG9jb2wuc3RhcnRzV2l0aCgnd3MnKSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgV2ViU29ja2V0Q29ubmVjdG9yKHVybCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IEFqYXgodXJsKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlc3BvbnNlVHlwZSA9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlIHx8ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCd0b3BpYycpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBUb3BpY0Nvbm5lY3Rvcih1cmwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMucHJvdG9jb2wuc3RhcnRzV2l0aCgnZmlsZScpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBGaWxlQ29ubmVjdG9yKHVybCxwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSByZWNvbm5lY3RUaW1lb3V0XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRSZWNvbm5lY3RUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG5cbiAgICAgICAgICAgIC8vIGNvbm5lY3RzIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iub25NZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gYmluZCBjaGFuZ2UgY29ubmVjdGlvbiBTVEFUVVNcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLm9uQ2hhbmdlU3RhdHVzICAgPSB0aGlzLm9uQ2hhbmdlU3RhdHVzLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRvcGljIHRvIGxpc3RlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIHRoZSB0b3BpYyB0byBsaXN0ZW5cbiAgICAgKi9cbiAgICBzZXRUb3BpYyh0b3BpYykge1xuICAgICAgICBpZihpc0RlZmluZWQodGhpcy5icm9hZGNhc3RDaGFubmVsKSkge1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodG9waWMpO1xuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYodGhpcy5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmKHRoaXMuY29ubmVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZGF0YSAgID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMucGFyc2VyLnBhcnNlRGF0YShldmVudCkpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGRhdGEgaXMgYXJyYXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2kgPCBkYXRhLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5iYXRjaFNpemUpICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVjYXVzZSBwYXJzZURhdGEgaXMgQVNZTkMsIHRoZSBjb25uZWN0b3IgY2FuIGZpbmlzaCBiZWZvcmUgdGhlIHBhcnNpbmcgbWV0aG9kLiBJbiB0aGF0IGNhc2UsIHdlIGhhdmUgdG8gZmx1c2hBTGwgZGF0YVxuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEFsbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZCh0aGlzLmJhdGNoU2l6ZSkgJiYgdGhpcy52YWx1ZXMubGVuZ3RoICE9PSAwICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNoYW5nZSBzdGF0dXMgZXZlbnQgaW50byB0aGUgYnJvYWRjYXN0IGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIG5ldyBzdGF0dXNcbiAgICAgKi9cbiAgICBvbkNoYW5nZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYoc3RhdHVzID09PSBTdGF0dXMuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlNUQVRVUyxcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgZGF0YVNvdXJjZUlkOiB0aGlzLmRhdGFTb3VyY2VJZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ29ubmVjdG9yKHtcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICB9XG5cbiAgICBmbHVzaEFsbCgpIHtcbiAgICAgICAgd2hpbGUodGhpcy52YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCBuYkVsZW1lbnRzID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMuYmF0Y2hTaXplKSAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPiB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgbmJFbGVtZW50cyA9IHRoaXMuYmF0Y2hTaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhU291cmNlSWQ6IHRoaXMuZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRBVEEsXG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLnNwbGljZSgwLCBuYkVsZW1lbnRzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbm5lY3RvciA9PT0gbnVsbCk/IGZhbHNlOiB0aGlzLmNvbm5lY3Rvci5pc0Nvbm5lY3RlZCgpO1xuICAgIH07XG5cbiAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIHdvcmtlcikge1xuICAgICAgICBpZihtZXNzYWdlLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb25uZWN0b3IobWVzc2FnZS5wcm9wZXJ0aWVzLCBtZXNzYWdlLnRvcGljLCBtZXNzYWdlLmlkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnZGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ3RvcGljJykge1xuICAgICAgICAgICAgdGhpcy5zZXRUb3BpYyhtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICd1cGRhdGUtdXJsJykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnaXMtY29ubmVjdGVkJykge1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaXMtY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmlzQ29ubmVjdGVkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBEYXRhU291cmNlSGFuZGxlcjtcblxuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IERhdGFTb3VyY2VIYW5kbGVyIGZyb20gXCIuL0RhdGFTb3VyY2VIYW5kbGVyXCI7XG5cbmNsYXNzIFRpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlciBleHRlbmRzIERhdGFTb3VyY2VIYW5kbGVye1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIHN1cGVyKHBhcnNlcik7XG4gICAgICAgIHRoaXMubGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFN0YXJ0VGltZSA9ICdub3cnO1xuICAgICAgICB0aGlzLnRpbWVTaGlmdCA9IDA7XG4gICAgICAgIHRoaXMudGltZUJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlRGF0YUNvbm5lY3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHN1cGVyLmNyZWF0ZURhdGFDb25uZWN0b3Ioe1xuICAgICAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgICAgIHRpbWVTaGlmdDogdGhpcy50aW1lU2hpZnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbGFzdFN0YXJ0VGltZUNzdCA9IHRoaXMucGFyc2VyLmxhc3RTdGFydFRpbWU7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yLm9uUmVjb25uZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm90IHJlYWwgdGltZSwgcHJlc2VydmUgbGFzdCB0aW1lc3RhbXAgdG8gcmVjb25uZWN0IGF0IHRoZSBsYXN0IHRpbWUgcmVjZWl2ZWRcbiAgICAgICAgICAgIC8vIGZvciB0aGF0LCB3ZSB1cGRhdGUgdGhlIFVSTCB3aXRoIHRoZSBuZXcgbGFzdCB0aW1lIHJlY2VpdmVkXG4gICAgICAgICAgICBpZiAobGFzdFN0YXJ0VGltZUNzdCAhPT0gJ25vdycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRVcmwodGhpcy5wYXJzZXIuYnVpbGRVcmwoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGltZVN0YW1wOiBpc0RlZmluZWQodGhpcy5sYXN0VGltZVN0YW1wKSA/IG5ldyBEYXRlKHRoaXMubGFzdFRpbWVTdGFtcCkudG9JU09TdHJpbmcoKTogcHJvcGVydGllcy5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcnNlci5wYXJzZVRpbWVTdGFtcChldmVudCkgKyB0aGlzLnRpbWVTaGlmdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgICAgICA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcnNlci5wYXJzZURhdGEoZXZlbnQpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGlzIGFycmF5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpIDwgZGF0YS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RUaW1lU3RhbXAgPSB0aW1lU3RhbXA7XG5cbiAgICAgICAgaWYodGhpcy5wYXJzZXIubGFzdFN0YXJ0VGltZSA9PT0gJ25vdycgfHwgKChpc0RlZmluZWQodGhpcy5iYXRjaFNpemUpICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICBpZih0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5sYXN0VGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMYXN0VGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0VGltZVN0YW1wO1xuICAgIH1cblxuICAgIHVwZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICBsZXQgbGFzdFRpbWVzdGFtcCA9ICBuZXcgRGF0ZSh0aGlzLmxhc3RUaW1lU3RhbXApLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgaWYocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgnc3RhcnRUaW1lJykpIHtcbiAgICAgICAgICAgIGxhc3RUaW1lc3RhbXAgPSBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucHJvcGVydGllcy5zdGFydFRpbWUgPT09ICdub3cnKXtcbiAgICAgICAgICAgIC8vaGFuZGxlIFJlYWxUaW1lXG4gICAgICAgICAgICBsYXN0VGltZXN0YW1wID0gJ25vdyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDb25uZWN0b3Ioe1xuICAgICAgICAgICAgLi4udGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgICAgIGxhc3RUaW1lU3RhbXA6IGxhc3RUaW1lc3RhbXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoaXNEZWZpbmVkKHByb3BlcnRpZXMpICYmIGlzRGVmaW5lZChwcm9wZXJ0aWVzLnJlY29ubmVjdCkgJiYgcHJvcGVydGllcy5yZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlLCB3b3JrZXIpIHtcbiAgICAgICAgc3VwZXIuaGFuZGxlTWVzc2FnZShtZXNzYWdlLCB3b3JrZXIpO1xuXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICdsYXN0LXRpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUaW1lU3RhbXAgPSB0aGlzLmdldExhc3RUaW1lU3RhbXAoKTtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2xhc3QtdGltZXN0YW1wJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBsYXN0VGltZVN0YW1wXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ3RvcGljJykge1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lVG9waWMobWVzc2FnZS50aW1lVG9waWMpO1xuICAgICAgICAgICAgc3VwZXIuc2V0VG9waWMobWVzc2FnZS50b3BpYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUaW1lVG9waWModGltZVRvcGljKSB7XG4gICAgICAgIGlmKHRoaXMudGltZUJyb2FkY2FzdENoYW5uZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGltZUJyb2FkY2FzdENoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGltZVRvcGljKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzRGF0YVNvdXJjZUhhbmRsZXI7XG5cbiIsImltcG9ydCBTb3NHZXRSZXN1bHRKc29uUGFyc2VyIGZyb20gJy4uL3BhcnNlcnMvU29zR2V0UmVzdWx0SnNvbi5wYXJzZXInO1xuaW1wb3J0IFRpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlciBmcm9tIFwiLi9UaW1lU2VyaWVzRGF0YVNvdXJjZUhhbmRsZXJcIjtcblxuY29uc3QgZGF0YVNvdXJjZUhhbmRsZXIgPSBuZXcgVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyKG5ldyBTb3NHZXRSZXN1bHRKc29uUGFyc2VyKCkpO1xuXG5zZWxmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgIGRhdGFTb3VyY2VIYW5kbGVyLmhhbmRsZU1lc3NhZ2UoZXZlbnQuZGF0YSwgc2VsZik7XG59XG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);