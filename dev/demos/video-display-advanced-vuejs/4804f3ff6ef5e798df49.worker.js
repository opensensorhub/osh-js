!function(Q){var B={};function F(U){if(B[U])return B[U].exports;var I=B[U]={i:U,l:!1,exports:{}};return Q[U].call(I.exports,I,I.exports,F),I.l=!0,I.exports}F.m=Q,F.c=B,F.d=function(Q,B,U){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:U})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(F.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var I in Q)F.d(U,I,function(B){return Q[B]}.bind(null,I));return U},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on sâ€™endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, timerResolution = 5) {\n    this.dataSourceMap = {};\n    this.bufferingTime = 1000;\n    this.startBufferingTime = -1;\n    this.tsRun = 0;\n    this.replaySpeed = replaySpeed;\n    this.timerResolution = timerResolution;\n    let maxBufferingTime = -1;\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n      maxBufferingTime = ds.bufferingTime > maxBufferingTime ? ds.bufferingTime : maxBufferingTime;\n    }\n\n    if (maxBufferingTime !== -1) {\n      this.bufferingTime = maxBufferingTime;\n    }\n  }\n\n  push(dataSourceId, dataBlock) {\n    const ds = this.dataSourceMap[dataSourceId];\n\n    if (!this.checkVersion(ds, dataBlock)) {\n      return;\n    }\n\n    if (this.startBufferingTime === -1) {\n      console.log(`synchronizer buffering data for ${this.bufferingTime}ms..`);\n      this.startBufferingTime = performance.now(); // start iterating on dataBlock after bufferingTime\n\n      this.timeoutBuffering = setTimeout(() => this.processData(), this.bufferingTime);\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - dataBlock.data.timestamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(dataBlock);\n  }\n\n  reset() {\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      const currentDs = this.dataSourceMap[currentDsId];\n      currentDs.dataBuffer = [];\n      currentDs.startBufferingTime = -1;\n      currentDs.latency = 0;\n      currentDs.status = Status.DISCONNECTED;\n      currentDs.version = undefined;\n    }\n\n    this.tsRun = 0;\n    this.startBufferingTime = -1;\n  }\n\n  processData() {\n    // the timeout has been cancelled\n    if (!isDefined(this.timeoutBuffering)) {\n      return;\n    }\n\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].data.timestamp < tsRef ? currentDs.dataBuffer[0].data.timestamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.timerResolution);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    maxLatency *= this.replaySpeed;\n    minLatency *= this.replaySpeed;\n    const dClock = (performance.now() - refClockTime) * this.replaySpeed;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {DataSource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      bufferingTime: dataSource.bufferingTime,\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      startBufferingTime: -1,\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      version: undefined\n    };\n  }\n\n  checkVersion(datasource, dataBlock) {\n    if (!isDefined(datasource.version) && datasource.status !== Status.DISCONNECTED) {\n      return true;\n    } else if (datasource.status === Status.DISCONNECTED && datasource.version !== dataBlock.version) {\n      return false;\n    }\n  }\n\n  onData(dataSourceId, dataBlock) {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n\n    if (isDefined(this.timeoutBuffering)) {\n      clearTimeout(this.timeoutBuffering);\n      this.timeoutBuffering = null;\n    }\n\n    console.log(\"Data synchronizer terminated successfully\");\n  }\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\nconst MAGIC_END_PACKET = 'magic-packet';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  TIME: 'time',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizer.worker.js\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nself.currentTime = -1;\n\nconst dataSources = {};\nlet timeBroadcastChannel = null;\nlet topicTime;\nlet topicData;\n\nself.onmessage = (event) => {\n    let data = undefined;\n    if(event.data.message === 'init') {\n        dataSynchronizerAlgo = new timesync_DataSynchronizerAlgo(\n            event.data.dataSources,\n            event.data.replaySpeed,\n            event.data.timerResolution\n        );\n        dataSynchronizerAlgo.onData = onData;\n        init = true;\n        addDataSources(event.data.dataSources);\n        topicData = event.data.dataTopic;\n        topicTime = event.data.timeTopic;\n        initBroadcastChannel(topicData, topicTime);\n    } else if(event.data.message === 'add' && event.data.dataSources) {\n        addDataSources(event.data.dataSources);\n    } else if(event.data.message === 'current-time') {\n        data = {\n            message: 'current-time',\n            data: self.currentTime\n        };\n    }  else if(event.data.message === 'reset') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.reset();\n        }\n        timeBroadcastChannel.postMessage({\n            type: EventType.TIME_CHANGED\n        });\n    }  else if(event.data.message === 'replay-speed') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;\n        }\n    } else if(event.data.message === 'data') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);\n        }\n    } else {\n        // skip response\n        return;\n    }\n    self.postMessage({\n        message: event.data.message,\n        data: data,\n        messageId: event.data.messageId\n    })\n\n}\n\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    console.log('listen on topic ',dataTopic)\n\n    dataSourceBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSourceBroadCastChannel.onmessage = async (event) => {\n        if(event.data.type === EventType.DATA) {\n            for(let i=0; i < event.data.values.length;i++) {\n                dataSynchronizerAlgo.push(\n                    event.data.dataSourceId,\n                    {\n                        ...event.data.values[i]\n                    }\n                );\n            }\n        } else if(event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            console.log(dataSources[dataSourceId].name + \": status=\" + event.data.status);\n            // bubble the message\n            bcChannels[dataSourceId].postMessage(event.data);\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\nasync function onData(dataSourceId, dataBlock) {\n    self.currentTime = dataBlock.data.timestamp;\n    bcChannels[dataSourceId].postMessage({\n            values: [dataBlock],\n            dataSourceId:dataSourceId,\n            type: EventType.DATA\n        }\n    );\n\n    timeBroadcastChannel.postMessage({\n        timestamp: dataBlock.data.timestamp,\n        dataSourceId: dataSourceId,\n        type: EventType.TIME\n    });\n}\n\n\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL1N0YXR1cy5qcz84ODhhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLmpzP2FkY2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvQ29uc3RhbnRzLmpzP2I5YjEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZXZlbnQvRXZlbnRUeXBlLmpzPzllMzAiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvdGltZXN5bmMvRGF0YVN5bmNocm9uaXplci53b3JrZXIuanM/NWYzMCJdLCJuYW1lcyI6WyJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoZXgycmdiIiwiaGV4IiwiciIsImciLCJiIiwibWF0Y2giLCJtYXAiLCJ4IiwicGFyc2VJbnQiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUcnVlIiwiYXNzZXJ0VHlwZSIsImFzc2VydEJvb2xlYW4iLCJhc3NlcnRTdHJpbmciLCJhc3NlcnROdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZSIsImFzc2VydE9iamVjdCIsImFzc2VydEFycmF5IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRIYXNWYWx1ZSIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaXNFbGVtZW50IiwibyIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc1dlYldvcmtlciIsIldvcmtlciIsInRha2VTY3JlZW5TaG90IiwiZGl2IiwicmVtb3ZlQ3NzIiwiY3NzIiwiZGl2Q3NzIiwiY2xhc3NOYW1lIiwiYWRkQ3NzIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlTGFzdENoYXJJZkV4aXN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsInJvdW5kSGFsZiIsIm51bSIsInJvdW5kIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJhcmdzIiwiY29udGV4dCIsInRpbWVzdGFtcCIsImxhdGVyIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJsYXN0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbE5vdyIsInRocm90dGxlIiwibGVhZGluZyIsInRyYWlsaW5nIiwiY3R4IiwicHJldmlvdXMiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJtZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImtleSIsImtleXMiLCJhc3NpZ24iLCJyZ2JhVG9BcnJheSIsInN0ciIsInN0YXJ0SWR4VmFsdWUiLCJlbmRJZHhWYWx1ZSIsInZhbHVlcyIsInN1YnN0ciIsInNwbGl0IiwiTnVtYmVyIiwiU3RhdHVzIiwiQ09OTkVDVElORyIsIkNPTk5FQ1RFRCIsIkRJU0NPTk5FQ1RFRCIsIkNMT1NFRF9FUlJPUiIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvIiwiY29uc3RydWN0b3IiLCJkYXRhU291cmNlcyIsInJlcGxheVNwZWVkIiwidGltZXJSZXNvbHV0aW9uIiwiZGF0YVNvdXJjZU1hcCIsImJ1ZmZlcmluZ1RpbWUiLCJzdGFydEJ1ZmZlcmluZ1RpbWUiLCJ0c1J1biIsIm1heEJ1ZmZlcmluZ1RpbWUiLCJkcyIsImFkZERhdGFTb3VyY2UiLCJkYXRhU291cmNlSWQiLCJkYXRhQmxvY2siLCJjaGVja1ZlcnNpb24iLCJjb25zb2xlIiwibG9nIiwicGVyZm9ybWFuY2UiLCJ0aW1lb3V0QnVmZmVyaW5nIiwicHJvY2Vzc0RhdGEiLCJsYXRlbmN5IiwiZGF0YUJ1ZmZlciIsInJlc2V0IiwiY2xvc2UiLCJjdXJyZW50RHNJZCIsImN1cnJlbnREcyIsInN0YXR1cyIsInZlcnNpb24iLCJ0c1JlZiIsImNsb2NrVGltZVJlZiIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlTmV4dERhdGEiLCJyZWZDbG9ja1RpbWUiLCJjdXJyZW50RHNUb1NoaWZ0IiwibWF4TGF0ZW5jeSIsIm1pbkxhdGVuY3kiLCJtaW4iLCJ0aW1lT3V0IiwiZENsb2NrIiwiZFRzIiwiZENsb2NrQWRqIiwicmVjIiwic2hpZnQiLCJvbkRhdGEiLCJkYXRhU291cmNlIiwidGltZWRPdXQiLCJkYXRhc291cmNlIiwic2V0U3RhdHVzIiwid2FybiIsImNsZWFySW50ZXJ2YWwiLCJEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyIsIlRJTUVfU1lOQ0hST05JWkVSX1RPUElDIiwiREFUQVNPVVJDRV9EQVRBX1RPUElDIiwiREFUQVNPVVJDRV9USU1FX1RPUElDIiwiRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDIiwiTUFHSUNfRU5EX1BBQ0tFVCIsIkV2ZW50VHlwZSIsIkRBVEEiLCJUSU1FIiwiU1RBVFVTIiwiVElNRV9DSEFOR0VEIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ08sTUFBTUEsUUFBUSxHQUFHQyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBWixJQUFrQixDQUFuQztBQUVQO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxTQUFULENBQW1CQyxDQUFu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RUFBRSxRQUhhO0VBSXJCQyxZQUFZLEVBQUU7QUFKTyxDQUFsQixDOztBQ0FzRDtBQUNQO0FBQ047O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2QkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QixTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiogKiBAbW9kdWxlIFV0aWxzICovXG5cbi8qKiBNYXhpbXVtIHZhbHVlIG9mIGEgbG9uZyAqL1xuZXhwb3J0IGNvbnN0IE1BWF9MT05HID0gTWF0aC5wb3coMiwgNTMpICsgMTtcblxuLyoqXG4gKiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodikge1xuICAgIHJldHVybiB0eXBlb2YgKHYpICE9PSAndW5kZWZpbmVkJyAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBoYXMgYSB2YWx1ZSxcbiB0aGF0IGlzIGl0IGlzIGRlZmluZWQgYW5kIG5vbiBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gaGV4IGNvbG9yIGludG8gUkdCQVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4MnJnYihoZXgpe1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleC5tYXRjaCgvXFx3XFx3L2cpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDE2KSk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIG9mIGEgcGFydGljdWxhciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNUeXBlKHYsIGV4cGVjdGVkVHlwZSkge1xuICAgIGxldCBoYXNWYWwgPSBoYXNWYWx1ZSh2KTtcbiAgICByZXR1cm4gaGFzVmFsICYmIHR5cGVvZiAodikgPT09IGV4cGVjdGVkVHlwZTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFRydWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2KSB8fCAhdikge1xuICAgICAgICB0aHJvdyBsZXROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUodiwgZXhwZWN0ZWRUeXBlLCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKHR5cGVvZiAodikgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBvZiB0eXBlIFwiICsgZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Jvb2xlYW4nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnc3RyaW5nJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ251bWJlcicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZSh2LCBsZXROYW1lKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpO1xuICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIjtcbiAgICB9XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNWYWx1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFoYXNWYWx1ZSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBub3QgYmUgbnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgteHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFtcHMvZW1iZWRzIGEgVVVJRCBpbnRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgVVVJRCBnZW5lcmF0ZWQgZm9yIGl0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFtcFVVSUQob2JqKSB7XG4gICAgb2JqLl9vc2hfaWQgPSBvYmouX29zaF9pZCB8fCByYW5kb21VVUlEKCk7XG4gICAgcmV0dXJuIG9iai5fb3NoX2lkO1xufVxuXG4vL2J1ZmZlciBpcyBhbiBBcnJheUJ1ZmZlciBvYmplY3QsIHRoZSBvZmZzZXQgaWYgc3BlY2lmaWVkIGluIGJ5dGVzLCBhbmQgdGhlIHR5cGUgaXMgYSBzdHJpbmdcbi8vY29ycmVzcG9uZGluZyB0byBhbiBPR0MgZGF0YSB0eXBlLlxuLy9TZWUgaHR0cDovL2RlZi5zZWVncmlkLmNzaXJvLmF1L3Npc3N2b2Mvb2djLWRlZi9yZXNvdXJjZT91cmk9aHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvZGF0YVR5cGUvT0dDLzAvXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyXG4gKiBAcGFyYW0gb2Zmc2V0XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlQnl0ZXMoYnVmZmVyLCBvZmZzZXQsIHR5cGUpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXG4gICAgLy9Ob3RlOiBUaGVyZSBleGlzdCB0eXBlcyBub3QgbGlzdGVkIGluIHRoZSBtYXAgYmVsb3cgdGhhdCBoYXZlIE9HQyBkZWZpbml0aW9ucywgYnV0IG5vIGFwcHJvcHJpYXRlXG4gICAgLy9tZXRob2RzIG9yIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXZhaWxhYmxlIGZvciBwYXJzaW5nIGluIGphdmFzY3JpcHQuIFRoZXkgYXJlIGZsb2F0MTI4LCBmbG9hdDE2LCBzaWduZWRMb25nLFxuICAgIC8vYW5kIHVuc2lnbmVkTG9uZ1xuICAgIGxldCB0eXBlTWFwID0ge1xuICAgICAgICBkb3VibGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDY0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQzMjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICAvL1RPRE86IHN0cmluZy11dGYtODpcbiAgICB9O1xuICAgIHJldHVybiB0eXBlTWFwW3R5cGVdKG9mZnNldCk7XG59XG5cbi8vVGhpcyBmdW5jdGlvbiByZWN1cnNpdmxleSBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRTdHJ1Y3R1cmUgdG8gZmlsbCBpblxuLy92YWx1ZXMgcmVhZCBmcm9tIGRhdGEgd2hpY2ggc2hvdWxkIGJlIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBheWxvYWQgZnJvbSBhIHdlYnNvY2tldFxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXRCeXRlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWREYXRhKHN0cnVjdCwgZGF0YSwgb2Zmc2V0Qnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gb2Zmc2V0Qnl0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyRmllbGRTdHJ1Y3QgPSBzdHJ1Y3QuZmllbGRzW2ldO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC50eXBlKSAmJiBjdXJyRmllbGRTdHJ1Y3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IFBhcnNlQnl0ZXMoZGF0YSwgb2Zmc2V0LCBjdXJyRmllbGRTdHJ1Y3QudHlwZSk7XG4gICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsID0gcmV0LnZhbDtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQuYnl0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkgJiYgY3VyckZpZWxkU3RydWN0LmNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGNvdW50IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgbGV0aWFibGVcbiAgICAgICAgICAgIGlmIChpc05hTihjdXJyRmllbGRTdHJ1Y3QuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gY3VyckZpZWxkU3RydWN0LmNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzdHJ1Y3QuaWQyRmllbGRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC5jb3VudCA9IHN0cnVjdC5maW5kRmllbGRCeU5hbWUoZmllbGROYW1lKS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJGaWVsZFN0cnVjdC5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyRmllbGRTdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3VyckZpZWxkU3RydWN0LmZpZWxkc1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBSZWFkRGF0YShmaWVsZCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbC5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlc3VsdFN0cnVjdHVyZVxuICogQHJldHVybiB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRSZXN1bHRPYmplY3QocmVzdWx0U3RydWN0dXJlKSB7XG4gICAgLy9UT0RPOiBoYW5kbGUgY2FzZXMgZm9yIG5lc3RlZCBhcnJheXMgLyBtYXRyaXggZGF0YSB0eXBlc1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xuICAgIHJldHVybiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Knxib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCbGluaygpIHtcbiAgICByZXR1cm4gKGlzQ2hyb21lIHx8IGlzT3BlcmEpICYmICEhd2luZG93LkNTUztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUludGVyc2VjdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG4gICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiBpc0RlZmluZWQoV29ya2VyKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRpdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVNjcmVlblNob3QoZGl2KSB7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3NzIGNsYXNzIGZyb20gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3NzKGRpdiwgY3NzKSB7XG4gICAgbGV0IGRpdkNzcyA9IGRpdi5jbGFzc05hbWU7XG4gICAgY3NzID0gZGl2Q3NzLnJlcGxhY2UoY3NzLCBcIlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gY3NzO1xufVxuXG5cbi8qKlxuICogQWRkIGEgY3NzIGNsYXNzIHRvIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byBhZGQgdGhlIGNsYXNzIHRvXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDc3MoZGl2LCBjc3MpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGl2LmNsYXNzTmFtZSArIFwiIFwiICsgY3NzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHtzdHJpbmd9IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbnB1dCB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgd2l0aG91dCB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxhc3RDaGFySWZFeGlzdCh2YWx1ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHVuZGVmaW5lZCkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8ICF2YWx1ZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5cbi8qKlxuICogUm91bmQgb2ZmIG51bWJlciB0byBuZWFyZXN0IDAuNVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gcm91bmQgb2ZmXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRIYWxmKG51bSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSoyKS8yO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLFxuICogd2lsbCBub3QgYmUgZXhlY3V0ZWQuIFRoZSBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgd2hlblxuICogaXQgd2lsbCBzdG9wIGJlaW5nIGNhbGxlZCBmb3IgbW9yZSB0aGFuIE4gbWlsbGlzZWNvbmRzLlxuICogSWYgdGhlIGBpbW1lZGlhdGVgIHBhcmFtZXRlciBpcyB0cnVlLCB0aGVuIHRoZSBmdW5jdGlvblxuICogd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgZmlyc3QgY2FsbCBpbnN0ZWFkIG9mIHRoZSBsYXN0LlxuICogUGFyYW1ldGVycyA6XG4gKiAtIGZ1bmM6IHRoZSBmdW5jdGlvbiB0byBgZGVib3VuY2VyYC5cbiAqIC0gd2FpdDogdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgKE4pIHRvIHdhaXQgYmVmb3JlXG4gKiBjYWxsIGZ1bmMoKVxuICogLSBpbW1lZGlhdGUgKG9wdGlvbmFsKTogQ2FsbCBmdW5jKCkgYXQgdGhlIGZpcnN0IGludm9jYXRpb25cbiAqIGluc3RlYWQgb2YgdGhlIGxhc3Qgb25lIChEZWZhdWx0IGZhbHNlKVxuICogLSBjb250ZXh0IChvcHRpb25hbCk6IHRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGNhbGwgZnVuYygpXG4gKiAodGhpcyBieSBkZWZhdWx0KVxuICovXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbGFzdCA9IG5vdyAtIHRpbWVzdGFtcDtcblxuICAgICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgbGVhZGluZywgdHJhaWxpbmcsIGNvbnRleHQpIHtcbiAgICB2YXIgY3R4LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZTtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiAhbGVhZGluZykgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgY3R4ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgdHJhaWxpbmcpIHtcbiAgICAgICAgICAgIC8vIFNpbm9uIG9uIHPigJllbmRvcnQgcGVuZGFudCBsZSB0ZW1wcyByZXN0YW50XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UgKHRhcmdldCwgc291cmNlKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGBzb3VyY2VgIHByb3BlcnRpZXMgYW5kIGlmIGFuIGBPYmplY3RgIHNldCBwcm9wZXJ0eSB0byBtZXJnZSBvZiBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgcHJvcGVydGllc1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgT2JqZWN0ICYmIGtleSBpbiB0YXJnZXQpIE9iamVjdC5hc3NpZ24oc291cmNlW2tleV0sIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpXG4gICAgfVxuXG4gICAgLy8gSm9pbiBgdGFyZ2V0YCBhbmQgbW9kaWZpZWQgYHNvdXJjZWBcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCB8fCB7fSwgc291cmNlKVxuICAgIHJldHVybiB0YXJnZXRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9BcnJheShzdHIpIHtcbiAgICBsZXQgc3RhcnRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcoJykgKyAxO1xuICAgIGxldCBlbmRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgbGV0IHZhbHVlcyA9IHN0ci5zdWJzdHIoc3RhcnRJZHhWYWx1ZSwgZW5kSWR4VmFsdWUtc3RhcnRJZHhWYWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xufVxuIiwiLyoqXG4gKiBFbnVtIGZvciBjb25uZWN0aW9uIHN0YXR1cy5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3tuYW1lOiBzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgU3RhdHVzID0ge1xuICAgIENPTk5FQ1RJTkc6IFwiY29ubmVjdGluZ1wiLFxuICAgIENPTk5FQ1RFRDogIFwiY29ubmVjdGVkXCIsXG4gICAgRElTQ09OTkVDVEVEOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgIENMT1NFRF9FUlJPUjogXCJjbG9zZWQtZXJyb3JcIlxufTtcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vcHJvdG9jb2wvU3RhdHVzLmpzXCI7XG5cbmNsYXNzIERhdGFTeW5jaHJvbml6ZXJBbGdvIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlcywgcmVwbGF5U3BlZWQgPSAxLCB0aW1lclJlc29sdXRpb24gPSA1KSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmJ1ZmZlcmluZ1RpbWUgPSAxMDAwO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgICAgICB0aGlzLnRzUnVuID0gMDtcbiAgICAgICAgdGhpcy5yZXBsYXlTcGVlZCA9IHJlcGxheVNwZWVkO1xuICAgICAgICB0aGlzLnRpbWVyUmVzb2x1dGlvbiA9IHRpbWVyUmVzb2x1dGlvbjtcbiAgICAgICAgbGV0IG1heEJ1ZmZlcmluZ1RpbWUgPSAtMTtcblxuICAgICAgICBmb3IgKGxldCBkcyBvZiBkYXRhU291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhU291cmNlKGRzKTtcbiAgICAgICAgICAgIG1heEJ1ZmZlcmluZ1RpbWUgPSBkcy5idWZmZXJpbmdUaW1lID4gbWF4QnVmZmVyaW5nVGltZSA/IGRzLmJ1ZmZlcmluZ1RpbWUgOiBtYXhCdWZmZXJpbmdUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhCdWZmZXJpbmdUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJpbmdUaW1lID0gbWF4QnVmZmVyaW5nVGltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1c2goZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2spIHtcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrVmVyc2lvbihkcywgZGF0YUJsb2NrKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHN5bmNocm9uaXplciBidWZmZXJpbmcgZGF0YSBmb3IgJHt0aGlzLmJ1ZmZlcmluZ1RpbWV9bXMuLmApO1xuICAgICAgICAgICAgdGhpcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGl0ZXJhdGluZyBvbiBkYXRhQmxvY2sgYWZ0ZXIgYnVmZmVyaW5nVGltZVxuICAgICAgICAgICAgdGhpcy50aW1lb3V0QnVmZmVyaW5nID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NEYXRhKCksIHRoaXMuYnVmZmVyaW5nVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF0ZW5jeSA9IDA7XG4gICAgICAgIGlmICh0aGlzLnRzUnVuID4gMCkge1xuICAgICAgICAgICAgbGF0ZW5jeSA9IHRoaXMudHNSdW4gLSBkYXRhQmxvY2suZGF0YS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZHMubGF0ZW5jeSA9IGxhdGVuY3kgPiBkcy5sYXRlbmN5ID8gbGF0ZW5jeSA6IChkcy5sYXRlbmN5ICsgbGF0ZW5jeSkgLyAyO1xuXG4gICAgICAgIGRzLmRhdGFCdWZmZXIucHVzaChkYXRhQmxvY2spO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygncmVzZXQgc3luY2hyb25pemVyIGFsZ28nKVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGN1cnJlbnREcy5kYXRhQnVmZmVyID0gW107XG4gICAgICAgICAgICBjdXJyZW50RHMuc3RhcnRCdWZmZXJpbmdUaW1lID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50RHMubGF0ZW5jeT0wO1xuICAgICAgICAgICAgY3VycmVudERzLnN0YXR1cz0gU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgICAgIGN1cnJlbnREcy52ZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHNSdW4gPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICAvLyB0aGUgdGltZW91dCBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICAgICAgaWYoIWlzRGVmaW5lZCh0aGlzLnRpbWVvdXRCdWZmZXJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRzUmVmID0gLTE7XG4gICAgICAgIGxldCBjbG9ja1RpbWVSZWYgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICAvLyBnZXQgcmVmZXJlbmNlIHN0YXJ0IHRpbWVzdGFtcFxuICAgICAgICAvLyB0aGUgcmVmZXJlbmNlIHN0YXJ0IHRpbWVzdGFtcCBzaG91bGQgdGhlIG9sZGVzdCBvbmVcbiAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0c1JlZiA9ICh0c1JlZiA9PT0gLTEgfHwgY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgPCB0c1JlZikgPyBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCA6XG4gICAgICAgICAgICAgICAgICAgIHRzUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEpIHJldHVybiB0aGUgb2xkZXN0IGRhdGEgaWYgYW55XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wdXRlTmV4dERhdGEodHNSZWYsIGNsb2NrVGltZVJlZikpIDtcblxuICAgICAgICB9LCB0aGlzLnRpbWVyUmVzb2x1dGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbmV4dCBkYXRhIGlmIGFueS4gV2UgcmV0dXJuIG9ubHkgMSB2YWx1ZSBmb3IgdGhpcyBpdGVyYXRpb24uIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXMgdG8gcmV0dXJuLFxuICAgICAqIHdlIHJldHVybiBvbmx5IHRoZSBvbGRlc3Qgb25lLlxuICAgICAqIEBwYXJhbSB0c1JlZiAtIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGZpcnN0IGRhdGFcbiAgICAgKiBAcGFyYW0gcmVmQ2xvY2tUaW1lIC0gdGhlIGFic29sdXRlIGRpZmYgdGltZSByZWFsbHkgc3BlbnRcbiAgICAgKi9cbiAgICBjb21wdXRlTmV4dERhdGEodHNSZWYsIHJlZkNsb2NrVGltZSkge1xuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBsZXQgY3VycmVudERzVG9TaGlmdCA9IG51bGw7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBtYXggbGF0ZW5jeVxuICAgICAgICBsZXQgbWF4TGF0ZW5jeSA9IDA7XG4gICAgICAgIGxldCBtaW5MYXRlbmN5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5sYXRlbmN5ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRlbmN5ID0gTWF0aC5taW4oY3VycmVudERzLmxhdGVuY3ksIGN1cnJlbnREcy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICBtYXhMYXRlbmN5ID0gKGxhdGVuY3kgPiBtYXhMYXRlbmN5KSA/IGxhdGVuY3kgOiBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIG1pbkxhdGVuY3kgPSAoY3VycmVudERzLmxhdGVuY3kgPCBtaW5MYXRlbmN5KSA/IGN1cnJlbnREcy5sYXRlbmN5IDogbWluTGF0ZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhMYXRlbmN5ICo9IHRoaXMucmVwbGF5U3BlZWQ7XG4gICAgICAgIG1pbkxhdGVuY3kgKj0gdGhpcy5yZXBsYXlTcGVlZDtcblxuICAgICAgICBjb25zdCBkQ2xvY2sgPSAocGVyZm9ybWFuY2Uubm93KCkgLSByZWZDbG9ja1RpbWUpICogdGhpcy5yZXBsYXlTcGVlZDtcbiAgICAgICAgdGhpcy50c1J1biA9IHRzUmVmICsgZENsb2NrO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbmV4dCBkYXRhIHRvIHJldHVyblxuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRUcyA9IChjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCAtIHRzUmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkQ2xvY2tBZGogPSBkQ2xvY2sgLSBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSBhbiBpbnRlcm1lZGlhdGUgb2JqZWN0IHRvIHN0b3JlIHRoZSBkYXRhIHRvIHNoaWZ0IGJlY2F1c2Ugd2Ugd2FudCB0byByZXR1cm4gdGhlIG9sZGVzdCBvbmVcbiAgICAgICAgICAgICAgICAvLyBvbmx5XG4gICAgICAgICAgICAgICAgaWYgKGRUcyA8PSBkQ2xvY2tBZGopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gb3RoZXIgb25lIHRvIGNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREc1RvU2hpZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWtlIHRoZSBvbGRlc3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IChjdXJyZW50RHNUb1NoaWZ0LmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgPCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgOiBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHBvcCB0aGUgZGF0YSBmcm9tIERTIHF1ZXVlXG4gICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVjID0gY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBsYXRlbmN5IGZsYWcgdG8gZGF0YSByZWNvcmQgYmVmb3JlIHdlIGRpc3BhdGNoIGl0XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHJlbGF0aXZlIGxhdGVuY3kgaW4gbWlsbGlzIGNvbXBhcmVkIHRvIHRoZSBEUyB3aXRoIHRoZSBsb3dlc3QgbGF0ZW5jeVxuICAgICAgICAgICAgLy8gc28gaXQgaXMgYWNjdXJhdGUgZXZlbiBpZiBsb2NhbCBkZXZpY2UgdGltZSBpcyBub3Qgc2V0IHByb3Blcmx5XG4gICAgICAgICAgICByZWNbJ0BsYXRlbmN5J10gPSBjdXJyZW50RHMubGF0ZW5jeSAtIG1pbkxhdGVuY3k7XG5cbiAgICAgICAgICAgIHRoaXMub25EYXRhKGN1cnJlbnREc1RvU2hpZnQuaWQsIHJlYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGFTb3VyY2UgdG8gYmUgc3luY2hyb25pemVkXG4gICAgICogQHBhcmFtIHtEYXRhU291cmNlfSBkYXRhU291cmNlIC0gdGhlIGRhdGFTb3VyY2UgdG8gc3luY2hyb25pemVcbiAgICAgKi9cbiAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2UuaWRdID0ge1xuICAgICAgICAgICAgYnVmZmVyaW5nVGltZTogZGF0YVNvdXJjZS5idWZmZXJpbmdUaW1lLFxuICAgICAgICAgICAgdGltZU91dDogZGF0YVNvdXJjZS50aW1lT3V0IHx8IDAsXG4gICAgICAgICAgICBkYXRhQnVmZmVyOiBbXSxcbiAgICAgICAgICAgIHN0YXJ0QnVmZmVyaW5nVGltZTogLTEsXG4gICAgICAgICAgICBpZDogZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFTb3VyY2UubmFtZSB8fCBkYXRhU291cmNlLmlkLFxuICAgICAgICAgICAgbGF0ZW5jeTogMCxcbiAgICAgICAgICAgIHN0YXR1czogU3RhdHVzLkRJU0NPTk5FQ1RFRCwgLy9NRUFOSU5HIEVuYWJsZWQsIDAgPSBEaXNhYmxlZFxuICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2hlY2tWZXJzaW9uKGRhdGFzb3VyY2UsIGRhdGFCbG9jaykge1xuICAgICAgICBpZighaXNEZWZpbmVkKGRhdGFzb3VyY2UudmVyc2lvbikgJiYgZGF0YXNvdXJjZS5zdGF0dXMgIT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YXNvdXJjZS5zdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQgJiYgZGF0YXNvdXJjZS52ZXJzaW9uICE9PSBkYXRhQmxvY2sudmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25EYXRhKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2NrKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkYXRhU291cmNlIHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXMgLSB0aGUgbmV3IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhU291cmNlSWQgLSB0aGUgY29ycmVzcG9uZGluZyBkYXRhU291cmNlIGlkXG4gICAgICovXG4gICAgc2V0U3RhdHVzKGRhdGFTb3VyY2VJZCwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChkYXRhU291cmNlSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oc3RhdHVzKycgRGF0YVNvdXJjZSAnICsgZGF0YVNvdXJjZUlkICsgJyBmcm9tIHRoZSBzeW5jaHJvbml6ZXIgJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmludGVydmFsKSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGlzRGVmaW5lZCh0aGlzLnRpbWVvdXRCdWZmZXJpbmcpKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0QnVmZmVyaW5nKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dEJ1ZmZlcmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJEYXRhIHN5bmNocm9uaXplciB0ZXJtaW5hdGVkIHN1Y2Nlc3NmdWxseVwiKTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN5bmNocm9uaXplckFsZ287XG4iLCJleHBvcnQgY29uc3QgREFUQV9TWU5DSFJPTklaRVJfVE9QSUMgPSAnZGF0YS1zeW5jaHJvbml6ZXItJztcbmV4cG9ydCBjb25zdCBUSU1FX1NZTkNIUk9OSVpFUl9UT1BJQyA9ICdkYXRhLXN5bmNocm9uaXplci10aW1lLSc7XG5cbmV4cG9ydCBjb25zdCBEQVRBU09VUkNFX0RBVEFfVE9QSUMgPSAnZGF0YXNvdXJjZS1kYXRhLSc7XG5leHBvcnQgY29uc3QgREFUQVNPVVJDRV9USU1FX1RPUElDID0gJ2RhdGFzb3VyY2UtdGltZS0nO1xuXG5leHBvcnQgY29uc3QgRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDID0gJ2ZmbXBlZy1kZWNvZGUtJztcblxuZXhwb3J0IGNvbnN0IE1BR0lDX0VORF9QQUNLRVQgPSAnbWFnaWMtcGFja2V0JztcbiIsImV4cG9ydCBjb25zdCBFdmVudFR5cGUgPSB7XG4gICAgREFUQTogJ2RhdGEnLFxuICAgIFRJTUU6ICd0aW1lJyxcbiAgICBTVEFUVVM6ICdzdGF0dXMnLFxuICAgIFRJTUVfQ0hBTkdFRDogJ3RpbWUtY2hhbmdlZCdcbn07XG4iLCJpbXBvcnQgRGF0YVN5bmNocm9uaXplckFsZ28gZnJvbSBcIi4vRGF0YVN5bmNocm9uaXplckFsZ28uanNcIjtcbmltcG9ydCB7REFUQVNPVVJDRV9EQVRBX1RPUElDfSBmcm9tIFwiLi4vQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge0V2ZW50VHlwZX0gZnJvbSBcIi4uL2V2ZW50L0V2ZW50VHlwZS5qc1wiO1xuXG5jb25zdCBiY0NoYW5uZWxzID0ge307XG5sZXQgZGF0YVN5bmNocm9uaXplckFsZ287XG5cbmxldCBpbml0ID0gZmFsc2U7XG5sZXQgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwgPSBudWxsO1xuc2VsZi5jdXJyZW50VGltZSA9IC0xO1xuXG5jb25zdCBkYXRhU291cmNlcyA9IHt9O1xubGV0IHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbmxldCB0b3BpY1RpbWU7XG5sZXQgdG9waWNEYXRhO1xuXG5zZWxmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvID0gbmV3IERhdGFTeW5jaHJvbml6ZXJBbGdvKFxuICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhU291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50LmRhdGEucmVwbGF5U3BlZWQsXG4gICAgICAgICAgICBldmVudC5kYXRhLnRpbWVyUmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkRhdGEgPSBvbkRhdGE7XG4gICAgICAgIGluaXQgPSB0cnVlO1xuICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICAgICAgdG9waWNEYXRhID0gZXZlbnQuZGF0YS5kYXRhVG9waWM7XG4gICAgICAgIHRvcGljVGltZSA9IGV2ZW50LmRhdGEudGltZVRvcGljO1xuICAgICAgICBpbml0QnJvYWRjYXN0Q2hhbm5lbCh0b3BpY0RhdGEsIHRvcGljVGltZSk7XG4gICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2FkZCcgJiYgZXZlbnQuZGF0YS5kYXRhU291cmNlcykge1xuICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnY3VycmVudC10aW1lJykge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ2N1cnJlbnQtdGltZScsXG4gICAgICAgICAgICBkYXRhOiBzZWxmLmN1cnJlbnRUaW1lXG4gICAgICAgIH07XG4gICAgfSAgZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZXNldCcpIHtcbiAgICAgICAgaWYoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlRJTUVfQ0hBTkdFRFxuICAgICAgICB9KTtcbiAgICB9ICBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ3JlcGxheS1zcGVlZCcpIHtcbiAgICAgICAgaWYoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlcGxheVNwZWVkID0gZXZlbnQuZGF0YS5yZXBsYXlTcGVlZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdkYXRhJykge1xuICAgICAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucHVzaChldmVudC5kYXRhLmRhdGFTb3VyY2VJZCwgZXZlbnQuZGF0YS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNraXAgcmVzcG9uc2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgbWVzc2FnZTogZXZlbnQuZGF0YS5tZXNzYWdlLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBtZXNzYWdlSWQ6IGV2ZW50LmRhdGEubWVzc2FnZUlkXG4gICAgfSlcblxufVxuXG5mdW5jdGlvbiBpbml0QnJvYWRjYXN0Q2hhbm5lbChkYXRhVG9waWMsIHRpbWVUb3BpYykge1xuICAgIGNvbnNvbGUubG9nKCdsaXN0ZW4gb24gdG9waWMgJyxkYXRhVG9waWMpXG5cbiAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGRhdGFUb3BpYyk7XG4gICAgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLkRBVEEpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpIDwgZXZlbnQuZGF0YS52YWx1ZXMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmVudC5kYXRhLnZhbHVlc1tpXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLlNUQVRVUykge1xuICAgICAgICAgICAgY29uc3QgZGF0YVNvdXJjZUlkID0gZXZlbnQuZGF0YS5kYXRhU291cmNlSWQ7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5zZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBldmVudC5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhU291cmNlc1tkYXRhU291cmNlSWRdLm5hbWUgKyBcIjogc3RhdHVzPVwiICsgZXZlbnQuZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgLy8gYnViYmxlIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRpbWVUb3BpYyk7XG5cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRhdGFTb3VyY2VzXG4gKi9cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2VzKGRhdGFTb3VyY2VzKSB7XG4gICAgZm9yKGxldCBkYXRhU291cmNlIG9mIGRhdGFTb3VyY2VzKSB7XG4gICAgICAgIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICBkYXRhU3luY2hyb25pemVyQWxnby5hZGREYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgIC8vIGNyZWF0ZSBhIEJDIHRvIHB1c2ggYmFjayB0aGUgc3luY2hyb25pemVkIGRhdGEgaW50byB0aGUgREFUQSBTdHJlYW0uXG4gICAgYmNDaGFubmVsc1tkYXRhU291cmNlLmlkXSA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKERBVEFTT1VSQ0VfREFUQV9UT1BJQyArIGRhdGFTb3VyY2UuaWQpO1xuXG4gICAgaWYoIShkYXRhU291cmNlLmlkIGluIGRhdGFTb3VyY2VzKSkge1xuICAgICAgICBkYXRhU291cmNlc1tkYXRhU291cmNlLmlkXSA9IGRhdGFTb3VyY2U7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBvbkRhdGEoZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2spIHtcbiAgICBzZWxmLmN1cnJlbnRUaW1lID0gZGF0YUJsb2NrLmRhdGEudGltZXN0YW1wO1xuICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZUlkXS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB2YWx1ZXM6IFtkYXRhQmxvY2tdLFxuICAgICAgICAgICAgZGF0YVNvdXJjZUlkOmRhdGFTb3VyY2VJZCxcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5EQVRBXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0aW1lc3RhbXA6IGRhdGFCbG9jay5kYXRhLnRpbWVzdGFtcCxcbiAgICAgICAgZGF0YVNvdXJjZUlkOiBkYXRhU291cmNlSWQsXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5USU1FXG4gICAgfSk7XG59XG5cblxuc2VsZi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28uY2xvc2UoKTtcbiAgICBjb25zb2xlLmxvZyhcIkRhdGEgU3luY2hyb25pemVyIGhhcyBiZWVuIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);