!function(Q){var I={};function B(F){if(I[F])return I[F].exports;var U=I[F]={i:F,l:!1,exports:{}};return Q[F].call(U.exports,U,U.exports,B),U.l=!0,U.exports}B.m=Q,B.c=I,B.d=function(Q,I,F){B.o(Q,I)||Object.defineProperty(Q,I,{enumerable:!0,get:F})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,I){if(1&I&&(Q=B(Q)),8&I)return Q;if(4&I&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(B.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&I&&"string"!=typeof Q)for(var U in Q)B.d(F,U,function(I){return Q[I]}.bind(null,U));return F},B.n=function(Q){var I=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(I,"a",I),I},B.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},B.p="",B(B.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\nconst MAGIC_END_PACKET = 'magic-packet';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  LAST_TIME: 'last-time',\n  MASTER_TIME: 'master-time',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on sâ€™endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/Mode.js\n/**\n * Enum for datasource mode.\n * @readonly\n * @enum {{name: string}}\n */\nconst Mode = {\n  REPLAY: \"replay\",\n  BATCH: \"batch\",\n  REAL_TIME: \"realTime\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/connector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  FETCH_STARTED: 'fetch-start',\n  FETCH_ENDED: 'fetch-end',\n  CLOSED: \"closed\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, timerResolution = 5) {\n    this.dataSourceMap = {};\n    this.tsRun = undefined;\n    this.timerResolution = timerResolution;\n    this.interval = null;\n    this.datasources = [];\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n    }\n  }\n\n  push(dataSourceId, dataBlocks) {}\n\n  getCurrentTimestamp() {\n    return this.tsRun;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].data.timestamp < tsRef ? currentDs.dataBuffer[0].data.timestamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.timerResolution);\n    console.warn(`Started Replay Algorithm with tsRef=${new Date(tsRef).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    throw Error('Should be overridden');\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    throw Error('Should be overridden');\n  }\n\n  checkVersion(datasource, dataBlock) {\n    throw Error('Should be overridden');\n  }\n\n  onData(dataSourceId, dataBlock) {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    throw Error('Should be overridden');\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      this.interval = undefined;\n    }\n\n    console.log(\"Data synchronizer terminated successfully\");\n  }\n\n  onStart() {}\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.replay.js\n\n\n\n\nclass DataSynchronizerAlgo_replay_DataSynchronizerAlgoReplay extends timesync_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, startTimestamp, endTimestamp, timerResolution = 5) {\n    super(dataSources, replaySpeed, timerResolution);\n    this.replaySpeed = replaySpeed;\n    this.startTimestamp = startTimestamp;\n    this.endTimestamp = endTimestamp;\n  }\n\n  push(dataSourceId, dataBlocks) {\n    if (dataBlocks.length === 0) {\n      return;\n    }\n\n    const ds = this.dataSourceMap[dataSourceId];\n    const lastData = dataBlocks[dataBlocks.length - 1];\n\n    if (!this.checkVersion(ds, lastData)) {\n      console.warn(`[DataSynchronizer] incompatible version ${ds.version} ~ ${lastData.version}, skipping data`);\n      return;\n    }\n\n    ds.dataBuffer.push(...dataBlocks);\n  }\n\n  processData() {\n    let clockTimeRef = performance.now();\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(this.startTimestamp, clockTimeRef)) {}\n\n      this.checkEnd();\n    }, this.timerResolution);\n    console.warn(`Started Replay Algorithm with tsRef=${new Date(this.startTimestamp).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null;\n    const dClock = (performance.now() - refClockTime) * this.replaySpeed;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClock) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      this.onData(currentDsToShift.id, currentDsToShift.dataBuffer.shift());\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      dataBuffer: [],\n      id: dataSource.id,\n      name: dataSource.name || dataSource.id,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      version: undefined\n    };\n    this.datasources.push(dataSource);\n  }\n\n  checkVersion(datasource, dataBlock) {\n    if (!isDefined(datasource.version)) {\n      return true;\n    } else if (datasource.version !== dataBlock.version) {\n      return false;\n    }\n  }\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n\n    this.checkStart();\n  }\n\n  checkStart() {\n    if (!isDefined(this.interval)) {\n      let nbDatasourcesFetchedOk = 0;\n      let totalDataSources = Object.keys(this.dataSourceMap).length;\n\n      for (let dataSourceID in this.dataSourceMap) {\n        if (this.dataSourceMap[dataSourceID].status === Status.FETCH_STARTED) nbDatasourcesFetchedOk++;\n      }\n\n      console.warn(`[Synchronizer] Fetched ${nbDatasourcesFetchedOk}/${totalDataSources} datasources`);\n\n      if (nbDatasourcesFetchedOk === totalDataSources) {\n        console.warn('Starting Replay Algorithm...');\n        this.processData();\n        this.onStart();\n      }\n    }\n  }\n\n  checkEnd() {\n    if (this.getCurrentTimestamp() >= this.endTimestamp) {\n      this.onEnd();\n      this.reset();\n    }\n  }\n\n  reset() {\n    this.tsRun = undefined;\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      this.resetDataSource(currentDsId);\n    }\n  }\n\n  resetDataSource(datasourceId) {\n    const currentDs = this.dataSourceMap[datasourceId];\n    currentDs.dataBuffer = [];\n    currentDs.status = Status.DISCONNECTED;\n    currentDs.version = undefined;\n  }\n\n  onEnd() {}\n\n  onStart() {}\n\n}\n\n/* harmony default export */ var DataSynchronizerAlgo_replay = (DataSynchronizerAlgo_replay_DataSynchronizerAlgoReplay);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.realtime.js\n\n\n\n\nclass DataSynchronizerAlgo_realtime_DataSynchronizerAlgoRealtime extends timesync_DataSynchronizerAlgo {\n  push(dataSourceId, dataBlocks) {\n    if (dataBlocks.length === 0) {\n      return;\n    }\n\n    const ds = this.dataSourceMap[dataSourceId];\n    const lastData = dataBlocks[dataBlocks.length - 1];\n\n    if (!this.checkVersion(ds, lastData)) {\n      return;\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - lastData.data.timestamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(...dataBlocks);\n\n    if (!isDefined(this.interval)) {\n      this.processData();\n    }\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    const dClock = performance.now() - refClockTime;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      version: undefined\n    };\n    this.datasources.push(dataSource);\n  }\n\n  checkVersion(datasource, dataBlock) {\n    if (datasource.status !== Status.DISCONNECTED) {\n      return true;\n    } else if (datasource.status === Status.DISCONNECTED && datasource.version !== dataBlock.version) {\n      return false;\n    }\n  }\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  reset() {\n    this.tsRun = undefined;\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      this.resetDataSource(currentDsId);\n    }\n  }\n\n  resetDataSource(datasourceId) {\n    const currentDs = this.dataSourceMap[datasourceId];\n    currentDs.dataBuffer = [];\n    currentDs.startBufferingTime = -1;\n    currentDs.latency = 0;\n    currentDs.status = Status.DISCONNECTED;\n    currentDs.version = undefined;\n  }\n\n}\n\n/* harmony default export */ var DataSynchronizerAlgo_realtime = (DataSynchronizerAlgo_realtime_DataSynchronizerAlgoRealtime);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizer.worker.js\n\n\n\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nlet DataSynchronizer_worker_lastData = undefined;\nconst dataSources = {};\nlet timeBroadcastChannel = null;\nlet topicTime;\nlet topicData;\nlet replaySpeed;\nlet masterTimeInterval = undefined;\nlet cTime;\nlet cId;\nlet lastTime = -1;\nlet version = -1;\nlet promise;\nlet DataSynchronizer_worker_masterTimeRefreshRate;\nlet startTimestamp;\nlet endTimestamp;\n\nself.onmessage = async (event) => {\n    if(isDefined(promise)) {\n        await promise;\n    }\n    promise = handleMessage(event);\n}\n\nasync function handleMessage(event) {\n    return new Promise((resolve, reject) => {\n        try {\n            let sendResponse = true;\n            let data = undefined;\n            if (event.data.message === 'init') {\n                replaySpeed = event.data.replaySpeed;\n                startTimestamp = new Date(event.data.startTime).getTime();\n                endTimestamp = new Date(event.data.endTime).getTime();\n\n                if (event.data.mode === Mode.REPLAY) {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_replay(\n                        event.data.dataSources,\n                        event.data.replaySpeed,\n                        startTimestamp,\n                        endTimestamp,\n                        event.data.timerResolution\n                    );\n                    dataSynchronizerAlgo.onEnd = onEnd;\n                    dataSynchronizerAlgo.onStart = onStart;\n                } else {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_realtime(\n                        event.data.dataSources,\n                        event.data.replaySpeed,\n                        event.data.timerResolution\n                    );\n                }\n                dataSynchronizerAlgo.onData = onData;\n                init = true;\n                addDataSources(event.data.dataSources);\n                topicData = event.data.topics.data;\n                topicTime = event.data.topics.time;\n                initBroadcastChannel(topicData, topicTime);\n                DataSynchronizer_worker_masterTimeRefreshRate = event.data.masterTimeRefreshRate;\n                startMasterTimeInterval(DataSynchronizer_worker_masterTimeRefreshRate);\n            } else if (event.data.message === 'add' && event.data.dataSources) {\n                addDataSources(event.data.dataSources);\n            } else if (event.data.message === 'current-time') {\n                data = {\n                    message: 'current-time',\n                    data: dataSynchronizerAlgo.getCurrentTimestamp()\n                };\n            } else if (event.data.message === 'reset') {\n                DataSynchronizer_worker_reset();\n            } else if (event.data.message === 'replay-speed') {\n                if (dataSynchronizerAlgo !== null) {\n                    DataSynchronizer_worker_reset();\n                    dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;\n                }\n            } else if (event.data.message === 'update-properties') {\n                DataSynchronizer_worker_reset();\n                let datasources = [];\n                if (dataSynchronizerAlgo !== null) {\n                    datasources = dataSynchronizerAlgo.datasources;\n                }\n\n                startTimestamp = new Date(event.data.startTime).getTime();\n                endTimestamp = new Date(event.data.endTime).getTime();\n\n                if (event.data.mode === Mode.REPLAY) {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_replay(\n                        datasources,\n                        event.data.replaySpeed,\n                        startTimestamp,\n                        endTimestamp,\n                        dataSynchronizerAlgo.timerResolution\n                    );\n                    dataSynchronizerAlgo.onEnd = onEnd;\n                    dataSynchronizerAlgo.onStart = onStart;\n                } else {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_realtime(\n                        datasources,\n                        dataSynchronizerAlgo.timerResolution\n                    );\n                }\n\n                dataSynchronizerAlgo.onData = onData;\n            } else if (event.data.message === 'data') {\n                checkMasterTime();\n                if (dataSynchronizerAlgo !== null) {\n                    dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);\n                }\n            } else {\n                // skip response\n                sendResponse = false;\n            }\n            if (sendResponse) {\n                self.postMessage({\n                    message: event.data.message,\n                    data: data,\n                    messageId: event.data.messageId\n                });\n            }\n            resolve();\n        }catch (ex) {\n            reject(ex);\n        }\n    });\n}\nfunction DataSynchronizer_worker_reset() {\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    version = -1;\n    if(dataSynchronizerAlgo !== null) {\n        dataSynchronizerAlgo.reset();\n    }\n    timeBroadcastChannel.postMessage({\n        type: EventType.TIME_CHANGED\n    });\n}\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    console.log('listen on topic ',dataTopic)\n\n    dataSourceBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSourceBroadCastChannel.onmessage = async (event) => {\n        checkMasterTime();\n        if(event.data.type === EventType.DATA) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId,event.data.values);\n        } else if(event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            console.log(dataSources[dataSourceId].name + \": status=\" + event.data.status);\n            // bubble the message\n            bcChannels[dataSourceId].postMessage(event.data);\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\nfunction checkMasterTime() {\n    if(!isDefined(masterTimeInterval)) {\n        startMasterTimeInterval(DataSynchronizer_worker_masterTimeRefreshRate);\n    }\n}\nasync function onEnd() {\n    const masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    // end at this time\n    timeBroadcastChannel.postMessage({\n        timestamp: masterTime,\n        type: EventType.MASTER_TIME\n    });\n}\n\nasync function onStart() {\n    // checkMasterTime();\n}\n\nasync function onData(dataSourceId, dataBlock) {\n    if((version === -1 && (isDefined(DataSynchronizer_worker_lastData) ) && dataBlock.version === DataSynchronizer_worker_lastData.dataBlock.version)){\n        return;\n    }\n\n    version = dataBlock.version;\n    DataSynchronizer_worker_lastData = {\n        dataSourceId: dataSourceId,\n        dataBlock: dataBlock\n    };\n    bcChannels[dataSourceId].postMessage({\n            values: [dataBlock],\n            dataSourceId:dataSourceId,\n            type: EventType.DATA\n        }\n    );\n}\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n\nlet DataSynchronizer_worker_masterTime;\nfunction startMasterTimeInterval(masterTimeRefreshRate) {\n    if (!isDefined(masterTimeInterval)) {\n        masterTimeInterval = setInterval(() => {\n            DataSynchronizer_worker_masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n            if (isDefined(DataSynchronizer_worker_masterTime)) {\n                timeBroadcastChannel.postMessage({\n                    timestamp: DataSynchronizer_worker_masterTime,\n                    type: EventType.MASTER_TIME\n                });\n            }\n\n            // check version\n            if (!isDefined(DataSynchronizer_worker_lastData) || version !== DataSynchronizer_worker_lastData.dataBlock.version || version === -1) {\n                return;\n            }\n            cTime = DataSynchronizer_worker_lastData.dataBlock.data.timestamp;\n            cId = DataSynchronizer_worker_lastData.dataSourceId;\n\n            if ((cTime !== -1 && lastTime === -1) || (lastTime !== -1 && cTime !== lastTime)) { // does not send the same data twice\n                timeBroadcastChannel.postMessage({\n                    timestamp: cTime,\n                    dataSourceId: cId,\n                    type: EventType.LAST_TIME\n                });\n            }\n            lastTime = cTime;\n        }, masterTimeRefreshRate);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9Db25zdGFudHMuanM/YjliMSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9ldmVudC9FdmVudFR5cGUuanM/OWUzMCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2RhdGFzb3VyY2UvTW9kZS5qcz80ZTI1Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2Nvbm5lY3Rvci9TdGF0dXMuanM/YTU4NyIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS90aW1lc3luYy9EYXRhU3luY2hyb25pemVyQWxnby5qcz9hZGNhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlcGxheS5qcz85MjExIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlYWx0aW1lLmpzP2ZlODkiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvdGltZXN5bmMvRGF0YVN5bmNocm9uaXplci53b3JrZXIuanM/NWYzMCJdLCJuYW1lcyI6WyJEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyIsIlRJTUVfU1lOQ0hST05JWkVSX1RPUElDIiwiREFUQVNPVVJDRV9EQVRBX1RPUElDIiwiREFUQVNPVVJDRV9USU1FX1RPUElDIiwiRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDIiwiTUFHSUNfRU5EX1BBQ0tFVCIsIkV2ZW50VHlwZSIsIkRBVEEiLCJMQVNUX1RJTUUiLCJNQVNURVJfVElNRSIsIlNUQVRVUyIsIlRJTUVfQ0hBTkdFRCIsIk1BWF9MT05HIiwiTWF0aCIsInBvdyIsImlzRGVmaW5lZCIsInYiLCJoYXNWYWx1ZSIsImhleDJyZ2IiLCJoZXgiLCJyIiwiZyIsImIiLCJtYXRjaCIsIm1hcCIsIngiLCJwYXJzZUludCIsImhhc1R5cGUiLCJleHBlY3RlZFR5cGUiLCJoYXNWYWwiLCJpc09iamVjdCIsImxldE5hbWUiLCJpc0FycmF5IiwiQXJyYXkiLCJpc0Z1bmN0aW9uIiwiYXNzZXJ0RGVmaW5lZCIsImFzc2VydFRydWUiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdGFtcFVVSUQiLCJvYmoiLCJfb3NoX2lkIiwiUGFyc2VCeXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsInR5cGUiLCJ2aWV3IiwiRGF0YVZpZXciLCJ0eXBlTWFwIiwiZG91YmxlIiwidmFsIiwiZ2V0RmxvYXQ2NCIsImJ5dGVzIiwiZmxvYXQ2NCIsImZsb2F0MzIiLCJnZXRGbG9hdDMyIiwic2lnbmVkQnl0ZSIsImdldEludDgiLCJzaWduZWRJbnQiLCJnZXRJbnQzMiIsInNpZ25lZFNob3J0IiwiZ2V0SW50MTYiLCJ1bnNpZ25lZEJ5dGUiLCJnZXRVaW50OCIsInVuc2lnbmVkSW50IiwiZ2V0VWludDMyIiwidW5zaWduZWRTaG9ydCIsImdldFVpbnQxNiIsIlJlYWREYXRhIiwic3RydWN0IiwiZGF0YSIsIm9mZnNldEJ5dGVzIiwiaSIsImZpZWxkcyIsImxlbmd0aCIsImN1cnJGaWVsZFN0cnVjdCIsInJldCIsImNvdW50IiwiaXNOYU4iLCJpZCIsImZpZWxkTmFtZSIsImlkMkZpZWxkTWFwIiwiZmluZEZpZWxkQnlOYW1lIiwiaiIsImZpZWxkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHVzaCIsIkdldFJlc3VsdE9iamVjdCIsInJlc3VsdFN0cnVjdHVyZSIsInJlc3VsdCIsIm5hbWUiLCJpdGVtIiwiayIsImlzT3BlcmEiLCJ3aW5kb3ciLCJvcHIiLCJhZGRvbnMiLCJvcGVyYSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkhUTUxFbGVtZW50IiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJ3ZWJzdG9yZSIsImlzQmxpbmsiLCJDU1MiLCJpc0FycmF5SW50ZXJzZWN0IiwiYSIsImZpbHRlciIsImVsZW1lbnQiLCJpc0VsZW1lbnQiLCJvIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzV2ViV29ya2VyIiwiV29ya2VyIiwidGFrZVNjcmVlblNob3QiLCJkaXYiLCJyZW1vdmVDc3MiLCJjc3MiLCJkaXZDc3MiLCJjbGFzc05hbWUiLCJhZGRDc3MiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVMYXN0Q2hhcklmRXhpc3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwicm91bmRIYWxmIiwibnVtIiwicm91bmQiLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwiaW1tZWRpYXRlIiwidGltZW91dCIsImFyZ3MiLCJjb250ZXh0IiwidGltZXN0YW1wIiwibGF0ZXIiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImxhc3QiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjYWxsTm93IiwidGhyb3R0bGUiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJjdHgiLCJwcmV2aW91cyIsInJlbWFpbmluZyIsImNsZWFyVGltZW91dCIsIm1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwia2V5Iiwia2V5cyIsImFzc2lnbiIsInJnYmFUb0FycmF5Iiwic3RyIiwic3RhcnRJZHhWYWx1ZSIsImVuZElkeFZhbHVlIiwidmFsdWVzIiwic3Vic3RyIiwic3BsaXQiLCJOdW1iZXIiLCJNb2RlIiwiUkVQTEFZIiwiQkFUQ0giLCJSRUFMX1RJTUUiLCJTdGF0dXMiLCJDT05ORUNUSU5HIiwiQ09OTkVDVEVEIiwiRElTQ09OTkVDVEVEIiwiRkVUQ0hfU1RBUlRFRCIsIkZFVENIX0VOREVEIiwiQ0xPU0VEIiwiQ0xPU0VEX0VSUk9SIiwiRGF0YVN5bmNocm9uaXplckFsZ28iLCJjb25zdHJ1Y3RvciIsImRhdGFTb3VyY2VzIiwidGltZXJSZXNvbHV0aW9uIiwiZGF0YVNvdXJjZU1hcCIsInRzUnVuIiwiaW50ZXJ2YWwiLCJkYXRhc291cmNlcyIsImRzIiwiYWRkRGF0YVNvdXJjZSIsImRhdGFTb3VyY2VJZCIsImRhdGFCbG9ja3MiLCJnZXRDdXJyZW50VGltZXN0YW1wIiwicHJvY2Vzc0RhdGEiLCJ0c1JlZiIsImNsb2NrVGltZVJlZiIsInBlcmZvcm1hbmNlIiwiY3VycmVudERzIiwiY3VycmVudERzSWQiLCJkYXRhQnVmZmVyIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlTmV4dERhdGEiLCJjb25zb2xlIiwid2FybiIsInRvSVNPU3RyaW5nIiwicmVmQ2xvY2tUaW1lIiwiRXJyb3IiLCJkYXRhU291cmNlIiwiY2hlY2tWZXJzaW9uIiwiZGF0YXNvdXJjZSIsImRhdGFCbG9jayIsIm9uRGF0YSIsInNldFN0YXR1cyIsInN0YXR1cyIsImNsb3NlIiwiY2xlYXJJbnRlcnZhbCIsImxvZyIsIm9uU3RhcnQiLCJEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheSIsInJlcGxheVNwZWVkIiwic3RhcnRUaW1lc3RhbXAiLCJlbmRUaW1lc3RhbXAiLCJsYXN0RGF0YSIsInZlcnNpb24iLCJjaGVja0VuZCIsImN1cnJlbnREc1RvU2hpZnQiLCJkQ2xvY2siLCJkVHMiLCJzaGlmdCIsImNoZWNrU3RhcnQiLCJuYkRhdGFzb3VyY2VzRmV0Y2hlZE9rIiwidG90YWxEYXRhU291cmNlcyIsImRhdGFTb3VyY2VJRCIsIm9uRW5kIiwicmVzZXQiLCJyZXNldERhdGFTb3VyY2UiLCJkYXRhc291cmNlSWQiLCJEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lIiwibGF0ZW5jeSIsIm1heExhdGVuY3kiLCJtaW5MYXRlbmN5IiwibWluIiwidGltZU91dCIsImRDbG9ja0FkaiIsInJlYyIsInRpbWVkT3V0Iiwic3RhcnRCdWZmZXJpbmdUaW1lIl0sIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsdUJBQXVCLEdBQUcsb0JBQWhDO0FBQ0EsTUFBTUMsdUJBQXVCLEdBQUcseUJBQWhDO0FBRUEsTUFBTUMscUJBQXFCLEdBQUcsa0JBQTlCO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsa0JBQTlCO0FBRUEsTUFBTUMsd0JBQXdCLEdBQUcsZ0JBQWpDO0FBRUEsTUFBTUMsZ0JBQWdCLEdBQUcsY0FBekIsQzs7QUNSQSxNQUFNQyxTQUFTLEdBQUc7RUFDckJDLElBQUksRUFBRSxNQURlO0VBRXJCQyxTQUFTLEVBQUUsV0FGVTtFQUdyQkMsV0FBVyxFQUFFLGFBSFE7RUFJckJDLE1BQU0sRUFBRSxRQUphO0VBS3JCQyxZQUFZLEVBQUU7QUFMTyxDQUFsQixDOztBQ0FQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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QUFDQSxjQUFjLFNBQVM7QUFDdkIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTLENBQUMsZ0NBQVEsNkJBQTZCLGdDQUFRO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGdDQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxrQ0FBVTtBQUNkO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0EsWUFBWSxrQ0FBVTtBQUN0QixnQkFBZ0IsU0FBUyxDQUFDLGtDQUFVO0FBQ3BDO0FBQ0EsK0JBQStCLGtDQUFVO0FBQ3pDLDBCQUEwQixTQUFTO0FBQ25DLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLGlCQUFpQixTQUFTLENBQUMsZ0NBQVEsaUJBQWlCLGdDQUFRO0FBQzVEO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQVE7QUFDNUIsa0JBQWtCLGdDQUFROztBQUUxQiwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IERBVEFfU1lOQ0hST05JWkVSX1RPUElDID0gJ2RhdGEtc3luY2hyb25pemVyLSc7XG5leHBvcnQgY29uc3QgVElNRV9TWU5DSFJPTklaRVJfVE9QSUMgPSAnZGF0YS1zeW5jaHJvbml6ZXItdGltZS0nO1xuXG5leHBvcnQgY29uc3QgREFUQVNPVVJDRV9EQVRBX1RPUElDID0gJ2RhdGFzb3VyY2UtZGF0YS0nO1xuZXhwb3J0IGNvbnN0IERBVEFTT1VSQ0VfVElNRV9UT1BJQyA9ICdkYXRhc291cmNlLXRpbWUtJztcblxuZXhwb3J0IGNvbnN0IEZGTVBFR19WSUVXX0RFQ09ERV9UT1BJQyA9ICdmZm1wZWctZGVjb2RlLSc7XG5cbmV4cG9ydCBjb25zdCBNQUdJQ19FTkRfUEFDS0VUID0gJ21hZ2ljLXBhY2tldCc7XG4iLCJleHBvcnQgY29uc3QgRXZlbnRUeXBlID0ge1xuICAgIERBVEE6ICdkYXRhJyxcbiAgICBMQVNUX1RJTUU6ICdsYXN0LXRpbWUnLFxuICAgIE1BU1RFUl9USU1FOiAnbWFzdGVyLXRpbWUnLFxuICAgIFNUQVRVUzogJ3N0YXR1cycsXG4gICAgVElNRV9DSEFOR0VEOiAndGltZS1jaGFuZ2VkJ1xufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqICogQG1vZHVsZSBVdGlscyAqL1xuXG4vKiogTWF4aW11bSB2YWx1ZSBvZiBhIGxvbmcgKi9cbmV4cG9ydCBjb25zdCBNQVhfTE9ORyA9IE1hdGgucG93KDIsIDUzKSArIDE7XG5cbi8qKlxuICogR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mICh2KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaGFzIGEgdmFsdWUsXG4gdGhhdCBpcyBpdCBpcyBkZWZpbmVkIGFuZCBub24gbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsdWUodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGhleCBjb2xvciBpbnRvIFJHQkFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleDJyZ2IoaGV4KXtcbiAgICBjb25zdCBbciwgZywgYl0gPSBoZXgubWF0Y2goL1xcd1xcdy9nKS5tYXAoeCA9PiBwYXJzZUludCh4LCAxNikpO1xuICAgIHJldHVybiBbciwgZywgYl07XG59XG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVHlwZSh2LCBleHBlY3RlZFR5cGUpIHtcbiAgICBsZXQgaGFzVmFsID0gaGFzVmFsdWUodik7XG4gICAgcmV0dXJuIGhhc1ZhbCAmJiB0eXBlb2YgKHYpID09PSBleHBlY3RlZFR5cGU7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUcnVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikgfHwgIXYpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKHYsIGV4cGVjdGVkVHlwZSwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICh0eXBlb2YgKHYpICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgb2YgdHlwZSBcIiArIGV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEJvb2xlYW4odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdib29sZWFuJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0cmluZyh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ3N0cmluZycsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdudW1iZXInLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmUodiwgbGV0TmFtZSkge1xuICAgIGFzc2VydE51bWJlcih2LCBsZXROYW1lKTtcbiAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCI7XG4gICAgfVxufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnb2JqZWN0JywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcnJheSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGFuIGFycmF5XCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SGFzVmFsdWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghaGFzVmFsdWUodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3Qgbm90IGJlIG51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVVVSUQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LXh4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3RhbXBzL2VtYmVkcyBhIFVVSUQgaW50byBhbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIFVVSUQgZ2VuZXJhdGVkIGZvciBpdFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbXBVVUlEKG9iaikge1xuICAgIG9iai5fb3NoX2lkID0gb2JqLl9vc2hfaWQgfHwgcmFuZG9tVVVJRCgpO1xuICAgIHJldHVybiBvYmouX29zaF9pZDtcbn1cblxuLy9idWZmZXIgaXMgYW4gQXJyYXlCdWZmZXIgb2JqZWN0LCB0aGUgb2Zmc2V0IGlmIHNwZWNpZmllZCBpbiBieXRlcywgYW5kIHRoZSB0eXBlIGlzIGEgc3RyaW5nXG4vL2NvcnJlc3BvbmRpbmcgdG8gYW4gT0dDIGRhdGEgdHlwZS5cbi8vU2VlIGh0dHA6Ly9kZWYuc2VlZ3JpZC5jc2lyby5hdS9zaXNzdm9jL29nYy1kZWYvcmVzb3VyY2U/dXJpPWh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2RhdGFUeXBlL09HQy8wL1xuLyoqXG4gKlxuICogQHBhcmFtIGJ1ZmZlclxuICogQHBhcmFtIG9mZnNldFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUJ5dGVzKGJ1ZmZlciwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblxuICAgIC8vTm90ZTogVGhlcmUgZXhpc3QgdHlwZXMgbm90IGxpc3RlZCBpbiB0aGUgbWFwIGJlbG93IHRoYXQgaGF2ZSBPR0MgZGVmaW5pdGlvbnMsIGJ1dCBubyBhcHByb3ByaWF0ZVxuICAgIC8vbWV0aG9kcyBvciBjb3JyZXNwb25kaW5nIHR5cGVzIGF2YWlsYWJsZSBmb3IgcGFyc2luZyBpbiBqYXZhc2NyaXB0LiBUaGV5IGFyZSBmbG9hdDEyOCwgZmxvYXQxNiwgc2lnbmVkTG9uZyxcbiAgICAvL2FuZCB1bnNpZ25lZExvbmdcbiAgICBsZXQgdHlwZU1hcCA9IHtcbiAgICAgICAgZG91YmxlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQ2NDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0MzI6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9UT0RPOiBzdHJpbmctdXRmLTg6XG4gICAgfTtcbiAgICByZXR1cm4gdHlwZU1hcFt0eXBlXShvZmZzZXQpO1xufVxuXG4vL1RoaXMgZnVuY3Rpb24gcmVjdXJzaXZsZXkgaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0U3RydWN0dXJlIHRvIGZpbGwgaW5cbi8vdmFsdWVzIHJlYWQgZnJvbSBkYXRhIHdoaWNoIHNob3VsZCBiZSBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBwYXlsb2FkIGZyb20gYSB3ZWJzb2NrZXRcbi8qKlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3RcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gb2Zmc2V0Qnl0ZXNcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWFkRGF0YShzdHJ1Y3QsIGRhdGEsIG9mZnNldEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IG9mZnNldEJ5dGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0LmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY3VyckZpZWxkU3RydWN0ID0gc3RydWN0LmZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QudHlwZSkgJiYgY3VyckZpZWxkU3RydWN0LnR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBQYXJzZUJ5dGVzKGRhdGEsIG9mZnNldCwgY3VyckZpZWxkU3RydWN0LnR5cGUpO1xuICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbCA9IHJldC52YWw7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcmV0LmJ5dGVzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QuY291bnQpICYmIGN1cnJGaWVsZFN0cnVjdC5jb3VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jaGVjayBpZiBjb3VudCBpcyBhIHJlZmVyZW5jZSB0byBhbm90aGVyIGxldGlhYmxlXG4gICAgICAgICAgICBpZiAoaXNOYU4oY3VyckZpZWxkU3RydWN0LmNvdW50KSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGN1cnJGaWVsZFN0cnVjdC5jb3VudDtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGROYW1lID0gc3RydWN0LmlkMkZpZWxkTWFwW2lkXTtcbiAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QuY291bnQgPSBzdHJ1Y3QuZmluZEZpZWxkQnlOYW1lKGZpZWxkTmFtZSkudmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VyckZpZWxkU3RydWN0LmZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGN1cnJGaWVsZFN0cnVjdC5maWVsZHNbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gUmVhZERhdGEoZmllbGQsIGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSByZXN1bHRTdHJ1Y3R1cmVcbiAqIEByZXR1cm4ge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gR2V0UmVzdWx0T2JqZWN0KHJlc3VsdFN0cnVjdHVyZSkge1xuICAgIC8vVE9ETzogaGFuZGxlIGNhc2VzIGZvciBuZXN0ZWQgYXJyYXlzIC8gbWF0cml4IGRhdGEgdHlwZXNcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQocmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10udmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVyYSgpIHtcbiAgICByZXR1cm4gKCEhd2luZG93Lm9wciAmJiAhIW9wci5hZGRvbnMpIHx8ICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gICAgcmV0dXJuICEhd2luZG93LmNocm9tZSAmJiAhIXdpbmRvdy5jaHJvbWUud2Vic3RvcmU7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp8Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmxpbmsoKSB7XG4gICAgcmV0dXJuIChpc0Nocm9tZSB8fCBpc09wZXJhKSAmJiAhIXdpbmRvdy5DU1M7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlJbnRlcnNlY3QoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGVsZW1lbnQpID4gLTE7XG4gICAgfSkubGVuZ3RoID4gMDtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxuICAgICAgICBvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICk7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKFdvcmtlcik7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkaXZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VTY3JlZW5TaG90KGRpdikge1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNzcyBjbGFzcyBmcm9tIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byByZW1vdmUgdGhlIGNsYXNzIGZyb21cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNzcyhkaXYsIGNzcykge1xuICAgIGxldCBkaXZDc3MgPSBkaXYuY2xhc3NOYW1lO1xuICAgIGNzcyA9IGRpdkNzcy5yZXBsYWNlKGNzcywgXCJcIik7XG4gICAgZGl2LmNsYXNzTmFtZSA9IGNzcztcbn1cblxuXG4vKipcbiAqIEFkZCBhIGNzcyBjbGFzcyB0byBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gYWRkIHRoZSBjbGFzcyB0b1xuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIGFkZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3NzKGRpdiwgY3NzKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRpdi5jbGFzc05hbWUgKyBcIiBcIiArIGNzcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB7c3RyaW5nfSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgaW5wdXQge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIHdpdGhvdXQgdGhlIGxhc3QgY2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMYXN0Q2hhcklmRXhpc3QodmFsdWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh1bmRlZmluZWQpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCAhdmFsdWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xufVxuXG4vKipcbiAqIFJvdW5kIG9mZiBudW1iZXIgdG8gbmVhcmVzdCAwLjVcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHJvdW5kIG9mZlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm91bmRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kSGFsZihudW0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0qMikvMjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCxcbiAqIHdpbGwgbm90IGJlIGV4ZWN1dGVkLiBUaGUgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHdoZW5cbiAqIGl0IHdpbGwgc3RvcCBiZWluZyBjYWxsZWQgZm9yIG1vcmUgdGhhbiBOIG1pbGxpc2Vjb25kcy5cbiAqIElmIHRoZSBgaW1tZWRpYXRlYCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlbiB0aGUgZnVuY3Rpb25cbiAqIHdpbGwgYmUgZXhlY3V0ZWQgYXQgdGhlIGZpcnN0IGNhbGwgaW5zdGVhZCBvZiB0aGUgbGFzdC5cbiAqIFBhcmFtZXRlcnMgOlxuICogLSBmdW5jOiB0aGUgZnVuY3Rpb24gdG8gYGRlYm91bmNlcmAuXG4gKiAtIHdhaXQ6IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIChOKSB0byB3YWl0IGJlZm9yZVxuICogY2FsbCBmdW5jKClcbiAqIC0gaW1tZWRpYXRlIChvcHRpb25hbCk6IENhbGwgZnVuYygpIGF0IHRoZSBmaXJzdCBpbnZvY2F0aW9uXG4gKiBpbnN0ZWFkIG9mIHRoZSBsYXN0IG9uZSAoRGVmYXVsdCBmYWxzZSlcbiAqIC0gY29udGV4dCAob3B0aW9uYWwpOiB0aGUgY29udGV4dCBpbiB3aGljaCB0byBjYWxsIGZ1bmMoKVxuICogKHRoaXMgYnkgZGVmYXVsdClcbiAqL1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGxhc3QgPSBub3cgLSB0aW1lc3RhbXA7XG5cbiAgICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIGxlYWRpbmcsIHRyYWlsaW5nLCBjb250ZXh0KSB7XG4gICAgdmFyIGN0eCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGU7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgIWxlYWRpbmcpIHByZXZpb3VzID0gbm93O1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIGN0eCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIHRyYWlsaW5nKSB7XG4gICAgICAgICAgICAvLyBTaW5vbiBvbiBz4oCZZW5kb3J0IHBlbmRhbnQgbGUgdGVtcHMgcmVzdGFudFxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBgc291cmNlYCBwcm9wZXJ0aWVzIGFuZCBpZiBhbiBgT2JqZWN0YCBzZXQgcHJvcGVydHkgdG8gbWVyZ2Ugb2YgYHRhcmdldGAgYW5kIGBzb3VyY2VgIHByb3BlcnRpZXNcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgICAgIGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCAmJiBrZXkgaW4gdGFyZ2V0KSBPYmplY3QuYXNzaWduKHNvdXJjZVtrZXldLCBtZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pKVxuICAgIH1cblxuICAgIC8vIEpvaW4gYHRhcmdldGAgYW5kIG1vZGlmaWVkIGBzb3VyY2VgXG4gICAgT2JqZWN0LmFzc2lnbih0YXJnZXQgfHwge30sIHNvdXJjZSlcbiAgICByZXR1cm4gdGFyZ2V0XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmdiYVRvQXJyYXkoc3RyKSB7XG4gICAgbGV0IHN0YXJ0SWR4VmFsdWUgPSBzdHIuaW5kZXhPZignKCcpICsgMTtcbiAgICBsZXQgZW5kSWR4VmFsdWUgPSBzdHIuaW5kZXhPZignKScpO1xuICAgIGxldCB2YWx1ZXMgPSBzdHIuc3Vic3RyKHN0YXJ0SWR4VmFsdWUsIGVuZElkeFZhbHVlLXN0YXJ0SWR4VmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZXMuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbn1cbiIsIi8qKlxuICogRW51bSBmb3IgZGF0YXNvdXJjZSBtb2RlLlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7e25hbWU6IHN0cmluZ319XG4gKi9cbmV4cG9ydCBjb25zdCBNb2RlID0ge1xuICAgIFJFUExBWTogXCJyZXBsYXlcIixcbiAgICBCQVRDSDogIFwiYmF0Y2hcIixcbiAgICBSRUFMX1RJTUU6IFwicmVhbFRpbWVcIlxufTtcbiIsIi8qKlxuICogRW51bSBmb3IgY29ubmVjdGlvbiBzdGF0dXMuXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHt7bmFtZTogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IFN0YXR1cyA9IHtcbiAgICBDT05ORUNUSU5HOiBcImNvbm5lY3RpbmdcIixcbiAgICBDT05ORUNURUQ6ICBcImNvbm5lY3RlZFwiLFxuICAgIERJU0NPTk5FQ1RFRDogXCJkaXNjb25uZWN0ZWRcIixcbiAgICBGRVRDSF9TVEFSVEVEOiAnZmV0Y2gtc3RhcnQnLFxuICAgIEZFVENIX0VOREVEOiAnZmV0Y2gtZW5kJyxcbiAgICBDTE9TRUQ6IFwiY2xvc2VkXCIsXG4gICAgQ0xPU0VEX0VSUk9SOiBcImNsb3NlZC1lcnJvclwiXG59O1xuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gXCIuLi9jb25uZWN0b3IvU3RhdHVzLmpzXCI7XG5cbmNsYXNzIERhdGFTeW5jaHJvbml6ZXJBbGdvIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlcywgdGltZXJSZXNvbHV0aW9uID0gNSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXAgPSB7fTtcbiAgICAgICAgdGhpcy50c1J1biA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50aW1lclJlc29sdXRpb24gPSB0aW1lclJlc29sdXRpb247XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFzb3VyY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGRzIG9mIGRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGFTb3VyY2UoZHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChkYXRhU291cmNlSWQsIGRhdGFCbG9ja3MpIHtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50VGltZXN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1J1bjtcbiAgICB9XG5cbiAgICBwcm9jZXNzRGF0YSgpIHtcbiAgICAgICAgbGV0IHRzUmVmID0gLTE7XG4gICAgICAgIGxldCBjbG9ja1RpbWVSZWYgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICAvLyBnZXQgcmVmZXJlbmNlIHN0YXJ0IHRpbWVzdGFtcFxuICAgICAgICAvLyB0aGUgcmVmZXJlbmNlIHN0YXJ0IHRpbWVzdGFtcCBzaG91bGQgdGhlIG9sZGVzdCBvbmVcbiAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0c1JlZiA9ICh0c1JlZiA9PT0gLTEgfHwgY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgPCB0c1JlZikgPyBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCA6XG4gICAgICAgICAgICAgICAgICAgIHRzUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEpIHJldHVybiB0aGUgb2xkZXN0IGRhdGEgaWYgYW55XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wdXRlTmV4dERhdGEodHNSZWYsIGNsb2NrVGltZVJlZikpIDtcblxuICAgICAgICB9LCB0aGlzLnRpbWVyUmVzb2x1dGlvbik7XG4gICAgICAgIGNvbnNvbGUud2FybihgU3RhcnRlZCBSZXBsYXkgQWxnb3JpdGhtIHdpdGggdHNSZWY9JHtuZXcgRGF0ZSh0c1JlZikudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBuZXh0IGRhdGEgaWYgYW55LiBXZSByZXR1cm4gb25seSAxIHZhbHVlIGZvciB0aGlzIGl0ZXJhdGlvbi4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHZhbHVlcyB0byByZXR1cm4sXG4gICAgICogd2UgcmV0dXJuIG9ubHkgdGhlIG9sZGVzdCBvbmUuXG4gICAgICogQHBhcmFtIHRzUmVmIC0gdGhlIHRpbWVzdGFtcCBvZiB0aGUgZmlyc3QgZGF0YVxuICAgICAqIEBwYXJhbSByZWZDbG9ja1RpbWUgLSB0aGUgYWJzb2x1dGUgZGlmZiB0aW1lIHJlYWxseSBzcGVudFxuICAgICAqL1xuICAgIGNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgcmVmQ2xvY2tUaW1lKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTaG91bGQgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YXNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTaG91bGQgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH1cblxuICAgIGNoZWNrVmVyc2lvbihkYXRhc291cmNlLCBkYXRhQmxvY2spIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgb25EYXRhKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2NrKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkYXRhU291cmNlIHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXMgLSB0aGUgbmV3IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhU291cmNlSWQgLSB0aGUgY29ycmVzcG9uZGluZyBkYXRhU291cmNlIGlkXG4gICAgICovXG4gICAgc2V0U3RhdHVzKGRhdGFTb3VyY2VJZCwgc3RhdHVzKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTaG91bGQgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgc3luY2hyb25pemVyIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgIH1cblxuICAgIG9uU3RhcnQoKSAge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN5bmNocm9uaXplckFsZ287XG4iLCJpbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uL3V0aWxzL1V0aWxzLmpzXCI7XG5pbXBvcnQge1N0YXR1c30gZnJvbSBcIi4uL2Nvbm5lY3Rvci9TdGF0dXMuanNcIjtcbmltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnbyBmcm9tIFwiLi9EYXRhU3luY2hyb25pemVyQWxnb1wiO1xuXG5jbGFzcyBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheSBleHRlbmRzIERhdGFTeW5jaHJvbml6ZXJBbGdvIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlcywgcmVwbGF5U3BlZWQgPSAxLCBzdGFydFRpbWVzdGFtcCwgZW5kVGltZXN0YW1wLCB0aW1lclJlc29sdXRpb24gPSA1KSB7XG4gICAgICAgIHN1cGVyKGRhdGFTb3VyY2VzLHJlcGxheVNwZWVkLHRpbWVyUmVzb2x1dGlvbik7XG4gICAgICAgIHRoaXMucmVwbGF5U3BlZWQgPSByZXBsYXlTcGVlZDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVzdGFtcCA9IHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICB0aGlzLmVuZFRpbWVzdGFtcCA9IGVuZFRpbWVzdGFtcDtcbiAgICB9XG5cbiAgICBwdXNoKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2Nrcykge1xuICAgICAgICBpZihkYXRhQmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXTtcbiAgICAgICAgY29uc3QgbGFzdERhdGEgPSBkYXRhQmxvY2tzW2RhdGFCbG9ja3MubGVuZ3RoLTFdO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tWZXJzaW9uKGRzLCBsYXN0RGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0RhdGFTeW5jaHJvbml6ZXJdIGluY29tcGF0aWJsZSB2ZXJzaW9uICR7ZHMudmVyc2lvbn0gfiAke2xhc3REYXRhLnZlcnNpb259LCBza2lwcGluZyBkYXRhYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZHMuZGF0YUJ1ZmZlci5wdXNoKC4uLmRhdGFCbG9ja3MpO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgY2xvY2tUaW1lUmVmID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEpIHJldHVybiB0aGUgb2xkZXN0IGRhdGEgaWYgYW55XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wdXRlTmV4dERhdGEodGhpcy5zdGFydFRpbWVzdGFtcCwgY2xvY2tUaW1lUmVmKSkge31cbiAgICAgICAgICAgIHRoaXMuY2hlY2tFbmQoKTtcbiAgICAgICAgfSwgdGhpcy50aW1lclJlc29sdXRpb24pO1xuICAgICAgICBjb25zb2xlLndhcm4oYFN0YXJ0ZWQgUmVwbGF5IEFsZ29yaXRobSB3aXRoIHRzUmVmPSR7bmV3IERhdGUodGhpcy5zdGFydFRpbWVzdGFtcCkudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBuZXh0IGRhdGEgaWYgYW55LiBXZSByZXR1cm4gb25seSAxIHZhbHVlIGZvciB0aGlzIGl0ZXJhdGlvbi4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHZhbHVlcyB0byByZXR1cm4sXG4gICAgICogd2UgcmV0dXJuIG9ubHkgdGhlIG9sZGVzdCBvbmUuXG4gICAgICogQHBhcmFtIHRzUmVmIC0gdGhlIHRpbWVzdGFtcCBvZiB0aGUgZmlyc3QgZGF0YVxuICAgICAqIEBwYXJhbSByZWZDbG9ja1RpbWUgLSB0aGUgYWJzb2x1dGUgZGlmZiB0aW1lIHJlYWxseSBzcGVudFxuICAgICAqL1xuICAgIGNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgcmVmQ2xvY2tUaW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50RHM7XG4gICAgICAgIGxldCBjdXJyZW50RHNUb1NoaWZ0ID0gbnVsbDtcblxuICAgICAgICBjb25zdCBkQ2xvY2sgPSAocGVyZm9ybWFuY2Uubm93KCkgLSByZWZDbG9ja1RpbWUpICogdGhpcy5yZXBsYXlTcGVlZDtcbiAgICAgICAgdGhpcy50c1J1biA9IHRzUmVmICsgZENsb2NrO1xuICAgICAgICAvLyBjb21wdXRlIG5leHQgZGF0YSB0byByZXR1cm5cbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkVHMgPSAoY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgLSB0c1JlZik7XG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIGFuIGludGVybWVkaWF0ZSBvYmplY3QgdG8gc3RvcmUgdGhlIGRhdGEgdG8gc2hpZnQgYmVjYXVzZSB3ZSB3YW50IHRvIHJldHVybiB0aGUgb2xkZXN0IG9uZVxuICAgICAgICAgICAgICAgIC8vIG9ubHlcbiAgICAgICAgICAgICAgICBpZiAoZFRzIDw9IGRDbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBvdGhlciBvbmUgdG8gY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IGN1cnJlbnREcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgdGhlIG9sZGVzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gKGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCA8IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA6IGN1cnJlbnREcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHkgcG9wIHRoZSBkYXRhIGZyb20gRFMgcXVldWVcbiAgICAgICAgaWYgKGN1cnJlbnREc1RvU2hpZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGN1cnJlbnREc1RvU2hpZnQuaWQsIGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YVNvdXJjZSB0byBiZSBzeW5jaHJvbml6ZWRcbiAgICAgKiBAcGFyYW0ge0RhdGFzb3VyY2V9IGRhdGFTb3VyY2UgLSB0aGUgZGF0YVNvdXJjZSB0byBzeW5jaHJvbml6ZVxuICAgICAqL1xuICAgIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZS5pZF0gPSB7XG4gICAgICAgICAgICBkYXRhQnVmZmVyOiBbXSxcbiAgICAgICAgICAgIGlkOiBkYXRhU291cmNlLmlkLFxuICAgICAgICAgICAgbmFtZTogZGF0YVNvdXJjZS5uYW1lIHx8IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICBzdGF0dXM6IFN0YXR1cy5ESVNDT05ORUNURUQsIC8vTUVBTklORyBFbmFibGVkLCAwID0gRGlzYWJsZWRcbiAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRhdGFzb3VyY2VzLnB1c2goZGF0YVNvdXJjZSk7XG4gICAgfVxuXG4gICAgY2hlY2tWZXJzaW9uKGRhdGFzb3VyY2UsIGRhdGFCbG9jaykge1xuICAgICAgICBpZighaXNEZWZpbmVkKGRhdGFzb3VyY2UudmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YXNvdXJjZS52ZXJzaW9uICE9PSBkYXRhQmxvY2sudmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkYXRhU291cmNlIHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXMgLSB0aGUgbmV3IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhU291cmNlSWQgLSB0aGUgY29ycmVzcG9uZGluZyBkYXRhU291cmNlIGlkXG4gICAgICovXG4gICAgc2V0U3RhdHVzKGRhdGFTb3VyY2VJZCwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChkYXRhU291cmNlSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oc3RhdHVzKycgRGF0YVNvdXJjZSAnICsgZGF0YVNvdXJjZUlkICsgJyBmcm9tIHRoZSBzeW5jaHJvbml6ZXIgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1N0YXJ0KCk7XG4gICAgfVxuXG4gICAgY2hlY2tTdGFydCgpIHtcbiAgICAgICAgaWYoIWlzRGVmaW5lZCh0aGlzLmludGVydmFsKSkge1xuICAgICAgICAgICAgbGV0IG5iRGF0YXNvdXJjZXNGZXRjaGVkT2sgPSAwO1xuICAgICAgICAgICAgbGV0IHRvdGFsRGF0YVNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGFTb3VyY2VNYXApLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yKGxldCBkYXRhU291cmNlSUQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2VJRF0uc3RhdHVzID09PSBTdGF0dXMuRkVUQ0hfU1RBUlRFRCkgbmJEYXRhc291cmNlc0ZldGNoZWRPaysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtTeW5jaHJvbml6ZXJdIEZldGNoZWQgJHtuYkRhdGFzb3VyY2VzRmV0Y2hlZE9rfS8ke3RvdGFsRGF0YVNvdXJjZXN9IGRhdGFzb3VyY2VzYCk7XG4gICAgICAgICAgICBpZihuYkRhdGFzb3VyY2VzRmV0Y2hlZE9rID09PSB0b3RhbERhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdGFydGluZyBSZXBsYXkgQWxnb3JpdGhtLi4uJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25TdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tFbmQoKSB7XG4gICAgICAgIGlmKHRoaXMuZ2V0Q3VycmVudFRpbWVzdGFtcCgpID49IHRoaXMuZW5kVGltZXN0YW1wKSB7XG4gICAgICAgICAgICB0aGlzLm9uRW5kKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy50c1J1biA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0IHN5bmNocm9uaXplciBhbGdvJylcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXREYXRhU291cmNlKGN1cnJlbnREc0lkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0RGF0YVNvdXJjZShkYXRhc291cmNlSWQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2RhdGFzb3VyY2VJZF07XG4gICAgICAgIGN1cnJlbnREcy5kYXRhQnVmZmVyID0gW107XG4gICAgICAgIGN1cnJlbnREcy5zdGF0dXM9IFN0YXR1cy5ESVNDT05ORUNURUQ7XG4gICAgICAgIGN1cnJlbnREcy52ZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG9uRW5kKCkge31cbiAgICBvblN0YXJ0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN5bmNocm9uaXplckFsZ29SZXBsYXk7XG4iLCJpbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uL3V0aWxzL1V0aWxzLmpzXCI7XG5pbXBvcnQge1N0YXR1c30gZnJvbSBcIi4uL2Nvbm5lY3Rvci9TdGF0dXMuanNcIjtcbmltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnbyBmcm9tIFwiLi9EYXRhU3luY2hyb25pemVyQWxnb1wiO1xuXG5jbGFzcyBEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lIGV4dGVuZHMgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIHB1c2goZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2tzKSB7XG4gICAgICAgIGlmKGRhdGFCbG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdO1xuICAgICAgICBjb25zdCBsYXN0RGF0YSA9IGRhdGFCbG9ja3NbZGF0YUJsb2Nrcy5sZW5ndGgtMV07XG4gICAgICAgIGlmICghdGhpcy5jaGVja1ZlcnNpb24oZHMsIGxhc3REYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhdGVuY3kgPSAwO1xuICAgICAgICBpZiAodGhpcy50c1J1biA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3kgPSB0aGlzLnRzUnVuIC0gbGFzdERhdGEuZGF0YS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZHMubGF0ZW5jeSA9IGxhdGVuY3kgPiBkcy5sYXRlbmN5ID8gbGF0ZW5jeSA6IChkcy5sYXRlbmN5ICsgbGF0ZW5jeSkgLyAyO1xuXG4gICAgICAgIGRzLmRhdGFCdWZmZXIucHVzaCguLi5kYXRhQmxvY2tzKTtcbiAgICAgICAgaWYoIWlzRGVmaW5lZCh0aGlzLmludGVydmFsKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbmV4dCBkYXRhIGlmIGFueS4gV2UgcmV0dXJuIG9ubHkgMSB2YWx1ZSBmb3IgdGhpcyBpdGVyYXRpb24uIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXMgdG8gcmV0dXJuLFxuICAgICAqIHdlIHJldHVybiBvbmx5IHRoZSBvbGRlc3Qgb25lLlxuICAgICAqIEBwYXJhbSB0c1JlZiAtIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGZpcnN0IGRhdGFcbiAgICAgKiBAcGFyYW0gcmVmQ2xvY2tUaW1lIC0gdGhlIGFic29sdXRlIGRpZmYgdGltZSByZWFsbHkgc3BlbnRcbiAgICAgKi9cbiAgICBjb21wdXRlTmV4dERhdGEodHNSZWYsIHJlZkNsb2NrVGltZSkge1xuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBsZXQgY3VycmVudERzVG9TaGlmdCA9IG51bGw7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBtYXggbGF0ZW5jeVxuICAgICAgICBsZXQgbWF4TGF0ZW5jeSA9IDA7XG4gICAgICAgIGxldCBtaW5MYXRlbmN5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5sYXRlbmN5ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRlbmN5ID0gTWF0aC5taW4oY3VycmVudERzLmxhdGVuY3ksIGN1cnJlbnREcy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICBtYXhMYXRlbmN5ID0gKGxhdGVuY3kgPiBtYXhMYXRlbmN5KSA/IGxhdGVuY3kgOiBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIG1pbkxhdGVuY3kgPSAoY3VycmVudERzLmxhdGVuY3kgPCBtaW5MYXRlbmN5KSA/IGN1cnJlbnREcy5sYXRlbmN5IDogbWluTGF0ZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkQ2xvY2sgPSAocGVyZm9ybWFuY2Uubm93KCkgLSByZWZDbG9ja1RpbWUpO1xuICAgICAgICB0aGlzLnRzUnVuID0gdHNSZWYgKyBkQ2xvY2s7XG4gICAgICAgIC8vIGNvbXB1dGUgbmV4dCBkYXRhIHRvIHJldHVyblxuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRUcyA9IChjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCAtIHRzUmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkQ2xvY2tBZGogPSBkQ2xvY2sgLSBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSBhbiBpbnRlcm1lZGlhdGUgb2JqZWN0IHRvIHN0b3JlIHRoZSBkYXRhIHRvIHNoaWZ0IGJlY2F1c2Ugd2Ugd2FudCB0byByZXR1cm4gdGhlIG9sZGVzdCBvbmVcbiAgICAgICAgICAgICAgICAvLyBvbmx5XG4gICAgICAgICAgICAgICAgaWYgKGRUcyA8PSBkQ2xvY2tBZGopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gb3RoZXIgb25lIHRvIGNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREc1RvU2hpZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWtlIHRoZSBvbGRlc3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IChjdXJyZW50RHNUb1NoaWZ0LmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgPCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgOiBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHBvcCB0aGUgZGF0YSBmcm9tIERTIHF1ZXVlXG4gICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVjID0gY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBsYXRlbmN5IGZsYWcgdG8gZGF0YSByZWNvcmQgYmVmb3JlIHdlIGRpc3BhdGNoIGl0XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHJlbGF0aXZlIGxhdGVuY3kgaW4gbWlsbGlzIGNvbXBhcmVkIHRvIHRoZSBEUyB3aXRoIHRoZSBsb3dlc3QgbGF0ZW5jeVxuICAgICAgICAgICAgLy8gc28gaXQgaXMgYWNjdXJhdGUgZXZlbiBpZiBsb2NhbCBkZXZpY2UgdGltZSBpcyBub3Qgc2V0IHByb3Blcmx5XG4gICAgICAgICAgICByZWNbJ0BsYXRlbmN5J10gPSBjdXJyZW50RHMubGF0ZW5jeSAtIG1pbkxhdGVuY3k7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShjdXJyZW50RHNUb1NoaWZ0LmlkLCByZWMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YXNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXSA9IHtcbiAgICAgICAgICAgIHRpbWVPdXQ6IGRhdGFTb3VyY2UudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZGF0YUJ1ZmZlcjogW10sXG4gICAgICAgICAgICBpZDogZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFTb3VyY2UubmFtZSB8fCBkYXRhU291cmNlLmlkLFxuICAgICAgICAgICAgbGF0ZW5jeTogMCxcbiAgICAgICAgICAgIHN0YXR1czogU3RhdHVzLkRJU0NPTk5FQ1RFRCwgLy9NRUFOSU5HIEVuYWJsZWQsIDAgPSBEaXNhYmxlZFxuICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZXMucHVzaChkYXRhU291cmNlKTtcbiAgICB9XG5cbiAgICBjaGVja1ZlcnNpb24oZGF0YXNvdXJjZSwgZGF0YUJsb2NrKSB7XG4gICAgICAgIGlmKGRhdGFzb3VyY2Uuc3RhdHVzICE9PSBTdGF0dXMuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGFzb3VyY2Uuc3RhdHVzID09PSBTdGF0dXMuRElTQ09OTkVDVEVEICYmIGRhdGFzb3VyY2UudmVyc2lvbiAhPT0gZGF0YUJsb2NrLnZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgZGF0YVNvdXJjZSBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIG5ldyBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVNvdXJjZUlkIC0gdGhlIGNvcnJlc3BvbmRpbmcgZGF0YVNvdXJjZSBpZFxuICAgICAqL1xuICAgIHNldFN0YXR1cyhkYXRhU291cmNlSWQsIHN0YXR1cykge1xuICAgICAgICBpZiAoZGF0YVNvdXJjZUlkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2VJZF0uc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHN0YXR1cysnIERhdGFTb3VyY2UgJyArIGRhdGFTb3VyY2VJZCArICcgZnJvbSB0aGUgc3luY2hyb25pemVyICcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHNSdW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXNldCBzeW5jaHJvbml6ZXIgYWxnbycpXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0RGF0YVNvdXJjZShjdXJyZW50RHNJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldERhdGFTb3VyY2UoZGF0YXNvdXJjZUlkKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhc291cmNlSWRdO1xuICAgICAgICBjdXJyZW50RHMuZGF0YUJ1ZmZlciA9IFtdO1xuICAgICAgICBjdXJyZW50RHMuc3RhcnRCdWZmZXJpbmdUaW1lID0gLTE7XG4gICAgICAgIGN1cnJlbnREcy5sYXRlbmN5PTA7XG4gICAgICAgIGN1cnJlbnREcy5zdGF0dXM9IFN0YXR1cy5ESVNDT05ORUNURUQ7XG4gICAgICAgIGN1cnJlbnREcy52ZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN5bmNocm9uaXplckFsZ29SZWFsdGltZTtcbiIsImltcG9ydCB7REFUQVNPVVJDRV9EQVRBX1RPUElDfSBmcm9tIFwiLi4vQ29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge0V2ZW50VHlwZX0gZnJvbSBcIi4uL2V2ZW50L0V2ZW50VHlwZS5qc1wiO1xuaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi91dGlscy9VdGlsc1wiO1xuaW1wb3J0IHtNb2RlfSBmcm9tIFwiLi4vZGF0YXNvdXJjZS9Nb2RlXCI7XG5pbXBvcnQgRGF0YVN5bmNocm9uaXplckFsZ29SZXBsYXkgZnJvbSBcIi4vRGF0YVN5bmNocm9uaXplckFsZ28ucmVwbGF5XCI7XG5pbXBvcnQgRGF0YVN5bmNocm9uaXplckFsZ29SZWFsdGltZSBmcm9tIFwiLi9EYXRhU3luY2hyb25pemVyQWxnby5yZWFsdGltZS5qc1wiO1xuXG5jb25zdCBiY0NoYW5uZWxzID0ge307XG5sZXQgZGF0YVN5bmNocm9uaXplckFsZ287XG5cbmxldCBpbml0ID0gZmFsc2U7XG5sZXQgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwgPSBudWxsO1xubGV0IGxhc3REYXRhID0gdW5kZWZpbmVkO1xuY29uc3QgZGF0YVNvdXJjZXMgPSB7fTtcbmxldCB0aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG5sZXQgdG9waWNUaW1lO1xubGV0IHRvcGljRGF0YTtcbmxldCByZXBsYXlTcGVlZDtcbmxldCBtYXN0ZXJUaW1lSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG5sZXQgY1RpbWU7XG5sZXQgY0lkO1xubGV0IGxhc3RUaW1lID0gLTE7XG5sZXQgdmVyc2lvbiA9IC0xO1xubGV0IHByb21pc2U7XG5sZXQgbWFzdGVyVGltZVJlZnJlc2hSYXRlO1xubGV0IHN0YXJ0VGltZXN0YW1wO1xubGV0IGVuZFRpbWVzdGFtcDtcblxuc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICBpZihpc0RlZmluZWQocHJvbWlzZSkpIHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZSA9IGhhbmRsZU1lc3NhZ2UoZXZlbnQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICByZXBsYXlTcGVlZCA9IGV2ZW50LmRhdGEucmVwbGF5U3BlZWQ7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAgPSBuZXcgRGF0ZShldmVudC5kYXRhLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGVuZFRpbWVzdGFtcCA9IG5ldyBEYXRlKGV2ZW50LmRhdGEuZW5kVGltZSkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEubW9kZSA9PT0gTW9kZS5SRVBMQVkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28gPSBuZXcgRGF0YVN5bmNocm9uaXplckFsZ29SZXBsYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmRhdGFTb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5yZXBsYXlTcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS50aW1lclJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25FbmQgPSBvbkVuZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25TdGFydCA9IG9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28gPSBuZXcgRGF0YVN5bmNocm9uaXplckFsZ29SZWFsdGltZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnJlcGxheVNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS50aW1lclJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25EYXRhID0gb25EYXRhO1xuICAgICAgICAgICAgICAgIGluaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZERhdGFTb3VyY2VzKGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpO1xuICAgICAgICAgICAgICAgIHRvcGljRGF0YSA9IGV2ZW50LmRhdGEudG9waWNzLmRhdGE7XG4gICAgICAgICAgICAgICAgdG9waWNUaW1lID0gZXZlbnQuZGF0YS50b3BpY3MudGltZTtcbiAgICAgICAgICAgICAgICBpbml0QnJvYWRjYXN0Q2hhbm5lbCh0b3BpY0RhdGEsIHRvcGljVGltZSk7XG4gICAgICAgICAgICAgICAgbWFzdGVyVGltZVJlZnJlc2hSYXRlID0gZXZlbnQuZGF0YS5tYXN0ZXJUaW1lUmVmcmVzaFJhdGU7XG4gICAgICAgICAgICAgICAgc3RhcnRNYXN0ZXJUaW1lSW50ZXJ2YWwobWFzdGVyVGltZVJlZnJlc2hSYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnYWRkJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgYWRkRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2N1cnJlbnQtdGltZScpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnY3VycmVudC10aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVN5bmNocm9uaXplckFsZ28uZ2V0Q3VycmVudFRpbWVzdGFtcCgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVzZXQnKSB7XG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVwbGF5LXNwZWVkJykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5yZXBsYXlTcGVlZCA9IGV2ZW50LmRhdGEucmVwbGF5U3BlZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICd1cGRhdGUtcHJvcGVydGllcycpIHtcbiAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhc291cmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhc291cmNlcyA9IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmRhdGFzb3VyY2VzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wID0gbmV3IERhdGUoZXZlbnQuZGF0YS5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBlbmRUaW1lc3RhbXAgPSBuZXcgRGF0ZShldmVudC5kYXRhLmVuZFRpbWUpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLm1vZGUgPT09IE1vZGUuUkVQTEFZKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvID0gbmV3IERhdGFTeW5jaHJvbml6ZXJBbGdvUmVwbGF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnJlcGxheVNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby50aW1lclJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25FbmQgPSBvbkVuZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25TdGFydCA9IG9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28gPSBuZXcgRGF0YVN5bmNocm9uaXplckFsZ29SZWFsdGltZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28udGltZXJSZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25EYXRhID0gb25EYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIGNoZWNrTWFzdGVyVGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5wdXNoKGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLCBldmVudC5kYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCByZXNwb25zZVxuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbmRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBldmVudC5kYXRhLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogZXZlbnQuZGF0YS5tZXNzYWdlSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfWNhdGNoIChleCkge1xuICAgICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChtYXN0ZXJUaW1lSW50ZXJ2YWwpO1xuICAgIG1hc3RlclRpbWVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICB2ZXJzaW9uID0gLTE7XG4gICAgaWYoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucmVzZXQoKTtcbiAgICB9XG4gICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuVElNRV9DSEFOR0VEXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0QnJvYWRjYXN0Q2hhbm5lbChkYXRhVG9waWMsIHRpbWVUb3BpYykge1xuICAgIGNvbnNvbGUubG9nKCdsaXN0ZW4gb24gdG9waWMgJyxkYXRhVG9waWMpXG5cbiAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGRhdGFUb3BpYyk7XG4gICAgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNoZWNrTWFzdGVyVGltZSgpO1xuICAgICAgICBpZihldmVudC5kYXRhLnR5cGUgPT09IEV2ZW50VHlwZS5EQVRBKSB7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5wdXNoKGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLGV2ZW50LmRhdGEudmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLlNUQVRVUykge1xuICAgICAgICAgICAgY29uc3QgZGF0YVNvdXJjZUlkID0gZXZlbnQuZGF0YS5kYXRhU291cmNlSWQ7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5zZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBldmVudC5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhU291cmNlc1tkYXRhU291cmNlSWRdLm5hbWUgKyBcIjogc3RhdHVzPVwiICsgZXZlbnQuZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgLy8gYnViYmxlIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRpbWVUb3BpYyk7XG5cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRhdGFTb3VyY2VzXG4gKi9cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2VzKGRhdGFTb3VyY2VzKSB7XG4gICAgZm9yKGxldCBkYXRhU291cmNlIG9mIGRhdGFTb3VyY2VzKSB7XG4gICAgICAgIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICBkYXRhU3luY2hyb25pemVyQWxnby5hZGREYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgIC8vIGNyZWF0ZSBhIEJDIHRvIHB1c2ggYmFjayB0aGUgc3luY2hyb25pemVkIGRhdGEgaW50byB0aGUgREFUQSBTdHJlYW0uXG4gICAgYmNDaGFubmVsc1tkYXRhU291cmNlLmlkXSA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKERBVEFTT1VSQ0VfREFUQV9UT1BJQyArIGRhdGFTb3VyY2UuaWQpO1xuXG4gICAgaWYoIShkYXRhU291cmNlLmlkIGluIGRhdGFTb3VyY2VzKSkge1xuICAgICAgICBkYXRhU291cmNlc1tkYXRhU291cmNlLmlkXSA9IGRhdGFTb3VyY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja01hc3RlclRpbWUoKSB7XG4gICAgaWYoIWlzRGVmaW5lZChtYXN0ZXJUaW1lSW50ZXJ2YWwpKSB7XG4gICAgICAgIHN0YXJ0TWFzdGVyVGltZUludGVydmFsKG1hc3RlclRpbWVSZWZyZXNoUmF0ZSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgY29uc3QgbWFzdGVyVGltZSA9IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmdldEN1cnJlbnRUaW1lc3RhbXAoKTtcbiAgICBjbGVhckludGVydmFsKG1hc3RlclRpbWVJbnRlcnZhbCk7XG4gICAgbWFzdGVyVGltZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIC8vIGVuZCBhdCB0aGlzIHRpbWVcbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHRpbWVzdGFtcDogbWFzdGVyVGltZSxcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1BU1RFUl9USU1FXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgLy8gY2hlY2tNYXN0ZXJUaW1lKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGFCbG9jaykge1xuICAgIGlmKCh2ZXJzaW9uID09PSAtMSAmJiAoaXNEZWZpbmVkKGxhc3REYXRhKSApICYmIGRhdGFCbG9jay52ZXJzaW9uID09PSBsYXN0RGF0YS5kYXRhQmxvY2sudmVyc2lvbikpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmVyc2lvbiA9IGRhdGFCbG9jay52ZXJzaW9uO1xuICAgIGxhc3REYXRhID0ge1xuICAgICAgICBkYXRhU291cmNlSWQ6IGRhdGFTb3VyY2VJZCxcbiAgICAgICAgZGF0YUJsb2NrOiBkYXRhQmxvY2tcbiAgICB9O1xuICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZUlkXS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB2YWx1ZXM6IFtkYXRhQmxvY2tdLFxuICAgICAgICAgICAgZGF0YVNvdXJjZUlkOmRhdGFTb3VyY2VJZCxcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5EQVRBXG4gICAgICAgIH1cbiAgICApO1xufVxuc2VsZi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28uY2xvc2UoKTtcbiAgICBjb25zb2xlLmxvZyhcIkRhdGEgU3luY2hyb25pemVyIGhhcyBiZWVuIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xufVxuXG5sZXQgbWFzdGVyVGltZTtcbmZ1bmN0aW9uIHN0YXJ0TWFzdGVyVGltZUludGVydmFsKG1hc3RlclRpbWVSZWZyZXNoUmF0ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKG1hc3RlclRpbWVJbnRlcnZhbCkpIHtcbiAgICAgICAgbWFzdGVyVGltZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgbWFzdGVyVGltZSA9IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmdldEN1cnJlbnRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQobWFzdGVyVGltZSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbWFzdGVyVGltZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1BU1RFUl9USU1FXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHZlcnNpb25cbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxhc3REYXRhKSB8fCB2ZXJzaW9uICE9PSBsYXN0RGF0YS5kYXRhQmxvY2sudmVyc2lvbiB8fCB2ZXJzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNUaW1lID0gbGFzdERhdGEuZGF0YUJsb2NrLmRhdGEudGltZXN0YW1wO1xuICAgICAgICAgICAgY0lkID0gbGFzdERhdGEuZGF0YVNvdXJjZUlkO1xuXG4gICAgICAgICAgICBpZiAoKGNUaW1lICE9PSAtMSAmJiBsYXN0VGltZSA9PT0gLTEpIHx8IChsYXN0VGltZSAhPT0gLTEgJiYgY1RpbWUgIT09IGxhc3RUaW1lKSkgeyAvLyBkb2VzIG5vdCBzZW5kIHRoZSBzYW1lIGRhdGEgdHdpY2VcbiAgICAgICAgICAgICAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogY1RpbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2VJZDogY0lkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTEFTVF9USU1FXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0VGltZSA9IGNUaW1lO1xuICAgICAgICB9LCBtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);