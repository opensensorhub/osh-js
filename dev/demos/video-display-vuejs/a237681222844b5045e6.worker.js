!function(Q){var B={};function F(I){if(B[I])return B[I].exports;var U=B[I]={i:I,l:!1,exports:{}};return Q[I].call(U.exports,U,U.exports,F),U.l=!0,U.exports}F.m=Q,F.c=B,F.d=function(Q,B,I){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:I})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var I=Object.create(null);if(F.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)F.d(I,U,function(B){return Q[B]}.bind(null,U));return I},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on sâ€™endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/parsers/DataSourceParser.js\n\n\nclass DataSourceParser_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the protocol protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @param {Number} properties.customUrlParams.video_bitrate - define a custom bitrate (in b/s)\n   * @param {Number} properties.customUrlParams.video_scale - define a custom scale, 0.0 < value < 1.0\n   * @param {Number} properties.customUrlParams.video_width - define a custom width\n   * @param {Number} properties.customUrlParams.video_height - define a custom height\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = \"\"; // adds protocol\n\n    url += properties.protocol + \"://\"; // adds endpoint url\n\n    url += properties.endpointUrl + \"?\"; // adds service\n\n    url += \"service=\" + properties.service; // adds version\n\n    url += \"&version=2.0&\"; // adds responseFormat (optional)\n\n    if (properties.responseFormat) {\n      url += \"&responseFormat=\" + properties.responseFormat;\n    }\n\n    if (isDefined(properties.customUrlParams) && Object.keys(properties.customUrlParams).length > 0) {\n      url += '&';\n\n      for (let key in properties.customUrlParams) {\n        url += key + '=' + properties.customUrlParams[key] + '&';\n      }\n\n      if (url.endsWith('&')) {\n        url = url.slice(0, -1);\n      }\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var parsers_DataSourceParser = (DataSourceParser_DataSourceParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/parsers/TimeSeriesParser.parser.js\n\n\n\nclass TimeSeriesParser_parser_TimeSeriesParserParser extends parsers_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the protocol protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = super.buildUrl(properties); // adds request\n\n    url += \"&request=GetResult\"; // adds offering\n\n    url += \"&offering=\" + properties.offeringID; // adds observedProperty\n\n    url += \"&observedProperty=\" + properties.observedProperty; // adds temporalFilter\n\n    const stTime = isDefined(properties.lastTimeStamp) ? properties.lastTimeStamp : properties.startTime;\n    this.lastStartTime = properties.startTime;\n    let endTime = properties.endTime;\n    url += \"&temporalFilter=phenomenonTime,\" + stTime + \"/\" + endTime;\n\n    if (properties.replaySpeed) {\n      // adds replaySpeed\n      url += \"&replaySpeed=\" + properties.replaySpeed;\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var TimeSeriesParser_parser = (TimeSeriesParser_parser_TimeSeriesParserParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/parsers/SosGetResultVideo.parser.js\n\n\n\nclass SosGetResultVideo_parser_VideoParser extends TimeSeriesParser_parser {\n  /**\n   * Extracts timestamp from the message. The timestamp is corresponding to the first 64bits of the binary message.\n   * @param {ArrayBuffer} data - the data to parse\n   * @return {Number} the extracted timestamp\n   */\n  parseTimeStamp(data) {\n    // read double time stamp as big endian\n    return new DataView(data).getFloat64(0, false) * 1000;\n  }\n  /**\n   * Extract data from the message. The H264 NAL unit starts at offset 12 after 8-bytes time stamp and 4-bytes frame length.\n   * @param {ArrayBuffer} data - the data to parse\n   * @return {Uint8Array} the parsed data\n   */\n\n\n  parseData(data) {\n    return {\n      // H264 NAL unit starts at offset 12 after 8-bytes time stamp and 4-bytes frame length\n      frameData: new Uint8Array(data, 12, data.byteLength - 12),\n      roll: 0\n    };\n  }\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the protocol protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {String} properties.foiId the foiId\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @param {Number} properties.customUrlParams.video_bitrate - define a custom bitrate (in b/s)\n   * @param {Number} properties.customUrlParams.video_scale - define a custom scale, 0.0 < value < 1.0\n   * @param {Number} properties.customUrlParams.video_width - define a custom width\n   * @param {Number} properties.customUrlParams.video_height - define a custom height\n   * @return {String} the full url\n   */\n\n\n  buildUrl(properties) {\n    let url = super.buildUrl(properties); // adds feature of interest urn\n\n    if (properties.foiId && properties.of !== '') {\n      url += '&featureOfInterest=' + properties.foiId;\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var SosGetResultVideo_parser = (SosGetResultVideo_parser_VideoParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/DataConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n/**\n * The DataConnector is the abstract class used to create different connectors.\n */\n\nclass DataConnector_DataConnector {\n  /**\n   * @param {String} url - The full url used to connect to the data stream\n   */\n  constructor(url, properties) {\n    this.url = url;\n    this.properties = properties;\n    this.id = \"DataConnector-\" + randomUUID();\n    this.reconnectTimeout = 1000 * 60 * 2; //2 min\n\n    this.status = Status.DISCONNECTED;\n    this.reconnectionInterval = -1;\n  }\n\n  checkAndClearReconnection() {\n    if (this.reconnectionInterval !== -1) {\n      clearInterval(this.reconnectionInterval);\n      this.reconnectionInterval = -1;\n    }\n  }\n\n  disconnect() {\n    this.checkStatus(Status.DISCONNECTED);\n    this.checkAndClearReconnection();\n  }\n  /**\n   * Sets the url\n   * @param url\n   */\n\n\n  setUrl(url) {\n    this.url = url;\n  }\n  /**\n   * The data protocol default id.\n   * @return {String}\n   */\n\n\n  getId() {\n    return this.id;\n  }\n  /**\n   * The stream url.\n   * @return {String}\n   */\n\n\n  getUrl() {\n    return this.url;\n  }\n  /**\n   * Sets the reconnection timeout\n   * @param {Number} timeout - delay in milliseconds before reconnecting dataSource\n   */\n\n\n  setReconnectTimeout(timeout) {\n    this.reconnectTimeout = timeout;\n  }\n\n  onReconnect() {\n    return true;\n  }\n\n  connect() {}\n\n  forceReconnect() {\n    this.disconnect();\n    this.connect();\n  }\n  /**\n   * Called when the connection STATUS changes\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {}\n  /**\n   * Check a change of the status and call the corresponding callbacks if necessary\n   * @param {Status} status - the currentStatus\n   */\n\n\n  checkStatus(status) {\n    if (status !== this.status) {\n      this.onChangeStatus(status);\n      this.status = status;\n    }\n  }\n  /**\n   * Called when the protocol has been disconnected\n   */\n\n\n  onDisconnect() {}\n  /**\n   * Called when the protocol has been connected\n   */\n\n\n  onConnect() {}\n\n}\n\n/* harmony default export */ var protocol_DataConnector = (DataConnector_DataConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/WebSocketConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the WebSocketConnector to connect to a remote server by creating a WebSocket channel.\n * @extends DataConnector\n * @example\n * import WebSocketConnector from 'osh-js/dataconnector/WebSocketConnector.js';\n *\n * let url = ...;\n * let connector = new WebSocketConnector(url);\n *\n * // connect\n * connector.connect();\n *\n * // disconnect\n * connector.disconnect();\n *\n * // close\n * connector.close();\n *\n */\n\nclass WebSocketConnector_WebSocketConnector extends protocol_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.interval = -1;\n    this.lastReceiveTime = 0;\n  }\n  /**\n   * Connect to the webSocket. If the system supports WebWorker, it will automatically creates one otherwise use\n   * the main thread.\n   */\n\n\n  async connect() {\n    if (!this.init) {\n      this.closed = false;\n      this.init = true; //creates Web Socket\n\n      this.ws = new WebSocket(this.getUrl());\n      this.ws.binaryType = 'arraybuffer';\n      this.checkStatus(Status.CONNECTING);\n      console.warn('WebSocket stream connecting');\n\n      this.ws.onopen = function (event) {\n        this.checkAndClearReconnection();\n        this.checkStatus(Status.CONNECTED);\n        console.warn('WebSocket stream connected');\n      }.bind(this);\n\n      this.ws.onmessage = function (event) {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        if (event.data.byteLength > 0) {\n          this.onMessage(event.data);\n        }\n      }.bind(this); // closes socket if any errors occur\n\n\n      this.ws.onerror = function (event) {\n        console.error('WebSocket stream error');\n        this.checkStatus(Status.CLOSED_ERROR);\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.createReconnection();\n      }.bind(this);\n\n      this.ws.onclose = event => {\n        console.warn('WebSocket stream closed: ', event.reason, event.code);\n\n        if (event.code !== 1000 && !this.closed) {\n          this.checkStatus(Status.CLOSED_ERROR);\n          this.createReconnection();\n        } else {\n          this.checkStatus(Status.DISCONNECTED);\n        }\n      };\n\n      if (this.reconnectionInterval !== -1) {\n        clearInterval(this.reconnectionInterval);\n        this.reconnectionInterval = -1;\n      }\n    }\n  }\n\n  createReconnection() {\n    if (!this.closed && this.reconnectionInterval === -1 && this.onReconnect()) {\n      this.reconnectionInterval = setInterval(function () {\n        let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n        if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n          console.warn('trying to reconnect', this.url);\n          this.init = false;\n          this.connect();\n        }\n      }.bind(this), this.reconnectTimeout);\n    }\n  }\n  /**\n   * Disconnects and close the websocket.\n   */\n\n\n  disconnect() {\n    super.disconnect();\n    this.init = false;\n    this.closed = true;\n\n    if (this.ws != null && this.ws.readyState !== WebSocket.CLOSED) {\n      this.ws.close();\n    }\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n\n  isConnected() {\n    return this.ws != null && this.ws.readyState === WebSocket.OPEN;\n  }\n\n}\n\n/* harmony default export */ var protocol_WebSocketConnector = (WebSocketConnector_WebSocketConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Ajax.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the AjaxConnector to connect to a remote server by making AjaxRequest.\n * @extends DataConnector\n * @example\n * import Ajax from 'core/protocol/Ajax.js';\n *\n * let request = ...;\n * let protocol = new Ajax(url);\n *\n * // handle onSuccess\n * protocol.onSuccess = function(event) {\n *  // does something\n * }\n *\n * protocol.onError = function(event) {\n *  // does something\n * }\n *\n * // send request\n * protocol.sendRequest(request);\n *\n */\n\nclass Ajax_Ajax extends protocol_DataConnector {\n  /**\n   * Creates Ajax.\n   * @param {String} url -\n   * @param {Object} properties -\n   * @param {String} properties.method -\n   * @param {String} properties.responseType -\n   */\n  constructor(url, properties) {\n    super(url);\n    this.method = \"POST\";\n    this.responseType = \"arraybuffer\";\n\n    if (isDefined(properties)) {\n      if (properties.method) {\n        this.method = properties.method;\n      }\n\n      if (properties.responseType) {\n        this.responseType = properties.responseType;\n      }\n    }\n  }\n  /**\n   * Sends the request to the defined server.\n   * @param {String} request - The Http request\n   * @param {String} extraUrl - get query parameters\n   */\n\n\n  sendRequest(request, extraUrl) {\n    let self = this;\n    let xmlhttp = new XMLHttpRequest();\n    xmlhttp.withCredentials = true;\n    xmlhttp.timeout = 60000;\n\n    if (request === null) {\n      if (isDefined(extraUrl)) {\n        xmlhttp.open(\"GET\", this.getUrl() + \"?\" + extraUrl, true);\n      } else {\n        xmlhttp.open(\"GET\", this.getUrl(), true);\n      }\n\n      xmlhttp.responseType = this.responseType;\n\n      xmlhttp.onload = oEvent => {\n        if (xmlhttp.response) {\n          self.onMessage(xmlhttp.response);\n        }\n\n        self.checkStatus(Status.DISCONNECTED);\n      };\n\n      xmlhttp.ontimeout = e => {\n        console.log(\"Timeout\");\n        self.checkStatus(Status.DISCONNECTED);\n      };\n\n      self.checkStatus(Status.CONNECTED);\n      xmlhttp.send(null);\n    } else {\n      xmlhttp.open(\"POST\", this.getUrl(), true);\n      xmlhttp.setRequestHeader('Content-Type', 'text/xml');\n      xmlhttp.send(request);\n      self.checkStatus(Status.CONNECTED);\n\n      xmlhttp.onreadystatechange = () => {\n        if (xmlhttp.readyState < 4) {// while waiting response from server\n        } else if (xmlhttp.readyState === 4) {\n          // 4 = Response from server has been completely loaded.\n          if (xmlhttp.status === 200 && xmlhttp.status < 300) {\n            // http status between 200 to 299 are all successful\n            self.onSuccess(xmlhttp.responseText);\n          } else {\n            self.onError(\"\");\n          }\n\n          self.checkStatus(Status.DISCONNECTED);\n        }\n      };\n    }\n  }\n  /**\n   * This is the callback method in case of getting error connection.\n   * @param event The error details\n   * @event\n   */\n\n\n  onError(event) {}\n  /**\n   * This is the callback method in case of getting success connection.\n   * @param event\n   * @event\n   */\n\n\n  onSuccess(event) {}\n  /**\n   * Sends the request\n   * @private\n   */\n\n\n  connect() {\n    this.sendRequest(null);\n  }\n\n  isConnected() {\n    return false;\n  }\n\n}\n\n/* harmony default export */ var protocol_Ajax = (Ajax_Ajax);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/TopicConnector.js\n\n/**\n * Defines the FileConnector to read a File content\n * @extends DataConnector\n * @example\n * import FileConnector from 'core/protocol/TopicConnector.js';\n *\n * let protocol = new TopicConnector(<topic_name>);\n *\n * // connect\n * protocol.connect();\n *\n * // disconnect\n * protocol.disconnect();\n *\n * // close\n * protocol.close();\n *\n */\n\nclass TopicConnector_TopicConnector extends protocol_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.lastReceiveTime = -1;\n    this.interval = -1;\n    this.broadcastChannel = null;\n  }\n  /**\n   * Connect to the broadcastChannel.\n   */\n\n\n  connect() {\n    if (this.broadcastChannel === null) {\n      //creates broadcastChannel\n      this.broadcastChannel = new BroadcastChannel(this.getUrl());\n\n      this.broadcastChannel.onmessage = event => {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        this.onMessage(event.data.data);\n      }; // closes socket if any errors occur\n\n\n      this.broadcastChannel.onerror = event => {\n        console.error('BroadcastChannel stream error: ' + event);\n        this.broadcastChannel.close();\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.opened = false;\n      };\n\n      this.opened = true; //init the reconnect handler\n\n      if (this.interval === -1) {\n        this.interval = setInterval(function () {\n          let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n          if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n            console.warn(`trying to reconnect after ${this.reconnectTimeout} ..`);\n            this.reconnect();\n          }\n        }.bind(this), this.reconnectTimeout);\n      }\n    }\n  }\n  /**\n   * Disconnects the websocket.\n   */\n\n\n  disconnect() {\n    this.fullDisconnect(true);\n  }\n  /**\n   * Fully disconnect the websocket connection by sending a close message to the webWorker.\n   * @param {Boolean} removeInterval  - force removing the interval\n   */\n\n\n  fullDisconnect(removeInterval) {\n    if (this.broadcastChannel != null) {\n      this.broadcastChannel.close();\n      this.broadcastChannel = null;\n    }\n\n    if (removeInterval) {\n      clearInterval(this.interval);\n    }\n\n    this.opened = false;\n  }\n  /**\n   * Try to reconnect if the connexion if closed\n   */\n\n\n  reconnect() {\n    this.onReconnect();\n\n    if (this.init) {\n      this.fullDisconnect(false);\n    }\n\n    this.connect();\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n  /**\n   * Closes the webSocket.\n   */\n\n\n  close() {\n    this.disconnect();\n  }\n\n  isConnected() {\n    return this.broadcastChannel !== null && this.opened;\n  }\n\n}\n\n/* harmony default export */ var protocol_TopicConnector = (TopicConnector_TopicConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/workers/DataSourceHandler.js\n\n\n\n\n\n\n\nclass DataSourceHandler_DataSourceHandler {\n  constructor(parser) {\n    this.parser = parser;\n    this.connector = null;\n    this.reconnectTimeout = 1000 * 10; // 10 secs\n\n    this.values = [];\n    this.version = -Number.MAX_SAFE_INTEGER;\n  }\n\n  init(propertiesStr, topic, dataSourceId) {\n    this.dataSourceId = dataSourceId; // check for existing protocol\n\n    if (this.connector !== null) {\n      this.connector.disconnect();\n      this.connector = null;\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    const properties = JSON.parse(propertiesStr);\n    this.handleProperties(properties);\n    this.createDataConnector(this.properties);\n  }\n\n  handleProperties(properties) {\n    if (isDefined(properties.bufferingTime)) {\n      this.bufferingTime = properties.bufferingTime;\n    }\n\n    if (isDefined(properties.timeOut)) {\n      this.timeOut = properties.timeOut;\n    }\n\n    if (isDefined(properties.reconnectTimeout)) {\n      this.reconnectTimeout = properties.reconnectTimeout;\n    }\n\n    this.properties = properties;\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    const url = this.parser.buildUrl(properties); // checks if type is WebSocketConnector\n\n    if (properties.protocol.startsWith('ws')) {\n      // for wss\n      this.connector = new protocol_WebSocketConnector(url);\n    } else if (properties.protocol.startsWith('http')) {\n      //for https\n      this.connector = new protocol_Ajax(url);\n      this.connector.responseType = properties.responseType || 'arraybuffer';\n    } else if (properties.protocol === 'topic') {\n      this.connector = new protocol_TopicConnector(url);\n    }\n\n    if (this.connector !== null) {\n      // set the reconnectTimeout\n      this.connector.setReconnectTimeout(this.reconnectTimeout); // connects the callback\n\n      this.connector.onMessage = this.onMessage.bind(this); // bind change connection STATUS\n\n      this.connector.onChangeStatus = this.onChangeStatus.bind(this);\n    }\n  }\n  /**\n   * Sets the current topic to listen\n   * @param {String} topic - the topic to listen\n   */\n\n\n  setTopic(topic) {\n    if (isDefined(this.broadcastChannel)) {\n      this.broadcastChannel.close();\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    this.topic = topic;\n  }\n\n  connect() {\n    if (this.connector !== null) {\n      this.connector.connect();\n    }\n  }\n\n  disconnect() {\n    if (this.connector !== null) {\n      this.connector.disconnect();\n    }\n  }\n\n  async onMessage(event) {\n    const data = await Promise.resolve(this.parser.parseData(event)); // check if data is array\n\n    if (Array.isArray(data)) {\n      for (let i = 0; i < data.length; i++) {\n        this.values.push({\n          data: data[i],\n          version: this.version\n        });\n\n        if (isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n          this.flush();\n        }\n      }\n    } else {\n      this.values.push({\n        data: data,\n        version: this.version\n      });\n    } // because parseData is ASYNC, the protocol can finish before the parsing method. In that case, we have to flushALl data\n\n\n    if (!this.isConnected()) {\n      this.flushAll();\n    } else if (isDefined(this.batchSize) && this.values.length !== 0 && this.values.length >= this.batchSize) {\n      this.flush();\n    }\n  }\n  /**\n   * Send a change status event into the broadcast channel\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {\n    if (status === Status.DISCONNECTED) {\n      this.flushAll();\n    }\n\n    this.broadcastChannel.postMessage({\n      type: EventType.STATUS,\n      status: status,\n      dataSourceId: this.dataSourceId\n    });\n  }\n\n  updateProperties(properties) {\n    this.disconnect();\n    this.createDataConnector({ ...this.properties,\n      ...properties\n    });\n    this.version++;\n    this.connect();\n  }\n\n  flushAll() {\n    while (this.values.length > 0) {\n      this.flush();\n    }\n  }\n\n  flush() {\n    let nbElements = this.values.length;\n\n    if (isDefined(this.batchSize) && this.values.length > this.batchSize) {\n      nbElements = this.batchSize;\n    }\n\n    this.broadcastChannel.postMessage({\n      dataSourceId: this.dataSourceId,\n      type: EventType.DATA,\n      values: this.values.splice(0, nbElements)\n    });\n  }\n\n  isConnected() {\n    return this.connector === null ? false : this.connector.isConnected();\n  }\n\n  handleMessage(message, worker) {\n    if (message.message === 'init') {\n      this.init(message.properties, message.topic, message.id);\n    } else if (message.message === 'connect') {\n      this.connect();\n    } else if (message.message === 'disconnect') {\n      this.disconnect();\n    } else if (message.message === 'topic') {\n      this.setTopic(message.topic);\n    } else if (message.message === 'update-url') {\n      this.updateProperties(message.data);\n    } else if (message.message === 'is-connected') {\n      worker.postMessage({\n        message: 'is-connected',\n        data: this.isConnected()\n      });\n    }\n  }\n\n}\n\n/* harmony default export */ var workers_DataSourceHandler = (DataSourceHandler_DataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/workers/TimeSeriesDataSourceHandler.js\n\n\n\n\nclass TimeSeriesDataSourceHandler_TimeSeriesDataSourceHandler extends workers_DataSourceHandler {\n  constructor(parser) {\n    super(parser);\n    this.lastTimeStamp = null;\n    this.lastStartTime = 'now';\n    this.timeShift = 0;\n    this.timeBroadcastChannel = null;\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    super.createDataConnector({ ...properties,\n      timeShift: this.timeShift\n    });\n    const lastStartTimeCst = this.parser.lastStartTime;\n\n    this.connector.onReconnect = () => {\n      // if not real time, preserve last timestamp to reconnect at the last time received\n      // for that, we update the URL with the new last time received\n      if (lastStartTimeCst !== 'now') {\n        this.connector.setUrl(this.parser.buildUrl({ ...properties,\n          lastTimeStamp: isDefined(this.lastTimeStamp) ? new Date(this.lastTimeStamp).toISOString() : properties.startTime\n        }));\n      }\n\n      return true;\n    };\n  }\n\n  handleProperties(properties) {\n    super.handleProperties(properties);\n\n    if (isDefined(properties.timeShift)) {\n      this.timeShift = properties.timeShift;\n    }\n\n    if (properties.startTime === 'now') {\n      this.batchSize = 1;\n    } else {\n      if (isDefined(properties.replaySpeed)) {\n        if (!isDefined(properties.batchSize)) {\n          this.batchSize = 1;\n        }\n      }\n\n      if (isDefined(properties.batchSize)) {\n        this.batchSize = properties.batchSize;\n      }\n    }\n  }\n\n  async onMessage(event) {\n    const timeStamp = await Promise.resolve(this.parser.parseTimeStamp(event) + this.timeShift);\n    const data = await Promise.resolve(this.parser.parseData(event)); // check if data is array\n\n    if (Array.isArray(data)) {\n      for (let i = 0; i < data.length; i++) {\n        this.values.push({\n          data: data[i],\n          timeStamp: timeStamp,\n          version: this.version\n        });\n      }\n    } else {\n      this.values.push({\n        data: data,\n        timeStamp: timeStamp,\n        version: this.version\n      });\n    }\n\n    this.lastTimeStamp = timeStamp;\n\n    if (this.parser.lastStartTime === 'now' || isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n      this.flush();\n\n      if (this.timeBroadcastChannel !== null) {\n        this.timeBroadcastChannel.postMessage({\n          timestamp: this.lastTimeStamp\n        });\n      }\n    }\n  }\n\n  getLastTimeStamp() {\n    return this.lastTimeStamp;\n  }\n\n  updateProperties(properties) {\n    this.disconnect();\n    this.timeBroadcastChannel.postMessage({\n      dataSourceId: this.dataSourceId,\n      type: EventType.TIME_CHANGED\n    });\n    let lastTimestamp = new Date(this.lastTimeStamp).toISOString();\n\n    if (properties.hasOwnProperty('startTime')) {\n      lastTimestamp = properties.startTime;\n    } else if (this.properties.startTime === 'now') {\n      //handle RealTime\n      lastTimestamp = 'now';\n    }\n\n    this.version++;\n    this.createDataConnector({ ...this.properties,\n      ...properties,\n      lastTimeStamp: lastTimestamp\n    });\n\n    if (isDefined(properties) && isDefined(properties.reconnect) && properties.reconnect) {\n      this.connect();\n    }\n  }\n\n  handleMessage(message, worker) {\n    super.handleMessage(message, worker);\n\n    if (message.message === 'last-timestamp') {\n      const lastTimeStamp = this.getLastTimeStamp();\n      worker.postMessage({\n        message: 'last-timestamp',\n        data: lastTimeStamp\n      });\n    } else if (message.message === 'topic') {\n      this.setTimeTopic(message.timeTopic);\n      super.setTopic(message.topic);\n    }\n  }\n\n  setTimeTopic(timeTopic) {\n    if (this.timeBroadcastChannel !== null) {\n      this.timeBroadcastChannel.close();\n    }\n\n    this.timeBroadcastChannel = new BroadcastChannel(timeTopic);\n  }\n\n}\n\n/* harmony default export */ var workers_TimeSeriesDataSourceHandler = (TimeSeriesDataSourceHandler_TimeSeriesDataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/workers/SosGetResultVideo.worker.js\n\n\n\nconst dataSourceHandler = new workers_TimeSeriesDataSourceHandler(new SosGetResultVideo_parser());\n\nself.onmessage = (event) => {\n    dataSourceHandler.handleMessage(event.data, self);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2RhdGFzb3VyY2UvcGFyc2Vycy9EYXRhU291cmNlUGFyc2VyLmpzP2NmYWYiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS9wYXJzZXJzL1RpbWVTZXJpZXNQYXJzZXIucGFyc2VyLmpzPzM0MjUiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS9wYXJzZXJzL1Nvc0dldFJlc3VsdFZpZGVvLnBhcnNlci5qcz85ZWM3Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL1N0YXR1cy5qcz84ODhhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL0RhdGFDb25uZWN0b3IuanM/ZTFmZCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9wcm90b2NvbC9XZWJTb2NrZXRDb25uZWN0b3IuanM/MjFkZSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9wcm90b2NvbC9BamF4LmpzP2U0MmQiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvcHJvdG9jb2wvVG9waWNDb25uZWN0b3IuanM/Zjk1MSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9ldmVudC9FdmVudFR5cGUuanM/OWUzMCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9kYXRhc291cmNlL3dvcmtlcnMvRGF0YVNvdXJjZUhhbmRsZXIuanM/YmNhZSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9kYXRhc291cmNlL3dvcmtlcnMvVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyLmpzPzIwODEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZGF0YXNvdXJjZS93b3JrZXJzL1Nvc0dldFJlc3VsdFZpZGVvLndvcmtlci5qcz85MzBjIl0sIm5hbWVzIjpbIk1BWF9MT05HIiwiTWF0aCIsInBvdyIsImlzRGVmaW5lZCIsInYiLCJoYXNWYWx1ZSIsImhleDJyZ2IiLCJoZXgiLCJyIiwiZyIsImIiLCJtYXRjaCIsIm1hcCIsIngiLCJwYXJzZUludCIsImhhc1R5cGUiLCJleHBlY3RlZFR5cGUiLCJoYXNWYWwiLCJpc09iamVjdCIsImxldE5hbWUiLCJpc0FycmF5IiwiQXJyYXkiLCJpc0Z1bmN0aW9uIiwiYXNzZXJ0RGVmaW5lZCIsImFzc2VydFRydWUiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdGFtcFVVSUQiLCJvYmoiLCJfb3NoX2lkIiwiUGFyc2VCeXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsInR5cGUiLCJ2aWV3IiwiRGF0YVZpZXciLCJ0eXBlTWFwIiwiZG91YmxlIiwidmFsIiwiZ2V0RmxvYXQ2NCIsImJ5dGVzIiwiZmxvYXQ2NCIsImZsb2F0MzIiLCJnZXRGbG9hdDMyIiwic2lnbmVkQnl0ZSIsImdldEludDgiLCJzaWduZWRJbnQiLCJnZXRJbnQzMiIsInNpZ25lZFNob3J0IiwiZ2V0SW50MTYiLCJ1bnNpZ25lZEJ5dGUiLCJnZXRVaW50OCIsInVuc2lnbmVkSW50IiwiZ2V0VWludDMyIiwidW5zaWduZWRTaG9ydCIsImdldFVpbnQxNiIsIlJlYWREYXRhIiwic3RydWN0IiwiZGF0YSIsIm9mZnNldEJ5dGVzIiwiaSIsImZpZWxkcyIsImxlbmd0aCIsImN1cnJGaWVsZFN0cnVjdCIsInJldCIsImNvdW50IiwiaXNOYU4iLCJpZCIsImZpZWxkTmFtZSIsImlkMkZpZWxkTWFwIiwiZmluZEZpZWxkQnlOYW1lIiwiaiIsImZpZWxkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHVzaCIsIkdldFJlc3VsdE9iamVjdCIsInJlc3VsdFN0cnVjdHVyZSIsInJlc3VsdCIsIm5hbWUiLCJpdGVtIiwiayIsImlzT3BlcmEiLCJ3aW5kb3ciLCJvcHIiLCJhZGRvbnMiLCJvcGVyYSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkhUTUxFbGVtZW50IiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJ3ZWJzdG9yZSIsImlzQmxpbmsiLCJDU1MiLCJpc0FycmF5SW50ZXJzZWN0IiwiYSIsImZpbHRlciIsImVsZW1lbnQiLCJpc0VsZW1lbnQiLCJvIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzV2ViV29ya2VyIiwiV29ya2VyIiwidGFrZVNjcmVlblNob3QiLCJkaXYiLCJyZW1vdmVDc3MiLCJjc3MiLCJkaXZDc3MiLCJjbGFzc05hbWUiLCJhZGRDc3MiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVMYXN0Q2hhcklmRXhpc3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwicm91bmRIYWxmIiwibnVtIiwicm91bmQiLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwiaW1tZWRpYXRlIiwidGltZW91dCIsImFyZ3MiLCJjb250ZXh0IiwidGltZXN0YW1wIiwibGF0ZXIiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImxhc3QiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjYWxsTm93IiwidGhyb3R0bGUiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJjdHgiLCJwcmV2aW91cyIsInJlbWFpbmluZyIsImNsZWFyVGltZW91dCIsIm1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwia2V5Iiwia2V5cyIsImFzc2lnbiIsInJnYmFUb0FycmF5Iiwic3RyIiwic3RhcnRJZHhWYWx1ZSIsImVuZElkeFZhbHVlIiwidmFsdWVzIiwic3Vic3RyIiwic3BsaXQiLCJOdW1iZXIiLCJEYXRhU291cmNlUGFyc2VyIiwiYnVpbGRVcmwiLCJwcm9wZXJ0aWVzIiwidXJsIiwicHJvdG9jb2wiLCJlbmRwb2ludFVybCIsInNlcnZpY2UiLCJyZXNwb25zZUZvcm1hdCIsImN1c3RvbVVybFBhcmFtcyIsInNsaWNlIiwiVGltZVNlcmllc1BhcnNlclBhcnNlciIsIm9mZmVyaW5nSUQiLCJvYnNlcnZlZFByb3BlcnR5Iiwic3RUaW1lIiwibGFzdFRpbWVTdGFtcCIsInN0YXJ0VGltZSIsImxhc3RTdGFydFRpbWUiLCJlbmRUaW1lIiwicmVwbGF5U3BlZWQiLCJWaWRlb1BhcnNlciIsIlRpbWVTZXJpZXNQYXJzZXIiLCJwYXJzZVRpbWVTdGFtcCIsInBhcnNlRGF0YSIsImZyYW1lRGF0YSIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwicm9sbCIsImZvaUlkIiwib2YiLCJTdGF0dXMiLCJDT05ORUNUSU5HIiwiQ09OTkVDVEVEIiwiRElTQ09OTkVDVEVEIiwiQ0xPU0VEX0VSUk9SIiwiRGF0YUNvbm5lY3RvciIsImNvbnN0cnVjdG9yIiwicmVjb25uZWN0VGltZW91dCIsInN0YXR1cyIsInJlY29ubmVjdGlvbkludGVydmFsIiwiY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbiIsImNsZWFySW50ZXJ2YWwiLCJkaXNjb25uZWN0IiwiY2hlY2tTdGF0dXMiLCJzZXRVcmwiLCJnZXRJZCIsImdldFVybCIsInNldFJlY29ubmVjdFRpbWVvdXQiLCJvblJlY29ubmVjdCIsImNvbm5lY3QiLCJmb3JjZVJlY29ubmVjdCIsIm9uQ2hhbmdlU3RhdHVzIiwib25EaXNjb25uZWN0Iiwib25Db25uZWN0IiwiV2ViU29ja2V0Q29ubmVjdG9yIiwiaW50ZXJ2YWwiLCJsYXN0UmVjZWl2ZVRpbWUiLCJpbml0IiwiY2xvc2VkIiwid3MiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwiY29uc29sZSIsIndhcm4iLCJvbm9wZW4iLCJldmVudCIsImJpbmQiLCJvbm1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJvbmVycm9yIiwiZXJyb3IiLCJjcmVhdGVSZWNvbm5lY3Rpb24iLCJvbmNsb3NlIiwicmVhc29uIiwiY29kZSIsInNldEludGVydmFsIiwiZGVsdGEiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwiY2xvc2UiLCJpc0Nvbm5lY3RlZCIsIk9QRU4iLCJBamF4IiwibWV0aG9kIiwicmVzcG9uc2VUeXBlIiwic2VuZFJlcXVlc3QiLCJyZXF1ZXN0IiwiZXh0cmFVcmwiLCJzZWxmIiwieG1saHR0cCIsIlhNTEh0dHBSZXF1ZXN0Iiwid2l0aENyZWRlbnRpYWxzIiwib3BlbiIsIm9ubG9hZCIsIm9FdmVudCIsInJlc3BvbnNlIiwib250aW1lb3V0IiwiZSIsImxvZyIsInNlbmQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwib25TdWNjZXNzIiwicmVzcG9uc2VUZXh0Iiwib25FcnJvciIsIlRvcGljQ29ubmVjdG9yIiwiYnJvYWRjYXN0Q2hhbm5lbCIsIkJyb2FkY2FzdENoYW5uZWwiLCJvcGVuZWQiLCJyZWNvbm5lY3QiLCJmdWxsRGlzY29ubmVjdCIsInJlbW92ZUludGVydmFsIiwiRXZlbnRUeXBlIiwiREFUQSIsIlNUQVRVUyIsIlRJTUVfQ0hBTkdFRCIsIkRhdGFTb3VyY2VIYW5kbGVyIiwicGFyc2VyIiwiY29ubmVjdG9yIiwidmVyc2lvbiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJwcm9wZXJ0aWVzU3RyIiwidG9waWMiLCJkYXRhU291cmNlSWQiLCJoYW5kbGVQcm9wZXJ0aWVzIiwiY3JlYXRlRGF0YUNvbm5lY3RvciIsImJ1ZmZlcmluZ1RpbWUiLCJ0aW1lT3V0Iiwic3RhcnRzV2l0aCIsInNldFRvcGljIiwiUHJvbWlzZSIsInJlc29sdmUiLCJiYXRjaFNpemUiLCJmbHVzaCIsImZsdXNoQWxsIiwicG9zdE1lc3NhZ2UiLCJ1cGRhdGVQcm9wZXJ0aWVzIiwibmJFbGVtZW50cyIsInNwbGljZSIsImhhbmRsZU1lc3NhZ2UiLCJtZXNzYWdlIiwid29ya2VyIiwiVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyIiwidGltZVNoaWZ0IiwidGltZUJyb2FkY2FzdENoYW5uZWwiLCJsYXN0U3RhcnRUaW1lQ3N0IiwidG9JU09TdHJpbmciLCJ0aW1lU3RhbXAiLCJnZXRMYXN0VGltZVN0YW1wIiwibGFzdFRpbWVzdGFtcCIsImhhc093blByb3BlcnR5Iiwic2V0VGltZVRvcGljIiwidGltZVRvcGljIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QU1PLElBQUk2SCxPQUFPLENBQUNBLE9BQVIsS0FBb0IsT0FBeEIsRUFBaUM7QUFDcEMsV0FBS1csWUFBTCxDQUFrQlgsT0FBTyxDQUFDWSxTQUExQjtBQUNBLFlBQU12QixRQUFOLENBQWVXLE9BQU8sQ0FBQ2xCLEtBQXZCO0FBQ0g7QUFDSjs7QUFFRDZCLGNBQVksQ0FBQ0MsU0FBRCxFQUFZO0FBQ3BCLFFBQUcsS0FBS1Isb0JBQUwsS0FBOEIsSUFBakMsRUFBdUM7QUFDbkMsV0FBS0Esb0JBQUwsQ0FBMEJqRSxLQUExQjtBQUNIOztBQUNELFNBQUtpRSxvQkFBTCxHQUE0QixJQUFJckMsZ0JBQUosQ0FBcUI2QyxTQUFyQixDQUE1QjtBQUNIOztBQTdJc0Q7O0FBK0k1Q1YsK0hBQWYsRTs7QUNuSjZFO0FBQ0w7O0FBRXhFLDhCQUE4QixtQ0FBMkIsS0FBSyx3QkFBdUI7O0FBRXJGO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiogKiBAbW9kdWxlIFV0aWxzICovXG5cbi8qKiBNYXhpbXVtIHZhbHVlIG9mIGEgbG9uZyAqL1xuZXhwb3J0IGNvbnN0IE1BWF9MT05HID0gTWF0aC5wb3coMiwgNTMpICsgMTtcblxuLyoqXG4gKiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodikge1xuICAgIHJldHVybiB0eXBlb2YgKHYpICE9PSAndW5kZWZpbmVkJyAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBoYXMgYSB2YWx1ZSxcbiB0aGF0IGlzIGl0IGlzIGRlZmluZWQgYW5kIG5vbiBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gaGV4IGNvbG9yIGludG8gUkdCQVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4MnJnYihoZXgpe1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleC5tYXRjaCgvXFx3XFx3L2cpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDE2KSk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIG9mIGEgcGFydGljdWxhciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNUeXBlKHYsIGV4cGVjdGVkVHlwZSkge1xuICAgIGxldCBoYXNWYWwgPSBoYXNWYWx1ZSh2KTtcbiAgICByZXR1cm4gaGFzVmFsICYmIHR5cGVvZiAodikgPT09IGV4cGVjdGVkVHlwZTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFRydWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2KSB8fCAhdikge1xuICAgICAgICB0aHJvdyBsZXROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUodiwgZXhwZWN0ZWRUeXBlLCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKHR5cGVvZiAodikgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBvZiB0eXBlIFwiICsgZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Jvb2xlYW4nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnc3RyaW5nJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ251bWJlcicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZSh2LCBsZXROYW1lKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpO1xuICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIjtcbiAgICB9XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNWYWx1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFoYXNWYWx1ZSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBub3QgYmUgbnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgteHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFtcHMvZW1iZWRzIGEgVVVJRCBpbnRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgVVVJRCBnZW5lcmF0ZWQgZm9yIGl0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFtcFVVSUQob2JqKSB7XG4gICAgb2JqLl9vc2hfaWQgPSBvYmouX29zaF9pZCB8fCByYW5kb21VVUlEKCk7XG4gICAgcmV0dXJuIG9iai5fb3NoX2lkO1xufVxuXG4vL2J1ZmZlciBpcyBhbiBBcnJheUJ1ZmZlciBvYmplY3QsIHRoZSBvZmZzZXQgaWYgc3BlY2lmaWVkIGluIGJ5dGVzLCBhbmQgdGhlIHR5cGUgaXMgYSBzdHJpbmdcbi8vY29ycmVzcG9uZGluZyB0byBhbiBPR0MgZGF0YSB0eXBlLlxuLy9TZWUgaHR0cDovL2RlZi5zZWVncmlkLmNzaXJvLmF1L3Npc3N2b2Mvb2djLWRlZi9yZXNvdXJjZT91cmk9aHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvZGF0YVR5cGUvT0dDLzAvXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyXG4gKiBAcGFyYW0gb2Zmc2V0XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlQnl0ZXMoYnVmZmVyLCBvZmZzZXQsIHR5cGUpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXG4gICAgLy9Ob3RlOiBUaGVyZSBleGlzdCB0eXBlcyBub3QgbGlzdGVkIGluIHRoZSBtYXAgYmVsb3cgdGhhdCBoYXZlIE9HQyBkZWZpbml0aW9ucywgYnV0IG5vIGFwcHJvcHJpYXRlXG4gICAgLy9tZXRob2RzIG9yIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXZhaWxhYmxlIGZvciBwYXJzaW5nIGluIGphdmFzY3JpcHQuIFRoZXkgYXJlIGZsb2F0MTI4LCBmbG9hdDE2LCBzaWduZWRMb25nLFxuICAgIC8vYW5kIHVuc2lnbmVkTG9uZ1xuICAgIGxldCB0eXBlTWFwID0ge1xuICAgICAgICBkb3VibGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDY0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQzMjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICAvL1RPRE86IHN0cmluZy11dGYtODpcbiAgICB9O1xuICAgIHJldHVybiB0eXBlTWFwW3R5cGVdKG9mZnNldCk7XG59XG5cbi8vVGhpcyBmdW5jdGlvbiByZWN1cnNpdmxleSBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRTdHJ1Y3R1cmUgdG8gZmlsbCBpblxuLy92YWx1ZXMgcmVhZCBmcm9tIGRhdGEgd2hpY2ggc2hvdWxkIGJlIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBheWxvYWQgZnJvbSBhIHdlYnNvY2tldFxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXRCeXRlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWREYXRhKHN0cnVjdCwgZGF0YSwgb2Zmc2V0Qnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gb2Zmc2V0Qnl0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyRmllbGRTdHJ1Y3QgPSBzdHJ1Y3QuZmllbGRzW2ldO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC50eXBlKSAmJiBjdXJyRmllbGRTdHJ1Y3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IFBhcnNlQnl0ZXMoZGF0YSwgb2Zmc2V0LCBjdXJyRmllbGRTdHJ1Y3QudHlwZSk7XG4gICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsID0gcmV0LnZhbDtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQuYnl0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkgJiYgY3VyckZpZWxkU3RydWN0LmNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGNvdW50IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgbGV0aWFibGVcbiAgICAgICAgICAgIGlmIChpc05hTihjdXJyRmllbGRTdHJ1Y3QuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gY3VyckZpZWxkU3RydWN0LmNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzdHJ1Y3QuaWQyRmllbGRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC5jb3VudCA9IHN0cnVjdC5maW5kRmllbGRCeU5hbWUoZmllbGROYW1lKS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJGaWVsZFN0cnVjdC5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyRmllbGRTdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3VyckZpZWxkU3RydWN0LmZpZWxkc1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBSZWFkRGF0YShmaWVsZCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbC5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlc3VsdFN0cnVjdHVyZVxuICogQHJldHVybiB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRSZXN1bHRPYmplY3QocmVzdWx0U3RydWN0dXJlKSB7XG4gICAgLy9UT0RPOiBoYW5kbGUgY2FzZXMgZm9yIG5lc3RlZCBhcnJheXMgLyBtYXRyaXggZGF0YSB0eXBlc1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xuICAgIHJldHVybiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Knxib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCbGluaygpIHtcbiAgICByZXR1cm4gKGlzQ2hyb21lIHx8IGlzT3BlcmEpICYmICEhd2luZG93LkNTUztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUludGVyc2VjdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG4gICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiBpc0RlZmluZWQoV29ya2VyKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRpdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVNjcmVlblNob3QoZGl2KSB7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3NzIGNsYXNzIGZyb20gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3NzKGRpdiwgY3NzKSB7XG4gICAgbGV0IGRpdkNzcyA9IGRpdi5jbGFzc05hbWU7XG4gICAgY3NzID0gZGl2Q3NzLnJlcGxhY2UoY3NzLCBcIlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gY3NzO1xufVxuXG5cbi8qKlxuICogQWRkIGEgY3NzIGNsYXNzIHRvIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byBhZGQgdGhlIGNsYXNzIHRvXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDc3MoZGl2LCBjc3MpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGl2LmNsYXNzTmFtZSArIFwiIFwiICsgY3NzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHtzdHJpbmd9IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbnB1dCB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgd2l0aG91dCB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxhc3RDaGFySWZFeGlzdCh2YWx1ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHVuZGVmaW5lZCkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8ICF2YWx1ZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5cbi8qKlxuICogUm91bmQgb2ZmIG51bWJlciB0byBuZWFyZXN0IDAuNVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gcm91bmQgb2ZmXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRIYWxmKG51bSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSoyKS8yO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLFxuICogd2lsbCBub3QgYmUgZXhlY3V0ZWQuIFRoZSBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgd2hlblxuICogaXQgd2lsbCBzdG9wIGJlaW5nIGNhbGxlZCBmb3IgbW9yZSB0aGFuIE4gbWlsbGlzZWNvbmRzLlxuICogSWYgdGhlIGBpbW1lZGlhdGVgIHBhcmFtZXRlciBpcyB0cnVlLCB0aGVuIHRoZSBmdW5jdGlvblxuICogd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgZmlyc3QgY2FsbCBpbnN0ZWFkIG9mIHRoZSBsYXN0LlxuICogUGFyYW1ldGVycyA6XG4gKiAtIGZ1bmM6IHRoZSBmdW5jdGlvbiB0byBgZGVib3VuY2VyYC5cbiAqIC0gd2FpdDogdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgKE4pIHRvIHdhaXQgYmVmb3JlXG4gKiBjYWxsIGZ1bmMoKVxuICogLSBpbW1lZGlhdGUgKG9wdGlvbmFsKTogQ2FsbCBmdW5jKCkgYXQgdGhlIGZpcnN0IGludm9jYXRpb25cbiAqIGluc3RlYWQgb2YgdGhlIGxhc3Qgb25lIChEZWZhdWx0IGZhbHNlKVxuICogLSBjb250ZXh0IChvcHRpb25hbCk6IHRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGNhbGwgZnVuYygpXG4gKiAodGhpcyBieSBkZWZhdWx0KVxuICovXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbGFzdCA9IG5vdyAtIHRpbWVzdGFtcDtcblxuICAgICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgbGVhZGluZywgdHJhaWxpbmcsIGNvbnRleHQpIHtcbiAgICB2YXIgY3R4LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZTtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiAhbGVhZGluZykgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgY3R4ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgdHJhaWxpbmcpIHtcbiAgICAgICAgICAgIC8vIFNpbm9uIG9uIHPigJllbmRvcnQgcGVuZGFudCBsZSB0ZW1wcyByZXN0YW50XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UgKHRhcmdldCwgc291cmNlKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGBzb3VyY2VgIHByb3BlcnRpZXMgYW5kIGlmIGFuIGBPYmplY3RgIHNldCBwcm9wZXJ0eSB0byBtZXJnZSBvZiBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgcHJvcGVydGllc1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgT2JqZWN0ICYmIGtleSBpbiB0YXJnZXQpIE9iamVjdC5hc3NpZ24oc291cmNlW2tleV0sIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpXG4gICAgfVxuXG4gICAgLy8gSm9pbiBgdGFyZ2V0YCBhbmQgbW9kaWZpZWQgYHNvdXJjZWBcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCB8fCB7fSwgc291cmNlKVxuICAgIHJldHVybiB0YXJnZXRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9BcnJheShzdHIpIHtcbiAgICBsZXQgc3RhcnRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcoJykgKyAxO1xuICAgIGxldCBlbmRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgbGV0IHZhbHVlcyA9IHN0ci5zdWJzdHIoc3RhcnRJZHhWYWx1ZSwgZW5kSWR4VmFsdWUtc3RhcnRJZHhWYWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xufVxuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlsc1wiO1xuXG5jbGFzcyBEYXRhU291cmNlUGFyc2VyIHtcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgZnVsbCB1cmwuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMucHJvdG9jb2wgdGhlIHByb3RvY29sIHByb3RvY29sXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgdGhlIGVuZHBvaW50IHVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnNlcnZpY2UgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5vZmZlcmluZ0lEIHRoZSBvZmZlcmluZ0lEXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2JzZXJ2ZWRQcm9wZXJ0eSB0aGUgb2JzZXJ2ZWQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5yZXNwb25zZUZvcm1hdCB0aGUgcmVzcG9uc2UgZm9ybWF0IChlLmcgdmlkZW8vbXA0KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcyAtIHRoZSBlbmNvZGluZyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX2JpdHJhdGUgLSBkZWZpbmUgYSBjdXN0b20gYml0cmF0ZSAoaW4gYi9zKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb19zY2FsZSAtIGRlZmluZSBhIGN1c3RvbSBzY2FsZSwgMC4wIDwgdmFsdWUgPCAxLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9fd2lkdGggLSBkZWZpbmUgYSBjdXN0b20gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9faGVpZ2h0IC0gZGVmaW5lIGEgY3VzdG9tIGhlaWdodFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGZ1bGwgdXJsXG4gICAgICovXG4gICAgYnVpbGRVcmwocHJvcGVydGllcykge1xuICAgICAgICBsZXQgdXJsID0gXCJcIjtcblxuICAgICAgICAvLyBhZGRzIHByb3RvY29sXG4gICAgICAgIHVybCArPSBwcm9wZXJ0aWVzLnByb3RvY29sICsgXCI6Ly9cIjtcblxuICAgICAgICAvLyBhZGRzIGVuZHBvaW50IHVybFxuICAgICAgICB1cmwgKz0gcHJvcGVydGllcy5lbmRwb2ludFVybCArIFwiP1wiO1xuXG4gICAgICAgIC8vIGFkZHMgc2VydmljZVxuICAgICAgICB1cmwgKz0gXCJzZXJ2aWNlPVwiICsgcHJvcGVydGllcy5zZXJ2aWNlO1xuXG4gICAgICAgIC8vIGFkZHMgdmVyc2lvblxuICAgICAgICB1cmwgKz0gXCImdmVyc2lvbj0yLjAmXCI7XG5cbiAgICAgICAgLy8gYWRkcyByZXNwb25zZUZvcm1hdCAob3B0aW9uYWwpXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnJlc3BvbnNlRm9ybWF0KSB7XG4gICAgICAgICAgICB1cmwgKz0gXCImcmVzcG9uc2VGb3JtYXQ9XCIgKyBwcm9wZXJ0aWVzLnJlc3BvbnNlRm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaXNEZWZpbmVkKHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zKSAmJiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXJsICs9ICcmJztcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHVybCArPSBrZXkrJz0nK3Byb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zW2tleV0rJyYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodXJsLmVuZHNXaXRoKCcmJykpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU291cmNlUGFyc2VyO1xuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlsc1wiO1xuaW1wb3J0IERhdGFTb3VyY2VQYXJzZXIgZnJvbSBcIi4vRGF0YVNvdXJjZVBhcnNlclwiO1xuXG5jbGFzcyBUaW1lU2VyaWVzUGFyc2VyUGFyc2VyIGV4dGVuZHMgRGF0YVNvdXJjZVBhcnNlciB7XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGZ1bGwgdXJsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnByb3RvY29sIHRoZSBwcm90b2NvbCBwcm90b2NvbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZHBvaW50VXJsIHRoZSBlbmRwb2ludCB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zZXJ2aWNlIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2ZmZXJpbmdJRCB0aGUgb2ZmZXJpbmdJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHkgdGhlIG9ic2VydmVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuc3RhcnRUaW1lIHRoZSBzdGFydCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZFRpbWUgdGhlIGVuZCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnJlcGxheVNwZWVkIHRoZSByZXBsYXkgZmFjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQgdGhlIHJlc3BvbnNlIGZvcm1hdCAoZS5nIHZpZGVvL21wNClcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCAtIHRoZSBsYXN0IHRpbWVzdGFtcCB0byBzdGFydCBhdCB0aGlzIHRpbWUgKElTTyBTdHJpbmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zIC0gdGhlIGVuY29kaW5nIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmdWxsIHVybFxuICAgICAqL1xuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHVybCA9IHN1cGVyLmJ1aWxkVXJsKHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIGFkZHMgcmVxdWVzdFxuICAgICAgICB1cmwgKz0gXCImcmVxdWVzdD1HZXRSZXN1bHRcIjtcblxuICAgICAgICAvLyBhZGRzIG9mZmVyaW5nXG4gICAgICAgIHVybCArPSBcIiZvZmZlcmluZz1cIiArIHByb3BlcnRpZXMub2ZmZXJpbmdJRDtcblxuICAgICAgICAvLyBhZGRzIG9ic2VydmVkUHJvcGVydHlcbiAgICAgICAgdXJsICs9IFwiJm9ic2VydmVkUHJvcGVydHk9XCIgKyBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHk7XG5cbiAgICAgICAgLy8gYWRkcyB0ZW1wb3JhbEZpbHRlclxuICAgICAgICBjb25zdCBzdFRpbWUgPSAoaXNEZWZpbmVkKHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCkpID8gcHJvcGVydGllcy5sYXN0VGltZVN0YW1wIDogIHByb3BlcnRpZXMuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmxhc3RTdGFydFRpbWUgPSBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBwcm9wZXJ0aWVzLmVuZFRpbWU7XG4gICAgICAgIHVybCArPSBcIiZ0ZW1wb3JhbEZpbHRlcj1waGVub21lbm9uVGltZSxcIiArIHN0VGltZSsgXCIvXCIgKyBlbmRUaW1lO1xuICAgICAgICBpZiAocHJvcGVydGllcy5yZXBsYXlTcGVlZCkge1xuICAgICAgICAgICAgLy8gYWRkcyByZXBsYXlTcGVlZFxuICAgICAgICAgICAgdXJsICs9IFwiJnJlcGxheVNwZWVkPVwiICsgcHJvcGVydGllcy5yZXBsYXlTcGVlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzUGFyc2VyUGFyc2VyO1xuIiwiaW1wb3J0IERhdGFTb3VyY2VQYXJzZXIgZnJvbSBcIi4vRGF0YVNvdXJjZVBhcnNlci5qc1wiO1xuaW1wb3J0IFRpbWVTZXJpZXNQYXJzZXIgZnJvbSBcIi4vVGltZVNlcmllc1BhcnNlci5wYXJzZXJcIjtcblxuY2xhc3MgVmlkZW9QYXJzZXIgZXh0ZW5kcyBUaW1lU2VyaWVzUGFyc2VyIHtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRpbWVzdGFtcCBmcm9tIHRoZSBtZXNzYWdlLiBUaGUgdGltZXN0YW1wIGlzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpcnN0IDY0Yml0cyBvZiB0aGUgYmluYXJ5IG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSAtIHRoZSBkYXRhIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgZXh0cmFjdGVkIHRpbWVzdGFtcFxuICAgICAqL1xuICAgIHBhcnNlVGltZVN0YW1wKGRhdGEpIHtcbiAgICAgICAgLy8gcmVhZCBkb3VibGUgdGltZSBzdGFtcCBhcyBiaWcgZW5kaWFuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YSkuZ2V0RmxvYXQ2NCgwLCBmYWxzZSkgKiAxMDAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgZGF0YSBmcm9tIHRoZSBtZXNzYWdlLiBUaGUgSDI2NCBOQUwgdW5pdCBzdGFydHMgYXQgb2Zmc2V0IDEyIGFmdGVyIDgtYnl0ZXMgdGltZSBzdGFtcCBhbmQgNC1ieXRlcyBmcmFtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSAtIHRoZSBkYXRhIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHBhcnNlZCBkYXRhXG4gICAgICovXG4gICAgcGFyc2VEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIEgyNjQgTkFMIHVuaXQgc3RhcnRzIGF0IG9mZnNldCAxMiBhZnRlciA4LWJ5dGVzIHRpbWUgc3RhbXAgYW5kIDQtYnl0ZXMgZnJhbWUgbGVuZ3RoXG4gICAgICAgICAgICBmcmFtZURhdGE6IG5ldyBVaW50OEFycmF5KGRhdGEsIDEyLCBkYXRhLmJ5dGVMZW5ndGggLSAxMiksXG4gICAgICAgICAgICByb2xsOiAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGZ1bGwgdXJsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnByb3RvY29sIHRoZSBwcm90b2NvbCBwcm90b2NvbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZHBvaW50VXJsIHRoZSBlbmRwb2ludCB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zZXJ2aWNlIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2ZmZXJpbmdJRCB0aGUgb2ZmZXJpbmdJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm9ic2VydmVkUHJvcGVydHkgdGhlIG9ic2VydmVkIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuc3RhcnRUaW1lIHRoZSBzdGFydCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLmVuZFRpbWUgdGhlIGVuZCB0aW1lIChJU08gZm9ybWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnJlcGxheVNwZWVkIHRoZSByZXBsYXkgZmFjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZm9pSWQgdGhlIGZvaUlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQgdGhlIHJlc3BvbnNlIGZvcm1hdCAoZS5nIHZpZGVvL21wNClcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCAtIHRoZSBsYXN0IHRpbWVzdGFtcCB0byBzdGFydCBhdCB0aGlzIHRpbWUgKElTTyBTdHJpbmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zIC0gdGhlIGVuY29kaW5nIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9fYml0cmF0ZSAtIGRlZmluZSBhIGN1c3RvbSBiaXRyYXRlIChpbiBiL3MpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX3NjYWxlIC0gZGVmaW5lIGEgY3VzdG9tIHNjYWxlLCAwLjAgPCB2YWx1ZSA8IDEuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb193aWR0aCAtIGRlZmluZSBhIGN1c3RvbSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb19oZWlnaHQgLSBkZWZpbmUgYSBjdXN0b20gaGVpZ2h0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgZnVsbCB1cmxcbiAgICAgKi9cbiAgICBidWlsZFVybChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxldCB1cmwgPSBzdXBlci5idWlsZFVybChwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBhZGRzIGZlYXR1cmUgb2YgaW50ZXJlc3QgdXJuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmZvaUlkICYmIHByb3BlcnRpZXMub2YgIT09ICcnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZmZWF0dXJlT2ZJbnRlcmVzdD0nICsgcHJvcGVydGllcy5mb2lJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgIFZpZGVvUGFyc2VyO1xuIiwiLyoqXG4gKiBFbnVtIGZvciBjb25uZWN0aW9uIHN0YXR1cy5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3tuYW1lOiBzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgU3RhdHVzID0ge1xuICAgIENPTk5FQ1RJTkc6IFwiY29ubmVjdGluZ1wiLFxuICAgIENPTk5FQ1RFRDogIFwiY29ubmVjdGVkXCIsXG4gICAgRElTQ09OTkVDVEVEOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgIENMT1NFRF9FUlJPUjogXCJjbG9zZWQtZXJyb3JcIlxufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IHtyYW5kb21VVUlEfSBmcm9tICcuLi91dGlscy9VdGlscy5qcyc7XG5pbXBvcnQge1N0YXR1c30gZnJvbSAnLi9TdGF0dXMuanMnO1xuXG4vKipcbiAqIFRoZSBEYXRhQ29ubmVjdG9yIGlzIHRoZSBhYnN0cmFjdCBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBkaWZmZXJlbnQgY29ubmVjdG9ycy5cbiAqL1xuY2xhc3MgRGF0YUNvbm5lY3RvciB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIGZ1bGwgdXJsIHVzZWQgdG8gY29ubmVjdCB0byB0aGUgZGF0YSBzdHJlYW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuaWQgPSBcIkRhdGFDb25uZWN0b3ItXCIgKyByYW5kb21VVUlEKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IDEwMDAgKiA2MCAqIDI7IC8vMiBtaW5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAgU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9IC0xO1xuICAgIH1cblxuICAgIGNoZWNrQW5kQ2xlYXJSZWNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgIT09IC0xKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jaGVja1N0YXR1cyhTdGF0dXMuRElTQ09OTkVDVEVEKTtcbiAgICAgICAgdGhpcy5jaGVja0FuZENsZWFyUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdXJsXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIHNldFVybCh1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgcHJvdG9jb2wgZGVmYXVsdCBpZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJlYW0gdXJsLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gdGltZW91dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSByZWNvbm5lY3RpbmcgZGF0YVNvdXJjZVxuICAgICAqL1xuICAgIHNldFJlY29ubmVjdFRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cblxuICAgIG9uUmVjb25uZWN0KCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbm5lY3QoKSB7fVxuXG4gICAgZm9yY2VSZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBTVEFUVVMgY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXMgLSB0aGUgbmV3IHN0YXR1c1xuICAgICAqL1xuICAgIG9uQ2hhbmdlU3RhdHVzKHN0YXR1cykge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgYSBjaGFuZ2Ugb2YgdGhlIHN0YXR1cyBhbmQgY2FsbCB0aGUgY29ycmVzcG9uZGluZyBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBjdXJyZW50U3RhdHVzXG4gICAgICovXG4gICAgY2hlY2tTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmKHN0YXR1cyAhPT0gdGhpcy5zdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBwcm90b2NvbCBoYXMgYmVlbiBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcHJvdG9jb2wgaGFzIGJlZW4gY29ubmVjdGVkXG4gICAgICovXG4gICAgb25Db25uZWN0KCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhQ29ubmVjdG9yO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQgRGF0YUNvbm5lY3RvciBmcm9tICcuL0RhdGFDb25uZWN0b3IuanMnO1xuaW1wb3J0IHtpc1dlYldvcmtlcn0gZnJvbSAnLi4vdXRpbHMvVXRpbHMuanMnO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gJy4vU3RhdHVzLmpzJztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBXZWJTb2NrZXRDb25uZWN0b3IgdG8gY29ubmVjdCB0byBhIHJlbW90ZSBzZXJ2ZXIgYnkgY3JlYXRpbmcgYSBXZWJTb2NrZXQgY2hhbm5lbC5cbiAqIEBleHRlbmRzIERhdGFDb25uZWN0b3JcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgV2ViU29ja2V0Q29ubmVjdG9yIGZyb20gJ29zaC1qcy9kYXRhY29ubmVjdG9yL1dlYlNvY2tldENvbm5lY3Rvci5qcyc7XG4gKlxuICogbGV0IHVybCA9IC4uLjtcbiAqIGxldCBjb25uZWN0b3IgPSBuZXcgV2ViU29ja2V0Q29ubmVjdG9yKHVybCk7XG4gKlxuICogLy8gY29ubmVjdFxuICogY29ubmVjdG9yLmNvbm5lY3QoKTtcbiAqXG4gKiAvLyBkaXNjb25uZWN0XG4gKiBjb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICpcbiAqIC8vIGNsb3NlXG4gKiBjb25uZWN0b3IuY2xvc2UoKTtcbiAqXG4gKi9cblxuY2xhc3MgV2ViU29ja2V0Q29ubmVjdG9yIGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyAtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgd2ViU29ja2V0LiBJZiB0aGUgc3lzdGVtIHN1cHBvcnRzIFdlYldvcmtlciwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIG90aGVyd2lzZSB1c2VcbiAgICAgKiB0aGUgbWFpbiB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmluaXQgPSB0cnVlO1xuICAgICAgICAgICAgLy9jcmVhdGVzIFdlYiBTb2NrZXRcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMuZ2V0VXJsKCkpO1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RJTkcpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgc3RyZWFtIGNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQW5kQ2xlYXJSZWNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKFN0YXR1cy5DT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViU29ja2V0IHN0cmVhbSBjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWNlaXZlVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBkYXRhIG9uIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIGNsb3NlcyBzb2NrZXQgaWYgYW55IGVycm9ycyBvY2N1clxuICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IHN0cmVhbSBlcnJvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkNMT1NFRF9FUlJPUik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBzdHJlYW0gY2xvc2VkOiAnLGV2ZW50LnJlYXNvbiwgZXZlbnQuY29kZSk7XG4gICAgICAgICAgICAgICAgaWYoZXZlbnQuY29kZSAhPT0gMTAwMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1N0YXR1cyhTdGF0dXMuQ0xPU0VEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVSZWNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZih0aGlzLnJlY29ubmVjdGlvbkludGVydmFsICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlUmVjb25uZWN0aW9uKCkge1xuICAgICAgICBpZighdGhpcy5jbG9zZWQgJiYgdGhpcy5yZWNvbm5lY3Rpb25JbnRlcnZhbCA9PT0gLTEgJiYgdGhpcy5vblJlY29ubmVjdCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkludGVydmFsID0gIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UmVjZWl2ZVRpbWU7XG4gICAgICAgICAgICAgICAgLy8gLTEgbWVhbnMgdGhlIFdTIHdlbnQgaW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0UmVjZWl2ZVRpbWUgPT09IC0xIHx8IChkZWx0YSA+PSB0aGlzLnJlY29ubmVjdFRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndHJ5aW5nIHRvIHJlY29ubmVjdCcsIHRoaXMudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGFuZCBjbG9zZSB0aGUgd2Vic29ja2V0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgc3VwZXIuZGlzY29ubmVjdCgpO1xuICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICBpZiAodGhpcy53cyAhPSBudWxsICYmIHRoaXMud3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvbk1lc3NhZ2UgbWV0aG9kIHVzZWQgYnkgdGhlIHdlYnNvY2tldCB0byBjYWxsYmFjayB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBjYWxsYmFjayBkYXRhXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25NZXNzYWdlKGRhdGEpIHtcbiAgICB9XG5cblxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMud3MgIT0gbnVsbCAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYlNvY2tldENvbm5lY3RvcjtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IERhdGFDb25uZWN0b3IgZnJvbSAnLi9EYXRhQ29ubmVjdG9yLmpzJztcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tICcuLi91dGlscy9VdGlscy5qcyc7XG5pbXBvcnQge1N0YXR1c30gZnJvbSAnLi9TdGF0dXMuanMnO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIEFqYXhDb25uZWN0b3IgdG8gY29ubmVjdCB0byBhIHJlbW90ZSBzZXJ2ZXIgYnkgbWFraW5nIEFqYXhSZXF1ZXN0LlxuICogQGV4dGVuZHMgRGF0YUNvbm5lY3RvclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBBamF4IGZyb20gJ2NvcmUvcHJvdG9jb2wvQWpheC5qcyc7XG4gKlxuICogbGV0IHJlcXVlc3QgPSAuLi47XG4gKiBsZXQgcHJvdG9jb2wgPSBuZXcgQWpheCh1cmwpO1xuICpcbiAqIC8vIGhhbmRsZSBvblN1Y2Nlc3NcbiAqIHByb3RvY29sLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgLy8gZG9lcyBzb21ldGhpbmdcbiAqIH1cbiAqXG4gKiBwcm90b2NvbC5vbkVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAvLyBkb2VzIHNvbWV0aGluZ1xuICogfVxuICpcbiAqIC8vIHNlbmQgcmVxdWVzdFxuICogcHJvdG9jb2wuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gKlxuICovXG5jbGFzcyBBamF4IGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIEFqYXguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLm1ldGhvZCAtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlIC1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIodXJsKTtcblxuICAgICAgICB0aGlzLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IHByb3BlcnRpZXMubWV0aG9kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHByb3BlcnRpZXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIGRlZmluZWQgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0IC0gVGhlIEh0dHAgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHRyYVVybCAtIGdldCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgZXh0cmFVcmwpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4bWxodHRwLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIHhtbGh0dHAudGltZW91dCA9IDYwMDAwO1xuICAgICAgICBpZiAocmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChleHRyYVVybCkpIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdGhpcy5nZXRVcmwoKSArIFwiP1wiICsgZXh0cmFVcmwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdGhpcy5nZXRVcmwoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxodHRwLnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgeG1saHR0cC5vbmxvYWQgPSAob0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhtbGh0dHAucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbk1lc3NhZ2UoeG1saHR0cC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeG1saHR0cC5vbnRpbWVvdXQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGltZW91dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RFRCk7XG4gICAgICAgICAgICB4bWxodHRwLnNlbmQobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJQT1NUXCIsIHRoaXMuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICAgICAgeG1saHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcblxuICAgICAgICAgICAgeG1saHR0cC5zZW5kKHJlcXVlc3QpO1xuICAgICAgICAgICAgc2VsZi5jaGVja1N0YXR1cyhTdGF0dXMuQ09OTkVDVEVEKTtcbiAgICAgICAgICAgIHhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PT0gNCkgeyAgICAgICAgICAgICAgICAvLyA0ID0gUmVzcG9uc2UgZnJvbSBzZXJ2ZXIgaGFzIGJlZW4gY29tcGxldGVseSBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnN0YXR1cyA9PT0gMjAwICYmIHhtbGh0dHAuc3RhdHVzIDwgMzAwKSB7IC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25TdWNjZXNzKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25FcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjYWxsYmFjayBtZXRob2QgaW4gY2FzZSBvZiBnZXR0aW5nIGVycm9yIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBlcnJvciBkZXRhaWxzXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25FcnJvcihldmVudCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY2FsbGJhY2sgbWV0aG9kIGluIGNhc2Ugb2YgZ2V0dGluZyBzdWNjZXNzIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25TdWNjZXNzKGV2ZW50KSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgcmVxdWVzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChudWxsKTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFqYXg7XG4iLCJpbXBvcnQgRGF0YUNvbm5lY3RvciBmcm9tIFwiLi9EYXRhQ29ubmVjdG9yXCI7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgRmlsZUNvbm5lY3RvciB0byByZWFkIGEgRmlsZSBjb250ZW50XG4gKiBAZXh0ZW5kcyBEYXRhQ29ubmVjdG9yXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IEZpbGVDb25uZWN0b3IgZnJvbSAnY29yZS9wcm90b2NvbC9Ub3BpY0Nvbm5lY3Rvci5qcyc7XG4gKlxuICogbGV0IHByb3RvY29sID0gbmV3IFRvcGljQ29ubmVjdG9yKDx0b3BpY19uYW1lPik7XG4gKlxuICogLy8gY29ubmVjdFxuICogcHJvdG9jb2wuY29ubmVjdCgpO1xuICpcbiAqIC8vIGRpc2Nvbm5lY3RcbiAqIHByb3RvY29sLmRpc2Nvbm5lY3QoKTtcbiAqXG4gKiAvLyBjbG9zZVxuICogcHJvdG9jb2wuY2xvc2UoKTtcbiAqXG4gKi9cbmNsYXNzIFRvcGljQ29ubmVjdG9yIGV4dGVuZHMgRGF0YUNvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyAtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIGJyb2FkY2FzdENoYW5uZWwuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jcmVhdGVzIGJyb2FkY2FzdENoYW5uZWxcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRoaXMuZ2V0VXJsKCkpO1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLm9ubWVzc2FnZSA9ICAoZXZlbnQpICA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgZGF0YSBvbiBtZXNzYWdlIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoZXZlbnQuZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGNsb3NlcyBzb2NrZXQgaWYgYW55IGVycm9ycyBvY2N1clxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLm9uZXJyb3IgPSAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQnJvYWRjYXN0Q2hhbm5lbCBzdHJlYW0gZXJyb3I6ICcgKyBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9pbml0IHRoZSByZWNvbm5lY3QgaGFuZGxlclxuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlY2VpdmVUaW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyAtMSBtZWFucyB0aGUgV1Mgd2VudCBpbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0UmVjZWl2ZVRpbWUgPT09IC0xIHx8IChkZWx0YSA+PSB0aGlzLnJlY29ubmVjdFRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHRyeWluZyB0byByZWNvbm5lY3QgYWZ0ZXIgJHt0aGlzLnJlY29ubmVjdFRpbWVvdXR9IC4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHdlYnNvY2tldC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmZ1bGxEaXNjb25uZWN0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bGx5IGRpc2Nvbm5lY3QgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGJ5IHNlbmRpbmcgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSB3ZWJXb3JrZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVJbnRlcnZhbCAgLSBmb3JjZSByZW1vdmluZyB0aGUgaW50ZXJ2YWxcbiAgICAgKi9cbiAgICBmdWxsRGlzY29ubmVjdChyZW1vdmVJbnRlcnZhbCkge1xuICAgICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gcmVjb25uZWN0IGlmIHRoZSBjb25uZXhpb24gaWYgY2xvc2VkXG4gICAgICovXG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICB0aGlzLm9uUmVjb25uZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbERpc2Nvbm5lY3QoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9uTWVzc2FnZSBtZXRob2QgdXNlZCBieSB0aGUgd2Vic29ja2V0IHRvIGNhbGxiYWNrIHRoZSBkYXRhXG4gICAgICogQHBhcmFtIGRhdGEgdGhlIGNhbGxiYWNrIGRhdGFcbiAgICAgKiBAZXZlbnRcbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UoZGF0YSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgd2ViU29ja2V0LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCAhPT0gbnVsbCAmJiB0aGlzLm9wZW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvcGljQ29ubmVjdG9yO1xuIiwiZXhwb3J0IGNvbnN0IEV2ZW50VHlwZSA9IHtcbiAgICBEQVRBOiAnZGF0YScsXG4gICAgU1RBVFVTOiAnc3RhdHVzJyxcbiAgICBUSU1FX0NIQU5HRUQ6ICd0aW1lLWNoYW5nZWQnXG59O1xuIiwiaW1wb3J0IFdlYlNvY2tldENvbm5lY3RvciBmcm9tIFwiLi4vLi4vcHJvdG9jb2wvV2ViU29ja2V0Q29ubmVjdG9yLmpzXCI7XG5pbXBvcnQgQWpheCBmcm9tIFwiLi4vLi4vcHJvdG9jb2wvQWpheC5qc1wiO1xuaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IFRvcGljQ29ubmVjdG9yIGZyb20gXCIuLi8uLi9wcm90b2NvbC9Ub3BpY0Nvbm5lY3Rvci5qc1wiO1xuaW1wb3J0IHtFdmVudFR5cGV9IGZyb20gXCIuLi8uLi9ldmVudC9FdmVudFR5cGUuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vLi4vcHJvdG9jb2wvU3RhdHVzXCI7XG5cbmNsYXNzIERhdGFTb3VyY2VIYW5kbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSAxMDAwICogMTA7IC8vIDEwIHNlY3NcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIGluaXQocHJvcGVydGllc1N0ciwgdG9waWMsIGRhdGFTb3VyY2VJZCkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2VJZCA9IGRhdGFTb3VyY2VJZDtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGV4aXN0aW5nIHByb3RvY29sXG4gICAgICAgIGlmKHRoaXMuY29ubmVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCh0b3BpYyk7XG5cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IEpTT04ucGFyc2UocHJvcGVydGllc1N0cik7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNvbm5lY3Rvcih0aGlzLnByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGhhbmRsZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMuYnVmZmVyaW5nVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyaW5nVGltZSA9IHByb3BlcnRpZXMuYnVmZmVyaW5nVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy50aW1lT3V0KSkge1xuICAgICAgICAgICAgdGhpcy50aW1lT3V0ID0gcHJvcGVydGllcy50aW1lT3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLnJlY29ubmVjdFRpbWVvdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBwcm9wZXJ0aWVzLnJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlRGF0YUNvbm5lY3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMucGFyc2VyLmJ1aWxkVXJsKHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIGNoZWNrcyBpZiB0eXBlIGlzIFdlYlNvY2tldENvbm5lY3RvclxuICAgICAgICBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCd3cycpKSB7IC8vIGZvciB3c3NcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IFdlYlNvY2tldENvbm5lY3Rvcih1cmwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7IC8vZm9yIGh0dHBzXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBBamF4KHVybCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5yZXNwb25zZVR5cGUgPSBwcm9wZXJ0aWVzLnJlc3BvbnNlVHlwZSB8fCAnYXJyYXlidWZmZXInO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMucHJvdG9jb2wgPT09ICd0b3BpYycpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IFRvcGljQ29ubmVjdG9yKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgcmVjb25uZWN0VGltZW91dFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iuc2V0UmVjb25uZWN0VGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBjb25uZWN0cyB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLm9uTWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIGJpbmQgY2hhbmdlIGNvbm5lY3Rpb24gU1RBVFVTXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5vbkNoYW5nZVN0YXR1cyAgID0gdGhpcy5vbkNoYW5nZVN0YXR1cy5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB0b3BpYyB0byBsaXN0ZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSB0aGUgdG9waWMgdG8gbGlzdGVuXG4gICAgICovXG4gICAgc2V0VG9waWModG9waWMpIHtcbiAgICAgICAgaWYoaXNEZWZpbmVkKHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCkpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRvcGljKTtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgIH1cblxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmKHRoaXMuY29ubmVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZih0aGlzLmNvbm5lY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgICA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcnNlci5wYXJzZURhdGEoZXZlbnQpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGlzIGFycmF5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpIDwgZGF0YS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5iYXRjaFNpemUpICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJlY2F1c2UgcGFyc2VEYXRhIGlzIEFTWU5DLCB0aGUgcHJvdG9jb2wgY2FuIGZpbmlzaCBiZWZvcmUgdGhlIHBhcnNpbmcgbWV0aG9kLiBJbiB0aGF0IGNhc2UsIHdlIGhhdmUgdG8gZmx1c2hBTGwgZGF0YVxuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEFsbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZCh0aGlzLmJhdGNoU2l6ZSkgJiYgdGhpcy52YWx1ZXMubGVuZ3RoICE9PSAwICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhIGNoYW5nZSBzdGF0dXMgZXZlbnQgaW50byB0aGUgYnJvYWRjYXN0IGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIG5ldyBzdGF0dXNcbiAgICAgKi9cbiAgICBvbkNoYW5nZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYoc3RhdHVzID09PSBTdGF0dXMuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlNUQVRVUyxcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgZGF0YVNvdXJjZUlkOiB0aGlzLmRhdGFTb3VyY2VJZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ29ubmVjdG9yKHtcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy52ZXJzaW9uKys7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGZsdXNoQWxsKCkge1xuICAgICAgICB3aGlsZSh0aGlzLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgbGV0IG5iRWxlbWVudHMgPSB0aGlzLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5iYXRjaFNpemUpICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+IHRoaXMuYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBuYkVsZW1lbnRzID0gdGhpcy5iYXRjaFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGRhdGFTb3VyY2VJZDogdGhpcy5kYXRhU291cmNlSWQsXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuREFUQSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy52YWx1ZXMuc3BsaWNlKDAsIG5iRWxlbWVudHMpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29ubmVjdG9yID09PSBudWxsKT8gZmFsc2U6IHRoaXMuY29ubmVjdG9yLmlzQ29ubmVjdGVkKCk7XG4gICAgfTtcblxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgd29ya2VyKSB7XG4gICAgICAgIGlmKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQobWVzc2FnZS5wcm9wZXJ0aWVzLCBtZXNzYWdlLnRvcGljLCBtZXNzYWdlLmlkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnZGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ3RvcGljJykge1xuICAgICAgICAgICAgdGhpcy5zZXRUb3BpYyhtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICd1cGRhdGUtdXJsJykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnaXMtY29ubmVjdGVkJykge1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaXMtY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmlzQ29ubmVjdGVkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBEYXRhU291cmNlSGFuZGxlcjtcblxuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IERhdGFTb3VyY2VIYW5kbGVyIGZyb20gXCIuL0RhdGFTb3VyY2VIYW5kbGVyXCI7XG5pbXBvcnQge0V2ZW50VHlwZX0gZnJvbSBcIi4uLy4uL2V2ZW50L0V2ZW50VHlwZVwiO1xuXG5jbGFzcyBUaW1lU2VyaWVzRGF0YVNvdXJjZUhhbmRsZXIgZXh0ZW5kcyBEYXRhU291cmNlSGFuZGxlcntcblxuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBzdXBlcihwYXJzZXIpO1xuICAgICAgICB0aGlzLmxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTdGFydFRpbWUgPSAnbm93JztcbiAgICAgICAgdGhpcy50aW1lU2hpZnQgPSAwO1xuICAgICAgICB0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNyZWF0ZURhdGFDb25uZWN0b3IocHJvcGVydGllcykge1xuICAgICAgICBzdXBlci5jcmVhdGVEYXRhQ29ubmVjdG9yKHtcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICB0aW1lU2hpZnQ6IHRoaXMudGltZVNoaWZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGxhc3RTdGFydFRpbWVDc3QgPSB0aGlzLnBhcnNlci5sYXN0U3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmNvbm5lY3Rvci5vblJlY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCByZWFsIHRpbWUsIHByZXNlcnZlIGxhc3QgdGltZXN0YW1wIHRvIHJlY29ubmVjdCBhdCB0aGUgbGFzdCB0aW1lIHJlY2VpdmVkXG4gICAgICAgICAgICAvLyBmb3IgdGhhdCwgd2UgdXBkYXRlIHRoZSBVUkwgd2l0aCB0aGUgbmV3IGxhc3QgdGltZSByZWNlaXZlZFxuICAgICAgICAgICAgaWYgKGxhc3RTdGFydFRpbWVDc3QgIT09ICdub3cnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iuc2V0VXJsKHRoaXMucGFyc2VyLmJ1aWxkVXJsKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRpbWVTdGFtcDogaXNEZWZpbmVkKHRoaXMubGFzdFRpbWVTdGFtcCkgPyBuZXcgRGF0ZSh0aGlzLmxhc3RUaW1lU3RhbXApLnRvSVNPU3RyaW5nKCk6IHByb3BlcnRpZXMuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgICAgICBzdXBlci5oYW5kbGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy50aW1lU2hpZnQpKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVTaGlmdCA9IHByb3BlcnRpZXMudGltZVNoaWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocHJvcGVydGllcy5zdGFydFRpbWUgPT09ICdub3cnKSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMucmVwbGF5U3BlZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQocHJvcGVydGllcy5iYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy5iYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBwcm9wZXJ0aWVzLmJhdGNoU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCB0aW1lU3RhbXAgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUodGhpcy5wYXJzZXIucGFyc2VUaW1lU3RhbXAoZXZlbnQpICsgdGhpcy50aW1lU2hpZnQpO1xuICAgICAgICBjb25zdCBkYXRhICAgICAgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUodGhpcy5wYXJzZXIucGFyc2VEYXRhKGV2ZW50KSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZGF0YSBpcyBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7aSA8IGRhdGEubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2ldLFxuICAgICAgICAgICAgICAgICAgICB0aW1lU3RhbXA6IHRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VGltZVN0YW1wID0gdGltZVN0YW1wO1xuXG4gICAgICAgIGlmKHRoaXMucGFyc2VyLmxhc3RTdGFydFRpbWUgPT09ICdub3cnIHx8ICgoaXNEZWZpbmVkKHRoaXMuYmF0Y2hTaXplKSAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPj0gdGhpcy5iYXRjaFNpemUpKSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgaWYodGhpcy50aW1lQnJvYWRjYXN0Q2hhbm5lbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubGFzdFRpbWVTdGFtcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGFzdFRpbWVTdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFRpbWVTdGFtcDtcbiAgICB9XG5cbiAgICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgdGhpcy50aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhU291cmNlSWQ6IHRoaXMuZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlRJTUVfQ0hBTkdFRFxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGFzdFRpbWVzdGFtcCA9ICBuZXcgRGF0ZSh0aGlzLmxhc3RUaW1lU3RhbXApLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgaWYocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgnc3RhcnRUaW1lJykpIHtcbiAgICAgICAgICAgIGxhc3RUaW1lc3RhbXAgPSBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucHJvcGVydGllcy5zdGFydFRpbWUgPT09ICdub3cnKXtcbiAgICAgICAgICAgIC8vaGFuZGxlIFJlYWxUaW1lXG4gICAgICAgICAgICBsYXN0VGltZXN0YW1wID0gJ25vdyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnNpb24rKztcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ29ubmVjdG9yKHtcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBsYXN0VGltZVN0YW1wOiBsYXN0VGltZXN0YW1wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGlzRGVmaW5lZChwcm9wZXJ0aWVzKSAmJiBpc0RlZmluZWQocHJvcGVydGllcy5yZWNvbm5lY3QpICYmIHByb3BlcnRpZXMucmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgd29ya2VyKSB7XG4gICAgICAgIHN1cGVyLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgd29ya2VyKTtcblxuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnbGFzdC10aW1lc3RhbXAnKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VGltZVN0YW1wID0gdGhpcy5nZXRMYXN0VGltZVN0YW1wKCk7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdsYXN0LXRpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgZGF0YTogbGFzdFRpbWVTdGFtcFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICd0b3BpYycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZVRvcGljKG1lc3NhZ2UudGltZVRvcGljKTtcbiAgICAgICAgICAgIHN1cGVyLnNldFRvcGljKG1lc3NhZ2UudG9waWMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGltZVRvcGljKHRpbWVUb3BpYykge1xuICAgICAgICBpZih0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVCcm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRpbWVUb3BpYyk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyO1xuXG4iLCJpbXBvcnQgU29zR2V0UmVzdWx0VmlkZW9QYXJzZXIgZnJvbSAnLi4vcGFyc2Vycy9Tb3NHZXRSZXN1bHRWaWRlby5wYXJzZXIuanMnO1xuaW1wb3J0IFRpbWVTZXJpZXNEYXRhU291cmNlSGFuZGxlciBmcm9tIFwiLi9UaW1lU2VyaWVzRGF0YVNvdXJjZUhhbmRsZXJcIjtcblxuY29uc3QgZGF0YVNvdXJjZUhhbmRsZXIgPSBuZXcgVGltZVNlcmllc0RhdGFTb3VyY2VIYW5kbGVyKG5ldyBTb3NHZXRSZXN1bHRWaWRlb1BhcnNlcigpKTtcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBkYXRhU291cmNlSGFuZGxlci5oYW5kbGVNZXNzYWdlKGV2ZW50LmRhdGEsIHNlbGYpO1xufVxuXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);